# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _simulation
else:
    import _simulation

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _simulation.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _simulation.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _simulation.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _simulation.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _simulation.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _simulation.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _simulation.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _simulation.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _simulation.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _simulation.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _simulation.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _simulation.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _simulation.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _simulation.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _simulation.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _simulation.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _simulation:
_simulation.SwigPyIterator_swigregister(SwigPyIterator)
import opensim.common
import opensim.simbody
class _StdVectorState(object):
    r"""Proxy of C++ std::vector< SimTK::State > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(_StdVectorState self) -> SwigPyIterator"""
        return _simulation._StdVectorState_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(_StdVectorState self) -> bool"""
        return _simulation._StdVectorState___nonzero__(self)

    def __bool__(self):
        r"""__bool__(_StdVectorState self) -> bool"""
        return _simulation._StdVectorState___bool__(self)

    def __len__(self):
        r"""__len__(_StdVectorState self) -> std::vector< SimTK::State >::size_type"""
        return _simulation._StdVectorState___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(_StdVectorState self, std::vector< SimTK::State >::difference_type i, std::vector< SimTK::State >::difference_type j) -> StdVectorState

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type
        j: std::vector< SimTK::State >::difference_type

        """
        return _simulation._StdVectorState___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(_StdVectorState self, std::vector< SimTK::State >::difference_type i, std::vector< SimTK::State >::difference_type j)

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type
        j: std::vector< SimTK::State >::difference_type

        __setslice__(_StdVectorState self, std::vector< SimTK::State >::difference_type i, std::vector< SimTK::State >::difference_type j, StdVectorState v)

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type
        j: std::vector< SimTK::State >::difference_type
        v: std::vector< SimTK::State,std::allocator< SimTK::State > > const &

        """
        return _simulation._StdVectorState___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(_StdVectorState self, std::vector< SimTK::State >::difference_type i, std::vector< SimTK::State >::difference_type j)

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type
        j: std::vector< SimTK::State >::difference_type

        """
        return _simulation._StdVectorState___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(_StdVectorState self, std::vector< SimTK::State >::difference_type i)

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type

        __delitem__(_StdVectorState self, SWIGPY_SLICEOBJECT * slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _simulation._StdVectorState___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(_StdVectorState self, SWIGPY_SLICEOBJECT * slice) -> StdVectorState

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(_StdVectorState self, std::vector< SimTK::State >::difference_type i) -> State

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type

        """
        return _simulation._StdVectorState___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(_StdVectorState self, SWIGPY_SLICEOBJECT * slice, StdVectorState v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< SimTK::State,std::allocator< SimTK::State > > const &

        __setitem__(_StdVectorState self, SWIGPY_SLICEOBJECT * slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(_StdVectorState self, std::vector< SimTK::State >::difference_type i, State x)

        Parameters
        ----------
        i: std::vector< SimTK::State >::difference_type
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState___setitem__(self, *args)

    def pop(self):
        r"""pop(_StdVectorState self) -> State"""
        return _simulation._StdVectorState_pop(self)

    def append(self, x):
        r"""
        append(_StdVectorState self, State x)

        Parameters
        ----------
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState_append(self, x)

    def empty(self):
        r"""empty(_StdVectorState self) -> bool"""
        return _simulation._StdVectorState_empty(self)

    def size(self):
        r"""size(_StdVectorState self) -> std::vector< SimTK::State >::size_type"""
        return _simulation._StdVectorState_size(self)

    def swap(self, v):
        r"""
        swap(_StdVectorState self, StdVectorState v)

        Parameters
        ----------
        v: std::vector< SimTK::State > &

        """
        return _simulation._StdVectorState_swap(self, v)

    def begin(self):
        r"""begin(_StdVectorState self) -> std::vector< SimTK::State >::iterator"""
        return _simulation._StdVectorState_begin(self)

    def end(self):
        r"""end(_StdVectorState self) -> std::vector< SimTK::State >::iterator"""
        return _simulation._StdVectorState_end(self)

    def rbegin(self):
        r"""rbegin(_StdVectorState self) -> std::vector< SimTK::State >::reverse_iterator"""
        return _simulation._StdVectorState_rbegin(self)

    def rend(self):
        r"""rend(_StdVectorState self) -> std::vector< SimTK::State >::reverse_iterator"""
        return _simulation._StdVectorState_rend(self)

    def clear(self):
        r"""clear(_StdVectorState self)"""
        return _simulation._StdVectorState_clear(self)

    def get_allocator(self):
        r"""get_allocator(_StdVectorState self) -> std::vector< SimTK::State >::allocator_type"""
        return _simulation._StdVectorState_get_allocator(self)

    def pop_back(self):
        r"""pop_back(_StdVectorState self)"""
        return _simulation._StdVectorState_pop_back(self)

    def erase(self, *args):
        r"""
        erase(_StdVectorState self, std::vector< SimTK::State >::iterator pos) -> std::vector< SimTK::State >::iterator

        Parameters
        ----------
        pos: std::vector< SimTK::State >::iterator

        erase(_StdVectorState self, std::vector< SimTK::State >::iterator first, std::vector< SimTK::State >::iterator last) -> std::vector< SimTK::State >::iterator

        Parameters
        ----------
        first: std::vector< SimTK::State >::iterator
        last: std::vector< SimTK::State >::iterator

        """
        return _simulation._StdVectorState_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(_StdVectorState self) -> _StdVectorState
        __init__(_StdVectorState self, StdVectorState other) -> _StdVectorState

        Parameters
        ----------
        other: std::vector< SimTK::State > const &

        __init__(_StdVectorState self, std::vector< SimTK::State >::size_type size) -> _StdVectorState

        Parameters
        ----------
        size: std::vector< SimTK::State >::size_type

        __init__(_StdVectorState self, std::vector< SimTK::State >::size_type size, State value) -> _StdVectorState

        Parameters
        ----------
        size: std::vector< SimTK::State >::size_type
        value: std::vector< SimTK::State >::value_type const &

        """
        _simulation._StdVectorState_swiginit(self, _simulation.new__StdVectorState(*args))

    def push_back(self, x):
        r"""
        push_back(_StdVectorState self, State x)

        Parameters
        ----------
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState_push_back(self, x)

    def front(self):
        r"""front(_StdVectorState self) -> State"""
        return _simulation._StdVectorState_front(self)

    def back(self):
        r"""back(_StdVectorState self) -> State"""
        return _simulation._StdVectorState_back(self)

    def assign(self, n, x):
        r"""
        assign(_StdVectorState self, std::vector< SimTK::State >::size_type n, State x)

        Parameters
        ----------
        n: std::vector< SimTK::State >::size_type
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(_StdVectorState self, std::vector< SimTK::State >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< SimTK::State >::size_type

        resize(_StdVectorState self, std::vector< SimTK::State >::size_type new_size, State x)

        Parameters
        ----------
        new_size: std::vector< SimTK::State >::size_type
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(_StdVectorState self, std::vector< SimTK::State >::iterator pos, State x) -> std::vector< SimTK::State >::iterator

        Parameters
        ----------
        pos: std::vector< SimTK::State >::iterator
        x: std::vector< SimTK::State >::value_type const &

        insert(_StdVectorState self, std::vector< SimTK::State >::iterator pos, std::vector< SimTK::State >::size_type n, State x)

        Parameters
        ----------
        pos: std::vector< SimTK::State >::iterator
        n: std::vector< SimTK::State >::size_type
        x: std::vector< SimTK::State >::value_type const &

        """
        return _simulation._StdVectorState_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(_StdVectorState self, std::vector< SimTK::State >::size_type n)

        Parameters
        ----------
        n: std::vector< SimTK::State >::size_type

        """
        return _simulation._StdVectorState_reserve(self, n)

    def capacity(self):
        r"""capacity(_StdVectorState self) -> std::vector< SimTK::State >::size_type"""
        return _simulation._StdVectorState_capacity(self)
    __swig_destroy__ = _simulation.delete__StdVectorState

# Register _StdVectorState in _simulation:
_simulation._StdVectorState_swigregister(_StdVectorState)
class SurfaceProperties(opensim.common.OpenSimObject):
    r"""
    SurfaceProperties class holds the appearance properties of a piece of Geometry
    displayed in the OpenSim visualizer or GUI as a surface. The properties in this
    class are specific to geometry that have surfaces so that these surfaces can be
    textured, or rendered using  a variety of shading models.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SurfaceProperties

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SurfaceProperties_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SurfaceProperties self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SurfaceProperties_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SurfaceProperties_getClassName()

    def clone(self):
        r"""clone(SurfaceProperties self) -> SurfaceProperties"""
        return _simulation.SurfaceProperties_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SurfaceProperties self) -> std::string const &"""
        return _simulation.SurfaceProperties_getConcreteClassName(self)

    def copyProperty_representation(self, source):
        r"""
        copyProperty_representation(SurfaceProperties self, SurfaceProperties source)

        Parameters
        ----------
        source: OpenSim::SurfaceProperties::Self const &

        """
        return _simulation.SurfaceProperties_copyProperty_representation(self, source)

    def append_representation(self, value):
        r"""
        append_representation(SurfaceProperties self, int const & value) -> int

        Parameters
        ----------
        value: int const &

        """
        return _simulation.SurfaceProperties_append_representation(self, value)

    def constructProperty_representation(self, initValue):
        r"""
        constructProperty_representation(SurfaceProperties self, int const & initValue)

        Parameters
        ----------
        initValue: int const &

        """
        return _simulation.SurfaceProperties_constructProperty_representation(self, initValue)

    def get_representation(self, *args):
        r"""
        get_representation(SurfaceProperties self, int i) -> int const

        Parameters
        ----------
        i: int

        get_representation(SurfaceProperties self) -> int const &
        """
        return _simulation.SurfaceProperties_get_representation(self, *args)

    def upd_representation(self, *args):
        r"""
        upd_representation(SurfaceProperties self, int i) -> int

        Parameters
        ----------
        i: int

        upd_representation(SurfaceProperties self) -> int &
        """
        return _simulation.SurfaceProperties_upd_representation(self, *args)

    def set_representation(self, *args):
        r"""
        set_representation(SurfaceProperties self, int i, int const & value)

        Parameters
        ----------
        i: int
        value: int const &

        set_representation(SurfaceProperties self, int const & value)

        Parameters
        ----------
        value: int const &

        """
        return _simulation.SurfaceProperties_set_representation(self, *args)

    def copyProperty_texture(self, source):
        r"""
        copyProperty_texture(SurfaceProperties self, SurfaceProperties source)

        Parameters
        ----------
        source: OpenSim::SurfaceProperties::Self const &

        """
        return _simulation.SurfaceProperties_copyProperty_texture(self, source)

    def append_texture(self, value):
        r"""
        append_texture(SurfaceProperties self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.SurfaceProperties_append_texture(self, value)

    def constructProperty_texture(self, *args):
        r"""
        constructProperty_texture(SurfaceProperties self)
        constructProperty_texture(SurfaceProperties self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.SurfaceProperties_constructProperty_texture(self, *args)

    def get_texture(self, *args):
        r"""
        get_texture(SurfaceProperties self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_texture(SurfaceProperties self) -> std::string const &
        """
        return _simulation.SurfaceProperties_get_texture(self, *args)

    def upd_texture(self, *args):
        r"""
        upd_texture(SurfaceProperties self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_texture(SurfaceProperties self) -> std::string &
        """
        return _simulation.SurfaceProperties_upd_texture(self, *args)

    def set_texture(self, *args):
        r"""
        set_texture(SurfaceProperties self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_texture(SurfaceProperties self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.SurfaceProperties_set_texture(self, *args)

    def __init__(self):
        r"""__init__(SurfaceProperties self) -> SurfaceProperties"""
        _simulation.SurfaceProperties_swiginit(self, _simulation.new_SurfaceProperties())
    __swig_destroy__ = _simulation.delete_SurfaceProperties

    def hasTexture(self):
        r"""hasTexture(SurfaceProperties self) -> bool"""
        return _simulation.SurfaceProperties_hasTexture(self)

# Register SurfaceProperties in _simulation:
_simulation.SurfaceProperties_swigregister(SurfaceProperties)
class Appearance(opensim.common.OpenSimObject):
    r"""
    A class that holds the Appearance properties of Geometry displayed
    in the OpenSim Visualizer. It affects how Geometry is displayed.

    Appearance contains properties that apply to all geometry.
    Geometry that have a surface so that it can be textured will utilize
    SurfaceProperties, while schematic line drawings (e.g. Arrows, Frames)
    can utilize CurveProperties which offers thickness.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Appearance

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Appearance_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Appearance self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Appearance_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Appearance_getClassName()

    def clone(self):
        r"""clone(Appearance self) -> Appearance"""
        return _simulation.Appearance_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Appearance self) -> std::string const &"""
        return _simulation.Appearance_getConcreteClassName(self)

    def copyProperty_visible(self, source):
        r"""
        copyProperty_visible(Appearance self, Appearance source)

        Parameters
        ----------
        source: OpenSim::Appearance::Self const &

        """
        return _simulation.Appearance_copyProperty_visible(self, source)

    def append_visible(self, value):
        r"""
        append_visible(Appearance self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Appearance_append_visible(self, value)

    def constructProperty_visible(self, initValue):
        r"""
        constructProperty_visible(Appearance self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Appearance_constructProperty_visible(self, initValue)

    def get_visible(self, *args):
        r"""
        get_visible(Appearance self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_visible(Appearance self) -> bool const &
        """
        return _simulation.Appearance_get_visible(self, *args)

    def upd_visible(self, *args):
        r"""
        upd_visible(Appearance self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_visible(Appearance self) -> bool &
        """
        return _simulation.Appearance_upd_visible(self, *args)

    def set_visible(self, *args):
        r"""
        set_visible(Appearance self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_visible(Appearance self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Appearance_set_visible(self, *args)

    def copyProperty_opacity(self, source):
        r"""
        copyProperty_opacity(Appearance self, Appearance source)

        Parameters
        ----------
        source: OpenSim::Appearance::Self const &

        """
        return _simulation.Appearance_copyProperty_opacity(self, source)

    def append_opacity(self, value):
        r"""
        append_opacity(Appearance self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Appearance_append_opacity(self, value)

    def constructProperty_opacity(self, initValue):
        r"""
        constructProperty_opacity(Appearance self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Appearance_constructProperty_opacity(self, initValue)

    def get_opacity(self, *args):
        r"""
        get_opacity(Appearance self, int i) -> double const

        Parameters
        ----------
        i: int

        get_opacity(Appearance self) -> double const &
        """
        return _simulation.Appearance_get_opacity(self, *args)

    def upd_opacity(self, *args):
        r"""
        upd_opacity(Appearance self, int i) -> double

        Parameters
        ----------
        i: int

        upd_opacity(Appearance self) -> double &
        """
        return _simulation.Appearance_upd_opacity(self, *args)

    def set_opacity(self, *args):
        r"""
        set_opacity(Appearance self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_opacity(Appearance self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Appearance_set_opacity(self, *args)

    def copyProperty_color(self, source):
        r"""
        copyProperty_color(Appearance self, Appearance source)

        Parameters
        ----------
        source: OpenSim::Appearance::Self const &

        """
        return _simulation.Appearance_copyProperty_color(self, source)

    def append_color(self, value):
        r"""
        append_color(Appearance self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Appearance_append_color(self, value)

    def constructProperty_color(self, initValue):
        r"""
        constructProperty_color(Appearance self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Appearance_constructProperty_color(self, initValue)

    def get_color(self, *args):
        r"""
        get_color(Appearance self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_color(Appearance self) -> Vec3
        """
        return _simulation.Appearance_get_color(self, *args)

    def upd_color(self, *args):
        r"""
        upd_color(Appearance self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_color(Appearance self) -> Vec3
        """
        return _simulation.Appearance_upd_color(self, *args)

    def set_color(self, *args):
        r"""
        set_color(Appearance self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_color(Appearance self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Appearance_set_color(self, *args)

    def copyProperty_SurfaceProperties(self, source):
        r"""
        copyProperty_SurfaceProperties(Appearance self, Appearance source)

        Parameters
        ----------
        source: OpenSim::Appearance::Self const &

        """
        return _simulation.Appearance_copyProperty_SurfaceProperties(self, source)

    def append_SurfaceProperties(self, value):
        r"""
        append_SurfaceProperties(Appearance self, SurfaceProperties value) -> int

        Parameters
        ----------
        value: OpenSim::SurfaceProperties const &

        """
        return _simulation.Appearance_append_SurfaceProperties(self, value)

    def constructProperty_SurfaceProperties(self, initValue):
        r"""
        constructProperty_SurfaceProperties(Appearance self, SurfaceProperties initValue)

        Parameters
        ----------
        initValue: OpenSim::SurfaceProperties const &

        """
        return _simulation.Appearance_constructProperty_SurfaceProperties(self, initValue)

    def get_SurfaceProperties(self, *args):
        r"""
        get_SurfaceProperties(Appearance self, int i) -> SurfaceProperties

        Parameters
        ----------
        i: int

        get_SurfaceProperties(Appearance self) -> SurfaceProperties
        """
        return _simulation.Appearance_get_SurfaceProperties(self, *args)

    def upd_SurfaceProperties(self, *args):
        r"""
        upd_SurfaceProperties(Appearance self, int i) -> SurfaceProperties

        Parameters
        ----------
        i: int

        upd_SurfaceProperties(Appearance self) -> SurfaceProperties
        """
        return _simulation.Appearance_upd_SurfaceProperties(self, *args)

    def set_SurfaceProperties(self, *args):
        r"""
        set_SurfaceProperties(Appearance self, int i, SurfaceProperties value)

        Parameters
        ----------
        i: int
        value: OpenSim::SurfaceProperties const &

        set_SurfaceProperties(Appearance self, SurfaceProperties value)

        Parameters
        ----------
        value: OpenSim::SurfaceProperties const &

        """
        return _simulation.Appearance_set_SurfaceProperties(self, *args)

    def __init__(self):
        r"""__init__(Appearance self) -> Appearance"""
        _simulation.Appearance_swiginit(self, _simulation.new_Appearance())
    __swig_destroy__ = _simulation.delete_Appearance

    def get_representation(self):
        r"""get_representation(Appearance self) -> OpenSim::VisualRepresentation"""
        return _simulation.Appearance_get_representation(self)

    def set_representation(self, rep):
        r"""
        set_representation(Appearance self, OpenSim::VisualRepresentation const & rep)

        Parameters
        ----------
        rep: OpenSim::VisualRepresentation const &

        """
        return _simulation.Appearance_set_representation(self, rep)

# Register Appearance in _simulation:
_simulation.Appearance_swigregister(Appearance)
class Geometry(opensim.common.Component):
    r"""
    Class Geometry is intended to be used as the base class for all
    geometry that needs to be represented in the system, including mesh files,
    and built in analytic shapes. Any ModelComponent can specify a list of
    Geometry items to represent itself in graphics window. The relation between
    a ModelComponent and specific Geometry utilizes the Component mechanism, as
    the specific pieces of geometry are treated as subcomponents. The placement
    of the Geometry in 3D space is computed from the Frame that the Geometry is
    "Connected" to.

    Geometry (and all its subclasses) serve as the set of higher level primitives
    available to OpenSim component writers to express the Geometry of interest.
    The Geometry class handles serialization and also the translation to a set of
    DecorativeGeometry objects that gets passed to the Visualization system to be
    rendered.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Geometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Geometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Geometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Geometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Geometry_getClassName()

    def clone(self):
        r"""clone(Geometry self) -> Geometry"""
        return _simulation.Geometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Geometry self) -> std::string const &"""
        return _simulation.Geometry_getConcreteClassName(self)

    def copyProperty_scale_factors(self, source):
        r"""
        copyProperty_scale_factors(Geometry self, Geometry source)

        Parameters
        ----------
        source: OpenSim::Geometry::Self const &

        """
        return _simulation.Geometry_copyProperty_scale_factors(self, source)

    def append_scale_factors(self, value):
        r"""
        append_scale_factors(Geometry self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Geometry_append_scale_factors(self, value)

    def constructProperty_scale_factors(self, initValue):
        r"""
        constructProperty_scale_factors(Geometry self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Geometry_constructProperty_scale_factors(self, initValue)

    def get_scale_factors(self, *args):
        r"""
        get_scale_factors(Geometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_scale_factors(Geometry self) -> Vec3
        """
        return _simulation.Geometry_get_scale_factors(self, *args)

    def upd_scale_factors(self, *args):
        r"""
        upd_scale_factors(Geometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_scale_factors(Geometry self) -> Vec3
        """
        return _simulation.Geometry_upd_scale_factors(self, *args)

    def set_scale_factors(self, *args):
        r"""
        set_scale_factors(Geometry self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_scale_factors(Geometry self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Geometry_set_scale_factors(self, *args)

    def copyProperty_Appearance(self, source):
        r"""
        copyProperty_Appearance(Geometry self, Geometry source)

        Parameters
        ----------
        source: OpenSim::Geometry::Self const &

        """
        return _simulation.Geometry_copyProperty_Appearance(self, source)

    def append_Appearance(self, value):
        r"""
        append_Appearance(Geometry self, Appearance value) -> int

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.Geometry_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue):
        r"""
        constructProperty_Appearance(Geometry self, Appearance initValue)

        Parameters
        ----------
        initValue: OpenSim::Appearance const &

        """
        return _simulation.Geometry_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args):
        r"""
        get_Appearance(Geometry self, int i) -> Appearance

        Parameters
        ----------
        i: int

        get_Appearance(Geometry self) -> Appearance
        """
        return _simulation.Geometry_get_Appearance(self, *args)

    def upd_Appearance(self, *args):
        r"""
        upd_Appearance(Geometry self, int i) -> Appearance

        Parameters
        ----------
        i: int

        upd_Appearance(Geometry self) -> Appearance
        """
        return _simulation.Geometry_upd_Appearance(self, *args)

    def set_Appearance(self, *args):
        r"""
        set_Appearance(Geometry self, int i, Appearance value)

        Parameters
        ----------
        i: int
        value: OpenSim::Appearance const &

        set_Appearance(Geometry self, Appearance value)

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.Geometry_set_Appearance(self, *args)
    PropertyIndex_socket_frame = property(_simulation.Geometry_PropertyIndex_socket_frame_get, _simulation.Geometry_PropertyIndex_socket_frame_set, doc=r"""PropertyIndex_socket_frame : OpenSim::PropertyIndex""")

    def constructSocket_frame(self):
        r"""constructSocket_frame(Geometry self) -> OpenSim::PropertyIndex"""
        return _simulation.Geometry_constructSocket_frame(self)

    def connectSocket_frame(self, object):
        r"""
        connectSocket_frame(Geometry self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Geometry_connectSocket_frame(self, object)
    PropertyIndex_input_transform = property(_simulation.Geometry_PropertyIndex_input_transform_get, _simulation.Geometry_PropertyIndex_input_transform_set, doc=r"""PropertyIndex_input_transform : OpenSim::PropertyIndex""")

    def connectInput_transform(self, *args):
        r"""
        connectInput_transform(Geometry self, AbstractOutput output, std::string const & alias="")

        Parameters
        ----------
        output: OpenSim::AbstractOutput const &
        alias: std::string const &

        connectInput_transform(Geometry self, AbstractChannel channel, std::string const & alias="")

        Parameters
        ----------
        channel: OpenSim::AbstractChannel const &
        alias: std::string const &

        """
        return _simulation.Geometry_connectInput_transform(self, *args)
    __swig_destroy__ = _simulation.delete_Geometry

    def setFrame(self, frame):
        r""" Interface methods to handle the Frame which the Geometry is attached to.  %Set the Frame of attachment *"""
        return _simulation.Geometry_setFrame(self, frame)

    def getFrame(self):
        r"""
        Return a reference to the name of the Frame to which
           this Geometry is attached (using a Socket). * Return a reference to the actual Frame to which this Geometry
           is attached.
        """
        return _simulation.Geometry_getFrame(self)

    def setColor(self, color):
        r"""
        Convenient access to set Appearance/Color
        color is RGB, each components is in the range [0, 1].
        """
        return _simulation.Geometry_setColor(self, color)

    def getColor(self):
        r"""
        Convenient access to get Appearance/Color
        returns RGB , each components is in the range [0, 1].
        """
        return _simulation.Geometry_getColor(self)

    def setOpacity(self, opacity):
        r""" Convenient access to set Appearance/Opacity"""
        return _simulation.Geometry_setOpacity(self, opacity)

    def getOpacity(self):
        r""" Convenient access to get Appearance/Opacity"""
        return _simulation.Geometry_getOpacity(self)

    def setRepresentation(self, rep):
        r""" Convenient access to set Appearance/representation"""
        return _simulation.Geometry_setRepresentation(self, rep)

    def getRepresentation(self):
        r""" Convenient access to get Appearance/representation"""
        return _simulation.Geometry_getRepresentation(self)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Implement method from Component interface. Subclasses only need to
        implement implementCreateDecorativeGeometry to generate an Array of
        SimTK::DecorativeGeometry. From then on, setting Transforms & Appearance
        is handled by the base class Geometry to avoid duplication.
        """
        return _simulation.Geometry_generateDecorations(self, fixed, hints, state, appendToThis)

# Register Geometry in _simulation:
_simulation.Geometry_swigregister(Geometry)
class LineGeometry(Geometry):
    r"""
    LineGeometry is a utility class used to abstract a line segment.
    It is used by muscle segments so that it's as small and useful as possible.

    NOTE: LineGeometry assumes its Frame is Ground!
    TODO make LineGeometry draw between actual Points!
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> LineGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.LineGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(LineGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.LineGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.LineGeometry_getClassName()

    def clone(self):
        r"""clone(LineGeometry self) -> LineGeometry"""
        return _simulation.LineGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(LineGeometry self) -> std::string const &"""
        return _simulation.LineGeometry_getConcreteClassName(self)

    def copyProperty_start_point(self, source):
        r"""
        copyProperty_start_point(LineGeometry self, LineGeometry source)

        Parameters
        ----------
        source: OpenSim::LineGeometry::Self const &

        """
        return _simulation.LineGeometry_copyProperty_start_point(self, source)

    def append_start_point(self, value):
        r"""
        append_start_point(LineGeometry self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_append_start_point(self, value)

    def constructProperty_start_point(self, initValue):
        r"""
        constructProperty_start_point(LineGeometry self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_constructProperty_start_point(self, initValue)

    def get_start_point(self, *args):
        r"""
        get_start_point(LineGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_start_point(LineGeometry self) -> Vec3
        """
        return _simulation.LineGeometry_get_start_point(self, *args)

    def upd_start_point(self, *args):
        r"""
        upd_start_point(LineGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_start_point(LineGeometry self) -> Vec3
        """
        return _simulation.LineGeometry_upd_start_point(self, *args)

    def set_start_point(self, *args):
        r"""
        set_start_point(LineGeometry self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_start_point(LineGeometry self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_set_start_point(self, *args)

    def copyProperty_end_point(self, source):
        r"""
        copyProperty_end_point(LineGeometry self, LineGeometry source)

        Parameters
        ----------
        source: OpenSim::LineGeometry::Self const &

        """
        return _simulation.LineGeometry_copyProperty_end_point(self, source)

    def append_end_point(self, value):
        r"""
        append_end_point(LineGeometry self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_append_end_point(self, value)

    def constructProperty_end_point(self, initValue):
        r"""
        constructProperty_end_point(LineGeometry self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_constructProperty_end_point(self, initValue)

    def get_end_point(self, *args):
        r"""
        get_end_point(LineGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_end_point(LineGeometry self) -> Vec3
        """
        return _simulation.LineGeometry_get_end_point(self, *args)

    def upd_end_point(self, *args):
        r"""
        upd_end_point(LineGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_end_point(LineGeometry self) -> Vec3
        """
        return _simulation.LineGeometry_upd_end_point(self, *args)

    def set_end_point(self, *args):
        r"""
        set_end_point(LineGeometry self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_end_point(LineGeometry self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.LineGeometry_set_end_point(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor that takes two end points

        |

        *Overload 2:*
        default constructor, creates line (0,0,0)-(1,1,1)
        """
        _simulation.LineGeometry_swiginit(self, _simulation.new_LineGeometry(*args))
    __swig_destroy__ = _simulation.delete_LineGeometry

    def getPoints(self, rPoint1, rPoint2):
        r""" Get end points as Vec3 in passed in arguments"""
        return _simulation.LineGeometry_getPoints(self, rPoint1, rPoint2)

    def setPoints(self, aPoint1, aPoint2):
        r""" %Set end points from passed in arguments"""
        return _simulation.LineGeometry_setPoints(self, aPoint1, aPoint2)

# Register LineGeometry in _simulation:
_simulation.LineGeometry_swigregister(LineGeometry)
class Arrow(Geometry):
    r"""
    Arrow is a Geometry subclass used to represent an arrow. The arrow goes from
    start_point (Property) and has direction (Property) and length (Property)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Arrow

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Arrow_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Arrow self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Arrow_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Arrow_getClassName()

    def clone(self):
        r"""clone(Arrow self) -> Arrow"""
        return _simulation.Arrow_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Arrow self) -> std::string const &"""
        return _simulation.Arrow_getConcreteClassName(self)

    def copyProperty_start_point(self, source):
        r"""
        copyProperty_start_point(Arrow self, Arrow source)

        Parameters
        ----------
        source: OpenSim::Arrow::Self const &

        """
        return _simulation.Arrow_copyProperty_start_point(self, source)

    def append_start_point(self, value):
        r"""
        append_start_point(Arrow self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Arrow_append_start_point(self, value)

    def constructProperty_start_point(self, initValue):
        r"""
        constructProperty_start_point(Arrow self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Arrow_constructProperty_start_point(self, initValue)

    def get_start_point(self, *args):
        r"""
        get_start_point(Arrow self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_start_point(Arrow self) -> Vec3
        """
        return _simulation.Arrow_get_start_point(self, *args)

    def upd_start_point(self, *args):
        r"""
        upd_start_point(Arrow self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_start_point(Arrow self) -> Vec3
        """
        return _simulation.Arrow_upd_start_point(self, *args)

    def set_start_point(self, *args):
        r"""
        set_start_point(Arrow self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_start_point(Arrow self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Arrow_set_start_point(self, *args)

    def copyProperty_direction(self, source):
        r"""
        copyProperty_direction(Arrow self, Arrow source)

        Parameters
        ----------
        source: OpenSim::Arrow::Self const &

        """
        return _simulation.Arrow_copyProperty_direction(self, source)

    def append_direction(self, value):
        r"""
        append_direction(Arrow self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Arrow_append_direction(self, value)

    def constructProperty_direction(self, initValue):
        r"""
        constructProperty_direction(Arrow self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Arrow_constructProperty_direction(self, initValue)

    def get_direction(self, *args):
        r"""
        get_direction(Arrow self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_direction(Arrow self) -> Vec3
        """
        return _simulation.Arrow_get_direction(self, *args)

    def upd_direction(self, *args):
        r"""
        upd_direction(Arrow self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_direction(Arrow self) -> Vec3
        """
        return _simulation.Arrow_upd_direction(self, *args)

    def set_direction(self, *args):
        r"""
        set_direction(Arrow self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_direction(Arrow self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Arrow_set_direction(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(Arrow self, Arrow source)

        Parameters
        ----------
        source: OpenSim::Arrow::Self const &

        """
        return _simulation.Arrow_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(Arrow self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Arrow_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(Arrow self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Arrow_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(Arrow self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(Arrow self) -> double const &
        """
        return _simulation.Arrow_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(Arrow self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(Arrow self) -> double &
        """
        return _simulation.Arrow_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(Arrow self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(Arrow self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Arrow_set_length(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        constructor that takes startPoint, direction vector and length

        |

        *Overload 2:*
        Default constructor that creates Arrow of length 1 starting at origin
        in the direction (1,1,1)
        """
        _simulation.Arrow_swiginit(self, _simulation.new_Arrow(*args))
    __swig_destroy__ = _simulation.delete_Arrow

# Register Arrow in _simulation:
_simulation.Arrow_swigregister(Arrow)
class AnalyticGeometry(Geometry):
    r"""
    Abstract class for analytical geometry (e.g. surfaces of revolution) whose
    rendering is optimized by the graphics library (e.g. threejs). Unlike other
    geometry, property edits require a recreation of the AnalyticGeometry on
    the renderer and not simple updates. AnalyticGeometry is the base class for
    Sphere, Cylinder, Cone, Ellipsoid and Torus geometry.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AnalyticGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AnalyticGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AnalyticGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AnalyticGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AnalyticGeometry_getClassName()

    def clone(self):
        r"""clone(AnalyticGeometry self) -> AnalyticGeometry"""
        return _simulation.AnalyticGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AnalyticGeometry self) -> std::string const &"""
        return _simulation.AnalyticGeometry_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_AnalyticGeometry

# Register AnalyticGeometry in _simulation:
_simulation.AnalyticGeometry_swigregister(AnalyticGeometry)
class Sphere(AnalyticGeometry):
    r"""A class to represent Sphere geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Sphere

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Sphere_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Sphere self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Sphere_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Sphere_getClassName()

    def clone(self):
        r"""clone(Sphere self) -> Sphere"""
        return _simulation.Sphere_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Sphere self) -> std::string const &"""
        return _simulation.Sphere_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(Sphere self, Sphere source)

        Parameters
        ----------
        source: OpenSim::Sphere::Self const &

        """
        return _simulation.Sphere_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(Sphere self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Sphere_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(Sphere self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Sphere_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(Sphere self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(Sphere self) -> double const &
        """
        return _simulation.Sphere_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(Sphere self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(Sphere self) -> double &
        """
        return _simulation.Sphere_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(Sphere self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(Sphere self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Sphere_set_radius(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, creates a sphere of radius 1.0

        |

        *Overload 2:*
        Another constructor that takes in a specified radius
        """
        _simulation.Sphere_swiginit(self, _simulation.new_Sphere(*args))
    __swig_destroy__ = _simulation.delete_Sphere

# Register Sphere in _simulation:
_simulation.Sphere_swigregister(Sphere)
class Ellipsoid(AnalyticGeometry):
    r"""A class to represent an Ellipsoid geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Ellipsoid

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Ellipsoid_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Ellipsoid self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Ellipsoid_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Ellipsoid_getClassName()

    def clone(self):
        r"""clone(Ellipsoid self) -> Ellipsoid"""
        return _simulation.Ellipsoid_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Ellipsoid self) -> std::string const &"""
        return _simulation.Ellipsoid_getConcreteClassName(self)

    def copyProperty_radii(self, source):
        r"""
        copyProperty_radii(Ellipsoid self, Ellipsoid source)

        Parameters
        ----------
        source: OpenSim::Ellipsoid::Self const &

        """
        return _simulation.Ellipsoid_copyProperty_radii(self, source)

    def append_radii(self, value):
        r"""
        append_radii(Ellipsoid self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Ellipsoid_append_radii(self, value)

    def constructProperty_radii(self, initValue):
        r"""
        constructProperty_radii(Ellipsoid self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Ellipsoid_constructProperty_radii(self, initValue)

    def get_radii(self, *args):
        r"""
        get_radii(Ellipsoid self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_radii(Ellipsoid self) -> Vec3
        """
        return _simulation.Ellipsoid_get_radii(self, *args)

    def upd_radii(self, *args):
        r"""
        upd_radii(Ellipsoid self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_radii(Ellipsoid self) -> Vec3
        """
        return _simulation.Ellipsoid_upd_radii(self, *args)

    def set_radii(self, *args):
        r"""
        set_radii(Ellipsoid self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_radii(Ellipsoid self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Ellipsoid_set_radii(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, creates an Ellipsoid of radii 0.5, 1., 2.

        |

        *Overload 2:*
        Constructor that takes in three radii
        """
        _simulation.Ellipsoid_swiginit(self, _simulation.new_Ellipsoid(*args))
    __swig_destroy__ = _simulation.delete_Ellipsoid

    def setEllipsoidParams(self, radius1, radius2, radius3):
        r""" Convenience interface to set radii"""
        return _simulation.Ellipsoid_setEllipsoidParams(self, radius1, radius2, radius3)

# Register Ellipsoid in _simulation:
_simulation.Ellipsoid_swigregister(Ellipsoid)
class Cylinder(AnalyticGeometry):
    r"""A class to represent a Cylinder geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Cylinder

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Cylinder_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Cylinder self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Cylinder_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Cylinder_getClassName()

    def clone(self):
        r"""clone(Cylinder self) -> Cylinder"""
        return _simulation.Cylinder_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Cylinder self) -> std::string const &"""
        return _simulation.Cylinder_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(Cylinder self, Cylinder source)

        Parameters
        ----------
        source: OpenSim::Cylinder::Self const &

        """
        return _simulation.Cylinder_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(Cylinder self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cylinder_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(Cylinder self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Cylinder_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(Cylinder self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(Cylinder self) -> double const &
        """
        return _simulation.Cylinder_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(Cylinder self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(Cylinder self) -> double &
        """
        return _simulation.Cylinder_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(Cylinder self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(Cylinder self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cylinder_set_radius(self, *args)

    def copyProperty_half_height(self, source):
        r"""
        copyProperty_half_height(Cylinder self, Cylinder source)

        Parameters
        ----------
        source: OpenSim::Cylinder::Self const &

        """
        return _simulation.Cylinder_copyProperty_half_height(self, source)

    def append_half_height(self, value):
        r"""
        append_half_height(Cylinder self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cylinder_append_half_height(self, value)

    def constructProperty_half_height(self, initValue):
        r"""
        constructProperty_half_height(Cylinder self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Cylinder_constructProperty_half_height(self, initValue)

    def get_half_height(self, *args):
        r"""
        get_half_height(Cylinder self, int i) -> double const

        Parameters
        ----------
        i: int

        get_half_height(Cylinder self) -> double const &
        """
        return _simulation.Cylinder_get_half_height(self, *args)

    def upd_half_height(self, *args):
        r"""
        upd_half_height(Cylinder self, int i) -> double

        Parameters
        ----------
        i: int

        upd_half_height(Cylinder self) -> double &
        """
        return _simulation.Cylinder_upd_half_height(self, *args)

    def set_half_height(self, *args):
        r"""
        set_half_height(Cylinder self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_half_height(Cylinder self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cylinder_set_half_height(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor that takes radius and half-height
        """
        _simulation.Cylinder_swiginit(self, _simulation.new_Cylinder(*args))
    __swig_destroy__ = _simulation.delete_Cylinder

    def getCylinderParams(self, params):
        r""" Convenient way to get the two parameters that define the cylinder"""
        return _simulation.Cylinder_getCylinderParams(self, params)

# Register Cylinder in _simulation:
_simulation.Cylinder_swigregister(Cylinder)
class Cone(AnalyticGeometry):
    r"""A class to represent a Cone geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Cone

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Cone_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Cone self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Cone_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Cone_getClassName()

    def clone(self):
        r"""clone(Cone self) -> Cone"""
        return _simulation.Cone_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Cone self) -> std::string const &"""
        return _simulation.Cone_getConcreteClassName(self)

    def copyProperty_origin(self, source):
        r"""
        copyProperty_origin(Cone self, Cone source)

        Parameters
        ----------
        source: OpenSim::Cone::Self const &

        """
        return _simulation.Cone_copyProperty_origin(self, source)

    def append_origin(self, value):
        r"""
        append_origin(Cone self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Cone_append_origin(self, value)

    def constructProperty_origin(self, initValue):
        r"""
        constructProperty_origin(Cone self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Cone_constructProperty_origin(self, initValue)

    def get_origin(self, *args):
        r"""
        get_origin(Cone self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_origin(Cone self) -> Vec3
        """
        return _simulation.Cone_get_origin(self, *args)

    def upd_origin(self, *args):
        r"""
        upd_origin(Cone self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_origin(Cone self) -> Vec3
        """
        return _simulation.Cone_upd_origin(self, *args)

    def set_origin(self, *args):
        r"""
        set_origin(Cone self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_origin(Cone self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Cone_set_origin(self, *args)

    def copyProperty_direction(self, source):
        r"""
        copyProperty_direction(Cone self, Cone source)

        Parameters
        ----------
        source: OpenSim::Cone::Self const &

        """
        return _simulation.Cone_copyProperty_direction(self, source)

    def append_direction(self, value):
        r"""
        append_direction(Cone self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Cone_append_direction(self, value)

    def constructProperty_direction(self, initValue):
        r"""
        constructProperty_direction(Cone self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Cone_constructProperty_direction(self, initValue)

    def get_direction(self, *args):
        r"""
        get_direction(Cone self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_direction(Cone self) -> Vec3
        """
        return _simulation.Cone_get_direction(self, *args)

    def upd_direction(self, *args):
        r"""
        upd_direction(Cone self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_direction(Cone self) -> Vec3
        """
        return _simulation.Cone_upd_direction(self, *args)

    def set_direction(self, *args):
        r"""
        set_direction(Cone self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_direction(Cone self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Cone_set_direction(self, *args)

    def copyProperty_base_radius(self, source):
        r"""
        copyProperty_base_radius(Cone self, Cone source)

        Parameters
        ----------
        source: OpenSim::Cone::Self const &

        """
        return _simulation.Cone_copyProperty_base_radius(self, source)

    def append_base_radius(self, value):
        r"""
        append_base_radius(Cone self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cone_append_base_radius(self, value)

    def constructProperty_base_radius(self, initValue):
        r"""
        constructProperty_base_radius(Cone self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Cone_constructProperty_base_radius(self, initValue)

    def get_base_radius(self, *args):
        r"""
        get_base_radius(Cone self, int i) -> double const

        Parameters
        ----------
        i: int

        get_base_radius(Cone self) -> double const &
        """
        return _simulation.Cone_get_base_radius(self, *args)

    def upd_base_radius(self, *args):
        r"""
        upd_base_radius(Cone self, int i) -> double

        Parameters
        ----------
        i: int

        upd_base_radius(Cone self) -> double &
        """
        return _simulation.Cone_upd_base_radius(self, *args)

    def set_base_radius(self, *args):
        r"""
        set_base_radius(Cone self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_base_radius(Cone self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cone_set_base_radius(self, *args)

    def copyProperty_height(self, source):
        r"""
        copyProperty_height(Cone self, Cone source)

        Parameters
        ----------
        source: OpenSim::Cone::Self const &

        """
        return _simulation.Cone_copyProperty_height(self, source)

    def append_height(self, value):
        r"""
        append_height(Cone self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cone_append_height(self, value)

    def constructProperty_height(self, initValue):
        r"""
        constructProperty_height(Cone self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Cone_constructProperty_height(self, initValue)

    def get_height(self, *args):
        r"""
        get_height(Cone self, int i) -> double const

        Parameters
        ----------
        i: int

        get_height(Cone self) -> double const &
        """
        return _simulation.Cone_get_height(self, *args)

    def upd_height(self, *args):
        r"""
        upd_height(Cone self, int i) -> double

        Parameters
        ----------
        i: int

        upd_height(Cone self) -> double &
        """
        return _simulation.Cone_upd_height(self, *args)

    def set_height(self, *args):
        r"""
        set_height(Cone self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_height(Cone self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Cone_set_height(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor that takes radius and half-height
        """
        _simulation.Cone_swiginit(self, _simulation.new_Cone(*args))
    __swig_destroy__ = _simulation.delete_Cone

# Register Cone in _simulation:
_simulation.Cone_swigregister(Cone)
class Torus(AnalyticGeometry):
    r"""
    A class to represent Torus geometry. The torus is centered at the
    origin with the axial direction aligned to the z-axis. It is defined by
    a ring_radius (radius of the circular centerline of the torus, measured
    from the origin), and a cross_section (radius of the torus cross-section:
    perpendicular distance from the circular centerline to the surface).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Torus

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Torus_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Torus self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Torus_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Torus_getClassName()

    def clone(self):
        r"""clone(Torus self) -> Torus"""
        return _simulation.Torus_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Torus self) -> std::string const &"""
        return _simulation.Torus_getConcreteClassName(self)

    def copyProperty_cross_section(self, source):
        r"""
        copyProperty_cross_section(Torus self, Torus source)

        Parameters
        ----------
        source: OpenSim::Torus::Self const &

        """
        return _simulation.Torus_copyProperty_cross_section(self, source)

    def append_cross_section(self, value):
        r"""
        append_cross_section(Torus self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Torus_append_cross_section(self, value)

    def constructProperty_cross_section(self, initValue):
        r"""
        constructProperty_cross_section(Torus self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Torus_constructProperty_cross_section(self, initValue)

    def get_cross_section(self, *args):
        r"""
        get_cross_section(Torus self, int i) -> double const

        Parameters
        ----------
        i: int

        get_cross_section(Torus self) -> double const &
        """
        return _simulation.Torus_get_cross_section(self, *args)

    def upd_cross_section(self, *args):
        r"""
        upd_cross_section(Torus self, int i) -> double

        Parameters
        ----------
        i: int

        upd_cross_section(Torus self) -> double &
        """
        return _simulation.Torus_upd_cross_section(self, *args)

    def set_cross_section(self, *args):
        r"""
        set_cross_section(Torus self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_cross_section(Torus self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Torus_set_cross_section(self, *args)

    def copyProperty_ring_radius(self, source):
        r"""
        copyProperty_ring_radius(Torus self, Torus source)

        Parameters
        ----------
        source: OpenSim::Torus::Self const &

        """
        return _simulation.Torus_copyProperty_ring_radius(self, source)

    def append_ring_radius(self, value):
        r"""
        append_ring_radius(Torus self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Torus_append_ring_radius(self, value)

    def constructProperty_ring_radius(self, initValue):
        r"""
        constructProperty_ring_radius(Torus self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Torus_constructProperty_ring_radius(self, initValue)

    def get_ring_radius(self, *args):
        r"""
        get_ring_radius(Torus self, int i) -> double const

        Parameters
        ----------
        i: int

        get_ring_radius(Torus self) -> double const &
        """
        return _simulation.Torus_get_ring_radius(self, *args)

    def upd_ring_radius(self, *args):
        r"""
        upd_ring_radius(Torus self, int i) -> double

        Parameters
        ----------
        i: int

        upd_ring_radius(Torus self) -> double &
        """
        return _simulation.Torus_upd_ring_radius(self, *args)

    def set_ring_radius(self, *args):
        r"""
        set_ring_radius(Torus self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_ring_radius(Torus self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Torus_set_ring_radius(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Constructor that takes in two radii
        """
        _simulation.Torus_swiginit(self, _simulation.new_Torus(*args))
    __swig_destroy__ = _simulation.delete_Torus

# Register Torus in _simulation:
_simulation.Torus_swigregister(Torus)
class Brick(Geometry):
    r"""A class to represent Brick geometry. Brick is specified by three half_lengths"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Brick

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Brick_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Brick self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Brick_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Brick_getClassName()

    def clone(self):
        r"""clone(Brick self) -> Brick"""
        return _simulation.Brick_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Brick self) -> std::string const &"""
        return _simulation.Brick_getConcreteClassName(self)

    def copyProperty_half_lengths(self, source):
        r"""
        copyProperty_half_lengths(Brick self, Brick source)

        Parameters
        ----------
        source: OpenSim::Brick::Self const &

        """
        return _simulation.Brick_copyProperty_half_lengths(self, source)

    def append_half_lengths(self, value):
        r"""
        append_half_lengths(Brick self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Brick_append_half_lengths(self, value)

    def constructProperty_half_lengths(self, initValue):
        r"""
        constructProperty_half_lengths(Brick self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Brick_constructProperty_half_lengths(self, initValue)

    def get_half_lengths(self, *args):
        r"""
        get_half_lengths(Brick self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_half_lengths(Brick self) -> Vec3
        """
        return _simulation.Brick_get_half_lengths(self, *args)

    def upd_half_lengths(self, *args):
        r"""
        upd_half_lengths(Brick self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_half_lengths(Brick self) -> Vec3
        """
        return _simulation.Brick_upd_half_lengths(self, *args)

    def set_half_lengths(self, *args):
        r"""
        set_half_lengths(Brick self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_half_lengths(Brick self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Brick_set_half_lengths(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes a Brick with half-length 0.1,0.2,0.3

        |

        *Overload 2:*
        Convenience constructor with specified half-lengths
        """
        _simulation.Brick_swiginit(self, _simulation.new_Brick(*args))
    __swig_destroy__ = _simulation.delete_Brick

# Register Brick in _simulation:
_simulation.Brick_swigregister(Brick)
class Mesh(Geometry):
    r"""
    A class to represent Mesh geometry that comes from a file.
    Supported file formats .vtp, .stl, .obj but will grow over time
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Mesh

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Mesh_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Mesh self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Mesh_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Mesh_getClassName()

    def clone(self):
        r"""clone(Mesh self) -> Mesh"""
        return _simulation.Mesh_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Mesh self) -> std::string const &"""
        return _simulation.Mesh_getConcreteClassName(self)

    def copyProperty_mesh_file(self, source):
        r"""
        copyProperty_mesh_file(Mesh self, Mesh source)

        Parameters
        ----------
        source: OpenSim::Mesh::Self const &

        """
        return _simulation.Mesh_copyProperty_mesh_file(self, source)

    def append_mesh_file(self, value):
        r"""
        append_mesh_file(Mesh self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Mesh_append_mesh_file(self, value)

    def constructProperty_mesh_file(self, initValue):
        r"""
        constructProperty_mesh_file(Mesh self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Mesh_constructProperty_mesh_file(self, initValue)

    def get_mesh_file(self, *args):
        r"""
        get_mesh_file(Mesh self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_mesh_file(Mesh self) -> std::string const &
        """
        return _simulation.Mesh_get_mesh_file(self, *args)

    def upd_mesh_file(self, *args):
        r"""
        upd_mesh_file(Mesh self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_mesh_file(Mesh self) -> std::string &
        """
        return _simulation.Mesh_upd_mesh_file(self, *args)

    def set_mesh_file(self, *args):
        r"""
        set_mesh_file(Mesh self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_mesh_file(Mesh self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Mesh_set_mesh_file(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Constructor that takes a mesh file name
        """
        _simulation.Mesh_swiginit(self, _simulation.new_Mesh(*args))

    def getGeometryFilename(self):
        r""" Retrieve file name"""
        return _simulation.Mesh_getGeometryFilename(self)
    __swig_destroy__ = _simulation.delete_Mesh

# Register Mesh in _simulation:
_simulation.Mesh_swigregister(Mesh)
class FrameGeometry(Geometry):
    r"""
    A class to represent Frame geometry. Knobs that can be changed
    are in Appearance::Representation, size, thickness.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FrameGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FrameGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FrameGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FrameGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FrameGeometry_getClassName()

    def clone(self):
        r"""clone(FrameGeometry self) -> FrameGeometry"""
        return _simulation.FrameGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FrameGeometry self) -> std::string const &"""
        return _simulation.FrameGeometry_getConcreteClassName(self)

    def copyProperty_display_radius(self, source):
        r"""
        copyProperty_display_radius(FrameGeometry self, FrameGeometry source)

        Parameters
        ----------
        source: OpenSim::FrameGeometry::Self const &

        """
        return _simulation.FrameGeometry_copyProperty_display_radius(self, source)

    def append_display_radius(self, value):
        r"""
        append_display_radius(FrameGeometry self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FrameGeometry_append_display_radius(self, value)

    def constructProperty_display_radius(self, initValue):
        r"""
        constructProperty_display_radius(FrameGeometry self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FrameGeometry_constructProperty_display_radius(self, initValue)

    def get_display_radius(self, *args):
        r"""
        get_display_radius(FrameGeometry self, int i) -> double const

        Parameters
        ----------
        i: int

        get_display_radius(FrameGeometry self) -> double const &
        """
        return _simulation.FrameGeometry_get_display_radius(self, *args)

    def upd_display_radius(self, *args):
        r"""
        upd_display_radius(FrameGeometry self, int i) -> double

        Parameters
        ----------
        i: int

        upd_display_radius(FrameGeometry self) -> double &
        """
        return _simulation.FrameGeometry_upd_display_radius(self, *args)

    def set_display_radius(self, *args):
        r"""
        set_display_radius(FrameGeometry self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_display_radius(FrameGeometry self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FrameGeometry_set_display_radius(self, *args)

    def __init__(self, scale=0.2):
        r""" Default constructor"""
        _simulation.FrameGeometry_swiginit(self, _simulation.new_FrameGeometry(scale))
    __swig_destroy__ = _simulation.delete_FrameGeometry

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        generateDecorations(FrameGeometry self, bool fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        state: SimTK::State const &
        appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.FrameGeometry_generateDecorations(self, fixed, hints, state, appendToThis)

# Register FrameGeometry in _simulation:
_simulation.FrameGeometry_swigregister(FrameGeometry)
class ModelComponent(opensim.common.Component):
    r"""
    This defines the abstract ModelComponent class, which is used to specify
    components of a musculoskeletal model and the elements they add to the
    underlying computational SimTK::System (MultibodySystem). A ModelComponent is
    an OpenSim::Component and therefore has the capabilities to add necessary
    system resources to the System and to manage access to those resources (See also: 
    Component)

    Bodies, Joints, Coordinates, Constraints, Forces, Actuators, Controllers,
    and even Model itself, are ModelComponents. Each component is "connected" to
    a model and an underlying SimTK::Subsystem, which by default is the
    System's DefaultSubsystem.

    The primary responsibility of a ModelComponent is to add its computational
    representation(s) of physical musculoskeletal structures to the underlying
    SimTK::System by implementing extendAddToSystem().

    Additional methods provide support for adding modeling options, state and
    cache variables (See also: Component).

    Public methods enable access to component variables via their names.

    Author: Ajay Seth, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponent

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponent_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponent self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponent_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponent_getClassName()

    def clone(self):
        r"""clone(ModelComponent self) -> ModelComponent"""
        return _simulation.ModelComponent_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponent self) -> std::string const &"""
        return _simulation.ModelComponent_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ModelComponent

    def connectToModel(self, model):
        r""" Connect this ModelComponent to its aggregate- a  Model"""
        return _simulation.ModelComponent_connectToModel(self, model)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ModelComponent_getModel(self)

    def updModel(self):
        r""" Get a modifiable reference to the Model this component is part of."""
        return _simulation.ModelComponent_updModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ModelComponent_hasModel(self)

    def preScale(self, s, scaleSet):
        r"""
        Perform any computations that must occur before ModelComponent::scale()
               is invoked on all ModelComponents in the Model. For example, a
               GeometryPath must calculate and store its path length in the original
               model before scaling so that an owning Muscle can use this information
               to update the properties of the muscle after scaling. This method calls
               the virtual extendPreScale() method, which may be implemented by any
               subclass of ModelComponent.
               See also: extendPreScale()
               See also: scale()
               See also: postScale()
        """
        return _simulation.ModelComponent_preScale(self, s, scaleSet)

    def scale(self, s, scaleSet):
        r"""
        Scale the ModelComponent. This method calls the virtual extendScale()
               method, which may be implemented by any subclass of ModelComponent.
               See also: preScale()
               See also: extendScale()
               See also: postScale()
        """
        return _simulation.ModelComponent_scale(self, s, scaleSet)

    def postScale(self, s, scaleSet):
        r"""
        Perform any computations that must occur after ModelComponent::scale()
               has been invoked on all ModelComponents in the Model. This method calls
               the virtual extendPostScale() method, which may be implemented by any
               subclass of ModelComponent.
               See also: preScale()
               See also: scale()
               See also: extendPostScale()
        """
        return _simulation.ModelComponent_postScale(self, s, scaleSet)

# Register ModelComponent in _simulation:
_simulation.ModelComponent_swigregister(ModelComponent)
class SetModelComponents(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetModelComponents

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetModelComponents_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetModelComponents self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetModelComponents_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetModelComponents_getClassName()

    def clone(self):
        r"""clone(SetModelComponents self) -> SetModelComponents"""
        return _simulation.SetModelComponents_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetModelComponents self) -> std::string const &"""
        return _simulation.SetModelComponents_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetModelComponents

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ModelComponent,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetModelComponents_swiginit(self, _simulation.new_SetModelComponents(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetModelComponents_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetModelComponents_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetModelComponents_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetModelComponents_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetModelComponents_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetModelComponents_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetModelComponents_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetModelComponents_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetModelComponents_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetModelComponents_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetModelComponents self)"""
        return _simulation.SetModelComponents_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetModelComponents_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ModelComponent`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ModelComponent`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetModelComponents_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetModelComponents_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetModelComponents_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetModelComponents_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetModelComponents_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetModelComponents_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetModelComponents_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetModelComponents_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetModelComponents_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetModelComponents_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetModelComponents in _simulation:
_simulation.SetModelComponents_swigregister(SetModelComponents)
class ModelComponentSetModelComponent(SetModelComponents):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::ModelComponent > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetModelComponent

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetModelComponent_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetModelComponent self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetModelComponent_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetModelComponent_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetModelComponent self) -> ModelComponentSetModelComponent"""
        return _simulation.ModelComponentSetModelComponent_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetModelComponent self) -> std::string const &"""
        return _simulation.ModelComponentSetModelComponent_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetModelComponent self)"""
        return _simulation.ModelComponentSetModelComponent_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetModelComponent self) -> ModelComponentSetModelComponent"""
        _simulation.ModelComponentSetModelComponent_swiginit(self, _simulation.new_ModelComponentSetModelComponent())
    __swig_destroy__ = _simulation.delete_ModelComponentSetModelComponent

# Register ModelComponentSetModelComponent in _simulation:
_simulation.ModelComponentSetModelComponent_swigregister(ModelComponentSetModelComponent)
class ComponentSet(ModelComponentSetModelComponent):
    r"""
    A class for holding a set of miscellaneous model components.

    Authors: Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ComponentSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ComponentSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ComponentSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ComponentSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ComponentSet_getClassName()

    def clone(self):
        r"""clone(ComponentSet self) -> ComponentSet"""
        return _simulation.ComponentSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ComponentSet self) -> std::string const &"""
        return _simulation.ComponentSet_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(ComponentSet self) -> ComponentSet"""
        _simulation.ComponentSet_swiginit(self, _simulation.new_ComponentSet())
    __swig_destroy__ = _simulation.delete_ComponentSet

# Register ComponentSet in _simulation:
_simulation.ComponentSet_swigregister(ComponentSet)
class SetMuscles(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetMuscles

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetMuscles_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetMuscles self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetMuscles_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetMuscles_getClassName()

    def clone(self):
        r"""clone(SetMuscles self) -> SetMuscles"""
        return _simulation.SetMuscles_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetMuscles self) -> std::string const &"""
        return _simulation.SetMuscles_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMuscles

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Muscle,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetMuscles_swiginit(self, _simulation.new_SetMuscles(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMuscles_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMuscles_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMuscles_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMuscles_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Muscle`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMuscles_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetMuscles_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMuscles_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Muscle`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMuscles_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMuscles_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMuscles_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetMuscles self)"""
        return _simulation.SetMuscles_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMuscles_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Muscle`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Muscle`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMuscles_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMuscles_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMuscles_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetMuscles_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetMuscles_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMuscles_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetMuscles_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetMuscles_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetMuscles_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMuscles_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMuscles in _simulation:
_simulation.SetMuscles_swigregister(SetMuscles)
class Solver(opensim.common.OpenSimObject):
    r"""
    The base (abstract) class for a family of objects responsible for solving
    system equations (statics, dynamic, kinematics, muscle, etc...) given by a
    model for values of interest.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Solver

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Solver_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Solver self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Solver_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Solver_getClassName()

    def clone(self):
        r"""clone(Solver self) -> Solver"""
        return _simulation.Solver_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Solver self) -> std::string const &"""
        return _simulation.Solver_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_Solver

    def getModel(self):
        r"""getModel(Solver self) -> Model"""
        return _simulation.Solver_getModel(self)

# Register Solver in _simulation:
_simulation.Solver_swigregister(Solver)
class InverseDynamicsSolver(Solver):
    r"""
    Solve for the generalized coordinate forces (1 per degree-of-
    freedom) that satisfy the unconstrained equations of motion given kinematics:
    q, u, u_dot

    The InverseDynamics equation: Tau = M*u_dot-G(q)-C(q,u)-A(q,u,t,x)

    The InverseDynamicsSolver utilizes efficient methods in Simbody(TM) to
    compute the generalized forces, Tau, without explicitly forming the Mass
    matrix, M. System gravity, G, centrifugal and Coriolis, C, forces are
    computed internally.
    Caller provides q,u,t (supplied by the State), the desired u_dot and the
    applied loads, A. If applied loads are due to forces in the model, these
    loads are automatically computed and applied unless explicitly disabled in
    the model.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> InverseDynamicsSolver

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.InverseDynamicsSolver_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(InverseDynamicsSolver self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.InverseDynamicsSolver_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.InverseDynamicsSolver_getClassName()

    def clone(self):
        r"""clone(InverseDynamicsSolver self) -> InverseDynamicsSolver"""
        return _simulation.InverseDynamicsSolver_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(InverseDynamicsSolver self) -> std::string const &"""
        return _simulation.InverseDynamicsSolver_getConcreteClassName(self)

    def __init__(self, model):
        r""" Construct an InverseDynamics solver applied to the provided model"""
        _simulation.InverseDynamicsSolver_swiginit(self, _simulation.new_InverseDynamicsSolver(model))

    def solve(self, *args):
        r"""
        *Overload 1:*
        Solve the inverse dynamics system of equations for generalized
               coordinate forces, Tau. Applied loads are computed by the model
               according to the state.
               :type s: :py:class:`State`, in
               :param s:    the system state specifying time, coordinates and speeds
               :type udot: :py:class:`Vector`, in, optional
               :param udot: the vector of generalized accelerations in the order

        |

        *Overload 2:*
        Solve the inverse dynamics system of equations for generalized coordinate forces, Tau.
               Applied loads are explicitly provided as generalized coordinate forces (MobilityForces)
               and/or a Vector of Spatial-body forces

        |

        *Overload 3:*
        Solve the inverse dynamics system of equations for generalized coordinate
               forces, Tau. Now the state is updated from known coordinates, q, as
               functions of time. Coordinate functions must be twice differentiable and
               are used to supply the coordinate speed and acceleration. Coordinate
               functions must be in the same order as the order of q's, u's, and udot's
               in the provided SimTK::State.
               NOTE: forces with internal states should be removed/disabled prior to
                     solving if default state is inappropriate

        |

        *Overload 4:*
        This is the same as above, but can be used when qdot != u. This adds an
               extra vector, coordinatesToSpeedsIndexMap, which is the length of number of u's in
               the SimTK::State, and whose i'th index is the index of the FunctionSet
               Qs from which each 'u' and 'udot' will be calculated.
        """
        return _simulation.InverseDynamicsSolver_solve(self, *args)
    __swig_destroy__ = _simulation.delete_InverseDynamicsSolver

# Register InverseDynamicsSolver in _simulation:
_simulation.InverseDynamicsSolver_swigregister(InverseDynamicsSolver)
class MomentArmSolver(Solver):
    r"""
    Solve for the effective moment arms at all degrees-of-freedom due to one or
    more point forces.  This may result from the underlying geometry of a Force
    or Actuator with a complex path (like ligaments and muscles) but this solver
    is only concerned with the set of points and unit forces that maps a scalar
    force value (like tension) to the resulting generalized force.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MomentArmSolver

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MomentArmSolver_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MomentArmSolver self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MomentArmSolver_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MomentArmSolver_getClassName()

    def clone(self):
        r"""clone(MomentArmSolver self) -> MomentArmSolver"""
        return _simulation.MomentArmSolver_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MomentArmSolver self) -> std::string const &"""
        return _simulation.MomentArmSolver_getConcreteClassName(self)

    def __init__(self, model):
        r"""
        __init__(MomentArmSolver self, Model model) -> MomentArmSolver

        Parameters
        ----------
        model: OpenSim::Model const &

        """
        _simulation.MomentArmSolver_swiginit(self, _simulation.new_MomentArmSolver(model))
    __swig_destroy__ = _simulation.delete_MomentArmSolver

    def solve(self, *args):
        r"""
        *Overload 1:*
        Solve for the effective moment-arm about the all coordinates (q) based
               on the geometric distribution of forces described by a GeometryPath.
           :type state: :py:class:`State`
           :param state:               current state of the model
           :type coordinate: :py:class:`Coordinate`
           :param coordinate:          Coordinate about which we want the moment-arm
           :type path: :py:class:`GeometryPath`
           :param path:                GeometryPath for which to calculate a moment-arm
           :rtype: float
           :return: ma                  resulting moment-arm as a double

        |

        *Overload 2:*
        Solve for the effective moment-arm about the specified coordinate based
               on the geometric distribution of forces described by the list of
               PointForceDirections.
           :type state: :py:class:`State`
           :param state:               current state of the model
           :type coordinate: :py:class:`Coordinate`
           :param coordinate:          Coordinate about which we want the moment-arm
           :type pfds: OpenSim::Array< OpenSim::PointForceDirection * >
           :param pfds:                PointForceDirections applied to the model
           :rtype: float
           :return: ma                  resulting moment-arm as a double
        """
        return _simulation.MomentArmSolver_solve(self, *args)

# Register MomentArmSolver in _simulation:
_simulation.MomentArmSolver_swigregister(MomentArmSolver)
class Frame(ModelComponent):
    r"""
    A Frame is an OpenSim representation of a reference frame. It consists of
    a right-handed set of three orthogonal axes and an origin point. Frames are
    intended to provide convenient reference frames for locating physical
    structures (such as joints and muscle attachments) as well as provide a
    convenient basis for performing spatial calculations. For example, if your
    system involves contact, you might define a Frame that is aligned with the
    normal direction of a contact surface and whose origin is at the
    center-of-pressure.

    Every Frame is capable of providing its SimTK::Transform (translation of
    the origin and the orientation of its axes) in the Ground frame as a
    function of the Model's (SimTK::MultibodySystem's) state.

    The Frame class also provides convenience methods for re-expressing vectors
    from one Frame to another.

    As already noted, Frames are useful for locating physical structures such as
    bodies, their joints, and the locations where constraints can be connected
    and forces can be applied. It is perhaps less evident that Frames can be
    extremely useful for relating a multitude of reference frames together to
    form chains and trees. For example, a Frame to specify muscle attachments
    (M) and a Frame to specify a joint location (J) could themselves be
    specified in an anatomical Frame (A) defined by bony landmarks identified
    by surface markers or tagged on CT or MRI images. The body (B), to which the
    anatomical frame (A) is attached, can be thought of as a "Base" frame or a
    root of a tree from which a set of descendant frames arise. In particular, a
    Base frame and all its descendants have the property that they share the
    same angular velocity, since they are affixed to the same underlying Frame
    (in this case a Body).

            M---muscle points
           /
      B---A

            J---joint axes

    Therefore, a useful concept is that of a Base frame, and a Frame can always
    provide a Base frame. If a Frame is not affixed to another frame, its Base
    frame is itself.

    See also: SimTK::Transform

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Frame

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Frame_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Frame self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Frame_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Frame_getClassName()

    def clone(self):
        r"""clone(Frame self) -> Frame"""
        return _simulation.Frame_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Frame self) -> std::string const &"""
        return _simulation.Frame_getConcreteClassName(self)

    def copyProperty_frame_geometry(self, source):
        r"""
        copyProperty_frame_geometry(Frame self, Frame source)

        Parameters
        ----------
        source: OpenSim::Frame::Self const &

        """
        return _simulation.Frame_copyProperty_frame_geometry(self, source)

    def append_frame_geometry(self, value):
        r"""
        append_frame_geometry(Frame self, FrameGeometry value) -> int

        Parameters
        ----------
        value: OpenSim::FrameGeometry const &

        """
        return _simulation.Frame_append_frame_geometry(self, value)

    def constructProperty_frame_geometry(self, initValue):
        r"""
        constructProperty_frame_geometry(Frame self, FrameGeometry initValue)

        Parameters
        ----------
        initValue: OpenSim::FrameGeometry const &

        """
        return _simulation.Frame_constructProperty_frame_geometry(self, initValue)

    def get_frame_geometry(self, *args):
        r"""
        get_frame_geometry(Frame self, int i) -> FrameGeometry

        Parameters
        ----------
        i: int

        get_frame_geometry(Frame self) -> FrameGeometry
        """
        return _simulation.Frame_get_frame_geometry(self, *args)

    def upd_frame_geometry(self, *args):
        r"""
        upd_frame_geometry(Frame self, int i) -> FrameGeometry

        Parameters
        ----------
        i: int

        upd_frame_geometry(Frame self) -> FrameGeometry
        """
        return _simulation.Frame_upd_frame_geometry(self, *args)

    def set_frame_geometry(self, *args):
        r"""
        set_frame_geometry(Frame self, int i, FrameGeometry value)

        Parameters
        ----------
        i: int
        value: OpenSim::FrameGeometry const &

        set_frame_geometry(Frame self, FrameGeometry value)

        Parameters
        ----------
        value: OpenSim::FrameGeometry const &

        """
        return _simulation.Frame_set_frame_geometry(self, *args)

    def copyProperty_attached_geometry(self, source):
        r"""
        copyProperty_attached_geometry(Frame self, Frame source)

        Parameters
        ----------
        source: OpenSim::Frame::Self const &

        """
        return _simulation.Frame_copyProperty_attached_geometry(self, source)

    def get_attached_geometry(self, i):
        r"""
        get_attached_geometry(Frame self, int i) -> Geometry

        Parameters
        ----------
        i: int

        """
        return _simulation.Frame_get_attached_geometry(self, i)

    def upd_attached_geometry(self, i):
        r"""
        upd_attached_geometry(Frame self, int i) -> Geometry

        Parameters
        ----------
        i: int

        """
        return _simulation.Frame_upd_attached_geometry(self, i)

    def set_attached_geometry(self, i, value):
        r"""
        set_attached_geometry(Frame self, int i, Geometry value)

        Parameters
        ----------
        i: int
        value: OpenSim::Geometry const &

        """
        return _simulation.Frame_set_attached_geometry(self, i, value)

    def append_attached_geometry(self, value):
        r"""
        append_attached_geometry(Frame self, Geometry value) -> int

        Parameters
        ----------
        value: OpenSim::Geometry const &

        """
        return _simulation.Frame_append_attached_geometry(self, value)

    def constructProperty_attached_geometry(self):
        r"""constructProperty_attached_geometry(Frame self)"""
        return _simulation.Frame_constructProperty_attached_geometry(self)
    _has_output_position = property(_simulation.Frame__has_output_position_get, _simulation.Frame__has_output_position_set, doc=r"""_has_output_position : bool""")
    _has_output_rotation = property(_simulation.Frame__has_output_rotation_get, _simulation.Frame__has_output_rotation_set, doc=r"""_has_output_rotation : bool""")
    _has_output_transform = property(_simulation.Frame__has_output_transform_get, _simulation.Frame__has_output_transform_set, doc=r"""_has_output_transform : bool""")
    _has_output_velocity = property(_simulation.Frame__has_output_velocity_get, _simulation.Frame__has_output_velocity_set, doc=r"""_has_output_velocity : bool""")
    _has_output_angular_velocity = property(_simulation.Frame__has_output_angular_velocity_get, _simulation.Frame__has_output_angular_velocity_set, doc=r"""_has_output_angular_velocity : bool""")
    _has_output_linear_velocity = property(_simulation.Frame__has_output_linear_velocity_get, _simulation.Frame__has_output_linear_velocity_set, doc=r"""_has_output_linear_velocity : bool""")
    _has_output_acceleration = property(_simulation.Frame__has_output_acceleration_get, _simulation.Frame__has_output_acceleration_set, doc=r"""_has_output_acceleration : bool""")
    _has_output_angular_acceleration = property(_simulation.Frame__has_output_angular_acceleration_get, _simulation.Frame__has_output_angular_acceleration_set, doc=r"""_has_output_angular_acceleration : bool""")
    _has_output_linear_acceleration = property(_simulation.Frame__has_output_linear_acceleration_get, _simulation.Frame__has_output_linear_acceleration_set, doc=r"""_has_output_linear_acceleration : bool""")
    __swig_destroy__ = _simulation.delete_Frame

    def getTransformInGround(self, state):
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.Frame_getTransformInGround(self, state)

    def getVelocityInGround(self, state):
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.Frame_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state):
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.Frame_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state):
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.Frame_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state):
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.Frame_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state):
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.Frame_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state):
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.Frame_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state, otherFrame):
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.Frame_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state, vec_F, otherFrame):
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.Frame_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state, vec_F):
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.Frame_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state, station_F, otherFrame):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.Frame_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.Frame_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.Frame_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.Frame_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self):
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.Frame_findBaseFrame(self)

    def findTransformInBaseFrame(self):
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.Frame_findTransformInBaseFrame(self)

    def getPositionInGround(self, state):
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.Frame_getPositionInGround(self, state)

    def getRotationInGround(self, state):
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.Frame_getRotationInGround(self, state)

    def attachGeometry(self, geom):
        r"""
        Attach Geometry to this Frame and have this Frame take ownership of
                it by adding it to this Frame's <attached_geometry> property list.
                The Geometry is treated as being fixed to this Frame such that the
                transform used to position the Geometry is that of this Frame.
        """
        val = _simulation.Frame_attachGeometry(self, geom)

        geom._markAdopted()


        return val


    def scaleAttachedGeometry(self, scaleFactors):
        r"""
        scaleAttachedGeometry(Frame self, Vec3 scaleFactors)

        Parameters
        ----------
        scaleFactors: SimTK::Vec3 const &

        """
        return _simulation.Frame_scaleAttachedGeometry(self, scaleFactors)

    def extendScale(self, s, scaleSet):
        r"""
        Scales Geometry components that reside in the Frame's
               `attached_geometry` list property. Note that Geometry residing elsewhere
               (e.g., in the `components` list property of a Frame or any other
               Component) will not be scaled. Note also that ContactGeometry derives
               from ModelComponent so the classes derived from ContactGeometry are
               responsible for scaling themselves. (However, `scale()` is not currently
               implemented on ContactGeometry or classes derived therefrom so they will
               not scale with the Model.)
        """
        return _simulation.Frame_extendScale(self, s, scaleSet)

# Register Frame in _simulation:
_simulation.Frame_swigregister(Frame)
class WrapObject(ModelComponent):
    r"""
    An abstract class that specifies the interface for a wrapping
    object.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapObject

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapObject_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapObject self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapObject_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapObject_getClassName()

    def clone(self):
        r"""clone(WrapObject self) -> WrapObject"""
        return _simulation.WrapObject_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapObject self) -> std::string const &"""
        return _simulation.WrapObject_getConcreteClassName(self)

    def copyProperty_active(self, source):
        r"""
        copyProperty_active(WrapObject self, WrapObject source)

        Parameters
        ----------
        source: OpenSim::WrapObject::Self const &

        """
        return _simulation.WrapObject_copyProperty_active(self, source)

    def append_active(self, value):
        r"""
        append_active(WrapObject self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.WrapObject_append_active(self, value)

    def constructProperty_active(self, initValue):
        r"""
        constructProperty_active(WrapObject self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.WrapObject_constructProperty_active(self, initValue)

    def get_active(self, *args):
        r"""
        get_active(WrapObject self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_active(WrapObject self) -> bool const &
        """
        return _simulation.WrapObject_get_active(self, *args)

    def upd_active(self, *args):
        r"""
        upd_active(WrapObject self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_active(WrapObject self) -> bool &
        """
        return _simulation.WrapObject_upd_active(self, *args)

    def set_active(self, *args):
        r"""
        set_active(WrapObject self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_active(WrapObject self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.WrapObject_set_active(self, *args)

    def copyProperty_xyz_body_rotation(self, source):
        r"""
        copyProperty_xyz_body_rotation(WrapObject self, WrapObject source)

        Parameters
        ----------
        source: OpenSim::WrapObject::Self const &

        """
        return _simulation.WrapObject_copyProperty_xyz_body_rotation(self, source)

    def append_xyz_body_rotation(self, value):
        r"""
        append_xyz_body_rotation(WrapObject self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_append_xyz_body_rotation(self, value)

    def constructProperty_xyz_body_rotation(self, initValue):
        r"""
        constructProperty_xyz_body_rotation(WrapObject self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_constructProperty_xyz_body_rotation(self, initValue)

    def get_xyz_body_rotation(self, *args):
        r"""
        get_xyz_body_rotation(WrapObject self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_xyz_body_rotation(WrapObject self) -> Vec3
        """
        return _simulation.WrapObject_get_xyz_body_rotation(self, *args)

    def upd_xyz_body_rotation(self, *args):
        r"""
        upd_xyz_body_rotation(WrapObject self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_xyz_body_rotation(WrapObject self) -> Vec3
        """
        return _simulation.WrapObject_upd_xyz_body_rotation(self, *args)

    def set_xyz_body_rotation(self, *args):
        r"""
        set_xyz_body_rotation(WrapObject self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_xyz_body_rotation(WrapObject self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_set_xyz_body_rotation(self, *args)

    def copyProperty_translation(self, source):
        r"""
        copyProperty_translation(WrapObject self, WrapObject source)

        Parameters
        ----------
        source: OpenSim::WrapObject::Self const &

        """
        return _simulation.WrapObject_copyProperty_translation(self, source)

    def append_translation(self, value):
        r"""
        append_translation(WrapObject self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_append_translation(self, value)

    def constructProperty_translation(self, initValue):
        r"""
        constructProperty_translation(WrapObject self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_constructProperty_translation(self, initValue)

    def get_translation(self, *args):
        r"""
        get_translation(WrapObject self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translation(WrapObject self) -> Vec3
        """
        return _simulation.WrapObject_get_translation(self, *args)

    def upd_translation(self, *args):
        r"""
        upd_translation(WrapObject self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translation(WrapObject self) -> Vec3
        """
        return _simulation.WrapObject_upd_translation(self, *args)

    def set_translation(self, *args):
        r"""
        set_translation(WrapObject self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translation(WrapObject self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapObject_set_translation(self, *args)

    def copyProperty_Appearance(self, source):
        r"""
        copyProperty_Appearance(WrapObject self, WrapObject source)

        Parameters
        ----------
        source: OpenSim::WrapObject::Self const &

        """
        return _simulation.WrapObject_copyProperty_Appearance(self, source)

    def append_Appearance(self, value):
        r"""
        append_Appearance(WrapObject self, Appearance value) -> int

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.WrapObject_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue):
        r"""
        constructProperty_Appearance(WrapObject self, Appearance initValue)

        Parameters
        ----------
        initValue: OpenSim::Appearance const &

        """
        return _simulation.WrapObject_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args):
        r"""
        get_Appearance(WrapObject self, int i) -> Appearance

        Parameters
        ----------
        i: int

        get_Appearance(WrapObject self) -> Appearance
        """
        return _simulation.WrapObject_get_Appearance(self, *args)

    def upd_Appearance(self, *args):
        r"""
        upd_Appearance(WrapObject self, int i) -> Appearance

        Parameters
        ----------
        i: int

        upd_Appearance(WrapObject self) -> Appearance
        """
        return _simulation.WrapObject_upd_Appearance(self, *args)

    def set_Appearance(self, *args):
        r"""
        set_Appearance(WrapObject self, int i, Appearance value)

        Parameters
        ----------
        i: int
        value: OpenSim::Appearance const &

        set_Appearance(WrapObject self, Appearance value)

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.WrapObject_set_Appearance(self, *args)

    def copyProperty_quadrant(self, source):
        r"""
        copyProperty_quadrant(WrapObject self, WrapObject source)

        Parameters
        ----------
        source: OpenSim::WrapObject::Self const &

        """
        return _simulation.WrapObject_copyProperty_quadrant(self, source)

    def append_quadrant(self, value):
        r"""
        append_quadrant(WrapObject self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapObject_append_quadrant(self, value)

    def constructProperty_quadrant(self, initValue):
        r"""
        constructProperty_quadrant(WrapObject self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.WrapObject_constructProperty_quadrant(self, initValue)

    def get_quadrant(self, *args):
        r"""
        get_quadrant(WrapObject self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_quadrant(WrapObject self) -> std::string const &
        """
        return _simulation.WrapObject_get_quadrant(self, *args)

    def upd_quadrant(self, *args):
        r"""
        upd_quadrant(WrapObject self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_quadrant(WrapObject self) -> std::string &
        """
        return _simulation.WrapObject_upd_quadrant(self, *args)

    def set_quadrant(self, *args):
        r"""
        set_quadrant(WrapObject self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_quadrant(WrapObject self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapObject_set_quadrant(self, *args)
    allQuadrants = _simulation.WrapObject_allQuadrants
    
    negativeX = _simulation.WrapObject_negativeX
    
    positiveX = _simulation.WrapObject_positiveX
    
    negativeY = _simulation.WrapObject_negativeY
    
    positiveY = _simulation.WrapObject_positiveY
    
    negativeZ = _simulation.WrapObject_negativeZ
    
    positiveZ = _simulation.WrapObject_positiveZ
    
    noWrap = _simulation.WrapObject_noWrap
    
    insideRadius = _simulation.WrapObject_insideRadius
    
    wrapped = _simulation.WrapObject_wrapped
    
    mandatoryWrap = _simulation.WrapObject_mandatoryWrap
    
    __swig_destroy__ = _simulation.delete_WrapObject

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(WrapObject self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.WrapObject_extendScale(self, s, scaleSet)

    def connectToModelAndBody(self, aModel, aBody):
        r"""
        connectToModelAndBody(WrapObject self, Model aModel, PhysicalFrame aBody)

        Parameters
        ----------
        aModel: OpenSim::Model &
        aBody: OpenSim::PhysicalFrame &

        """
        return _simulation.WrapObject_connectToModelAndBody(self, aModel, aBody)

    def getFrame(self):
        r"""getFrame(WrapObject self) -> PhysicalFrame"""
        return _simulation.WrapObject_getFrame(self)

    def setFrame(self, frame):
        r"""
        setFrame(WrapObject self, PhysicalFrame frame)

        Parameters
        ----------
        frame: OpenSim::PhysicalFrame const &

        """
        return _simulation.WrapObject_setFrame(self, frame)

    def getActiveUseDefault(self):
        r"""getActiveUseDefault(WrapObject self) -> bool"""
        return _simulation.WrapObject_getActiveUseDefault(self)

    def getQuadrantNameUseDefault(self):
        r"""getQuadrantNameUseDefault(WrapObject self) -> bool"""
        return _simulation.WrapObject_getQuadrantNameUseDefault(self)

    def getTransform(self):
        r"""getTransform(WrapObject self) -> Transform"""
        return _simulation.WrapObject_getTransform(self)

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapObject self) -> char const *"""
        return _simulation.WrapObject_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapObject self) -> std::string"""
        return _simulation.WrapObject_getDimensionsString(self)

    def wrapPathSegment(self, state, aPoint1, aPoint2, aPathWrap, aWrapResult):
        r"""
        Calculate the wrapping of one path segment over one wrap object.
        :type state: :py:class:`State`
        :param state:   The State of the model
        :type aPoint1: :py:class:`AbstractPathPoint`
        :param aPoint1: The first path point
        :type aPoint2: :py:class:`AbstractPathPoint`
        :param aPoint2: The second path point
        :type aPathWrap: :py:class:`PathWrap`
        :param aPathWrap: An object holding the parameters for this path/wrap-object pairing
        :type aWrapResult: OpenSim::WrapResult
        :param aWrapResult: The result of the wrapping (tangent points, etc.)
        :rtype: int
        :return: The status, as a WrapAction enum
        """
        return _simulation.WrapObject_wrapPathSegment(self, state, aPoint1, aPoint2, aPathWrap, aWrapResult)

# Register WrapObject in _simulation:
_simulation.WrapObject_swigregister(WrapObject)
class SetWrapObject(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetWrapObject

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetWrapObject_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetWrapObject self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetWrapObject_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetWrapObject_getClassName()

    def clone(self):
        r"""clone(SetWrapObject self) -> SetWrapObject"""
        return _simulation.SetWrapObject_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetWrapObject self) -> std::string const &"""
        return _simulation.SetWrapObject_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetWrapObject

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::WrapObject,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetWrapObject_swiginit(self, _simulation.new_SetWrapObject(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetWrapObject_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetWrapObject_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetWrapObject_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetWrapObject_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetWrapObject_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetWrapObject_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetWrapObject_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetWrapObject_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetWrapObject_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetWrapObject_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetWrapObject self)"""
        return _simulation.SetWrapObject_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetWrapObject_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`WrapObject`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`WrapObject`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetWrapObject_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetWrapObject_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetWrapObject_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetWrapObject_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetWrapObject_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetWrapObject_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetWrapObject_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetWrapObject_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetWrapObject_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetWrapObject_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetWrapObject in _simulation:
_simulation.SetWrapObject_swigregister(SetWrapObject)
class ModelComponentSetWrapObjects(SetWrapObject):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::WrapObject > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetWrapObjects

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetWrapObjects_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetWrapObjects self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetWrapObjects_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetWrapObjects_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetWrapObjects self) -> ModelComponentSetWrapObjects"""
        return _simulation.ModelComponentSetWrapObjects_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetWrapObjects self) -> std::string const &"""
        return _simulation.ModelComponentSetWrapObjects_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetWrapObjects self)"""
        return _simulation.ModelComponentSetWrapObjects_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetWrapObjects self) -> ModelComponentSetWrapObjects"""
        _simulation.ModelComponentSetWrapObjects_swiginit(self, _simulation.new_ModelComponentSetWrapObjects())
    __swig_destroy__ = _simulation.delete_ModelComponentSetWrapObjects

# Register ModelComponentSetWrapObjects in _simulation:
_simulation.ModelComponentSetWrapObjects_swigregister(ModelComponentSetWrapObjects)
class WrapObjectSet(ModelComponentSetWrapObjects):
    r"""
    A class for holding a set of wrap objects.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapObjectSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapObjectSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapObjectSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapObjectSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapObjectSet_getClassName()

    def clone(self):
        r"""clone(WrapObjectSet self) -> WrapObjectSet"""
        return _simulation.WrapObjectSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapObjectSet self) -> std::string const &"""
        return _simulation.WrapObjectSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(WrapObjectSet self) -> WrapObjectSet
        __init__(WrapObjectSet self, std::string const & file, bool updateFromXML=True) -> WrapObjectSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.WrapObjectSet_swiginit(self, _simulation.new_WrapObjectSet(*args))
    __swig_destroy__ = _simulation.delete_WrapObjectSet

# Register WrapObjectSet in _simulation:
_simulation.WrapObjectSet_swigregister(WrapObjectSet)
class PhysicalFrame(Frame):
    r"""
    A PhysicalFrame is a Frame that locates a physical element of the multi-
    body system that underlies a Model. A PhysicalFrame supports physical
    connections (e.g. Joints, Constraints) and is the Frame type upon which
    forces can be applied. A concrete example of a PhysicalFrame is a Body.
    Attributes of a Body (its center-of-mass, geometry, ...) are located in the
    Body frame. Bodies are connected by Joints and Constraints and Forces are
    readily applied to them. A location that represents an offset from the Body
    frame, can also be a PhysicalFrame (e.g. a PhysicalOffsetFrame).

    See also: PhysicalOffsetFrame

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PhysicalFrame

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PhysicalFrame_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PhysicalFrame self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PhysicalFrame_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PhysicalFrame_getClassName()

    def clone(self):
        r"""clone(PhysicalFrame self) -> PhysicalFrame"""
        return _simulation.PhysicalFrame_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PhysicalFrame self) -> std::string const &"""
        return _simulation.PhysicalFrame_getConcreteClassName(self)

    def copyProperty_WrapObjectSet(self, source):
        r"""
        copyProperty_WrapObjectSet(PhysicalFrame self, PhysicalFrame source)

        Parameters
        ----------
        source: OpenSim::PhysicalFrame::Self const &

        """
        return _simulation.PhysicalFrame_copyProperty_WrapObjectSet(self, source)

    def append_WrapObjectSet(self, value):
        r"""
        append_WrapObjectSet(PhysicalFrame self, WrapObjectSet value) -> int

        Parameters
        ----------
        value: OpenSim::WrapObjectSet const &

        """
        return _simulation.PhysicalFrame_append_WrapObjectSet(self, value)

    def constructProperty_WrapObjectSet(self, initValue):
        r"""
        constructProperty_WrapObjectSet(PhysicalFrame self, WrapObjectSet initValue)

        Parameters
        ----------
        initValue: OpenSim::WrapObjectSet const &

        """
        return _simulation.PhysicalFrame_constructProperty_WrapObjectSet(self, initValue)

    def get_WrapObjectSet(self, *args):
        r"""
        get_WrapObjectSet(PhysicalFrame self, int i) -> WrapObjectSet

        Parameters
        ----------
        i: int

        get_WrapObjectSet(PhysicalFrame self) -> WrapObjectSet
        """
        return _simulation.PhysicalFrame_get_WrapObjectSet(self, *args)

    def upd_WrapObjectSet(self, *args):
        r"""
        upd_WrapObjectSet(PhysicalFrame self, int i) -> WrapObjectSet

        Parameters
        ----------
        i: int

        upd_WrapObjectSet(PhysicalFrame self) -> WrapObjectSet
        """
        return _simulation.PhysicalFrame_upd_WrapObjectSet(self, *args)

    def set_WrapObjectSet(self, *args):
        r"""
        set_WrapObjectSet(PhysicalFrame self, int i, WrapObjectSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::WrapObjectSet const &

        set_WrapObjectSet(PhysicalFrame self, WrapObjectSet value)

        Parameters
        ----------
        value: OpenSim::WrapObjectSet const &

        """
        return _simulation.PhysicalFrame_set_WrapObjectSet(self, *args)
    __swig_destroy__ = _simulation.delete_PhysicalFrame

    def getMobilizedBodyIndex(self):
        r"""
        This method returns the MobilizedBodyIndex of the MobilizedBody for this
        PhysicalFrame. This index is only available after Model::initSystem() has
        been invoked.

        The MobilizedBodyIndex is necessary to access the underlying MobilizedBody
        in the System. It allows access to physical quantities (e.g. forces)
        associated with individual PhysicalFrames. For examples, the underlying
        MultibodySystem's net body forces are represented as a Vector of spatial
        forces (torque and force on each body) and it is indexed by the
        MobilizedBodyIndex.

        :rtype: int
        :return: index The MobilizedBodyIndex corresponding to this PhysicalFrame's
                       underlying MobilizedBody

        See also: getMobilizedBody, updMobilizedBody
        """
        return _simulation.PhysicalFrame_getMobilizedBodyIndex(self)

    def getMobilizedBody(self):
        r"""
        Access a readable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.PhysicalFrame_getMobilizedBody(self)

    def updMobilizedBody(self):
        r"""
        Access a writable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.PhysicalFrame_updMobilizedBody(self)

    def getWrapObject(self, aName):
        r"""
        Deprecated methods for intermediate integration of Frames  Get the named wrap object, if it exists.

        :type aName: string
        :param aName: Name of the wrap object.
        :rtype: :py:class:`WrapObject`
        :return: const Pointer to the wrap object.
        """
        return _simulation.PhysicalFrame_getWrapObject(self, aName)

    def getWrapObjectSet(self):
        r"""getWrapObjectSet(PhysicalFrame self) -> WrapObjectSet"""
        return _simulation.PhysicalFrame_getWrapObjectSet(self)

    def addWrapObject(self, wrapObject):
        r"""
         Add a wrap object to the Body. Note that the Body takes ownership of
        the WrapObject.
        """
        val = _simulation.PhysicalFrame_addWrapObject(self, wrapObject)

        wrapObject._markAdopted()


        return val


# Register PhysicalFrame in _simulation:
_simulation.PhysicalFrame_swigregister(PhysicalFrame)
class Ground(PhysicalFrame):
    r"""
    Ground is an inertial reference frame in which the
    motion of all Frames and points may conveniently and efficiently
    be expressed. As a PhysicalFrame, Ground supports physical connections
    (e.g. Joints, Constraints), and forces can be applied to it.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Ground

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Ground_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Ground self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Ground_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Ground_getClassName()

    def clone(self):
        r"""clone(Ground self) -> Ground"""
        return _simulation.Ground_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Ground self) -> std::string const &"""
        return _simulation.Ground_getConcreteClassName(self)

    def __init__(self):
        r""" Default Constructor"""
        _simulation.Ground_swiginit(self, _simulation.new_Ground())
    __swig_destroy__ = _simulation.delete_Ground

# Register Ground in _simulation:
_simulation.Ground_swigregister(Ground)
class PhysicalFrameWithOffset(PhysicalFrame):
    r"""
    An OffsetFrame is a Frame whose transform (translation and orientation)
    with respect to another (parent) Frame is constant in time. It acts as an
    extension of the parent Frame type so that an OffsetFrame<PhysicalFrame>,
    for example, can be treated as a PhysicalFrame. This enables Frames to be
    filtered by their type (e.g. Physical or not), regardless of whether or
    not the Frame is also an OffsetFrame. (A class whose super class is a
    template parameter is called a mixin class.)

    OffsetFrames also have the property that if they form a chain or a tree,
    each OffsetFrame shares the same Base which is the parent of the first/root
    OffsetFrame in the tree. This allows Solvers and algorithms to work directly
    with the Base which can be more efficient.

    OffsetFrame is an abstract class. Derive concrete subclasses in order to
    accommodate new Frame types that require their offsets to retain the same
    type as the parent. For example:

    .. code-block:: c++

        class PhysicalOffsetFrame : public OffsetFrame<PhysicalFrame>

    See also: PhysicalOffsetFrame.

    :param C: The type of the parent frame, as well as the super class. Must be
        of type Frame.

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PhysicalFrameWithOffset

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PhysicalFrameWithOffset_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PhysicalFrameWithOffset self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PhysicalFrameWithOffset_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PhysicalFrameWithOffset_getClassName()

    def clone(self):
        r"""clone(PhysicalFrameWithOffset self) -> PhysicalFrameWithOffset"""
        return _simulation.PhysicalFrameWithOffset_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PhysicalFrameWithOffset self) -> std::string const &"""
        return _simulation.PhysicalFrameWithOffset_getConcreteClassName(self)

    def copyProperty_translation(self, source):
        r"""
        copyProperty_translation(PhysicalFrameWithOffset self, PhysicalFrameWithOffset source)

        Parameters
        ----------
        source: OpenSim::OffsetFrame< OpenSim::PhysicalFrame >::Self const &

        """
        return _simulation.PhysicalFrameWithOffset_copyProperty_translation(self, source)

    def append_translation(self, value):
        r"""
        append_translation(PhysicalFrameWithOffset self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_append_translation(self, value)

    def constructProperty_translation(self, initValue):
        r"""
        constructProperty_translation(PhysicalFrameWithOffset self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_constructProperty_translation(self, initValue)

    def get_translation(self, *args):
        r"""
        get_translation(PhysicalFrameWithOffset self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translation(PhysicalFrameWithOffset self) -> Vec3
        """
        return _simulation.PhysicalFrameWithOffset_get_translation(self, *args)

    def upd_translation(self, *args):
        r"""
        upd_translation(PhysicalFrameWithOffset self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translation(PhysicalFrameWithOffset self) -> Vec3
        """
        return _simulation.PhysicalFrameWithOffset_upd_translation(self, *args)

    def set_translation(self, *args):
        r"""
        set_translation(PhysicalFrameWithOffset self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translation(PhysicalFrameWithOffset self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_set_translation(self, *args)

    def copyProperty_orientation(self, source):
        r"""
        copyProperty_orientation(PhysicalFrameWithOffset self, PhysicalFrameWithOffset source)

        Parameters
        ----------
        source: OpenSim::OffsetFrame< OpenSim::PhysicalFrame >::Self const &

        """
        return _simulation.PhysicalFrameWithOffset_copyProperty_orientation(self, source)

    def append_orientation(self, value):
        r"""
        append_orientation(PhysicalFrameWithOffset self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_append_orientation(self, value)

    def constructProperty_orientation(self, initValue):
        r"""
        constructProperty_orientation(PhysicalFrameWithOffset self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_constructProperty_orientation(self, initValue)

    def get_orientation(self, *args):
        r"""
        get_orientation(PhysicalFrameWithOffset self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_orientation(PhysicalFrameWithOffset self) -> Vec3
        """
        return _simulation.PhysicalFrameWithOffset_get_orientation(self, *args)

    def upd_orientation(self, *args):
        r"""
        upd_orientation(PhysicalFrameWithOffset self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_orientation(PhysicalFrameWithOffset self) -> Vec3
        """
        return _simulation.PhysicalFrameWithOffset_upd_orientation(self, *args)

    def set_orientation(self, *args):
        r"""
        set_orientation(PhysicalFrameWithOffset self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_orientation(PhysicalFrameWithOffset self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PhysicalFrameWithOffset_set_orientation(self, *args)
    PropertyIndex_socket_parent = property(_simulation.PhysicalFrameWithOffset_PropertyIndex_socket_parent_get, _simulation.PhysicalFrameWithOffset_PropertyIndex_socket_parent_set, doc=r"""PropertyIndex_socket_parent : OpenSim::PropertyIndex""")

    def connectSocket_parent(self, object):
        r"""
        connectSocket_parent(PhysicalFrameWithOffset self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PhysicalFrameWithOffset_connectSocket_parent(self, object)

    def setParentFrame(self, parent):
        r""" Sets the parent reference frame"""
        return _simulation.PhysicalFrameWithOffset_setParentFrame(self, parent)

    def getParentFrame(self):
        r""" Get the parent reference frame"""
        return _simulation.PhysicalFrameWithOffset_getParentFrame(self)

    def getOffsetTransform(self):
        r"""
        Get the transform that describes the translational and rotational offset
        of this frame (F frame) relative to its parent frame (B frame).  This method
        returns the transform converting quantities expressed in F frame to
        quantities expressed in the B frame. This is mathematically stated as,
        vec_P = X_BF*vec_F ,
        where X_BF is the transform returned by getTransform.

        This transform is computed using the translation and orientation
        properties of this object.

        :rtype: :py:class:`Transform`
        :return: offset  The transform between this frame and its parent frame.
        """
        return _simulation.PhysicalFrameWithOffset_getOffsetTransform(self)

    def setOffsetTransform(self, offset):
        r"""
        Sets the transform the translates and rotates this frame (F frame) from
        its parent frame (P frame). You should provide the transform X_PF
        such that vec_P = X_PF*vec_F.

        This transform is stored via the translation and orientation
        properties of this object.

        :type offset: :py:class:`Transform`
        :param offset:   The transform between this frame and its parent frame.
        """
        return _simulation.PhysicalFrameWithOffset_setOffsetTransform(self, offset)

    def extendScale(self, s, scaleSet):
        r""" Scale the offset given scale factors for spatial (XYZ) dimensions."""
        return _simulation.PhysicalFrameWithOffset_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_PhysicalFrameWithOffset

# Register PhysicalFrameWithOffset in _simulation:
_simulation.PhysicalFrameWithOffset_swigregister(PhysicalFrameWithOffset)
class PhysicalOffsetFrame(PhysicalFrameWithOffset):
    r"""
    A PhysicalOffsetFrame is a PhysicalFrame whose transform is specified as a
    constant offset from another PhysicalFrame. PhysicalOffsetFrames can be used
    to specify the location of a Joint or Constraint on a Body or any other
    PhysicalFrame. For example, the location and orientation of the knee joint
    frame specified in the femur (thigh) and tibia (shank) Body reference frames.
    This class has the methods of both the OffsetFrame (template) and the
    PhysicalFrame class.

    NOTE: PhysicalOffsetFrame is closed to extensions. Consider extending
    OffsetFrame and/or use the mixin with a derived class of PhysicalFrame.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PhysicalOffsetFrame

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PhysicalOffsetFrame_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PhysicalOffsetFrame self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PhysicalOffsetFrame_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PhysicalOffsetFrame_getClassName()

    def clone(self):
        r"""clone(PhysicalOffsetFrame self) -> PhysicalOffsetFrame"""
        return _simulation.PhysicalOffsetFrame_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PhysicalOffsetFrame self) -> std::string const &"""
        return _simulation.PhysicalOffsetFrame_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_PhysicalOffsetFrame

    def __init__(self, *args):
        r"""
        __init__(PhysicalOffsetFrame self) -> PhysicalOffsetFrame
        __init__(PhysicalOffsetFrame self, PhysicalFrame parent, Transform offset) -> PhysicalOffsetFrame

        Parameters
        ----------
        parent: OpenSim::PhysicalFrame const &
        offset: SimTK::Transform const &

        __init__(PhysicalOffsetFrame self, std::string const & name, PhysicalFrame parent, Transform offset) -> PhysicalOffsetFrame

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        offset: SimTK::Transform const &

        __init__(PhysicalOffsetFrame self, std::string const & name, std::string const & parentName, Transform offset) -> PhysicalOffsetFrame

        Parameters
        ----------
        name: std::string const &
        parentName: std::string const &
        offset: SimTK::Transform const &

        """
        _simulation.PhysicalOffsetFrame_swiginit(self, _simulation.new_PhysicalOffsetFrame(*args))

# Register PhysicalOffsetFrame in _simulation:
_simulation.PhysicalOffsetFrame_swigregister(PhysicalOffsetFrame)
class SetFrames(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetFrames

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetFrames_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetFrames self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetFrames_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetFrames_getClassName()

    def clone(self):
        r"""clone(SetFrames self) -> SetFrames"""
        return _simulation.SetFrames_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetFrames self) -> std::string const &"""
        return _simulation.SetFrames_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetFrames

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Frame,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetFrames_swiginit(self, _simulation.new_SetFrames(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetFrames_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetFrames_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetFrames_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetFrames_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Frame`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetFrames_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetFrames_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Frame`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetFrames_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Frame`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetFrames_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Frame`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetFrames_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Frame`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetFrames_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetFrames self)"""
        return _simulation.SetFrames_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Frame`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetFrames_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Frame`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Frame`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetFrames_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetFrames_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetFrames_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetFrames_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetFrames_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetFrames_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetFrames_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetFrames_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetFrames_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetFrames_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetFrames in _simulation:
_simulation.SetFrames_swigregister(SetFrames)
class ModelComponentSetFrames(SetFrames):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Frame > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetFrames

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetFrames_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetFrames self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetFrames_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetFrames_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetFrames self) -> ModelComponentSetFrames"""
        return _simulation.ModelComponentSetFrames_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetFrames self) -> std::string const &"""
        return _simulation.ModelComponentSetFrames_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetFrames self)"""
        return _simulation.ModelComponentSetFrames_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetFrames self) -> ModelComponentSetFrames"""
        _simulation.ModelComponentSetFrames_swiginit(self, _simulation.new_ModelComponentSetFrames())
    __swig_destroy__ = _simulation.delete_ModelComponentSetFrames

# Register ModelComponentSetFrames in _simulation:
_simulation.ModelComponentSetFrames_swigregister(ModelComponentSetFrames)
class Body(PhysicalFrame):
    r"""
    An OpenSim::Body is a PhysicalFrame (reference frame) with associated
    inertia specified by its mass, center-of-mass located in the PhysicalFrame,
    and its moment of inertia tensor about the center-of-mass.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Body

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Body_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Body self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Body_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Body_getClassName()

    def clone(self):
        r"""clone(Body self) -> Body"""
        return _simulation.Body_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Body self) -> std::string const &"""
        return _simulation.Body_getConcreteClassName(self)

    def copyProperty_mass(self, source):
        r"""
        copyProperty_mass(Body self, Body source)

        Parameters
        ----------
        source: OpenSim::Body::Self const &

        """
        return _simulation.Body_copyProperty_mass(self, source)

    def append_mass(self, value):
        r"""
        append_mass(Body self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Body_append_mass(self, value)

    def constructProperty_mass(self, initValue):
        r"""
        constructProperty_mass(Body self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Body_constructProperty_mass(self, initValue)

    def get_mass(self, *args):
        r"""
        get_mass(Body self, int i) -> double const

        Parameters
        ----------
        i: int

        get_mass(Body self) -> double const &
        """
        return _simulation.Body_get_mass(self, *args)

    def upd_mass(self, *args):
        r"""
        upd_mass(Body self, int i) -> double

        Parameters
        ----------
        i: int

        upd_mass(Body self) -> double &
        """
        return _simulation.Body_upd_mass(self, *args)

    def set_mass(self, *args):
        r"""
        set_mass(Body self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_mass(Body self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Body_set_mass(self, *args)

    def copyProperty_mass_center(self, source):
        r"""
        copyProperty_mass_center(Body self, Body source)

        Parameters
        ----------
        source: OpenSim::Body::Self const &

        """
        return _simulation.Body_copyProperty_mass_center(self, source)

    def append_mass_center(self, value):
        r"""
        append_mass_center(Body self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Body_append_mass_center(self, value)

    def constructProperty_mass_center(self, initValue):
        r"""
        constructProperty_mass_center(Body self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Body_constructProperty_mass_center(self, initValue)

    def get_mass_center(self, *args):
        r"""
        get_mass_center(Body self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_mass_center(Body self) -> Vec3
        """
        return _simulation.Body_get_mass_center(self, *args)

    def upd_mass_center(self, *args):
        r"""
        upd_mass_center(Body self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_mass_center(Body self) -> Vec3
        """
        return _simulation.Body_upd_mass_center(self, *args)

    def set_mass_center(self, *args):
        r"""
        set_mass_center(Body self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_mass_center(Body self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Body_set_mass_center(self, *args)

    def copyProperty_inertia(self, source):
        r"""
        copyProperty_inertia(Body self, Body source)

        Parameters
        ----------
        source: OpenSim::Body::Self const &

        """
        return _simulation.Body_copyProperty_inertia(self, source)

    def append_inertia(self, value):
        r"""
        append_inertia(Body self, Vec6 value) -> int

        Parameters
        ----------
        value: SimTK::Vec6 const &

        """
        return _simulation.Body_append_inertia(self, value)

    def constructProperty_inertia(self, initValue):
        r"""
        constructProperty_inertia(Body self, Vec6 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec6 const &

        """
        return _simulation.Body_constructProperty_inertia(self, initValue)

    def get_inertia(self, *args):
        r"""
        get_inertia(Body self, int i) -> Vec6

        Parameters
        ----------
        i: int

        get_inertia(Body self) -> Vec6
        """
        return _simulation.Body_get_inertia(self, *args)

    def upd_inertia(self, *args):
        r"""
        upd_inertia(Body self, int i) -> Vec6

        Parameters
        ----------
        i: int

        upd_inertia(Body self) -> Vec6
        """
        return _simulation.Body_upd_inertia(self, *args)

    def set_inertia(self, *args):
        r"""
        set_inertia(Body self, int i, Vec6 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec6 const &

        set_inertia(Body self, Vec6 value)

        Parameters
        ----------
        value: SimTK::Vec6 const &

        """
        return _simulation.Body_set_inertia(self, *args)
    _has_output_momentum_about_origin = property(_simulation.Body__has_output_momentum_about_origin_get, _simulation.Body__has_output_momentum_about_origin_set, doc=r"""_has_output_momentum_about_origin : bool""")
    _has_output_angular_momentum_about_origin = property(_simulation.Body__has_output_angular_momentum_about_origin_get, _simulation.Body__has_output_angular_momentum_about_origin_set, doc=r"""_has_output_angular_momentum_about_origin : bool""")
    _has_output_linear_momentum_about_origin = property(_simulation.Body__has_output_linear_momentum_about_origin_get, _simulation.Body__has_output_linear_momentum_about_origin_set, doc=r"""_has_output_linear_momentum_about_origin : bool""")
    _has_output_momentum_about_mass_center = property(_simulation.Body__has_output_momentum_about_mass_center_get, _simulation.Body__has_output_momentum_about_mass_center_set, doc=r"""_has_output_momentum_about_mass_center : bool""")
    _has_output_angular_momentum_about_mass_center = property(_simulation.Body__has_output_angular_momentum_about_mass_center_get, _simulation.Body__has_output_angular_momentum_about_mass_center_set, doc=r"""_has_output_angular_momentum_about_mass_center : bool""")
    _has_output_linear_momentum_about_mass_center = property(_simulation.Body__has_output_linear_momentum_about_mass_center_get, _simulation.Body__has_output_linear_momentum_about_mass_center_set, doc=r"""_has_output_linear_momentum_about_mass_center : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Body_swiginit(self, _simulation.new_Body(*args))

    def getMass(self):
        r""" Access Properties of the Body  The mass of the body in kg"""
        return _simulation.Body_getMass(self)

    def setMass(self, mass):
        r"""
        setMass(Body self, double const & mass)

        Parameters
        ----------
        mass: double const &

        """
        return _simulation.Body_setMass(self, mass)

    def getMassCenter(self):
        r""" The body center of mass location (Vec3) in the Body frame."""
        return _simulation.Body_getMassCenter(self)

    def setMassCenter(self, com):
        r"""
        setMassCenter(Body self, Vec3 com)

        Parameters
        ----------
        com: SimTK::Vec3 const &

        """
        return _simulation.Body_setMassCenter(self, com)

    def getInertia(self):
        r""" The body's inertia about the center of mass location."""
        return _simulation.Body_getInertia(self)

    def setInertia(self, aInertia):
        r"""
        setInertia(Body self, Inertia aInertia)

        Parameters
        ----------
        aInertia: SimTK::Inertia const &

        """
        return _simulation.Body_setInertia(self, aInertia)

    def getMassProperties(self):
        r"""
        Assemble body inertial properties: mass, center of mass location, moment
               of inertia about the origin of the body and return as
               SimTK::MassProperties.
        """
        return _simulation.Body_getMassProperties(self)

    def scale(self, scaleFactors, scaleMass=False):
        r""" Scale the Body's center of mass location and its inertial properties."""
        return _simulation.Body_scale(self, scaleFactors, scaleMass)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the Body's center of mass location only. Note that
               scaleInertialProperties() must be called after this method to update the
               Body's mass and inertia tensor.
        """
        return _simulation.Body_extendScale(self, s, scaleSet)

    def scaleInertialProperties(self, *args):
        r"""
        scaleInertialProperties(Body self, ScaleSet scaleSet, bool scaleMass=True)

        Parameters
        ----------
        scaleSet: OpenSim::ScaleSet const &
        scaleMass: bool

        scaleInertialProperties(Body self, Vec3 scaleFactors, bool scaleMass=True)

        Parameters
        ----------
        scaleFactors: SimTK::Vec3 const &
        scaleMass: bool

        """
        return _simulation.Body_scaleInertialProperties(self, *args)

    def scaleMass(self, aScaleFactor):
        r"""
        scaleMass(Body self, double aScaleFactor)

        Parameters
        ----------
        aScaleFactor: double

        """
        return _simulation.Body_scaleMass(self, aScaleFactor)

    def calcMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's spatial momentum (angular, linear) measured and
           expressed in Ground, but taken about the Body origin.
        """
        return _simulation.Body_calcMomentumAboutOrigin(self, s)

    def calcAngularMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's angular momentum measured and expressed in Ground,
           but taken about the Body origin.
        """
        return _simulation.Body_calcAngularMomentumAboutOrigin(self, s)

    def calcLinearMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's linear momentum measured and expressed in Ground,
           but taken about the Body origin.
        """
        return _simulation.Body_calcLinearMomentumAboutOrigin(self, s)

    def calcMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's spatial momentum (angular, linear) measured and
           expressed in Ground, but taken about the Body mass center.
        """
        return _simulation.Body_calcMomentumAboutMassCenter(self, s)

    def calcAngularMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's angular momentum measured and expressed in Ground,
           but taken about the Body mass center.
        """
        return _simulation.Body_calcAngularMomentumAboutMassCenter(self, s)

    def calcLinearMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's linear momentum measured and expressed in Ground,
           but taken about the Body mass center.
        """
        return _simulation.Body_calcLinearMomentumAboutMassCenter(self, s)
    __swig_destroy__ = _simulation.delete_Body

# Register Body in _simulation:
_simulation.Body_swigregister(Body)
class SetBodies(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetBodies

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetBodies_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetBodies self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetBodies_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetBodies_getClassName()

    def clone(self):
        r"""clone(SetBodies self) -> SetBodies"""
        return _simulation.SetBodies_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetBodies self) -> std::string const &"""
        return _simulation.SetBodies_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetBodies

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Body,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetBodies_swiginit(self, _simulation.new_SetBodies(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetBodies_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetBodies_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetBodies_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetBodies_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Body`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetBodies_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetBodies_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Body`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodies_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Body`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodies_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Body`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetBodies_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Body`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetBodies_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetBodies self)"""
        return _simulation.SetBodies_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Body`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetBodies_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Body`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Body`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetBodies_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetBodies_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetBodies_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetBodies_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetBodies_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetBodies_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetBodies_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetBodies_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetBodies_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetBodies_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetBodies in _simulation:
_simulation.SetBodies_swigregister(SetBodies)
class ModelComponentSetBodies(SetBodies):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Body > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetBodies

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetBodies_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetBodies self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetBodies_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetBodies_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetBodies self) -> ModelComponentSetBodies"""
        return _simulation.ModelComponentSetBodies_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetBodies self) -> std::string const &"""
        return _simulation.ModelComponentSetBodies_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetBodies self)"""
        return _simulation.ModelComponentSetBodies_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetBodies self) -> ModelComponentSetBodies"""
        _simulation.ModelComponentSetBodies_swiginit(self, _simulation.new_ModelComponentSetBodies())
    __swig_destroy__ = _simulation.delete_ModelComponentSetBodies

# Register ModelComponentSetBodies in _simulation:
_simulation.ModelComponentSetBodies_swigregister(ModelComponentSetBodies)
class BodySet(ModelComponentSetBodies):
    r"""
    A class for holding a set of bodies.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BodySet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BodySet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BodySet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BodySet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BodySet_getClassName()

    def clone(self):
        r"""clone(BodySet self) -> BodySet"""
        return _simulation.BodySet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodySet self) -> std::string const &"""
        return _simulation.BodySet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(BodySet self) -> BodySet
        __init__(BodySet self, std::string const & file, bool updateFromXML=True) -> BodySet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.BodySet_swiginit(self, _simulation.new_BodySet(*args))
    __swig_destroy__ = _simulation.delete_BodySet

# Register BodySet in _simulation:
_simulation.BodySet_swigregister(BodySet)
class BodyScale(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how
    to scale a body segment.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BodyScale

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BodyScale_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BodyScale self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BodyScale_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BodyScale_getClassName()

    def clone(self):
        r"""clone(BodyScale self) -> BodyScale"""
        return _simulation.BodyScale_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodyScale self) -> std::string const &"""
        return _simulation.BodyScale_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(BodyScale self) -> BodyScale
        __init__(BodyScale self, BodyScale aBodyScale) -> BodyScale

        Parameters
        ----------
        aBodyScale: OpenSim::BodyScale const &

        """
        _simulation.BodyScale_swiginit(self, _simulation.new_BodyScale(*args))
    __swig_destroy__ = _simulation.delete_BodyScale

    def copyData(self, aBodyScale):
        r"""
        copyData(BodyScale self, BodyScale aBodyScale)

        Parameters
        ----------
        aBodyScale: OpenSim::BodyScale const &

        """
        return _simulation.BodyScale_copyData(self, aBodyScale)

    def getAxisNames(self):
        r"""getAxisNames(BodyScale self) -> ArrayStr"""
        return _simulation.BodyScale_getAxisNames(self)

    def setAxisNames(self, aAxisNames):
        r"""
        setAxisNames(BodyScale self, ArrayStr aAxisNames)

        Parameters
        ----------
        aAxisNames: OpenSim::Array< std::string > const &

        """
        return _simulation.BodyScale_setAxisNames(self, aAxisNames)

# Register BodyScale in _simulation:
_simulation.BodyScale_swigregister(BodyScale)
class SetBodyScales(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetBodyScales

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetBodyScales_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetBodyScales self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetBodyScales_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetBodyScales_getClassName()

    def clone(self):
        r"""clone(SetBodyScales self) -> SetBodyScales"""
        return _simulation.SetBodyScales_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetBodyScales self) -> std::string const &"""
        return _simulation.SetBodyScales_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetBodyScales

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::BodyScale,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetBodyScales_swiginit(self, _simulation.new_SetBodyScales(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetBodyScales_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetBodyScales_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetBodyScales_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetBodyScales_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetBodyScales_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetBodyScales_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodyScales_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodyScales_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetBodyScales_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetBodyScales_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetBodyScales self)"""
        return _simulation.SetBodyScales_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetBodyScales_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`BodyScale`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`BodyScale`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetBodyScales_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetBodyScales_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetBodyScales_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetBodyScales_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetBodyScales_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetBodyScales_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetBodyScales_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetBodyScales_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetBodyScales_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetBodyScales_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetBodyScales in _simulation:
_simulation.SetBodyScales_swigregister(SetBodyScales)
class BodyScaleSet(SetBodyScales):
    r"""
    A class for holding a set of body scales.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BodyScaleSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BodyScaleSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BodyScaleSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BodyScaleSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BodyScaleSet_getClassName()

    def clone(self):
        r"""clone(BodyScaleSet self) -> BodyScaleSet"""
        return _simulation.BodyScaleSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodyScaleSet self) -> std::string const &"""
        return _simulation.BodyScaleSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(BodyScaleSet self) -> BodyScaleSet
        __init__(BodyScaleSet self, BodyScaleSet aBodyScaleSet) -> BodyScaleSet

        Parameters
        ----------
        aBodyScaleSet: OpenSim::BodyScaleSet const &

        """
        _simulation.BodyScaleSet_swiginit(self, _simulation.new_BodyScaleSet(*args))
    __swig_destroy__ = _simulation.delete_BodyScaleSet

    def adoptAndAppend(self, aBodyScale):
        aBodyScale._markAdopted()
        return super(BodyScaleSet, self).adoptAndAppend(aBodyScale)


# Register BodyScaleSet in _simulation:
_simulation.BodyScaleSet_swigregister(BodyScaleSet)
class SimbodyEngine(opensim.common.OpenSimObject):
    r"""
    A wrapper class to use the SimTK Simbody dynamics engine as the underlying
    engine for OpenSim.

    Authors: Frank C. Anderson, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SimbodyEngine

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SimbodyEngine_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SimbodyEngine self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SimbodyEngine_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SimbodyEngine_getClassName()

    def clone(self):
        r"""clone(SimbodyEngine self) -> SimbodyEngine"""
        return _simulation.SimbodyEngine_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SimbodyEngine self) -> std::string const &"""
        return _simulation.SimbodyEngine_getConcreteClassName(self)
    _model = property(_simulation.SimbodyEngine__model_get, _simulation.SimbodyEngine__model_set, doc=r""" Pointer to the model that owns this dynamics engine.""")
    __swig_destroy__ = _simulation.delete_SimbodyEngine

    def __init__(self, *args):
        r"""
        __init__(SimbodyEngine self) -> SimbodyEngine
        __init__(SimbodyEngine self, std::string const & aFileName) -> SimbodyEngine

        Parameters
        ----------
        aFileName: std::string const &

        __init__(SimbodyEngine self, SimbodyEngine aEngine) -> SimbodyEngine

        Parameters
        ----------
        aEngine: OpenSim::SimbodyEngine const &

        """
        _simulation.SimbodyEngine_swiginit(self, _simulation.new_SimbodyEngine(*args))

    def getModel(self):
        r"""getModel(SimbodyEngine self) -> Model"""
        return _simulation.SimbodyEngine_getModel(self)

    def setModel(self, aModel):
        r"""
        setModel(SimbodyEngine self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.SimbodyEngine_setModel(self, aModel)

    def connectSimbodyEngineToModel(self, aModel):
        r"""
        connectSimbodyEngineToModel(SimbodyEngine self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.SimbodyEngine_connectSimbodyEngineToModel(self, aModel)

    def computeReactions(self, s, rForces, rTorques):
        r"""
        computeReactions(SimbodyEngine self, State s, VectorVec3 rForces, VectorVec3 rTorques)

        Parameters
        ----------
        s: SimTK::State const &
        rForces: SimTK::Vector_< SimTK::Vec3 > &
        rTorques: SimTK::Vector_< SimTK::Vec3 > &

        """
        return _simulation.SimbodyEngine_computeReactions(self, s, rForces, rTorques)

    def formCompleteStorages(self, s, aQIn, rQComplete, rUComplete):
        r"""
        From a potentially partial specification of the generalized coordinates,
        form a complete storage of the generalized coordinates (q's) and
        generalized speeds (u's) in radians and radians/s respectively.

        :type s: :py:class:`State`
        :param s: Used as working memory.
        :type aQIn: :py:class:`Storage`
        :param aQIn: Storage containing the q's or a subset of the q's.
        :type rQComplete: :py:class:`Storage`
        :param rQComplete: Storage containing all the q's.  If q's were not
            in aQIn, the values are set to 0.0.  When a q is constrained, its value
            is altered to be consistent with the constraint.  The caller is responsible
            for deleting the memory associated with this storage. Units are radians.
        :type rUComplete: :py:class:`Storage`
        :param rUComplete: Storage containing all the u's.  The generalized speeds
            are obtained by spline fitting the q's and differentiating the splines.
            When a u is constrained, its value is altered to be consistent with the
            constraint.  The caller is responsible for deleting the memory
            associated with this storage. Units are radians/s.
        """
        return _simulation.SimbodyEngine_formCompleteStorages(self, s, aQIn, rQComplete, rUComplete)

    def convertDegreesToRadians(self, *args):
        r"""
        convertDegreesToRadians(SimbodyEngine self, Storage rStorage)

        Parameters
        ----------
        rStorage: OpenSim::Storage &

        convertDegreesToRadians(SimbodyEngine self, TimeSeriesTable table)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &

        convertDegreesToRadians(SimbodyEngine self, double * aQDeg, double * rQRad)

        Parameters
        ----------
        aQDeg: double *
        rQRad: double *

        """
        return _simulation.SimbodyEngine_convertDegreesToRadians(self, *args)

    def convertRadiansToDegrees(self, *args):
        r"""
        convertRadiansToDegrees(SimbodyEngine self, Storage rStorage)

        Parameters
        ----------
        rStorage: OpenSim::Storage &

        convertRadiansToDegrees(SimbodyEngine self, TimeSeriesTable table)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &

        convertRadiansToDegrees(SimbodyEngine self, double * aQRad, double * rQDeg)

        Parameters
        ----------
        aQRad: double *
        rQDeg: double *

        """
        return _simulation.SimbodyEngine_convertRadiansToDegrees(self, *args)

    def convertAnglesToDirectionCosines(self, *args):
        r"""
        convertAnglesToDirectionCosines(SimbodyEngine self, double aE1, double aE2, double aE3, double [3][3] rDirCos)

        Parameters
        ----------
        aE1: double
        aE2: double
        aE3: double
        rDirCos: double [3][3]

        convertAnglesToDirectionCosines(SimbodyEngine self, double aE1, double aE2, double aE3, double * rDirCos)

        Parameters
        ----------
        aE1: double
        aE2: double
        aE3: double
        rDirCos: double *

        """
        return _simulation.SimbodyEngine_convertAnglesToDirectionCosines(self, *args)

    def convertDirectionCosinesToAngles(self, *args):
        r"""
        convertDirectionCosinesToAngles(SimbodyEngine self, double [3][3] aDirCos, double * rE1, double * rE2, double * rE3)

        Parameters
        ----------
        aDirCos: double [3][3]
        rE1: double *
        rE2: double *
        rE3: double *

        convertDirectionCosinesToAngles(SimbodyEngine self, double * aDirCos, double * rE1, double * rE2, double * rE3)

        Parameters
        ----------
        aDirCos: double *
        rE1: double *
        rE2: double *
        rE3: double *

        """
        return _simulation.SimbodyEngine_convertDirectionCosinesToAngles(self, *args)

    def convertDirectionCosinesToQuaternions(self, *args):
        r"""
        convertDirectionCosinesToQuaternions(SimbodyEngine self, double [3][3] aDirCos, double * rQ1, double * rQ2, double * rQ3, double * rQ4)

        Parameters
        ----------
        aDirCos: double [3][3]
        rQ1: double *
        rQ2: double *
        rQ3: double *
        rQ4: double *

        convertDirectionCosinesToQuaternions(SimbodyEngine self, double * aDirCos, double * rQ1, double * rQ2, double * rQ3, double * rQ4)

        Parameters
        ----------
        aDirCos: double *
        rQ1: double *
        rQ2: double *
        rQ3: double *
        rQ4: double *

        """
        return _simulation.SimbodyEngine_convertDirectionCosinesToQuaternions(self, *args)

    def convertQuaternionsToDirectionCosines(self, *args):
        r"""
        convertQuaternionsToDirectionCosines(SimbodyEngine self, double aQ1, double aQ2, double aQ3, double aQ4, double [3][3] rDirCos)

        Parameters
        ----------
        aQ1: double
        aQ2: double
        aQ3: double
        aQ4: double
        rDirCos: double [3][3]

        convertQuaternionsToDirectionCosines(SimbodyEngine self, double aQ1, double aQ2, double aQ3, double aQ4, double * rDirCos)

        Parameters
        ----------
        aQ1: double
        aQ2: double
        aQ3: double
        aQ4: double
        rDirCos: double *

        """
        return _simulation.SimbodyEngine_convertQuaternionsToDirectionCosines(self, *args)

    def getPosition(self, s, aBody, aPoint, rPos):
        r""" **(Deprecated)** Use Frame::getPositionInGround() instead."""
        return _simulation.SimbodyEngine_getPosition(self, s, aBody, aPoint, rPos)

    def getVelocity(self, s, aBody, aPoint, rVel):
        r""" **(Deprecated)** Use Frame::getVelocityInGround() instead."""
        return _simulation.SimbodyEngine_getVelocity(self, s, aBody, aPoint, rVel)

    def getAcceleration(self, s, aBody, aPoint, rAcc):
        r""" **(Deprecated)** Use Frame::getAccelerationInGround() instead."""
        return _simulation.SimbodyEngine_getAcceleration(self, s, aBody, aPoint, rAcc)

    def getDirectionCosines(self, *args):
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::getTransformInGround().R() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::getTransformInGround().R() instead.
        """
        return _simulation.SimbodyEngine_getDirectionCosines(self, *args)

    def getAngularVelocity(self, s, aBody, rAngVel):
        r""" **(Deprecated)** Use Frame::getVelocityInGround()[0] instead."""
        return _simulation.SimbodyEngine_getAngularVelocity(self, s, aBody, rAngVel)

    def getAngularVelocityBodyLocal(self, s, aBody, rAngVel):
        r""" **(Deprecated)** See Frame::getVelocityInGround()[0]."""
        return _simulation.SimbodyEngine_getAngularVelocityBodyLocal(self, s, aBody, rAngVel)

    def getAngularAcceleration(self, s, aBody, rAngAcc):
        r""" **(Deprecated)** Use Frame::getAccelerationInGround()[0] instead."""
        return _simulation.SimbodyEngine_getAngularAcceleration(self, s, aBody, rAngAcc)

    def getAngularAccelerationBodyLocal(self, s, aBody, rAngAcc):
        r""" **(Deprecated)** See Frame::getAccelerationInGround()[0]."""
        return _simulation.SimbodyEngine_getAngularAccelerationBodyLocal(self, s, aBody, rAngAcc)

    def getTransform(self, s, aBody):
        r""" **(Deprecated)** Use Frame::getTransformInGround() instead."""
        return _simulation.SimbodyEngine_getTransform(self, s, aBody)

    def transform(self, *args):
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::expressVectorInAnotherFrame() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::expressVectorInAnotherFrame() instead.
        """
        return _simulation.SimbodyEngine_transform(self, *args)

    def transformPosition(self, *args):
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::findStationLocationInAnotherFrame() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::findStationLocationInAnotherFrame() instead.

        |

        *Overload 3:*
        **(Deprecated)** Use Frame::findStationLocationInGround() instead.

        |

        *Overload 4:*
        **(Deprecated)** Use Frame::findStationLocationInGround() instead.
        """
        return _simulation.SimbodyEngine_transformPosition(self, *args)

    def calcDistance(self, *args):
        r"""
        *Overload 1:*
        **(Deprecated)** Use Point::calcDistanceBetween() or Frame::findStationLocationInGround() instead

        |

        *Overload 2:*
        **(Deprecated)** Use Point::calcDistanceBetween() or Frame::findStationLocationInGround() instead
        """
        return _simulation.SimbodyEngine_calcDistance(self, *args)

# Register SimbodyEngine in _simulation:
_simulation.SimbodyEngine_swigregister(SimbodyEngine)
class TransformAxis(opensim.common.OpenSimObject):
    r"""
    A class expressing a transformation of a child body in relation to a parent
    body along either a translation or about a rotation axis. The TransformAxis
    function specified the spatial displacement that is achieved as a function
    of the generalized coordinate(s).

    Author: Peter Loan, Frank C. Anderson, Jeffrey A. Reinbolt, Ajay Seth,
            Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TransformAxis

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TransformAxis_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TransformAxis self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TransformAxis_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TransformAxis_getClassName()

    def clone(self):
        r"""clone(TransformAxis self) -> TransformAxis"""
        return _simulation.TransformAxis_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TransformAxis self) -> std::string const &"""
        return _simulation.TransformAxis_getConcreteClassName(self)

    def copyProperty_coordinates(self, source):
        r"""
        The "coordinates" property holds a list of strings representing the
           generalized coordinate names that serve as the independent variables of
           the transform function. *
        """
        return _simulation.TransformAxis_copyProperty_coordinates(self, source)

    def get_coordinates(self, i):
        r"""
        get_coordinates(TransformAxis self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.TransformAxis_get_coordinates(self, i)

    def upd_coordinates(self, i):
        r"""
        upd_coordinates(TransformAxis self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.TransformAxis_upd_coordinates(self, i)

    def set_coordinates(self, i, value):
        r"""
        set_coordinates(TransformAxis self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.TransformAxis_set_coordinates(self, i, value)

    def append_coordinates(self, value):
        r"""
        append_coordinates(TransformAxis self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.TransformAxis_append_coordinates(self, value)

    def constructProperty_coordinates(self):
        r"""constructProperty_coordinates(TransformAxis self)"""
        return _simulation.TransformAxis_constructProperty_coordinates(self)

    def copyProperty_axis(self, source):
        r"""
        The "axis" property holds the axis direction of the rotation or
           translation axis of the transform as a Vec3. *
        """
        return _simulation.TransformAxis_copyProperty_axis(self, source)

    def append_axis(self, value):
        r"""
        append_axis(TransformAxis self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.TransformAxis_append_axis(self, value)

    def constructProperty_axis(self, initValue):
        r"""
        constructProperty_axis(TransformAxis self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.TransformAxis_constructProperty_axis(self, initValue)

    def get_axis(self, *args):
        r"""
        get_axis(TransformAxis self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_axis(TransformAxis self) -> Vec3
        """
        return _simulation.TransformAxis_get_axis(self, *args)

    def upd_axis(self, *args):
        r"""
        upd_axis(TransformAxis self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_axis(TransformAxis self) -> Vec3
        """
        return _simulation.TransformAxis_upd_axis(self, *args)

    def set_axis(self, *args):
        r"""
        set_axis(TransformAxis self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_axis(TransformAxis self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.TransformAxis_set_axis(self, *args)

    def copyProperty_function(self, source):
        r"""
        The "function" property holds the transform function of the
           generalized coordinate(s) used to represent the amount of displacement
           about/along the specified axis. If none is specified a Constant function
           is applied. *
        """
        return _simulation.TransformAxis_copyProperty_function(self, source)

    def append_function(self, value):
        r"""
        append_function(TransformAxis self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.TransformAxis_append_function(self, value)

    def constructProperty_function(self, initValue):
        r"""
        constructProperty_function(TransformAxis self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.TransformAxis_constructProperty_function(self, initValue)

    def get_function(self, *args):
        r"""
        get_function(TransformAxis self, int i) -> Function

        Parameters
        ----------
        i: int

        get_function(TransformAxis self) -> Function
        """
        return _simulation.TransformAxis_get_function(self, *args)

    def upd_function(self, *args):
        r"""
        upd_function(TransformAxis self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_function(TransformAxis self) -> Function
        """
        return _simulation.TransformAxis_upd_function(self, *args)

    def set_function(self, *args):
        r"""
        set_function(TransformAxis self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_function(TransformAxis self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.TransformAxis_set_function(self, *args)

    def __init__(self, *args):
        r"""
        __init__(TransformAxis self) -> TransformAxis
        __init__(TransformAxis self, ArrayStr coordNames, Vec3 axis) -> TransformAxis

        Parameters
        ----------
        coordNames: OpenSim::Array< std::string > const &
        axis: SimTK::Vec3 const &

        __init__(TransformAxis self, SimTK::Xml::Element & node) -> TransformAxis

        Parameters
        ----------
        node: SimTK::Xml::Element &

        """
        _simulation.TransformAxis_swiginit(self, _simulation.new_TransformAxis(*args))

    def setCoordinateNames(self, coordNames):
        r"""
        %Set the names of the generalized coordinates that affect the motion
           along the axis controlled by this %TransformAxis object.
           :type coordNames: OpenSim::Array< std::string >
           :param coordNames:   Names of the generalized coordinates. *
        """
        return _simulation.TransformAxis_setCoordinateNames(self, coordNames)

    def getCoordinateNames(self):
        r"""
        Get the generalized coordinate names associated with this object.
           The returned value is a references to the Property<string> that contains
           the list of coordinate names.
           See also: get_coordinates() *
        """
        return _simulation.TransformAxis_getCoordinateNames(self)

    def getCoordinateNamesInArray(self):
        r""" Copy the coordinate names into an OpenSim::Array for convenience. *"""
        return _simulation.TransformAxis_getCoordinateNamesInArray(self)

    def setAxis(self, axis):
        r""" %Set the value of the "axis" property. *"""
        return _simulation.TransformAxis_setAxis(self, axis)

    def getAxis(self, *args):
        r"""
        *Overload 1:*
        Return the current value of the "axis" property. *

        |

        *Overload 2:*
        Alternate signature that writes the axis value to its argument. *

        |

        *Overload 3:*
        Get one component (0,1, or 2) of the axis vector. *
        """
        return _simulation.TransformAxis_getAxis(self, *args)

    def hasFunction(self):
        r"""
        Determine whether a custom function has been specified to map between
           the generalized coordinate and the amount of transformation along the
           specified axis. *
        """
        return _simulation.TransformAxis_hasFunction(self)

    def getFunction(self):
        r"""
        Get the custom function that maps between the generalized coordinates
           and the amount of displacement along the specified axis. If no function
           has been specified, this throws an exception; check first with hasFunction()
           if you aren't sure. *
        """
        return _simulation.TransformAxis_getFunction(self)

    def updFunction(self):
        r""" Get writable access to the transform function. *"""
        return _simulation.TransformAxis_updFunction(self)

    def setFunction(self, *args):
        r"""
        *Overload 1:*
        %Set the custom function that maps between the generalized coordinates
           and the amount of displacement about/along the specified axis. This object
           adopts ownership of the Function object, don't delete it yourself! It will
           be deleted when this %TransformAxis object is deleted. *

        |

        *Overload 2:*
        %Set the custom function that maps between the generalized coordinates
           and the amount of transformation about/along the specified axis. This method
           creates a *copy* of the supplied Function object, which is unaffected.
           Use the other signature if you want this %TransformAxis to take over
           ownership of the Function object. *
        """
        return _simulation.TransformAxis_setFunction(self, *args)

    def getJoint(self):
        r"""
        Return a reference to the Joint to which this %TransformAxis
           applies. *
        """
        return _simulation.TransformAxis_getJoint(self)

    def getValue(self, s):
        r"""
        getValue(TransformAxis self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.TransformAxis_getValue(self, s)

    def connectToJoint(self, owningJoint):
        r"""
        Connect the %TransformAxis to its owning Joint after the model has
           been deserialized or copied. *
        """
        return _simulation.TransformAxis_connectToJoint(self, owningJoint)
    __swig_destroy__ = _simulation.delete_TransformAxis

# Register TransformAxis in _simulation:
_simulation.TransformAxis_swigregister(TransformAxis)
class SpatialTransform(opensim.common.OpenSimObject):
    r"""
    A class encapsulating the spatial transformation between two bodies that
    defines the behavior of a custom joint.

    Authors: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SpatialTransform

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SpatialTransform_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SpatialTransform self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SpatialTransform_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SpatialTransform_getClassName()

    def clone(self):
        r"""clone(SpatialTransform self) -> SpatialTransform"""
        return _simulation.SpatialTransform_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SpatialTransform self) -> std::string const &"""
        return _simulation.SpatialTransform_getConcreteClassName(self)

    def copyProperty_rotation1(self, source):
        r"""
        Define the individual transform axes (6) that specify the spatial
           transform; each is a TransformAxis object. *
        """
        return _simulation.SpatialTransform_copyProperty_rotation1(self, source)

    def append_rotation1(self, value):
        r"""
        append_rotation1(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_rotation1(self, value)

    def constructProperty_rotation1(self, initValue):
        r"""
        constructProperty_rotation1(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_rotation1(self, initValue)

    def get_rotation1(self, *args):
        r"""
        get_rotation1(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_rotation1(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_rotation1(self, *args)

    def upd_rotation1(self, *args):
        r"""
        upd_rotation1(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_rotation1(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_rotation1(self, *args)

    def set_rotation1(self, *args):
        r"""
        set_rotation1(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_rotation1(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_rotation1(self, *args)

    def copyProperty_rotation2(self, source):
        r"""
        copyProperty_rotation2(SpatialTransform self, SpatialTransform source)

        Parameters
        ----------
        source: OpenSim::SpatialTransform::Self const &

        """
        return _simulation.SpatialTransform_copyProperty_rotation2(self, source)

    def append_rotation2(self, value):
        r"""
        append_rotation2(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_rotation2(self, value)

    def constructProperty_rotation2(self, initValue):
        r"""
        constructProperty_rotation2(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_rotation2(self, initValue)

    def get_rotation2(self, *args):
        r"""
        get_rotation2(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_rotation2(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_rotation2(self, *args)

    def upd_rotation2(self, *args):
        r"""
        upd_rotation2(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_rotation2(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_rotation2(self, *args)

    def set_rotation2(self, *args):
        r"""
        set_rotation2(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_rotation2(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_rotation2(self, *args)

    def copyProperty_rotation3(self, source):
        r"""
        copyProperty_rotation3(SpatialTransform self, SpatialTransform source)

        Parameters
        ----------
        source: OpenSim::SpatialTransform::Self const &

        """
        return _simulation.SpatialTransform_copyProperty_rotation3(self, source)

    def append_rotation3(self, value):
        r"""
        append_rotation3(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_rotation3(self, value)

    def constructProperty_rotation3(self, initValue):
        r"""
        constructProperty_rotation3(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_rotation3(self, initValue)

    def get_rotation3(self, *args):
        r"""
        get_rotation3(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_rotation3(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_rotation3(self, *args)

    def upd_rotation3(self, *args):
        r"""
        upd_rotation3(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_rotation3(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_rotation3(self, *args)

    def set_rotation3(self, *args):
        r"""
        set_rotation3(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_rotation3(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_rotation3(self, *args)

    def copyProperty_translation1(self, source):
        r"""
        copyProperty_translation1(SpatialTransform self, SpatialTransform source)

        Parameters
        ----------
        source: OpenSim::SpatialTransform::Self const &

        """
        return _simulation.SpatialTransform_copyProperty_translation1(self, source)

    def append_translation1(self, value):
        r"""
        append_translation1(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_translation1(self, value)

    def constructProperty_translation1(self, initValue):
        r"""
        constructProperty_translation1(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_translation1(self, initValue)

    def get_translation1(self, *args):
        r"""
        get_translation1(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_translation1(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_translation1(self, *args)

    def upd_translation1(self, *args):
        r"""
        upd_translation1(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_translation1(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_translation1(self, *args)

    def set_translation1(self, *args):
        r"""
        set_translation1(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_translation1(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_translation1(self, *args)

    def copyProperty_translation2(self, source):
        r"""
        copyProperty_translation2(SpatialTransform self, SpatialTransform source)

        Parameters
        ----------
        source: OpenSim::SpatialTransform::Self const &

        """
        return _simulation.SpatialTransform_copyProperty_translation2(self, source)

    def append_translation2(self, value):
        r"""
        append_translation2(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_translation2(self, value)

    def constructProperty_translation2(self, initValue):
        r"""
        constructProperty_translation2(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_translation2(self, initValue)

    def get_translation2(self, *args):
        r"""
        get_translation2(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_translation2(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_translation2(self, *args)

    def upd_translation2(self, *args):
        r"""
        upd_translation2(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_translation2(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_translation2(self, *args)

    def set_translation2(self, *args):
        r"""
        set_translation2(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_translation2(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_translation2(self, *args)

    def copyProperty_translation3(self, source):
        r"""
        copyProperty_translation3(SpatialTransform self, SpatialTransform source)

        Parameters
        ----------
        source: OpenSim::SpatialTransform::Self const &

        """
        return _simulation.SpatialTransform_copyProperty_translation3(self, source)

    def append_translation3(self, value):
        r"""
        append_translation3(SpatialTransform self, TransformAxis value) -> int

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_append_translation3(self, value)

    def constructProperty_translation3(self, initValue):
        r"""
        constructProperty_translation3(SpatialTransform self, TransformAxis initValue)

        Parameters
        ----------
        initValue: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_constructProperty_translation3(self, initValue)

    def get_translation3(self, *args):
        r"""
        get_translation3(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        get_translation3(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_get_translation3(self, *args)

    def upd_translation3(self, *args):
        r"""
        upd_translation3(SpatialTransform self, int i) -> TransformAxis

        Parameters
        ----------
        i: int

        upd_translation3(SpatialTransform self) -> TransformAxis
        """
        return _simulation.SpatialTransform_upd_translation3(self, *args)

    def set_translation3(self, *args):
        r"""
        set_translation3(SpatialTransform self, int i, TransformAxis value)

        Parameters
        ----------
        i: int
        value: OpenSim::TransformAxis const &

        set_translation3(SpatialTransform self, TransformAxis value)

        Parameters
        ----------
        value: OpenSim::TransformAxis const &

        """
        return _simulation.SpatialTransform_set_translation3(self, *args)

    def __init__(self):
        r"""__init__(SpatialTransform self) -> SpatialTransform"""
        _simulation.SpatialTransform_swiginit(self, _simulation.new_SpatialTransform())

    def connectToJoint(self, owningJoint):
        r"""
        This tells the SpatialTransform the CustomJoint to which it belongs;
           this is not copied on copy construction or assignment. *
        """
        return _simulation.SpatialTransform_connectToJoint(self, owningJoint)

    def constructIndependentAxes(self, nAxes, startIndex):
        r""" Make sure axes are not parallel. *"""
        return _simulation.SpatialTransform_constructIndependentAxes(self, nAxes, startIndex)

    def getCoordinateNames(self):
        r"""
        Construct a list of all unique coordinate names used by any of the
           contained TransformAxis objects. *
        """
        return _simulation.SpatialTransform_getCoordinateNames(self)

    def getFunctions(self):
        r"""
        For each axis, construct a list of the coordinate indices that dictate
           motion along that axis. * Create a new SimTK::Function corresponding to each axis; these are
           heap allocated and it is up to the caller to delete them. *
        """
        return _simulation.SpatialTransform_getFunctions(self)

    def getAxes(self):
        r""" Get the axis direction associated with each TransformAxis. *"""
        return _simulation.SpatialTransform_getAxes(self)

    def scale(self, scaleFactors):
        r"""
        scale(SpatialTransform self, Vec3 scaleFactors)

        Parameters
        ----------
        scaleFactors: SimTK::Vec3 const

        """
        return _simulation.SpatialTransform_scale(self, scaleFactors)

    def getTransformAxis(self, whichAxis):
        r"""
        Select one of the 6 axis, numbered 0-5 with rotation first, then
           translation. *
        """
        return _simulation.SpatialTransform_getTransformAxis(self, whichAxis)

    def updTransformAxis(self, whichAxis):
        r""" Same, but returns a writable reference to the TransformAxis. *"""
        return _simulation.SpatialTransform_updTransformAxis(self, whichAxis)
    __swig_destroy__ = _simulation.delete_SpatialTransform

# Register SpatialTransform in _simulation:
_simulation.SpatialTransform_swigregister(SpatialTransform)
class Coordinate(ModelComponent):
    r"""
    A Coordinate is a ModelComponent for managing the access and behavior
    of a model's generalized coordinate including its value, speed and
    acceleration (once system accelerations have been realized).
    As a ModelComponent it provides resources to enable a Coordinate to be
    locked, prescribed, or clamped (limited to a min-to-max range).

    Authors: Ajay Seth, Ayman Habib, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Coordinate

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Coordinate_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Coordinate self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Coordinate_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Coordinate_getClassName()

    def clone(self):
        r"""clone(Coordinate self) -> Coordinate"""
        return _simulation.Coordinate_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Coordinate self) -> std::string const &"""
        return _simulation.Coordinate_getConcreteClassName(self)

    def copyProperty_default_value(self, source):
        r"""
        copyProperty_default_value(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_default_value(self, source)

    def append_default_value(self, value):
        r"""
        append_default_value(Coordinate self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Coordinate_append_default_value(self, value)

    def constructProperty_default_value(self, initValue):
        r"""
        constructProperty_default_value(Coordinate self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Coordinate_constructProperty_default_value(self, initValue)

    def get_default_value(self, *args):
        r"""
        get_default_value(Coordinate self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_value(Coordinate self) -> double const &
        """
        return _simulation.Coordinate_get_default_value(self, *args)

    def upd_default_value(self, *args):
        r"""
        upd_default_value(Coordinate self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_value(Coordinate self) -> double &
        """
        return _simulation.Coordinate_upd_default_value(self, *args)

    def set_default_value(self, *args):
        r"""
        set_default_value(Coordinate self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_value(Coordinate self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Coordinate_set_default_value(self, *args)

    def copyProperty_default_speed_value(self, source):
        r"""
        copyProperty_default_speed_value(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_default_speed_value(self, source)

    def append_default_speed_value(self, value):
        r"""
        append_default_speed_value(Coordinate self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Coordinate_append_default_speed_value(self, value)

    def constructProperty_default_speed_value(self, initValue):
        r"""
        constructProperty_default_speed_value(Coordinate self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Coordinate_constructProperty_default_speed_value(self, initValue)

    def get_default_speed_value(self, *args):
        r"""
        get_default_speed_value(Coordinate self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_speed_value(Coordinate self) -> double const &
        """
        return _simulation.Coordinate_get_default_speed_value(self, *args)

    def upd_default_speed_value(self, *args):
        r"""
        upd_default_speed_value(Coordinate self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_speed_value(Coordinate self) -> double &
        """
        return _simulation.Coordinate_upd_default_speed_value(self, *args)

    def set_default_speed_value(self, *args):
        r"""
        set_default_speed_value(Coordinate self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_speed_value(Coordinate self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Coordinate_set_default_speed_value(self, *args)

    def copyProperty_range(self, source):
        r"""
        copyProperty_range(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_range(self, source)

    def get_range(self, i):
        r"""
        get_range(Coordinate self, int i) -> double const &

        Parameters
        ----------
        i: int

        """
        return _simulation.Coordinate_get_range(self, i)

    def upd_range(self, i):
        r"""
        upd_range(Coordinate self, int i) -> double &

        Parameters
        ----------
        i: int

        """
        return _simulation.Coordinate_upd_range(self, i)

    def set_range(self, i, value):
        r"""
        set_range(Coordinate self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        """
        return _simulation.Coordinate_set_range(self, i, value)

    def append_range(self, value):
        r"""
        append_range(Coordinate self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Coordinate_append_range(self, value)

    def copyProperty_clamped(self, source):
        r"""
        copyProperty_clamped(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_clamped(self, source)

    def append_clamped(self, value):
        r"""
        append_clamped(Coordinate self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_append_clamped(self, value)

    def constructProperty_clamped(self, initValue):
        r"""
        constructProperty_clamped(Coordinate self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Coordinate_constructProperty_clamped(self, initValue)

    def get_clamped(self, *args):
        r"""
        get_clamped(Coordinate self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_clamped(Coordinate self) -> bool const &
        """
        return _simulation.Coordinate_get_clamped(self, *args)

    def upd_clamped(self, *args):
        r"""
        upd_clamped(Coordinate self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_clamped(Coordinate self) -> bool &
        """
        return _simulation.Coordinate_upd_clamped(self, *args)

    def set_clamped(self, *args):
        r"""
        set_clamped(Coordinate self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_clamped(Coordinate self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_set_clamped(self, *args)

    def copyProperty_locked(self, source):
        r"""
        copyProperty_locked(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_locked(self, source)

    def append_locked(self, value):
        r"""
        append_locked(Coordinate self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_append_locked(self, value)

    def constructProperty_locked(self, initValue):
        r"""
        constructProperty_locked(Coordinate self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Coordinate_constructProperty_locked(self, initValue)

    def get_locked(self, *args):
        r"""
        get_locked(Coordinate self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_locked(Coordinate self) -> bool const &
        """
        return _simulation.Coordinate_get_locked(self, *args)

    def upd_locked(self, *args):
        r"""
        upd_locked(Coordinate self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_locked(Coordinate self) -> bool &
        """
        return _simulation.Coordinate_upd_locked(self, *args)

    def set_locked(self, *args):
        r"""
        set_locked(Coordinate self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_locked(Coordinate self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_set_locked(self, *args)

    def copyProperty_prescribed_function(self, source):
        r"""
        copyProperty_prescribed_function(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_prescribed_function(self, source)

    def append_prescribed_function(self, value):
        r"""
        append_prescribed_function(Coordinate self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.Coordinate_append_prescribed_function(self, value)

    def constructProperty_prescribed_function(self, *args):
        r"""
        constructProperty_prescribed_function(Coordinate self)
        constructProperty_prescribed_function(Coordinate self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.Coordinate_constructProperty_prescribed_function(self, *args)

    def get_prescribed_function(self, *args):
        r"""
        get_prescribed_function(Coordinate self, int i) -> Function

        Parameters
        ----------
        i: int

        get_prescribed_function(Coordinate self) -> Function
        """
        return _simulation.Coordinate_get_prescribed_function(self, *args)

    def upd_prescribed_function(self, *args):
        r"""
        upd_prescribed_function(Coordinate self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_prescribed_function(Coordinate self) -> Function
        """
        return _simulation.Coordinate_upd_prescribed_function(self, *args)

    def set_prescribed_function(self, *args):
        r"""
        set_prescribed_function(Coordinate self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_prescribed_function(Coordinate self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.Coordinate_set_prescribed_function(self, *args)

    def copyProperty_prescribed(self, source):
        r"""
        copyProperty_prescribed(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_prescribed(self, source)

    def append_prescribed(self, value):
        r"""
        append_prescribed(Coordinate self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_append_prescribed(self, value)

    def constructProperty_prescribed(self, initValue):
        r"""
        constructProperty_prescribed(Coordinate self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Coordinate_constructProperty_prescribed(self, initValue)

    def get_prescribed(self, *args):
        r"""
        get_prescribed(Coordinate self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_prescribed(Coordinate self) -> bool const &
        """
        return _simulation.Coordinate_get_prescribed(self, *args)

    def upd_prescribed(self, *args):
        r"""
        upd_prescribed(Coordinate self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_prescribed(Coordinate self) -> bool &
        """
        return _simulation.Coordinate_upd_prescribed(self, *args)

    def set_prescribed(self, *args):
        r"""
        set_prescribed(Coordinate self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_prescribed(Coordinate self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_set_prescribed(self, *args)

    def copyProperty_is_free_to_satisfy_constraints(self, source):
        r"""
        copyProperty_is_free_to_satisfy_constraints(Coordinate self, Coordinate source)

        Parameters
        ----------
        source: OpenSim::Coordinate::Self const &

        """
        return _simulation.Coordinate_copyProperty_is_free_to_satisfy_constraints(self, source)

    def append_is_free_to_satisfy_constraints(self, value):
        r"""
        append_is_free_to_satisfy_constraints(Coordinate self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_append_is_free_to_satisfy_constraints(self, value)

    def constructProperty_is_free_to_satisfy_constraints(self, initValue):
        r"""
        constructProperty_is_free_to_satisfy_constraints(Coordinate self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Coordinate_constructProperty_is_free_to_satisfy_constraints(self, initValue)

    def get_is_free_to_satisfy_constraints(self, *args):
        r"""
        get_is_free_to_satisfy_constraints(Coordinate self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_is_free_to_satisfy_constraints(Coordinate self) -> bool const &
        """
        return _simulation.Coordinate_get_is_free_to_satisfy_constraints(self, *args)

    def upd_is_free_to_satisfy_constraints(self, *args):
        r"""
        upd_is_free_to_satisfy_constraints(Coordinate self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_is_free_to_satisfy_constraints(Coordinate self) -> bool &
        """
        return _simulation.Coordinate_upd_is_free_to_satisfy_constraints(self, *args)

    def set_is_free_to_satisfy_constraints(self, *args):
        r"""
        set_is_free_to_satisfy_constraints(Coordinate self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_is_free_to_satisfy_constraints(Coordinate self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Coordinate_set_is_free_to_satisfy_constraints(self, *args)
    _has_output_value = property(_simulation.Coordinate__has_output_value_get, _simulation.Coordinate__has_output_value_set, doc=r"""_has_output_value : bool""")
    _has_output_speed = property(_simulation.Coordinate__has_output_speed_get, _simulation.Coordinate__has_output_speed_set, doc=r"""_has_output_speed : bool""")
    _has_output_acceleration = property(_simulation.Coordinate__has_output_acceleration_get, _simulation.Coordinate__has_output_acceleration_set, doc=r"""_has_output_acceleration : bool""")
    Undefined = _simulation.Coordinate_Undefined
    r""" 0"""
    Rotational = _simulation.Coordinate_Rotational
    r""" 1"""
    Translational = _simulation.Coordinate_Translational
    r""" 2"""
    Coupled = _simulation.Coordinate_Coupled
    r""" 3"""

    def getJoint(self):
        r"""* access to the Coordinate's owning joint"""
        return _simulation.Coordinate_getJoint(self)

    def getMotionType(self):
        r"""
        access to the generalized Coordinate's motion type
               This can be Rotational, Translational, or Coupled (both)
        """
        return _simulation.Coordinate_getMotionType(self)

    def getValue(self, s):
        r""" get the value of the Coordinate from the state"""
        return _simulation.Coordinate_getValue(self, s)

    def setValue(self, s, aValue, enforceContraints=True):
        r"""
        Set the value of the Coordinate on to the state.
               Optional flag to enforce the constraints immediately (true by default),
               which can adjust all coordinate values in the state to satisfy model
               constraints. Use getValue(s) to see if/how the value was adjusted to
               satisfy the kinematic constraints. If setting multiple Coordinate values
               consecutively, e.g. in a loop, set the flag to false and then call
               Model::assemble(state) once all Coordinate values have been set.
               Alternatively, use Model::setStateVariableValues() to set all coordinate
               values and their speeds at once followed by Model::assemble(state).

               The provided value will be clamped to the coordinate's range if
               the coordinate is clamped and enforceConstraints is true.
        """
        return _simulation.Coordinate_setValue(self, s, aValue, enforceContraints)

    def getSpeedValue(self, s):
        r""" get the speed value of the Coordinate from the state"""
        return _simulation.Coordinate_getSpeedValue(self, s)

    def setSpeedValue(self, s, aValue):
        r"""
        setSpeedValue(Coordinate self, State s, double aValue)

        Parameters
        ----------
        s: SimTK::State &
        aValue: double

        """
        return _simulation.Coordinate_setSpeedValue(self, s, aValue)

    def getSpeedName(self):
        r"""
        return the name (label) used to identify the Coordinate's speed
               state variable. Returns the string "<coordinate_name>/speed"
        """
        return _simulation.Coordinate_getSpeedName(self)

    def getQDotValue(self, s):
        r"""
         get the derivative of Coordinate's value from the state. This value is
        not* necessarily equal to the value returned by getSpeedValue().
        """
        return _simulation.Coordinate_getQDotValue(self, s)

    def getDefaultValue(self):
        r"""
        get the default value for this coordinate. This is the value
               used if no value has been set prior to a simulation.
        """
        return _simulation.Coordinate_getDefaultValue(self)

    def setDefaultValue(self, aDefaultValue):
        r"""
        setDefaultValue(Coordinate self, double aDefaultValue)

        Parameters
        ----------
        aDefaultValue: double

        """
        return _simulation.Coordinate_setDefaultValue(self, aDefaultValue)

    def getDefaultSpeedValue(self):
        r"""
        get the default speed value for this coordinate. This is the value
               used if no value has been set prior to a simulation.
        """
        return _simulation.Coordinate_getDefaultSpeedValue(self)

    def setDefaultSpeedValue(self, aDefaultSpeedValue):
        r"""
        setDefaultSpeedValue(Coordinate self, double aDefaultSpeedValue)

        Parameters
        ----------
        aDefaultSpeedValue: double

        """
        return _simulation.Coordinate_setDefaultSpeedValue(self, aDefaultSpeedValue)

    def getAccelerationValue(self, s):
        r"""
        get acceleration of the coordinate is dependent on having
               realized the model and state to the acceleration stage
        """
        return _simulation.Coordinate_getAccelerationValue(self, s)

    def getClamped(self, s):
        r"""
        determine or set whether or not the Coordinate is
               "clamped" between a range of values.
        """
        return _simulation.Coordinate_getClamped(self, s)

    def setClamped(self, s, aClamped):
        r"""
        setClamped(Coordinate self, State s, bool aClamped)

        Parameters
        ----------
        s: SimTK::State &
        aClamped: bool

        """
        return _simulation.Coordinate_setClamped(self, s, aClamped)

    def getDefaultClamped(self):
        r""" get/set whether or not the Coordinate is clamped by default"""
        return _simulation.Coordinate_getDefaultClamped(self)

    def setDefaultClamped(self, aClamped):
        r"""
        setDefaultClamped(Coordinate self, bool aClamped)

        Parameters
        ----------
        aClamped: bool

        """
        return _simulation.Coordinate_setDefaultClamped(self, aClamped)

    def getRangeMin(self):
        r""" get the value for the Coordinate's range of motion"""
        return _simulation.Coordinate_getRangeMin(self)

    def getRangeMax(self):
        r"""getRangeMax(Coordinate self) -> double"""
        return _simulation.Coordinate_getRangeMax(self)

    def setRangeMin(self, aMin):
        r"""
        setRangeMin(Coordinate self, double aMin)

        Parameters
        ----------
        aMin: double

        """
        return _simulation.Coordinate_setRangeMin(self, aMin)

    def setRangeMax(self, aMax):
        r"""
        setRangeMax(Coordinate self, double aMax)

        Parameters
        ----------
        aMax: double

        """
        return _simulation.Coordinate_setRangeMax(self, aMax)

    def getLocked(self, s):
        r"""
        determine or set whether or not the Coordinate is
               "locked" for a given state of the Model.
        """
        return _simulation.Coordinate_getLocked(self, s)

    def setLocked(self, s, aLocked):
        r"""
        setLocked(Coordinate self, State s, bool aLocked)

        Parameters
        ----------
        s: SimTK::State &
        aLocked: bool

        """
        return _simulation.Coordinate_setLocked(self, s, aLocked)

    def getDefaultLocked(self):
        r""" get/set whether or not the Coordinate is locked by default"""
        return _simulation.Coordinate_getDefaultLocked(self)

    def setDefaultLocked(self, aLocked):
        r"""
        setDefaultLocked(Coordinate self, bool aLocked)

        Parameters
        ----------
        aLocked: bool

        """
        return _simulation.Coordinate_setDefaultLocked(self, aLocked)

    def isPrescribed(self, s):
        r"""
        determine or set whether or not the Coordinate is
               "prescribed" for a given state of the Model.
        """
        return _simulation.Coordinate_isPrescribed(self, s)

    def setIsPrescribed(self, s, isPrescribed):
        r"""
        setIsPrescribed(Coordinate self, State s, bool isPrescribed)

        Parameters
        ----------
        s: SimTK::State &
        isPrescribed: bool

        """
        return _simulation.Coordinate_setIsPrescribed(self, s, isPrescribed)

    def getDefaultIsPrescribed(self):
        r""" get/set whether or not the Coordinate is locked by default"""
        return _simulation.Coordinate_getDefaultIsPrescribed(self)

    def setDefaultIsPrescribed(self, isPrescribed):
        r"""
        setDefaultIsPrescribed(Coordinate self, bool isPrescribed)

        Parameters
        ----------
        isPrescribed: bool

        """
        return _simulation.Coordinate_setDefaultIsPrescribed(self, isPrescribed)

    def setPrescribedFunction(self, function):
        r"""
        Specify an OpenSim Function specifies the prescribed motion for this
               Coordinate as a function of time. Note, this function must provide
               valid first and second order derivatives.
        """
        return _simulation.Coordinate_setPrescribedFunction(self, function)

    def getPrescribedFunction(self):
        r"""getPrescribedFunction(Coordinate self) -> Function"""
        return _simulation.Coordinate_getPrescribedFunction(self)

    def isDependent(self, s):
        r"""
        Return true if coordinate is dependent on other coordinates via a coupler
               constraint OR it has been flagged as free to change when satisfying
               the model's kinematic constraints in general.
        """
        return _simulation.Coordinate_isDependent(self, s)

    def isConstrained(self, s):
        r""" Return true if coordinate is locked, prescribed, or dependent on other coordinates"""
        return _simulation.Coordinate_isConstrained(self, s)

    def getMobilizerQIndex(self):
        r"""*"""
        return _simulation.Coordinate_getMobilizerQIndex(self)

    def getBodyIndex(self):
        r"""getBodyIndex(Coordinate self) -> SimTK::MobilizedBodyIndex"""
        return _simulation.Coordinate_getBodyIndex(self)

    def getUserSpecifiedMotionTypePriorTo40(self):
        r"""*"""
        return _simulation.Coordinate_getUserSpecifiedMotionTypePriorTo40(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Coordinate_swiginit(self, _simulation.new_Coordinate(*args))
    __swig_destroy__ = _simulation.delete_Coordinate

# Register Coordinate in _simulation:
_simulation.Coordinate_swigregister(Coordinate)
class SetCoordinates(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetCoordinates

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetCoordinates_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetCoordinates self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetCoordinates_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetCoordinates_getClassName()

    def clone(self):
        r"""clone(SetCoordinates self) -> SetCoordinates"""
        return _simulation.SetCoordinates_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetCoordinates self) -> std::string const &"""
        return _simulation.SetCoordinates_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetCoordinates

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Coordinate,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetCoordinates_swiginit(self, _simulation.new_SetCoordinates(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetCoordinates_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetCoordinates_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetCoordinates_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetCoordinates_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetCoordinates_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetCoordinates_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetCoordinates_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetCoordinates_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetCoordinates_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetCoordinates_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetCoordinates self)"""
        return _simulation.SetCoordinates_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetCoordinates_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Coordinate`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Coordinate`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetCoordinates_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetCoordinates_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetCoordinates_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetCoordinates_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetCoordinates_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetCoordinates_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetCoordinates_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetCoordinates_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetCoordinates_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetCoordinates_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetCoordinates in _simulation:
_simulation.SetCoordinates_swigregister(SetCoordinates)
class CoordinateSet(SetCoordinates):
    r"""
    A class for holding a set of coordinates.

    Authors: Peter Loan, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CoordinateSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.CoordinateSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CoordinateSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.CoordinateSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.CoordinateSet_getClassName()

    def clone(self):
        r"""clone(CoordinateSet self) -> CoordinateSet"""
        return _simulation.CoordinateSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CoordinateSet self) -> std::string const &"""
        return _simulation.CoordinateSet_getConcreteClassName(self)

    def populate(self, model):
        r"""
        Populate this %Set as a flat list of all Model Coordinates given
        the a Model with Joints, which owns the Coordinates.
        """
        return _simulation.CoordinateSet_populate(self, model)

    def getSpeedNames(self, rNames):
        r"""
        getSpeedNames(CoordinateSet self, ArrayStr rNames)

        Parameters
        ----------
        rNames: OpenSim::Array< std::string > &

        """
        return _simulation.CoordinateSet_getSpeedNames(self, rNames)

    def __init__(self, *args):
        r"""
        __init__(CoordinateSet self) -> CoordinateSet
        __init__(CoordinateSet self, std::string const & file, bool updateFromXML=True) -> CoordinateSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.CoordinateSet_swiginit(self, _simulation.new_CoordinateSet(*args))
    __swig_destroy__ = _simulation.delete_CoordinateSet

# Register CoordinateSet in _simulation:
_simulation.CoordinateSet_swigregister(CoordinateSet)
class JointFramesAreTheSame(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::JointFramesAreTheSame class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, thisName, sameName):
        r"""
        __init__(JointFramesAreTheSame self, std::string const & file, size_t line, std::string const & func, std::string const & thisName, std::string const & sameName) -> JointFramesAreTheSame

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        thisName: std::string const &
        sameName: std::string const &

        """
        _simulation.JointFramesAreTheSame_swiginit(self, _simulation.new_JointFramesAreTheSame(file, line, func, thisName, sameName))
    __swig_destroy__ = _simulation.delete_JointFramesAreTheSame

# Register JointFramesAreTheSame in _simulation:
_simulation.JointFramesAreTheSame_swigregister(JointFramesAreTheSame)
class Joint(ModelComponent):
    r"""
    An OpenSim Joint is an OpenSim::ModelComponent which connects two PhysicalFrames
    together and specifies their relative permissible motion as described in
    internal coordinates. The base Joint specifies two frames (e.g. one per body),
    which the joint spans. The relative motion (including the # of coordinates)
    are defined by concrete Joints, which specify the permissible kinematics of
    a child joint frame (on a child body) with respect to a parent joint frame
    (on a parent body). The designation of parent and child are used only to
    identify the directionality of the joint and in which frame the joint
    coordinates are expressed.

    For example, A PinJoint between a parent frame, P, and a child frame, B,
    has a coordinate value of zero when the two frames are aligned and
    positive coordinate values are the angle between the frames' X-axes given
    a positive Z-rotation of the child frame about the coincident Z-axis in
    the parent frame.

    Note: the parent and child frames must be added to the model by the time
          you call initSystem() on the model.

    Concrete Joints can specify relative translations and even coupled
    rotations and translations (see EllipsoidJoint and CustomJoint). For more
    details on how the underlying formulation supports coupled curvilinear
    joints, see "Minimal formulation of joint motion for biomechanisms", 2010
    A Seth, M Sherman, P Eastman, S Delp; Nonlinear dynamics 62 (1), 291-303

    **C++ example**

    .. code-block:: c++

        Define a pin joint that attaches pendulum (an OpenSim::Body) to ground.
        PinJoint* myPin = new PinJoint("pendulumToGround", myModel.getGround(),
                                       pendulum);

    **Python example**

    .. code-block:: python

            # Define a ball joint between blockA and blockB.
            abJoint = osim.BallJoint('JointName', blockA, blockB)

    If you want to connect to an existing PhysicalFrame (e.g., a Body or Ground)
    but not to its origin, you can create and connect to a PhysicalOffsetFrame; the
    following convenience constructor does this for you:

    **C++ example**

    .. code-block:: c++

        Define a pin joint that attaches the end of pendulum to the ground origin.
        PinJoint* myPin = new PinJoint("pendulumToGround",
                                       myModel.getGround(),   //parent PhysicalFrame
                                       Vec3(0),               //location in parent
                                       Vec3(0),               //orientation in parent
                                       pendulum,              //child PhysicalFrame
                                       Vec3(0,-length/2.,0),  //location in child
                                       Vec3(0));              //orientation in child


    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Joint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Joint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Joint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Joint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Joint_getClassName()

    def clone(self):
        r"""clone(Joint self) -> Joint"""
        return _simulation.Joint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Joint self) -> std::string const &"""
        return _simulation.Joint_getConcreteClassName(self)

    def copyProperty_coordinates(self, source):
        r"""
        copyProperty_coordinates(Joint self, Joint source)

        Parameters
        ----------
        source: OpenSim::Joint::Self const &

        """
        return _simulation.Joint_copyProperty_coordinates(self, source)

    def get_coordinates(self, i):
        r"""
        get_coordinates(Joint self, int i) -> Coordinate

        Parameters
        ----------
        i: int

        """
        return _simulation.Joint_get_coordinates(self, i)

    def upd_coordinates(self, i):
        r"""
        upd_coordinates(Joint self, int i) -> Coordinate

        Parameters
        ----------
        i: int

        """
        return _simulation.Joint_upd_coordinates(self, i)

    def set_coordinates(self, i, value):
        r"""
        set_coordinates(Joint self, int i, Coordinate value)

        Parameters
        ----------
        i: int
        value: OpenSim::Coordinate const &

        """
        return _simulation.Joint_set_coordinates(self, i, value)

    def append_coordinates(self, value):
        r"""
        append_coordinates(Joint self, Coordinate value) -> int

        Parameters
        ----------
        value: OpenSim::Coordinate const &

        """
        return _simulation.Joint_append_coordinates(self, value)

    def constructProperty_coordinates(self):
        r"""constructProperty_coordinates(Joint self)"""
        return _simulation.Joint_constructProperty_coordinates(self)

    def copyProperty_frames(self, source):
        r"""
        copyProperty_frames(Joint self, Joint source)

        Parameters
        ----------
        source: OpenSim::Joint::Self const &

        """
        return _simulation.Joint_copyProperty_frames(self, source)

    def get_frames(self, i):
        r"""
        get_frames(Joint self, int i) -> PhysicalOffsetFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.Joint_get_frames(self, i)

    def upd_frames(self, i):
        r"""
        upd_frames(Joint self, int i) -> PhysicalOffsetFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.Joint_upd_frames(self, i)

    def set_frames(self, i, value):
        r"""
        set_frames(Joint self, int i, PhysicalOffsetFrame value)

        Parameters
        ----------
        i: int
        value: OpenSim::PhysicalOffsetFrame const &

        """
        return _simulation.Joint_set_frames(self, i, value)

    def append_frames(self, value):
        r"""
        append_frames(Joint self, PhysicalOffsetFrame value) -> int

        Parameters
        ----------
        value: OpenSim::PhysicalOffsetFrame const &

        """
        return _simulation.Joint_append_frames(self, value)

    def constructProperty_frames(self):
        r"""constructProperty_frames(Joint self)"""
        return _simulation.Joint_constructProperty_frames(self)
    PropertyIndex_socket_parent_frame = property(_simulation.Joint_PropertyIndex_socket_parent_frame_get, _simulation.Joint_PropertyIndex_socket_parent_frame_set, doc=r"""PropertyIndex_socket_parent_frame : OpenSim::PropertyIndex""")

    def connectSocket_parent_frame(self, object):
        r"""
        connectSocket_parent_frame(Joint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Joint_connectSocket_parent_frame(self, object)
    PropertyIndex_socket_child_frame = property(_simulation.Joint_PropertyIndex_socket_child_frame_get, _simulation.Joint_PropertyIndex_socket_child_frame_set, doc=r"""PropertyIndex_socket_child_frame : OpenSim::PropertyIndex""")

    def connectSocket_child_frame(self, object):
        r"""
        connectSocket_child_frame(Joint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Joint_connectSocket_child_frame(self, object)
    _has_output_power = property(_simulation.Joint__has_output_power_get, _simulation.Joint__has_output_power_set, doc=r"""_has_output_power : bool""")
    _has_output_reaction_on_parent = property(_simulation.Joint__has_output_reaction_on_parent_get, _simulation.Joint__has_output_reaction_on_parent_set, doc=r"""_has_output_reaction_on_parent : bool""")
    _has_output_reaction_on_child = property(_simulation.Joint__has_output_reaction_on_child_get, _simulation.Joint__has_output_reaction_on_child_set, doc=r"""_has_output_reaction_on_child : bool""")
    __swig_destroy__ = _simulation.delete_Joint

    def getChildFrame(self):
        r"""
        Get the child joint frame.

        :rtype: :py:class:`PhysicalFrame`
        :return: const PhysicalFrame reference.
        """
        return _simulation.Joint_getChildFrame(self)

    def getParentFrame(self):
        r"""
        Get the parent frame to which this joint attaches.

        :rtype: :py:class:`PhysicalFrame`
        :return: const ref to parent PhysicalFrame.
        """
        return _simulation.Joint_getParentFrame(self)

    def getCoordinate(self):
        r"""
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.
        """
        return _simulation.Joint_getCoordinate(self)

    def updCoordinate(self):
        r"""
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.
        """
        return _simulation.Joint_updCoordinate(self)

    def numCoordinates(self):
        r"""numCoordinates(Joint self) -> int"""
        return _simulation.Joint_numCoordinates(self)

    def isCoordinateUsed(self, aCoordinate):
        r"""
        isCoordinateUsed(Joint self, Coordinate aCoordinate) -> bool

        Parameters
        ----------
        aCoordinate: OpenSim::Coordinate const &

        """
        return _simulation.Joint_isCoordinateUsed(self, aCoordinate)

    def addFrame(self, frame):
        r"""
         Add a frame to the *frames* property in this Joint. The frame is
        adopted, and should have been dynamically allocated.
        Use this function instead of append_frames().
        """
        return _simulation.Joint_addFrame(self, frame)

    def calcEquivalentSpatialForce(self, state, mobilityForces):
        r"""
        Given some system mobility (generalized) forces, calculate the
           equivalent spatial body force for this Joint. Keep in mind that there are
           typically nm < 6 mobilities per joint with an infinite set of solutions that
           can map nm gen forces to 6 spatial force components (3 for torque + 3 for
           force). The solution returned provides the "most" effective force and torque
           in the joint frame. This means the smallest magnitude force and/or torque
           that will result in the same generalized force. If a generalized force is
           defined along/about a joint axis, then this should be evident in the
           reported results as a force or torque on the same axis.  NOTE: Joints
           comprised of multiple mobilizers and/or constraints, should override this
           method and account for multiple internal components.

           :type state: :py:class:`State`
           :param state: containing the generalized coordinate and speed values
           :type mobilityForces: :py:class:`Vector`
           :param mobilityForces: for the system as computed by inverse dynamics,
                                     for example
           :rtype: :py:class:`SpatialVec`
           :return: spatial force, FB_G, acting on the body connected by this joint at
               its location B, expressed in ground.
        """
        return _simulation.Joint_calcEquivalentSpatialForce(self, state, mobilityForces)

    def calcReactionOnParentExpressedInGround(self, state):
        r"""
        Joint Reaction forces  Calculate the joint reaction force and moment acting on the parent frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on parent frame, P,
                           and expressed in ground, G.
        """
        return _simulation.Joint_calcReactionOnParentExpressedInGround(self, state)

    def calcReactionOnChildExpressedInGround(self, state):
        r"""
        Calculate the joint reaction force and moment acting on the child frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on child frame, C,
                           and expressed in ground, G.
        """
        return _simulation.Joint_calcReactionOnChildExpressedInGround(self, state)

    def calcPower(self, s):
        r"""
        Joints in general do not contribute power since the reaction space
               forces are orthogonal to the mobility space. However, when joint motion
               is prescribed, the internal forces that move the joint will do work. In
               that case, the power is non-zero and the supplied SimTK::State
               must already have been realized to %Acceleration stage so that
               constraint forces are available.
        """
        return _simulation.Joint_calcPower(self, s)

# Register Joint in _simulation:
_simulation.Joint_swigregister(Joint)
class JointHasNoCoordinates(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::JointHasNoCoordinates class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func):
        r"""
        __init__(JointHasNoCoordinates self, std::string const & file, size_t line, std::string const & func) -> JointHasNoCoordinates

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &

        """
        _simulation.JointHasNoCoordinates_swiginit(self, _simulation.new_JointHasNoCoordinates(file, line, func))
    __swig_destroy__ = _simulation.delete_JointHasNoCoordinates

# Register JointHasNoCoordinates in _simulation:
_simulation.JointHasNoCoordinates_swigregister(JointHasNoCoordinates)
class SetJoints(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetJoints

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetJoints_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetJoints self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetJoints_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetJoints_getClassName()

    def clone(self):
        r"""clone(SetJoints self) -> SetJoints"""
        return _simulation.SetJoints_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetJoints self) -> std::string const &"""
        return _simulation.SetJoints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetJoints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Joint,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetJoints_swiginit(self, _simulation.new_SetJoints(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetJoints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetJoints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetJoints_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetJoints_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Joint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetJoints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetJoints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Joint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetJoints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Joint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetJoints_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Joint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetJoints_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Joint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetJoints_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetJoints self)"""
        return _simulation.SetJoints_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Joint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetJoints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Joint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Joint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetJoints_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetJoints_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetJoints_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetJoints_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetJoints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetJoints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetJoints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetJoints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetJoints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetJoints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetJoints in _simulation:
_simulation.SetJoints_swigregister(SetJoints)
class ModelComponentSetJoints(SetJoints):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Joint > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetJoints

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetJoints_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetJoints self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetJoints_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetJoints_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetJoints self) -> ModelComponentSetJoints"""
        return _simulation.ModelComponentSetJoints_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetJoints self) -> std::string const &"""
        return _simulation.ModelComponentSetJoints_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetJoints self)"""
        return _simulation.ModelComponentSetJoints_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetJoints self) -> ModelComponentSetJoints"""
        _simulation.ModelComponentSetJoints_swiginit(self, _simulation.new_ModelComponentSetJoints())
    __swig_destroy__ = _simulation.delete_ModelComponentSetJoints

# Register ModelComponentSetJoints in _simulation:
_simulation.ModelComponentSetJoints_swigregister(ModelComponentSetJoints)
class JointSet(ModelComponentSetJoints):
    r"""
    A class for holding a set of joints.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> JointSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.JointSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(JointSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.JointSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.JointSet_getClassName()

    def clone(self):
        r"""clone(JointSet self) -> JointSet"""
        return _simulation.JointSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(JointSet self) -> std::string const &"""
        return _simulation.JointSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(JointSet self) -> JointSet
        __init__(JointSet self, std::string const & file, bool updateFromXML=True) -> JointSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.JointSet_swiginit(self, _simulation.new_JointSet(*args))
    __swig_destroy__ = _simulation.delete_JointSet

# Register JointSet in _simulation:
_simulation.JointSet_swigregister(JointSet)
class Constraint(ModelComponent):
    r"""
    A parent class for implementing a Simbody Constraint.
    Specific constraints should be derived from this class.

    Author: Frank C. Anderson
    Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Constraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Constraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Constraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Constraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Constraint_getClassName()

    def clone(self):
        r"""clone(Constraint self) -> Constraint"""
        return _simulation.Constraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Constraint self) -> std::string const &"""
        return _simulation.Constraint_getConcreteClassName(self)

    def copyProperty_isEnforced(self, source):
        r"""
        copyProperty_isEnforced(Constraint self, Constraint source)

        Parameters
        ----------
        source: OpenSim::Constraint::Self const &

        """
        return _simulation.Constraint_copyProperty_isEnforced(self, source)

    def append_isEnforced(self, value):
        r"""
        append_isEnforced(Constraint self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Constraint_append_isEnforced(self, value)

    def constructProperty_isEnforced(self, initValue):
        r"""
        constructProperty_isEnforced(Constraint self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Constraint_constructProperty_isEnforced(self, initValue)

    def get_isEnforced(self, *args):
        r"""
        get_isEnforced(Constraint self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_isEnforced(Constraint self) -> bool const &
        """
        return _simulation.Constraint_get_isEnforced(self, *args)

    def upd_isEnforced(self, *args):
        r"""
        upd_isEnforced(Constraint self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_isEnforced(Constraint self) -> bool &
        """
        return _simulation.Constraint_upd_isEnforced(self, *args)

    def set_isEnforced(self, *args):
        r"""
        set_isEnforced(Constraint self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_isEnforced(Constraint self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Constraint_set_isEnforced(self, *args)
    __swig_destroy__ = _simulation.delete_Constraint

    def updateFromConstraint(self, s, aConstraint):
        r"""
        updateFromConstraint(Constraint self, State s, Constraint aConstraint)

        Parameters
        ----------
        s: SimTK::State &
        aConstraint: OpenSim::Constraint const &

        """
        return _simulation.Constraint_updateFromConstraint(self, s, aConstraint)

    def isEnforced(self, s):
        r"""Determine whether or not this Constraint is being enforced."""
        return _simulation.Constraint_isEnforced(self, s)

    def setIsEnforced(self, s, isEnforced):
        r"""
        Set whether or not this Constraint is enforced.
        The realization Stage is dropped to Instance whenever the 'isEnforced'
        flag is changed, but setting the same value has no effect.
        """
        return _simulation.Constraint_setIsEnforced(self, s, isEnforced)

    def calcConstraintForces(self, s, bodyForcesInAncestor, mobilityForces):
        r"""
        calcConstraintForces(Constraint self, State s, VectorOfSpatialVec bodyForcesInAncestor, Vector mobilityForces)

        Parameters
        ----------
        s: SimTK::State const &
        bodyForcesInAncestor: SimTK::Vector_< SimTK::SpatialVec > &
        mobilityForces: SimTK::Vector &

        """
        return _simulation.Constraint_calcConstraintForces(self, s, bodyForcesInAncestor, mobilityForces)

    def getRecordLabels(self):
        r"""
        Methods to query the Constraint forces (defaults to the Lagrange
        multipliers) applied to the MultibodySystem. The names of the quantities
        (column labels) are returned by this first method, getRecordLabels()
        """
        return _simulation.Constraint_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given a SimTK::State, extract all the values necessary to report
        constraint forces (e.g. multipliers). Subclasses can override to report
        the location, frame, etc.. of force application. This method is used in
        conjunction with getRecordLabels() and must return an Array of equal
        size.
        """
        return _simulation.Constraint_getRecordValues(self, state)

    def setContactPointForInducedAccelerations(self, s, point):
        r"""
        This method specifies the interface that a constraint must implement
        in order to be used by the Induced Accelerations Analysis
        """
        return _simulation.Constraint_setContactPointForInducedAccelerations(self, s, point)

# Register Constraint in _simulation:
_simulation.Constraint_swigregister(Constraint)
class SetConstraints(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetConstraints

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetConstraints_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetConstraints self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetConstraints_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetConstraints_getClassName()

    def clone(self):
        r"""clone(SetConstraints self) -> SetConstraints"""
        return _simulation.SetConstraints_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetConstraints self) -> std::string const &"""
        return _simulation.SetConstraints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetConstraints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Constraint,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetConstraints_swiginit(self, _simulation.new_SetConstraints(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetConstraints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetConstraints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetConstraints_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetConstraints_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Constraint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetConstraints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetConstraints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetConstraints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Constraint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetConstraints_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetConstraints_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetConstraints_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetConstraints self)"""
        return _simulation.SetConstraints_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetConstraints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Constraint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Constraint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetConstraints_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetConstraints_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetConstraints_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetConstraints_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetConstraints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetConstraints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetConstraints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetConstraints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetConstraints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetConstraints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetConstraints in _simulation:
_simulation.SetConstraints_swigregister(SetConstraints)
class ModelComponentSetConstraints(SetConstraints):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Constraint > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetConstraints

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetConstraints_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetConstraints self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetConstraints_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetConstraints_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetConstraints self) -> ModelComponentSetConstraints"""
        return _simulation.ModelComponentSetConstraints_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetConstraints self) -> std::string const &"""
        return _simulation.ModelComponentSetConstraints_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetConstraints self)"""
        return _simulation.ModelComponentSetConstraints_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetConstraints self) -> ModelComponentSetConstraints"""
        _simulation.ModelComponentSetConstraints_swiginit(self, _simulation.new_ModelComponentSetConstraints())
    __swig_destroy__ = _simulation.delete_ModelComponentSetConstraints

# Register ModelComponentSetConstraints in _simulation:
_simulation.ModelComponentSetConstraints_swigregister(ModelComponentSetConstraints)
class ConstraintSet(ModelComponentSetConstraints):
    r"""
    A class for holding a set of constraints.

    Authors: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ConstraintSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ConstraintSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ConstraintSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ConstraintSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ConstraintSet_getClassName()

    def clone(self):
        r"""clone(ConstraintSet self) -> ConstraintSet"""
        return _simulation.ConstraintSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ConstraintSet self) -> std::string const &"""
        return _simulation.ConstraintSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ConstraintSet self) -> ConstraintSet
        __init__(ConstraintSet self, std::string const & file, bool updateFromXML=True) -> ConstraintSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.ConstraintSet_swiginit(self, _simulation.new_ConstraintSet(*args))
    __swig_destroy__ = _simulation.delete_ConstraintSet

# Register ConstraintSet in _simulation:
_simulation.ConstraintSet_swigregister(ConstraintSet)
class Force(ModelComponent):
    r"""
    This abstract class represents a force applied to bodies or generalized
    coordinates during a simulation. Each subclass represents a different type
    of force. The actual force computation is done by a SimTK::Force, which is
    created by extendAddToSystem().

    Author: Peter Eastman
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Force

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Force_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Force self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Force_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Force_getClassName()

    def clone(self):
        r"""clone(Force self) -> Force"""
        return _simulation.Force_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Force self) -> std::string const &"""
        return _simulation.Force_getConcreteClassName(self)

    def copyProperty_appliesForce(self, source):
        r"""
        copyProperty_appliesForce(Force self, Force source)

        Parameters
        ----------
        source: OpenSim::Force::Self const &

        """
        return _simulation.Force_copyProperty_appliesForce(self, source)

    def append_appliesForce(self, value):
        r"""
        append_appliesForce(Force self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Force_append_appliesForce(self, value)

    def constructProperty_appliesForce(self, initValue):
        r"""
        constructProperty_appliesForce(Force self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Force_constructProperty_appliesForce(self, initValue)

    def get_appliesForce(self, *args):
        r"""
        get_appliesForce(Force self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_appliesForce(Force self) -> bool const &
        """
        return _simulation.Force_get_appliesForce(self, *args)

    def upd_appliesForce(self, *args):
        r"""
        upd_appliesForce(Force self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_appliesForce(Force self) -> bool &
        """
        return _simulation.Force_upd_appliesForce(self, *args)

    def set_appliesForce(self, *args):
        r"""
        set_appliesForce(Force self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_appliesForce(Force self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Force_set_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Force__has_output_potential_energy_get, _simulation.Force__has_output_potential_energy_set, doc=r"""_has_output_potential_energy : bool""")

    def shouldBeParallelized(self):
        r"""
        Tell Simbody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Force_shouldBeParallelized(self)

    def appliesForce(self, s):
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Force_appliesForce(self, s)

    def setAppliesForce(self, s, applyForce):
        r""" %Set whether or not the Force is applied."""
        return _simulation.Force_setAppliesForce(self, s, applyForce)

    def getRecordLabels(self):
        r"""
        Methods to query a Force for the value actually applied during
        simulation. The names of the quantities (column labels) is returned by
        this first function getRecordLabels().
        """
        return _simulation.Force_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.Force_getRecordValues(self, state)

    def hasVisualPath(self):
        r"""
         Return a flag indicating whether the Force is applied along a path that
        can be visualized. If you override this method to return true for a
        specific subclass, it must also implement the getPath() method.
        """
        return _simulation.Force_hasVisualPath(self)

    def getForceIndex(self):
        r""" Return the index to the SimTK::Force in the underlying system."""
        return _simulation.Force_getForceIndex(self)
    __swig_destroy__ = _simulation.delete_Force

# Register Force in _simulation:
_simulation.Force_swigregister(Force)
class ForceProducer(Force):
    r"""
    A `ForceProducer` is an abstract `OpenSim::Force` that can emit (produce)
    its forces one-by-one into a virtual `OpenSim::ForceConsumer`.

    The benefit of this is that it enables arbitrary external code to directly
    introspect each force before it gets resolved to the underlying body-/generalized-force
    vector that `OpenSim::Force::computeForce` manipulates. This can be useful for
    visualizing/dumping user data (e.g. because user-written `OpenSim::ExternalForce`s
    produce point-forces) or debugging (because it's easier to debug forces if they
    come one-at-a-time rather than trying to figure out which parts of downstream code
    touched which parts of a `SimTK::Vector_<SimTK::SpatialVec>` during
    `OpenSim::Force::computeForce`).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ForceProducer

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ForceProducer_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ForceProducer self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ForceProducer_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ForceProducer_getClassName()

    def clone(self):
        r"""clone(ForceProducer self) -> ForceProducer"""
        return _simulation.ForceProducer_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ForceProducer self) -> std::string const &"""
        return _simulation.ForceProducer_getConcreteClassName(self)

    def produceForces(self, state, forceConsumer):
        r"""
        Uses `implProduceForces` to produce (emit) forces evaluated from `state` into the
        provided `ForceConsumer`.

        Notes: this function only produces the forces and does not apply them to anything. It's
              up to the `ForceConsumer` implementation to handle the forces. Therefore,
              `Force::appliesForces` is ignored by this method.

        :type state: :py:class:`State`
        :param state:       the state used to evaluate forces
        :param consumer:    a `ForceConsumer` that shall receive each of the produced forces
        """
        return _simulation.ForceProducer_produceForces(self, state, forceConsumer)

    def computeForce(self, state, bodyForces, generalizedForces):
        r"""
        Inhereted from `OpenSim::Force`.

        `ForceProducer` overrides `OpenSim::Force::computeForce` with a default
        implementation that, provided `OpenSim::Force::appliesForces` is `true`,
        internally uses `produceForces` to mutate the provided `bodyForces` in a
        manner that's compatible with the `OpenSim::Force` API.
        """
        return _simulation.ForceProducer_computeForce(self, state, bodyForces, generalizedForces)
    __swig_destroy__ = _simulation.delete_ForceProducer

# Register ForceProducer in _simulation:
_simulation.ForceProducer_swigregister(ForceProducer)
class SetForces(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetForces

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetForces_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetForces self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetForces_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetForces_getClassName()

    def clone(self):
        r"""clone(SetForces self) -> SetForces"""
        return _simulation.SetForces_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetForces self) -> std::string const &"""
        return _simulation.SetForces_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetForces

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Force,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetForces_swiginit(self, _simulation.new_SetForces(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetForces_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetForces_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetForces_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetForces_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Force`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetForces_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetForces_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Force`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetForces_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Force`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetForces_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Force`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetForces_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Force`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetForces_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetForces self)"""
        return _simulation.SetForces_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Force`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetForces_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Force`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Force`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetForces_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetForces_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetForces_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetForces_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetForces_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetForces_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetForces_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetForces_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetForces_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetForces_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetForces in _simulation:
_simulation.SetForces_swigregister(SetForces)
class ModelComponentSetForces(SetForces):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Force > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetForces

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetForces_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetForces self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetForces_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetForces_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetForces self) -> ModelComponentSetForces"""
        return _simulation.ModelComponentSetForces_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetForces self) -> std::string const &"""
        return _simulation.ModelComponentSetForces_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetForces self)"""
        return _simulation.ModelComponentSetForces_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetForces self) -> ModelComponentSetForces"""
        _simulation.ModelComponentSetForces_swiginit(self, _simulation.new_ModelComponentSetForces())
    __swig_destroy__ = _simulation.delete_ModelComponentSetForces

# Register ModelComponentSetForces in _simulation:
_simulation.ModelComponentSetForces_swigregister(ModelComponentSetForces)
class ForceSet(ModelComponentSetForces):
    r"""
    A class for holding and managing a set of forces for a model.
    This class is based on ModelComponentSet

    Authors: Ajay Seth, Jack Middleton
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ForceSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ForceSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ForceSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ForceSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ForceSet_getClassName()

    def clone(self):
        r"""clone(ForceSet self) -> ForceSet"""
        return _simulation.ForceSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ForceSet self) -> std::string const &"""
        return _simulation.ForceSet_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ForceSet

    def extendConnectToModel(self, aModel):
        r"""
        extendConnectToModel(ForceSet self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.ForceSet_extendConnectToModel(self, aModel)

    def remove(self, aIndex):
        r"""
        remove(ForceSet self, int aIndex) -> bool

        Parameters
        ----------
        aIndex: int

        """
        return _simulation.ForceSet_remove(self, aIndex)

    def appendNative(self, aForce):
        r"""
        appendNative(ForceSet self, Force aForce) -> bool

        Parameters
        ----------
        aForce: OpenSim::Force *

        """
        return _simulation.ForceSet_appendNative(self, aForce)

    def append(self, aForceSet, aAllowDuplicateNames=False):
        r"""
        append(ForceSet self, ForceSet aForceSet, bool aAllowDuplicateNames=False) -> bool

        Parameters
        ----------
        aForceSet: OpenSim::ForceSet &
        aAllowDuplicateNames: bool

        """
        return _simulation.ForceSet_append(self, aForceSet, aAllowDuplicateNames)

    def set(self, aIndex, aForce, preserveGroups=False):
        r"""
        set(ForceSet self, int aIndex, Force aForce, bool preserveGroups=False) -> bool

        Parameters
        ----------
        aIndex: int
        aForce: OpenSim::Force *
        preserveGroups: bool

        """
        return _simulation.ForceSet_set(self, aIndex, aForce, preserveGroups)

    def insert(self, aIndex, aObject):
        r"""
        insert(ForceSet self, int aIndex, Force aObject) -> bool

        Parameters
        ----------
        aIndex: int
        aObject: OpenSim::Force *

        """
        return _simulation.ForceSet_insert(self, aIndex, aObject)

    def getActuators(self):
        r"""getActuators(ForceSet self) -> SetActuators"""
        return _simulation.ForceSet_getActuators(self)

    def updActuators(self):
        r"""updActuators(ForceSet self) -> SetActuators"""
        return _simulation.ForceSet_updActuators(self)

    def getMuscles(self):
        r"""getMuscles(ForceSet self) -> SetMuscles"""
        return _simulation.ForceSet_getMuscles(self)

    def updMuscles(self):
        r"""updMuscles(ForceSet self) -> SetMuscles"""
        return _simulation.ForceSet_updMuscles(self)

    def getStateVariableNames(self, rNames):
        r"""
        getStateVariableNames(ForceSet self, ArrayStr rNames)

        Parameters
        ----------
        rNames: OpenSim::Array< std::string > &

        """
        return _simulation.ForceSet_getStateVariableNames(self, rNames)

    def check(self):
        r"""check(ForceSet self) -> bool"""
        return _simulation.ForceSet_check(self)

    def __init__(self, *args):
        r"""
        __init__(ForceSet self) -> ForceSet
        __init__(ForceSet self, ForceSet arg2) -> ForceSet

        Parameters
        ----------
        arg2: OpenSim::ForceSet const &

        __init__(ForceSet self, ForceSet arg2) -> ForceSet

        Parameters
        ----------
        arg2: OpenSim::ForceSet &&

        __init__(ForceSet self, std::string const & file, bool updateFromXML=True) -> ForceSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.ForceSet_swiginit(self, _simulation.new_ForceSet(*args))

    def adoptAndAppend(self, aForce):
        aForce._markAdopted()
        return super(ForceSet, self).adoptAndAppend(aForce)


    def append(self, aForce):
        aForce._markAdopted()
        return self.appendNative(aForce)


# Register ForceSet in _simulation:
_simulation.ForceSet_swigregister(ForceSet)
class ExternalForce(ForceProducer):
    r"""
    An ExternalForce is a Force class specialized at applying an external force
    and/or torque to a body as described by arrays (columns) of a Storage object.
    The source of the Storage may be experimental sensor recording or user
    generated data. The Storage must be able to supply (1) an array of time, (2)
    arrays for the x,y,z, components of force and/or torque in time. Optionally,
    (3) arrays for the point of force application in time. An ExternalForce
    must specify the identifier (e.g. Force1.x Force1.y Force1.z) for the force
    components (columns) listed in the Storage either by individual labels or
    collectively (e.g. as "Force1"). Similarly, identifiers for the applied
    torque and optionally the point of force application must be specified.

    If an identifier is supplied and it cannot uniquely identify the force data
    (e.g. the force, torque, or point) in the Storage, then an Exception is
    thrown.

    An ExternalForce must apply at least a force or a torque and therefore both
    identifiers cannot be empty.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExternalForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExternalForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExternalForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExternalForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExternalForce_getClassName()

    def clone(self):
        r"""clone(ExternalForce self) -> ExternalForce"""
        return _simulation.ExternalForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getConcreteClassName(self)

    def copyProperty_applied_to_body(self, source):
        r"""
        copyProperty_applied_to_body(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_applied_to_body(self, source)

    def append_applied_to_body(self, value):
        r"""
        append_applied_to_body(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_applied_to_body(self, value)

    def constructProperty_applied_to_body(self, initValue):
        r"""
        constructProperty_applied_to_body(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_applied_to_body(self, initValue)

    def get_applied_to_body(self, *args):
        r"""
        get_applied_to_body(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_applied_to_body(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_applied_to_body(self, *args)

    def upd_applied_to_body(self, *args):
        r"""
        upd_applied_to_body(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_applied_to_body(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_applied_to_body(self, *args)

    def set_applied_to_body(self, *args):
        r"""
        set_applied_to_body(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_applied_to_body(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_applied_to_body(self, *args)

    def copyProperty_force_expressed_in_body(self, source):
        r"""
        copyProperty_force_expressed_in_body(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_force_expressed_in_body(self, source)

    def append_force_expressed_in_body(self, value):
        r"""
        append_force_expressed_in_body(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_force_expressed_in_body(self, value)

    def constructProperty_force_expressed_in_body(self, initValue):
        r"""
        constructProperty_force_expressed_in_body(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_force_expressed_in_body(self, initValue)

    def get_force_expressed_in_body(self, *args):
        r"""
        get_force_expressed_in_body(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_force_expressed_in_body(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_force_expressed_in_body(self, *args)

    def upd_force_expressed_in_body(self, *args):
        r"""
        upd_force_expressed_in_body(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_force_expressed_in_body(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_force_expressed_in_body(self, *args)

    def set_force_expressed_in_body(self, *args):
        r"""
        set_force_expressed_in_body(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_force_expressed_in_body(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_force_expressed_in_body(self, *args)

    def copyProperty_point_expressed_in_body(self, source):
        r"""
        copyProperty_point_expressed_in_body(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_point_expressed_in_body(self, source)

    def append_point_expressed_in_body(self, value):
        r"""
        append_point_expressed_in_body(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_point_expressed_in_body(self, value)

    def constructProperty_point_expressed_in_body(self, initValue):
        r"""
        constructProperty_point_expressed_in_body(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_point_expressed_in_body(self, initValue)

    def get_point_expressed_in_body(self, *args):
        r"""
        get_point_expressed_in_body(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_point_expressed_in_body(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_point_expressed_in_body(self, *args)

    def upd_point_expressed_in_body(self, *args):
        r"""
        upd_point_expressed_in_body(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_point_expressed_in_body(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_point_expressed_in_body(self, *args)

    def set_point_expressed_in_body(self, *args):
        r"""
        set_point_expressed_in_body(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_point_expressed_in_body(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_point_expressed_in_body(self, *args)

    def copyProperty_force_identifier(self, source):
        r"""
        copyProperty_force_identifier(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_force_identifier(self, source)

    def append_force_identifier(self, value):
        r"""
        append_force_identifier(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_force_identifier(self, value)

    def constructProperty_force_identifier(self, *args):
        r"""
        constructProperty_force_identifier(ExternalForce self)
        constructProperty_force_identifier(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_force_identifier(self, *args)

    def get_force_identifier(self, *args):
        r"""
        get_force_identifier(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_force_identifier(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_force_identifier(self, *args)

    def upd_force_identifier(self, *args):
        r"""
        upd_force_identifier(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_force_identifier(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_force_identifier(self, *args)

    def set_force_identifier(self, *args):
        r"""
        set_force_identifier(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_force_identifier(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_force_identifier(self, *args)

    def copyProperty_point_identifier(self, source):
        r"""
        copyProperty_point_identifier(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_point_identifier(self, source)

    def append_point_identifier(self, value):
        r"""
        append_point_identifier(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_point_identifier(self, value)

    def constructProperty_point_identifier(self, *args):
        r"""
        constructProperty_point_identifier(ExternalForce self)
        constructProperty_point_identifier(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_point_identifier(self, *args)

    def get_point_identifier(self, *args):
        r"""
        get_point_identifier(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_point_identifier(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_point_identifier(self, *args)

    def upd_point_identifier(self, *args):
        r"""
        upd_point_identifier(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_point_identifier(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_point_identifier(self, *args)

    def set_point_identifier(self, *args):
        r"""
        set_point_identifier(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_point_identifier(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_point_identifier(self, *args)

    def copyProperty_torque_identifier(self, source):
        r"""
        copyProperty_torque_identifier(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_torque_identifier(self, source)

    def append_torque_identifier(self, value):
        r"""
        append_torque_identifier(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_torque_identifier(self, value)

    def constructProperty_torque_identifier(self, *args):
        r"""
        constructProperty_torque_identifier(ExternalForce self)
        constructProperty_torque_identifier(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_torque_identifier(self, *args)

    def get_torque_identifier(self, *args):
        r"""
        get_torque_identifier(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_torque_identifier(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_torque_identifier(self, *args)

    def upd_torque_identifier(self, *args):
        r"""
        upd_torque_identifier(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_torque_identifier(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_torque_identifier(self, *args)

    def set_torque_identifier(self, *args):
        r"""
        set_torque_identifier(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_torque_identifier(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_torque_identifier(self, *args)

    def copyProperty_data_source_name(self, source):
        r"""
        copyProperty_data_source_name(ExternalForce self, ExternalForce source)

        Parameters
        ----------
        source: OpenSim::ExternalForce::Self const &

        """
        return _simulation.ExternalForce_copyProperty_data_source_name(self, source)

    def append_data_source_name(self, value):
        r"""
        append_data_source_name(ExternalForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_append_data_source_name(self, value)

    def constructProperty_data_source_name(self, *args):
        r"""
        constructProperty_data_source_name(ExternalForce self)
        constructProperty_data_source_name(ExternalForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExternalForce_constructProperty_data_source_name(self, *args)

    def get_data_source_name(self, *args):
        r"""
        get_data_source_name(ExternalForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_data_source_name(ExternalForce self) -> std::string const &
        """
        return _simulation.ExternalForce_get_data_source_name(self, *args)

    def upd_data_source_name(self, *args):
        r"""
        upd_data_source_name(ExternalForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_data_source_name(ExternalForce self) -> std::string &
        """
        return _simulation.ExternalForce_upd_data_source_name(self, *args)

    def set_data_source_name(self, *args):
        r"""
        set_data_source_name(ExternalForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_data_source_name(ExternalForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExternalForce_set_data_source_name(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ExternalForce self) -> ExternalForce
        __init__(ExternalForce self, Storage dataSource, std::string const & forceIdentifier="force", std::string const & pointIdentifier="point", std::string const & torqueIdentifier="torque", std::string const & appliedToBodyName="", std::string const & forceExpressedInBodyName="ground", std::string const & pointExpressedInBodyName="ground") -> ExternalForce

        Parameters
        ----------
        dataSource: OpenSim::Storage const &
        forceIdentifier: std::string const &
        pointIdentifier: std::string const &
        torqueIdentifier: std::string const &
        appliedToBodyName: std::string const &
        forceExpressedInBodyName: std::string const &
        pointExpressedInBodyName: std::string const &

        __init__(ExternalForce self, SimTK::Xml::Element & aNode) -> ExternalForce

        Parameters
        ----------
        aNode: SimTK::Xml::Element &

        """
        _simulation.ExternalForce_swiginit(self, _simulation.new_ExternalForce(*args))

    def setDataSource(self, dataSource):
        r"""
        Associate the data source from which the force, point and/or torque data
        is to be extracted.
        """
        return _simulation.ExternalForce_setDataSource(self, dataSource)

    def getDataSourceName(self):
        r""" Get the name of the data source for the force data. *"""
        return _simulation.ExternalForce_getDataSourceName(self)

    def setAppliedToBodyName(self, applyToName):
        r""" Specify or obtain the body to which the force will be applied"""
        return _simulation.ExternalForce_setAppliedToBodyName(self, applyToName)

    def getAppliedToBodyName(self):
        r"""getAppliedToBodyName(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getAppliedToBodyName(self)

    def setPointExpressedInBodyName(self, pointInBodyName):
        r""" Specify or obtain the body in which the point of application is expressed"""
        return _simulation.ExternalForce_setPointExpressedInBodyName(self, pointInBodyName)

    def getPointExpressedInBodyName(self):
        r"""getPointExpressedInBodyName(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getPointExpressedInBodyName(self)

    def setForceExpressedInBodyName(self, forceInBodyName):
        r""" Specify or obtain the body in which the force is expressed"""
        return _simulation.ExternalForce_setForceExpressedInBodyName(self, forceInBodyName)

    def getForceExpressedInBodyName(self):
        r"""getForceExpressedInBodyName(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getForceExpressedInBodyName(self)

    def setForceIdentifier(self, aForceIdentifier):
        r"""Identifiers"""
        return _simulation.ExternalForce_setForceIdentifier(self, aForceIdentifier)

    def setPointIdentifier(self, aPointIdentifier):
        r"""
        setPointIdentifier(ExternalForce self, std::string const aPointIdentifier)

        Parameters
        ----------
        aPointIdentifier: std::string const

        """
        return _simulation.ExternalForce_setPointIdentifier(self, aPointIdentifier)

    def setTorqueIdentifier(self, aTorqueIdentifier):
        r"""
        setTorqueIdentifier(ExternalForce self, std::string const aTorqueIdentifier)

        Parameters
        ----------
        aTorqueIdentifier: std::string const

        """
        return _simulation.ExternalForce_setTorqueIdentifier(self, aTorqueIdentifier)

    def getForceIdentifier(self):
        r"""getForceIdentifier(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getForceIdentifier(self)

    def getPointIdentifier(self):
        r"""getPointIdentifier(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getPointIdentifier(self)

    def getTorqueIdentifier(self):
        r"""getTorqueIdentifier(ExternalForce self) -> std::string const &"""
        return _simulation.ExternalForce_getTorqueIdentifier(self)

    def getForceAtTime(self, aTime):
        r"""Convenience methods to access external forces at a given time"""
        return _simulation.ExternalForce_getForceAtTime(self, aTime)

    def getPointAtTime(self, aTime):
        r"""
        getPointAtTime(ExternalForce self, double aTime) -> Vec3

        Parameters
        ----------
        aTime: double

        """
        return _simulation.ExternalForce_getPointAtTime(self, aTime)

    def getTorqueAtTime(self, aTime):
        r"""
        getTorqueAtTime(ExternalForce self, double aTime) -> Vec3

        Parameters
        ----------
        aTime: double

        """
        return _simulation.ExternalForce_getTorqueAtTime(self, aTime)

    def getRecordLabels(self):
        r"""
        Methods used for reporting.
        First identify the labels for individual components
        """
        return _simulation.ExternalForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.ExternalForce_getRecordValues(self, state)

    def appliesForce(self):
        r"""
        Methods to query the force properties to find out if it's a body vs.
        point force and/or if it applies a torque.
        """
        return _simulation.ExternalForce_appliesForce(self)

    def specifiesPoint(self):
        r"""specifiesPoint(ExternalForce self) -> bool"""
        return _simulation.ExternalForce_specifiesPoint(self)

    def appliesTorque(self):
        r"""appliesTorque(ExternalForce self) -> bool"""
        return _simulation.ExternalForce_appliesTorque(self)
    __swig_destroy__ = _simulation.delete_ExternalForce

# Register ExternalForce in _simulation:
_simulation.ExternalForce_swigregister(ExternalForce)
class SetExternalForces(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetExternalForces

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetExternalForces_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetExternalForces self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetExternalForces_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetExternalForces_getClassName()

    def clone(self):
        r"""clone(SetExternalForces self) -> SetExternalForces"""
        return _simulation.SetExternalForces_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetExternalForces self) -> std::string const &"""
        return _simulation.SetExternalForces_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetExternalForces

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ExternalForce,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetExternalForces_swiginit(self, _simulation.new_SetExternalForces(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetExternalForces_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetExternalForces_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetExternalForces_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetExternalForces_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetExternalForces_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetExternalForces_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetExternalForces_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetExternalForces_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetExternalForces_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetExternalForces_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetExternalForces self)"""
        return _simulation.SetExternalForces_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetExternalForces_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ExternalForce`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ExternalForce`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetExternalForces_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetExternalForces_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetExternalForces_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetExternalForces_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetExternalForces_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetExternalForces_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetExternalForces_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetExternalForces_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetExternalForces_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetExternalForces_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetExternalForces in _simulation:
_simulation.SetExternalForces_swigregister(SetExternalForces)
class ModelComponentSetExternalForces(SetExternalForces):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::ExternalForce > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetExternalForces

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetExternalForces_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetExternalForces self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetExternalForces_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetExternalForces_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetExternalForces self) -> ModelComponentSetExternalForces"""
        return _simulation.ModelComponentSetExternalForces_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetExternalForces self) -> std::string const &"""
        return _simulation.ModelComponentSetExternalForces_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetExternalForces self)"""
        return _simulation.ModelComponentSetExternalForces_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetExternalForces self) -> ModelComponentSetExternalForces"""
        _simulation.ModelComponentSetExternalForces_swiginit(self, _simulation.new_ModelComponentSetExternalForces())
    __swig_destroy__ = _simulation.delete_ModelComponentSetExternalForces

# Register ModelComponentSetExternalForces in _simulation:
_simulation.ModelComponentSetExternalForces_swigregister(ModelComponentSetExternalForces)
class TwoFrameLinkerForce(Force):
    r"""
    TwoFrameLinker is a utility class to extend a Component such that it connects
    two Frames. For example, a WeldConstraint and BushingForces operate between
    two frames to restrict their motion. A TwoFrameLinker<Force, PhysicalFrame>,
    for example, is a Force that operates between two PhyscialFrames and it is
    the base class for BushingForces.
    (A class whose super class is a template parameter is called a mixin class.)

    .. code-block:: c++

           class BushingForce : public TwoFrameLinker<Force, PhysicalFrame>

    :param C: The base class.
    :param F: The type of frame that the class links together.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TwoFrameLinkerForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TwoFrameLinkerForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TwoFrameLinkerForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TwoFrameLinkerForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TwoFrameLinkerForce_getClassName()

    def clone(self):
        r"""clone(TwoFrameLinkerForce self) -> TwoFrameLinkerForce"""
        return _simulation.TwoFrameLinkerForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TwoFrameLinkerForce self) -> std::string const &"""
        return _simulation.TwoFrameLinkerForce_getConcreteClassName(self)

    def copyProperty_frames(self, source):
        r""" Frames added to satisfy the sockets of this TwoFrameLinker Component"""
        return _simulation.TwoFrameLinkerForce_copyProperty_frames(self, source)

    def get_frames(self, i):
        r"""
        get_frames(TwoFrameLinkerForce self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerForce_get_frames(self, i)

    def upd_frames(self, i):
        r"""
        upd_frames(TwoFrameLinkerForce self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerForce_upd_frames(self, i)

    def set_frames(self, i, value):
        r"""
        set_frames(TwoFrameLinkerForce self, int i, PhysicalFrame value)

        Parameters
        ----------
        i: int
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerForce_set_frames(self, i, value)

    def append_frames(self, value):
        r"""
        append_frames(TwoFrameLinkerForce self, PhysicalFrame value) -> int

        Parameters
        ----------
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerForce_append_frames(self, value)

    def constructProperty_frames(self):
        r"""constructProperty_frames(TwoFrameLinkerForce self)"""
        return _simulation.TwoFrameLinkerForce_constructProperty_frames(self)
    PropertyIndex_socket_frame1 = property(_simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame1_get, _simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame1_set, doc=r"""PropertyIndex_socket_frame1 : OpenSim::PropertyIndex""")

    def connectSocket_frame1(self, object):
        r"""
        connectSocket_frame1(TwoFrameLinkerForce self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerForce_connectSocket_frame1(self, object)
    PropertyIndex_socket_frame2 = property(_simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame2_get, _simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame2_set, doc=r"""PropertyIndex_socket_frame2 : OpenSim::PropertyIndex""")

    def connectSocket_frame2(self, object):
        r"""
        connectSocket_frame2(TwoFrameLinkerForce self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerForce_connectSocket_frame2(self, object)

    def getFrame1(self):
        r"""
        Access the first frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForce_getFrame1(self)

    def getFrame2(self):
        r"""
        Access the second frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForce_getFrame2(self)

    def computeRelativeOffset(self, s):
        r"""
        Compute the relative offset Transform between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForce_computeRelativeOffset(self, s)

    def computeRelativeVelocity(self, s):
        r"""
        Compute the relative spatial velocity between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForce_computeRelativeVelocity(self, s)

    def computeDeflection(self, s):
        r"""
        Compute the deflection (spatial separation) of the two frames connected
               by the TwoFrameLinker. Angular deflections expressed as XYZ body-fixed
               Euler angles of frame2 w.r.t frame1.
               NOTE: When using deflections to compute spatial forces, these forces
                   may not be valid for large deflections, because Euler angles are
                   unable to uniquely distinguish an X rotation angle of +/-180 degs,
                   and subsequent rotations that are +/-90 degs. It is mainly useful
                   for calculating errors for constraints and forces for computing
                   restoration forces.
            :rtype: :py:class:`Vec6`
            :return: dq     Vec6 of (3) angular and (3) translational deflections.
        """
        return _simulation.TwoFrameLinkerForce_computeDeflection(self, s)

    def computeDeflectionRate(self, s):
        r"""
        Compute the deflection rate (dqdot) of the two frames connected by
               this TwoFrameLinker component. Angular velocity is expressed as Euler
               (XYZ body-fixed) angle derivatives. Note that the derivatives
               become singular as the second Euler angle approaches 90 degs.
           :rtype: :py:class:`Vec6`
           :return: dqdot  Vec6 of (3) angular and (3) translational deflection rates.
        """
        return _simulation.TwoFrameLinkerForce_computeDeflectionRate(self, s)
    __swig_destroy__ = _simulation.delete_TwoFrameLinkerForce

# Register TwoFrameLinkerForce in _simulation:
_simulation.TwoFrameLinkerForce_swigregister(TwoFrameLinkerForce)
class TwoFrameLinkerForceProducer(ForceProducer):
    r"""
    TwoFrameLinker is a utility class to extend a Component such that it connects
    two Frames. For example, a WeldConstraint and BushingForces operate between
    two frames to restrict their motion. A TwoFrameLinker<Force, PhysicalFrame>,
    for example, is a Force that operates between two PhyscialFrames and it is
    the base class for BushingForces.
    (A class whose super class is a template parameter is called a mixin class.)

    .. code-block:: c++

           class BushingForce : public TwoFrameLinker<Force, PhysicalFrame>

    :param C: The base class.
    :param F: The type of frame that the class links together.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TwoFrameLinkerForceProducer

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TwoFrameLinkerForceProducer_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TwoFrameLinkerForceProducer self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TwoFrameLinkerForceProducer_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TwoFrameLinkerForceProducer_getClassName()

    def clone(self):
        r"""clone(TwoFrameLinkerForceProducer self) -> TwoFrameLinkerForceProducer"""
        return _simulation.TwoFrameLinkerForceProducer_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TwoFrameLinkerForceProducer self) -> std::string const &"""
        return _simulation.TwoFrameLinkerForceProducer_getConcreteClassName(self)

    def copyProperty_frames(self, source):
        r""" Frames added to satisfy the sockets of this TwoFrameLinker Component"""
        return _simulation.TwoFrameLinkerForceProducer_copyProperty_frames(self, source)

    def get_frames(self, i):
        r"""
        get_frames(TwoFrameLinkerForceProducer self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerForceProducer_get_frames(self, i)

    def upd_frames(self, i):
        r"""
        upd_frames(TwoFrameLinkerForceProducer self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerForceProducer_upd_frames(self, i)

    def set_frames(self, i, value):
        r"""
        set_frames(TwoFrameLinkerForceProducer self, int i, PhysicalFrame value)

        Parameters
        ----------
        i: int
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerForceProducer_set_frames(self, i, value)

    def append_frames(self, value):
        r"""
        append_frames(TwoFrameLinkerForceProducer self, PhysicalFrame value) -> int

        Parameters
        ----------
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerForceProducer_append_frames(self, value)

    def constructProperty_frames(self):
        r"""constructProperty_frames(TwoFrameLinkerForceProducer self)"""
        return _simulation.TwoFrameLinkerForceProducer_constructProperty_frames(self)
    PropertyIndex_socket_frame1 = property(_simulation.TwoFrameLinkerForceProducer_PropertyIndex_socket_frame1_get, _simulation.TwoFrameLinkerForceProducer_PropertyIndex_socket_frame1_set, doc=r"""PropertyIndex_socket_frame1 : OpenSim::PropertyIndex""")

    def connectSocket_frame1(self, object):
        r"""
        connectSocket_frame1(TwoFrameLinkerForceProducer self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerForceProducer_connectSocket_frame1(self, object)
    PropertyIndex_socket_frame2 = property(_simulation.TwoFrameLinkerForceProducer_PropertyIndex_socket_frame2_get, _simulation.TwoFrameLinkerForceProducer_PropertyIndex_socket_frame2_set, doc=r"""PropertyIndex_socket_frame2 : OpenSim::PropertyIndex""")

    def connectSocket_frame2(self, object):
        r"""
        connectSocket_frame2(TwoFrameLinkerForceProducer self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerForceProducer_connectSocket_frame2(self, object)

    def getFrame1(self):
        r"""
        Access the first frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForceProducer_getFrame1(self)

    def getFrame2(self):
        r"""
        Access the second frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForceProducer_getFrame2(self)

    def computeRelativeOffset(self, s):
        r"""
        Compute the relative offset Transform between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForceProducer_computeRelativeOffset(self, s)

    def computeRelativeVelocity(self, s):
        r"""
        Compute the relative spatial velocity between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForceProducer_computeRelativeVelocity(self, s)

    def computeDeflection(self, s):
        r"""
        Compute the deflection (spatial separation) of the two frames connected
               by the TwoFrameLinker. Angular deflections expressed as XYZ body-fixed
               Euler angles of frame2 w.r.t frame1.
               NOTE: When using deflections to compute spatial forces, these forces
                   may not be valid for large deflections, because Euler angles are
                   unable to uniquely distinguish an X rotation angle of +/-180 degs,
                   and subsequent rotations that are +/-90 degs. It is mainly useful
                   for calculating errors for constraints and forces for computing
                   restoration forces.
            :rtype: :py:class:`Vec6`
            :return: dq     Vec6 of (3) angular and (3) translational deflections.
        """
        return _simulation.TwoFrameLinkerForceProducer_computeDeflection(self, s)

    def computeDeflectionRate(self, s):
        r"""
        Compute the deflection rate (dqdot) of the two frames connected by
               this TwoFrameLinker component. Angular velocity is expressed as Euler
               (XYZ body-fixed) angle derivatives. Note that the derivatives
               become singular as the second Euler angle approaches 90 degs.
           :rtype: :py:class:`Vec6`
           :return: dqdot  Vec6 of (3) angular and (3) translational deflection rates.
        """
        return _simulation.TwoFrameLinkerForceProducer_computeDeflectionRate(self, s)
    __swig_destroy__ = _simulation.delete_TwoFrameLinkerForceProducer

# Register TwoFrameLinkerForceProducer in _simulation:
_simulation.TwoFrameLinkerForceProducer_swigregister(TwoFrameLinkerForceProducer)
class TwoFrameLinkerConstraint(Constraint):
    r"""
    TwoFrameLinker is a utility class to extend a Component such that it connects
    two Frames. For example, a WeldConstraint and BushingForces operate between
    two frames to restrict their motion. A TwoFrameLinker<Force, PhysicalFrame>,
    for example, is a Force that operates between two PhyscialFrames and it is
    the base class for BushingForces.
    (A class whose super class is a template parameter is called a mixin class.)

    .. code-block:: c++

           class BushingForce : public TwoFrameLinker<Force, PhysicalFrame>

    :param C: The base class.
    :param F: The type of frame that the class links together.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TwoFrameLinkerConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TwoFrameLinkerConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TwoFrameLinkerConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TwoFrameLinkerConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TwoFrameLinkerConstraint_getClassName()

    def clone(self):
        r"""clone(TwoFrameLinkerConstraint self) -> TwoFrameLinkerConstraint"""
        return _simulation.TwoFrameLinkerConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TwoFrameLinkerConstraint self) -> std::string const &"""
        return _simulation.TwoFrameLinkerConstraint_getConcreteClassName(self)

    def copyProperty_frames(self, source):
        r""" Frames added to satisfy the sockets of this TwoFrameLinker Component"""
        return _simulation.TwoFrameLinkerConstraint_copyProperty_frames(self, source)

    def get_frames(self, i):
        r"""
        get_frames(TwoFrameLinkerConstraint self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerConstraint_get_frames(self, i)

    def upd_frames(self, i):
        r"""
        upd_frames(TwoFrameLinkerConstraint self, int i) -> PhysicalFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.TwoFrameLinkerConstraint_upd_frames(self, i)

    def set_frames(self, i, value):
        r"""
        set_frames(TwoFrameLinkerConstraint self, int i, PhysicalFrame value)

        Parameters
        ----------
        i: int
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerConstraint_set_frames(self, i, value)

    def append_frames(self, value):
        r"""
        append_frames(TwoFrameLinkerConstraint self, PhysicalFrame value) -> int

        Parameters
        ----------
        value: OpenSim::PhysicalFrame const &

        """
        return _simulation.TwoFrameLinkerConstraint_append_frames(self, value)

    def constructProperty_frames(self):
        r"""constructProperty_frames(TwoFrameLinkerConstraint self)"""
        return _simulation.TwoFrameLinkerConstraint_constructProperty_frames(self)
    PropertyIndex_socket_frame1 = property(_simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame1_get, _simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame1_set, doc=r"""PropertyIndex_socket_frame1 : OpenSim::PropertyIndex""")

    def connectSocket_frame1(self, object):
        r"""
        connectSocket_frame1(TwoFrameLinkerConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerConstraint_connectSocket_frame1(self, object)
    PropertyIndex_socket_frame2 = property(_simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame2_get, _simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame2_set, doc=r"""PropertyIndex_socket_frame2 : OpenSim::PropertyIndex""")

    def connectSocket_frame2(self, object):
        r"""
        connectSocket_frame2(TwoFrameLinkerConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.TwoFrameLinkerConstraint_connectSocket_frame2(self, object)

    def getFrame1(self):
        r"""
        Access the first frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerConstraint_getFrame1(self)

    def getFrame2(self):
        r"""
        Access the second frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerConstraint_getFrame2(self)

    def computeRelativeOffset(self, s):
        r"""
        Compute the relative offset Transform between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerConstraint_computeRelativeOffset(self, s)

    def computeRelativeVelocity(self, s):
        r"""
        Compute the relative spatial velocity between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerConstraint_computeRelativeVelocity(self, s)

    def computeDeflection(self, s):
        r"""
        Compute the deflection (spatial separation) of the two frames connected
               by the TwoFrameLinker. Angular deflections expressed as XYZ body-fixed
               Euler angles of frame2 w.r.t frame1.
               NOTE: When using deflections to compute spatial forces, these forces
                   may not be valid for large deflections, because Euler angles are
                   unable to uniquely distinguish an X rotation angle of +/-180 degs,
                   and subsequent rotations that are +/-90 degs. It is mainly useful
                   for calculating errors for constraints and forces for computing
                   restoration forces.
            :rtype: :py:class:`Vec6`
            :return: dq     Vec6 of (3) angular and (3) translational deflections.
        """
        return _simulation.TwoFrameLinkerConstraint_computeDeflection(self, s)

    def computeDeflectionRate(self, s):
        r"""
        Compute the deflection rate (dqdot) of the two frames connected by
               this TwoFrameLinker component. Angular velocity is expressed as Euler
               (XYZ body-fixed) angle derivatives. Note that the derivatives
               become singular as the second Euler angle approaches 90 degs.
           :rtype: :py:class:`Vec6`
           :return: dqdot  Vec6 of (3) angular and (3) translational deflection rates.
        """
        return _simulation.TwoFrameLinkerConstraint_computeDeflectionRate(self, s)
    __swig_destroy__ = _simulation.delete_TwoFrameLinkerConstraint

# Register TwoFrameLinkerConstraint in _simulation:
_simulation.TwoFrameLinkerConstraint_swigregister(TwoFrameLinkerConstraint)
class FreeJoint(Joint):
    r"""
    A class implementing a Free joint.  The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Free.
    Free joint allows unrestricted motion with three rotations and three translations.
    Rotations are modeled similarly to BallJoint -using quaternions with no
    singularities- while the translational generalized coordinates are XYZ
    Translations along the parent axis. Generalized speeds are equal to the computed
    angular velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation of
    position (:math:`\vec{u} \neq \dot{\vec{q}}`).

    Image: freeJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FreeJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FreeJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FreeJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FreeJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FreeJoint_getClassName()

    def clone(self):
        r"""clone(FreeJoint self) -> FreeJoint"""
        return _simulation.FreeJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FreeJoint self) -> std::string const &"""
        return _simulation.FreeJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.FreeJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.FreeJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.FreeJoint_Coord_Rotation3Z
    r""" 2"""
    Coord_TranslationX = _simulation.FreeJoint_Coord_TranslationX
    r""" 3"""
    Coord_TranslationY = _simulation.FreeJoint_Coord_TranslationY
    r""" 4"""
    Coord_TranslationZ = _simulation.FreeJoint_Coord_TranslationZ
    r""" 5"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.FreeJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.FreeJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(FreeJoint self) -> FreeJoint
        __init__(FreeJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> FreeJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(FreeJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> FreeJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.FreeJoint_swiginit(self, _simulation.new_FreeJoint(*args))
    __swig_destroy__ = _simulation.delete_FreeJoint

# Register FreeJoint in _simulation:
_simulation.FreeJoint_swigregister(FreeJoint)
class CustomJoint(Joint):
    r"""
    A class implementing a custom joint.  The underlying implementation in Simbody
    is a SimTK::MobilizedBody::FunctionBased. Custom joints offer a generic joint
    representation, which can be used to model both conventional (pins, slider,
    universal, etc.) as well as more complex biomechanical joints. The behavior of
    a custom joint is specified by its SpatialTransform. A SpatialTransform is com-
    prised of 6 TransformAxes (3 rotations and 3 translations) that define the
    spatial position of Child in Parent as a function of coordinates. Each transform
    axis has a function of joint coordinates that describes the motion about or along
    the transform axis. The order of the spatial transform is fixed with rotations
    first followed by translations. Subsequently, coupled motion (i.e., describing
    motion of two degrees of freedom as a function of one coordinate) is handled by
    transform axis functions that depend on the same coordinate(s).

    Author: Ajay Seth, Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CustomJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.CustomJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CustomJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.CustomJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.CustomJoint_getClassName()

    def clone(self):
        r"""clone(CustomJoint self) -> CustomJoint"""
        return _simulation.CustomJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CustomJoint self) -> std::string const &"""
        return _simulation.CustomJoint_getConcreteClassName(self)

    def copyProperty_SpatialTransform(self, source):
        r"""
        Spatial transform defining how the child body moves with respect
           to the parent body as a function of the generalized coordinates.
           Motion over 6 (independent) spatial axes must be defined.
        """
        return _simulation.CustomJoint_copyProperty_SpatialTransform(self, source)

    def append_SpatialTransform(self, value):
        r"""
        append_SpatialTransform(CustomJoint self, SpatialTransform value) -> int

        Parameters
        ----------
        value: OpenSim::SpatialTransform const &

        """
        return _simulation.CustomJoint_append_SpatialTransform(self, value)

    def constructProperty_SpatialTransform(self, initValue):
        r"""
        constructProperty_SpatialTransform(CustomJoint self, SpatialTransform initValue)

        Parameters
        ----------
        initValue: OpenSim::SpatialTransform const &

        """
        return _simulation.CustomJoint_constructProperty_SpatialTransform(self, initValue)

    def get_SpatialTransform(self, *args):
        r"""
        get_SpatialTransform(CustomJoint self, int i) -> SpatialTransform

        Parameters
        ----------
        i: int

        get_SpatialTransform(CustomJoint self) -> SpatialTransform
        """
        return _simulation.CustomJoint_get_SpatialTransform(self, *args)

    def upd_SpatialTransform(self, *args):
        r"""
        upd_SpatialTransform(CustomJoint self, int i) -> SpatialTransform

        Parameters
        ----------
        i: int

        upd_SpatialTransform(CustomJoint self) -> SpatialTransform
        """
        return _simulation.CustomJoint_upd_SpatialTransform(self, *args)

    def set_SpatialTransform(self, *args):
        r"""
        set_SpatialTransform(CustomJoint self, int i, SpatialTransform value)

        Parameters
        ----------
        i: int
        value: OpenSim::SpatialTransform const &

        set_SpatialTransform(CustomJoint self, SpatialTransform value)

        Parameters
        ----------
        value: OpenSim::SpatialTransform const &

        """
        return _simulation.CustomJoint_set_SpatialTransform(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor

        |

        *Overload 2:*
        Construct joint with supplied coordinates and transform axes

        |

        *Overload 3:*
        Joint constructor with explicit parent and child offsets in terms of
               their location and orientation.
        """
        _simulation.CustomJoint_swiginit(self, _simulation.new_CustomJoint(*args))

    def getSpatialTransform(self):
        r"""getSpatialTransform(CustomJoint self) -> SpatialTransform"""
        return _simulation.CustomJoint_getSpatialTransform(self)

    def updSpatialTransform(self):
        r"""updSpatialTransform(CustomJoint self) -> SpatialTransform"""
        return _simulation.CustomJoint_updSpatialTransform(self)

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
        """
        return _simulation.CustomJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
        """
        return _simulation.CustomJoint_updCoordinate(self, *args)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(CustomJoint self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.CustomJoint_extendScale(self, s, scaleSet)

    def updateFromXMLNode(self, aNode, versionNumber=-1):
        r""" Override of the default implementation to account for versioning."""
        return _simulation.CustomJoint_updateFromXMLNode(self, aNode, versionNumber)
    __swig_destroy__ = _simulation.delete_CustomJoint

# Register CustomJoint in _simulation:
_simulation.CustomJoint_swigregister(CustomJoint)
class EllipsoidJoint(Joint):
    r"""
    A class implementing a Ellipsoid joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Ellipsoid. An Ellipsoid joint provides three
    mobilities – coordinated rotation and translation along the surface of an ellipsoid
     fixed to the parent body. The ellipsoid surface is determined by an input Vec3 which
    describes the ellipsoid radius. Generalized speeds are equal to the computed angular
    velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation of
    position (:math:`\vec{u} \neq \dot{\vec{q}}`)

    Image: ellipsoid.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> EllipsoidJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.EllipsoidJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(EllipsoidJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.EllipsoidJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.EllipsoidJoint_getClassName()

    def clone(self):
        r"""clone(EllipsoidJoint self) -> EllipsoidJoint"""
        return _simulation.EllipsoidJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(EllipsoidJoint self) -> std::string const &"""
        return _simulation.EllipsoidJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.EllipsoidJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.EllipsoidJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.EllipsoidJoint_Coord_Rotation3Z
    r""" 2"""

    def copyProperty_Appearance(self, source):
        r"""
        copyProperty_Appearance(EllipsoidJoint self, EllipsoidJoint source)

        Parameters
        ----------
        source: OpenSim::EllipsoidJoint::Self const &

        """
        return _simulation.EllipsoidJoint_copyProperty_Appearance(self, source)

    def append_Appearance(self, value):
        r"""
        append_Appearance(EllipsoidJoint self, Appearance value) -> int

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.EllipsoidJoint_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue):
        r"""
        constructProperty_Appearance(EllipsoidJoint self, Appearance initValue)

        Parameters
        ----------
        initValue: OpenSim::Appearance const &

        """
        return _simulation.EllipsoidJoint_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args):
        r"""
        get_Appearance(EllipsoidJoint self, int i) -> Appearance

        Parameters
        ----------
        i: int

        get_Appearance(EllipsoidJoint self) -> Appearance
        """
        return _simulation.EllipsoidJoint_get_Appearance(self, *args)

    def upd_Appearance(self, *args):
        r"""
        upd_Appearance(EllipsoidJoint self, int i) -> Appearance

        Parameters
        ----------
        i: int

        upd_Appearance(EllipsoidJoint self) -> Appearance
        """
        return _simulation.EllipsoidJoint_upd_Appearance(self, *args)

    def set_Appearance(self, *args):
        r"""
        set_Appearance(EllipsoidJoint self, int i, Appearance value)

        Parameters
        ----------
        i: int
        value: OpenSim::Appearance const &

        set_Appearance(EllipsoidJoint self, Appearance value)

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.EllipsoidJoint_set_Appearance(self, *args)

    def copyProperty_radii_x_y_z(self, source):
        r"""
        copyProperty_radii_x_y_z(EllipsoidJoint self, EllipsoidJoint source)

        Parameters
        ----------
        source: OpenSim::EllipsoidJoint::Self const &

        """
        return _simulation.EllipsoidJoint_copyProperty_radii_x_y_z(self, source)

    def append_radii_x_y_z(self, value):
        r"""
        append_radii_x_y_z(EllipsoidJoint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.EllipsoidJoint_append_radii_x_y_z(self, value)

    def constructProperty_radii_x_y_z(self, initValue):
        r"""
        constructProperty_radii_x_y_z(EllipsoidJoint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.EllipsoidJoint_constructProperty_radii_x_y_z(self, initValue)

    def get_radii_x_y_z(self, *args):
        r"""
        get_radii_x_y_z(EllipsoidJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_radii_x_y_z(EllipsoidJoint self) -> Vec3
        """
        return _simulation.EllipsoidJoint_get_radii_x_y_z(self, *args)

    def upd_radii_x_y_z(self, *args):
        r"""
        upd_radii_x_y_z(EllipsoidJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_radii_x_y_z(EllipsoidJoint self) -> Vec3
        """
        return _simulation.EllipsoidJoint_upd_radii_x_y_z(self, *args)

    def set_radii_x_y_z(self, *args):
        r"""
        set_radii_x_y_z(EllipsoidJoint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_radii_x_y_z(EllipsoidJoint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.EllipsoidJoint_set_radii_x_y_z(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience Joint like Constructor

        |

        *Overload 2:*
        Deprecated Joint Constructor
        """
        _simulation.EllipsoidJoint_swiginit(self, _simulation.new_EllipsoidJoint(*args))

    def setEllipsoidRadii(self, radii):
        r"""
        setEllipsoidRadii(EllipsoidJoint self, Vec3 radii)

        Parameters
        ----------
        radii: SimTK::Vec3 const &

        """
        return _simulation.EllipsoidJoint_setEllipsoidRadii(self, radii)

    def setEllipsoidVisible(self, visible):
        r""" Turn on/off the ellipsoid drawn by generateDecorations()."""
        return _simulation.EllipsoidJoint_setEllipsoidVisible(self, visible)

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.EllipsoidJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.EllipsoidJoint_updCoordinate(self, *args)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(EllipsoidJoint self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.EllipsoidJoint_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_EllipsoidJoint

# Register EllipsoidJoint in _simulation:
_simulation.EllipsoidJoint_swigregister(EllipsoidJoint)
class BallJoint(Joint):
    r"""
    A class implementing a Ball joint. The underlying implementation in Simbody is
    SimTK::MobilizedBody::Ball. The Ball joint implements a fixed 1-2-3 (X-Y-Z)
    body-fixed Euler sequence, without translations, for generalized coordinate
    calculation. Ball joint uses quaternions in calculation and are therefore
    singularity-free (unlike GimbalJoint). Generalized speeds are equal to the
    computed angular velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation
    of position (:math:`\vec{u} \neq \dot{\vec{q}}`).

    Image: ballJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BallJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BallJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BallJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BallJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BallJoint_getClassName()

    def clone(self):
        r"""clone(BallJoint self) -> BallJoint"""
        return _simulation.BallJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BallJoint self) -> std::string const &"""
        return _simulation.BallJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.BallJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.BallJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.BallJoint_Coord_Rotation3Z
    r""" 2"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.BallJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.BallJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(BallJoint self) -> BallJoint
        __init__(BallJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> BallJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(BallJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> BallJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.BallJoint_swiginit(self, _simulation.new_BallJoint(*args))
    __swig_destroy__ = _simulation.delete_BallJoint

# Register BallJoint in _simulation:
_simulation.BallJoint_swigregister(BallJoint)
class PinJoint(Joint):
    r"""
    A Class implementing a Pin joint. The underlying implementation in Simbody is a
    SimTK::MobilizedBody::Pin. Pin provides one DOF about the common Z-axis of the
    joint (not body) frames in the parent and child body. If you want rotation about
    a different direction, rotate the joint and body frames such that the z axes
    are in the desired direction.

    Image: pinJoint.gif

     Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PinJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PinJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PinJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PinJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PinJoint_getClassName()

    def clone(self):
        r"""clone(PinJoint self) -> PinJoint"""
        return _simulation.PinJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PinJoint self) -> std::string const &"""
        return _simulation.PinJoint_getConcreteClassName(self)
    Coord_RotationZ = _simulation.PinJoint_Coord_RotationZ
    r""" 0"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PinJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PinJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(PinJoint self) -> PinJoint
        __init__(PinJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> PinJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(PinJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> PinJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.PinJoint_swiginit(self, _simulation.new_PinJoint(*args))
    __swig_destroy__ = _simulation.delete_PinJoint

# Register PinJoint in _simulation:
_simulation.PinJoint_swigregister(PinJoint)
class SliderJoint(Joint):
    r"""
    A class implementing a Slider joint. The underlying implementation in Simbody
    is a SimTK::MobilizedBody::Slider. The Slider provides a single coordinate
    along the common X-axis of the parent and child joint frames.

    Image: sliderJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SliderJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SliderJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SliderJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SliderJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SliderJoint_getClassName()

    def clone(self):
        r"""clone(SliderJoint self) -> SliderJoint"""
        return _simulation.SliderJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SliderJoint self) -> std::string const &"""
        return _simulation.SliderJoint_getConcreteClassName(self)
    Coord_TranslationX = _simulation.SliderJoint_Coord_TranslationX
    r""" 0"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.SliderJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.SliderJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(SliderJoint self) -> SliderJoint
        __init__(SliderJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> SliderJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(SliderJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> SliderJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.SliderJoint_swiginit(self, _simulation.new_SliderJoint(*args))
    __swig_destroy__ = _simulation.delete_SliderJoint

# Register SliderJoint in _simulation:
_simulation.SliderJoint_swigregister(SliderJoint)
class WeldJoint(Joint):
    r"""
    A class implementing a Weld joint. The underlying implementation in Simbody is
    a SimTK::MobilizedBody::Weld. There is no relative motion of bodies joined by
    a weld. Weld joints are often used to create composite bodies from
    smaller simpler bodies. You can also get the reaction force at the weld in the
    usual manner.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WeldJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WeldJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WeldJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WeldJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WeldJoint_getClassName()

    def clone(self):
        r"""clone(WeldJoint self) -> WeldJoint"""
        return _simulation.WeldJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WeldJoint self) -> std::string const &"""
        return _simulation.WeldJoint_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(WeldJoint self) -> WeldJoint
        __init__(WeldJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> WeldJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(WeldJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> WeldJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.WeldJoint_swiginit(self, _simulation.new_WeldJoint(*args))
    __swig_destroy__ = _simulation.delete_WeldJoint

# Register WeldJoint in _simulation:
_simulation.WeldJoint_swigregister(WeldJoint)
class GimbalJoint(Joint):
    r"""
    A class implementing a Gimbal joint. The underlying implementation Simbody is a
    SimTK::MobilizedBody::Gimbal. The opensim Gimbal joint implementation uses a
     X-Y-Z body fixed Euler sequence for generalized coordinates calculation.
    Gimbal joints have a singularity when Y is near :math:`\frac{\pi}{2}`.
    Generalized speeds are equal to the Euler angle derivatives  (:math:`\vec{u} = \dot{\vec{q}}`)

    Image: gimbalJoint.gif

    Author: Tim Dorn
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> GimbalJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.GimbalJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(GimbalJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.GimbalJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.GimbalJoint_getClassName()

    def clone(self):
        r"""clone(GimbalJoint self) -> GimbalJoint"""
        return _simulation.GimbalJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(GimbalJoint self) -> std::string const &"""
        return _simulation.GimbalJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.GimbalJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.GimbalJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.GimbalJoint_Coord_Rotation3Z
    r""" 2"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.GimbalJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.GimbalJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(GimbalJoint self) -> GimbalJoint
        __init__(GimbalJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> GimbalJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(GimbalJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> GimbalJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.GimbalJoint_swiginit(self, _simulation.new_GimbalJoint(*args))
    __swig_destroy__ = _simulation.delete_GimbalJoint

# Register GimbalJoint in _simulation:
_simulation.GimbalJoint_swigregister(GimbalJoint)
class UniversalJoint(Joint):
    r"""
    A class implementing a Universal joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Universal.
    Universal provides two DoF: rotation about the x axis of the joint frames,
    followed by a rotation about the new y axis. The joint is badly behaved when the
    second rotation is near 90 degrees.

    Image: universalJoint.gif

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> UniversalJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.UniversalJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(UniversalJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.UniversalJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.UniversalJoint_getClassName()

    def clone(self):
        r"""clone(UniversalJoint self) -> UniversalJoint"""
        return _simulation.UniversalJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(UniversalJoint self) -> std::string const &"""
        return _simulation.UniversalJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.UniversalJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.UniversalJoint_Coord_Rotation2Y
    r""" 1"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.UniversalJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.UniversalJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(UniversalJoint self) -> UniversalJoint
        __init__(UniversalJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> UniversalJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(UniversalJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> UniversalJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.UniversalJoint_swiginit(self, _simulation.new_UniversalJoint(*args))
    __swig_destroy__ = _simulation.delete_UniversalJoint

# Register UniversalJoint in _simulation:
_simulation.UniversalJoint_swigregister(UniversalJoint)
class PlanarJoint(Joint):
    r"""
    A class implementing a Planar joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Planar. A Planar joint provides three
    ordered mobilities; rotation about Z and translation in X then Y.

    Image: planarJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PlanarJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PlanarJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PlanarJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PlanarJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PlanarJoint_getClassName()

    def clone(self):
        r"""clone(PlanarJoint self) -> PlanarJoint"""
        return _simulation.PlanarJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PlanarJoint self) -> std::string const &"""
        return _simulation.PlanarJoint_getConcreteClassName(self)
    Coord_RotationZ = _simulation.PlanarJoint_Coord_RotationZ
    r""" 0"""
    Coord_TranslationX = _simulation.PlanarJoint_Coord_TranslationX
    r""" 1"""
    Coord_TranslationY = _simulation.PlanarJoint_Coord_TranslationY
    r""" 2"""

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PlanarJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PlanarJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        r"""
        __init__(PlanarJoint self) -> PlanarJoint
        __init__(PlanarJoint self, std::string const & name, PhysicalFrame parent, PhysicalFrame child) -> PlanarJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        child: OpenSim::PhysicalFrame const &

        __init__(PlanarJoint self, std::string const & name, PhysicalFrame parent, Vec3 locationInParent, Vec3 orientationInParent, PhysicalFrame child, Vec3 locationInChild, Vec3 orientationInChild) -> PlanarJoint

        Parameters
        ----------
        name: std::string const &
        parent: OpenSim::PhysicalFrame const &
        locationInParent: SimTK::Vec3 const &
        orientationInParent: SimTK::Vec3 const &
        child: OpenSim::PhysicalFrame const &
        locationInChild: SimTK::Vec3 const &
        orientationInChild: SimTK::Vec3 const &

        """
        _simulation.PlanarJoint_swiginit(self, _simulation.new_PlanarJoint(*args))
    __swig_destroy__ = _simulation.delete_PlanarJoint

# Register PlanarJoint in _simulation:
_simulation.PlanarJoint_swigregister(PlanarJoint)
class ScapulothoracicJoint(Joint):
    r"""
    A class implementing a 4-DOF ScapulothoracicJoint.

    Motion of the scapula is described by an ellipsoid surface fixed to the
    thorax upon which the joint frame of scapul rides. The DOFs are:

    abduction/adduction
        Motion on the surface. described by latitude and longitudinal angles.

    elevation/depression
        Motion on the surface. described by latitude and longitudinal angles.

    upward rotation
        Rotation about the normal to the ellipsoid surface

    winging
        rotation about and axis fixed to the scapula frame. Defaults to
        scapula-y

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ScapulothoracicJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ScapulothoracicJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ScapulothoracicJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ScapulothoracicJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ScapulothoracicJoint_getClassName()

    def clone(self):
        r"""clone(ScapulothoracicJoint self) -> ScapulothoracicJoint"""
        return _simulation.ScapulothoracicJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ScapulothoracicJoint self) -> std::string const &"""
        return _simulation.ScapulothoracicJoint_getConcreteClassName(self)

    def copyProperty_thoracic_ellipsoid_radii_x_y_z(self, source):
        r"""
        copyProperty_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, ScapulothoracicJoint source)

        Parameters
        ----------
        source: OpenSim::ScapulothoracicJoint::Self const &

        """
        return _simulation.ScapulothoracicJoint_copyProperty_thoracic_ellipsoid_radii_x_y_z(self, source)

    def append_thoracic_ellipsoid_radii_x_y_z(self, value):
        r"""
        append_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ScapulothoracicJoint_append_thoracic_ellipsoid_radii_x_y_z(self, value)

    def constructProperty_thoracic_ellipsoid_radii_x_y_z(self, initValue):
        r"""
        constructProperty_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ScapulothoracicJoint_constructProperty_thoracic_ellipsoid_radii_x_y_z(self, initValue)

    def get_thoracic_ellipsoid_radii_x_y_z(self, *args):
        r"""
        get_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self) -> Vec3
        """
        return _simulation.ScapulothoracicJoint_get_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def upd_thoracic_ellipsoid_radii_x_y_z(self, *args):
        r"""
        upd_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self) -> Vec3
        """
        return _simulation.ScapulothoracicJoint_upd_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def set_thoracic_ellipsoid_radii_x_y_z(self, *args):
        r"""
        set_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_thoracic_ellipsoid_radii_x_y_z(ScapulothoracicJoint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ScapulothoracicJoint_set_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def copyProperty_scapula_winging_axis_origin(self, source):
        r"""
        copyProperty_scapula_winging_axis_origin(ScapulothoracicJoint self, ScapulothoracicJoint source)

        Parameters
        ----------
        source: OpenSim::ScapulothoracicJoint::Self const &

        """
        return _simulation.ScapulothoracicJoint_copyProperty_scapula_winging_axis_origin(self, source)

    def get_scapula_winging_axis_origin(self, i):
        r"""
        get_scapula_winging_axis_origin(ScapulothoracicJoint self, int i) -> double const &

        Parameters
        ----------
        i: int

        """
        return _simulation.ScapulothoracicJoint_get_scapula_winging_axis_origin(self, i)

    def upd_scapula_winging_axis_origin(self, i):
        r"""
        upd_scapula_winging_axis_origin(ScapulothoracicJoint self, int i) -> double &

        Parameters
        ----------
        i: int

        """
        return _simulation.ScapulothoracicJoint_upd_scapula_winging_axis_origin(self, i)

    def set_scapula_winging_axis_origin(self, i, value):
        r"""
        set_scapula_winging_axis_origin(ScapulothoracicJoint self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        """
        return _simulation.ScapulothoracicJoint_set_scapula_winging_axis_origin(self, i, value)

    def append_scapula_winging_axis_origin(self, value):
        r"""
        append_scapula_winging_axis_origin(ScapulothoracicJoint self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScapulothoracicJoint_append_scapula_winging_axis_origin(self, value)

    def copyProperty_scapula_winging_axis_direction(self, source):
        r"""
        copyProperty_scapula_winging_axis_direction(ScapulothoracicJoint self, ScapulothoracicJoint source)

        Parameters
        ----------
        source: OpenSim::ScapulothoracicJoint::Self const &

        """
        return _simulation.ScapulothoracicJoint_copyProperty_scapula_winging_axis_direction(self, source)

    def append_scapula_winging_axis_direction(self, value):
        r"""
        append_scapula_winging_axis_direction(ScapulothoracicJoint self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScapulothoracicJoint_append_scapula_winging_axis_direction(self, value)

    def constructProperty_scapula_winging_axis_direction(self, initValue):
        r"""
        constructProperty_scapula_winging_axis_direction(ScapulothoracicJoint self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ScapulothoracicJoint_constructProperty_scapula_winging_axis_direction(self, initValue)

    def get_scapula_winging_axis_direction(self, *args):
        r"""
        get_scapula_winging_axis_direction(ScapulothoracicJoint self, int i) -> double const

        Parameters
        ----------
        i: int

        get_scapula_winging_axis_direction(ScapulothoracicJoint self) -> double const &
        """
        return _simulation.ScapulothoracicJoint_get_scapula_winging_axis_direction(self, *args)

    def upd_scapula_winging_axis_direction(self, *args):
        r"""
        upd_scapula_winging_axis_direction(ScapulothoracicJoint self, int i) -> double

        Parameters
        ----------
        i: int

        upd_scapula_winging_axis_direction(ScapulothoracicJoint self) -> double &
        """
        return _simulation.ScapulothoracicJoint_upd_scapula_winging_axis_direction(self, *args)

    def set_scapula_winging_axis_direction(self, *args):
        r"""
        set_scapula_winging_axis_direction(ScapulothoracicJoint self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_scapula_winging_axis_direction(ScapulothoracicJoint self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScapulothoracicJoint_set_scapula_winging_axis_direction(self, *args)
    Coord_Abduction = _simulation.ScapulothoracicJoint_Coord_Abduction
    
    Coord_Elevation = _simulation.ScapulothoracicJoint_Coord_Elevation
    
    Coord_UpwardRotation = _simulation.ScapulothoracicJoint_Coord_UpwardRotation
    
    Coord_Winging = _simulation.ScapulothoracicJoint_Coord_Winging
    

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default contructor

        |

        *Overload 2:*
        Convenience Joint-like Constructor

        |

        *Overload 3:*
        Convenience constructor
        """
        _simulation.ScapulothoracicJoint_swiginit(self, _simulation.new_ScapulothoracicJoint(*args))

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
         Convenience method to get a const reference to the Coordinate associated
                with a single-degree-of-freedom Joint. If the Joint has more than one
                Coordinate, you must use get_coordinates() or provide the appropriate
                argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*

        Get a const reference to a Coordinate associated with this Joint.
        See also: Coord
        """
        return _simulation.ScapulothoracicJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
         Convenience method to get a writable reference to the Coordinate
                associated with a single-degree-of-freedom Joint. If the Joint has more
                than one Coordinate, you must use upd_coordinates() or provide the
                appropriate argument to the updCoordinate() method defined in the
                derived class.

        |

        *Overload 2:*

        Get a writable reference to a Coordinate associated with this Joint.
        See also: Coord
        """
        return _simulation.ScapulothoracicJoint_updCoordinate(self, *args)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(ScapulothoracicJoint self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.ScapulothoracicJoint_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_ScapulothoracicJoint

# Register ScapulothoracicJoint in _simulation:
_simulation.ScapulothoracicJoint_swigregister(ScapulothoracicJoint)
class ConstantCurvatureJoint(Joint):
    r"""
    A class implementing a ConstantCurvatureJoint joint. A ConstantCurvatureJoint
    connects two bodies by a line segment of a fixed length. The endpoint of the
    ConstantCurvatureJoint can be rotated by euler angles, and the offset is
    computed as a function of the euler angles and the fixed length of the line
    segment.

    This joint was originally designed as a lightweight way to model spine segments,
    which can be approximated without individual link segments be instead using 3 of
    these joints in series.

    Author: Keenon Werling
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ConstantCurvatureJoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ConstantCurvatureJoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ConstantCurvatureJoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ConstantCurvatureJoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ConstantCurvatureJoint_getClassName()

    def clone(self):
        r"""clone(ConstantCurvatureJoint self) -> ConstantCurvatureJoint"""
        return _simulation.ConstantCurvatureJoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ConstantCurvatureJoint self) -> std::string const &"""
        return _simulation.ConstantCurvatureJoint_getConcreteClassName(self)
    Coord_RotationX = _simulation.ConstantCurvatureJoint_Coord_RotationX
    r""" 0"""
    Coord_RotationZ = _simulation.ConstantCurvatureJoint_Coord_RotationZ
    r""" 1"""
    Coord_RotationY = _simulation.ConstantCurvatureJoint_Coord_RotationY
    r""" 2"""

    def copyProperty_neutral_angle_x_z_y(self, source):
        r"""
        copyProperty_neutral_angle_x_z_y(ConstantCurvatureJoint self, ConstantCurvatureJoint source)

        Parameters
        ----------
        source: OpenSim::ConstantCurvatureJoint::Self const &

        """
        return _simulation.ConstantCurvatureJoint_copyProperty_neutral_angle_x_z_y(self, source)

    def append_neutral_angle_x_z_y(self, value):
        r"""
        append_neutral_angle_x_z_y(ConstantCurvatureJoint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantCurvatureJoint_append_neutral_angle_x_z_y(self, value)

    def constructProperty_neutral_angle_x_z_y(self, initValue):
        r"""
        constructProperty_neutral_angle_x_z_y(ConstantCurvatureJoint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ConstantCurvatureJoint_constructProperty_neutral_angle_x_z_y(self, initValue)

    def get_neutral_angle_x_z_y(self, *args):
        r"""
        get_neutral_angle_x_z_y(ConstantCurvatureJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_neutral_angle_x_z_y(ConstantCurvatureJoint self) -> Vec3
        """
        return _simulation.ConstantCurvatureJoint_get_neutral_angle_x_z_y(self, *args)

    def upd_neutral_angle_x_z_y(self, *args):
        r"""
        upd_neutral_angle_x_z_y(ConstantCurvatureJoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_neutral_angle_x_z_y(ConstantCurvatureJoint self) -> Vec3
        """
        return _simulation.ConstantCurvatureJoint_upd_neutral_angle_x_z_y(self, *args)

    def set_neutral_angle_x_z_y(self, *args):
        r"""
        set_neutral_angle_x_z_y(ConstantCurvatureJoint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_neutral_angle_x_z_y(ConstantCurvatureJoint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantCurvatureJoint_set_neutral_angle_x_z_y(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(ConstantCurvatureJoint self, ConstantCurvatureJoint source)

        Parameters
        ----------
        source: OpenSim::ConstantCurvatureJoint::Self const &

        """
        return _simulation.ConstantCurvatureJoint_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(ConstantCurvatureJoint self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ConstantCurvatureJoint_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(ConstantCurvatureJoint self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ConstantCurvatureJoint_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(ConstantCurvatureJoint self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(ConstantCurvatureJoint self) -> double const &
        """
        return _simulation.ConstantCurvatureJoint_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(ConstantCurvatureJoint self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(ConstantCurvatureJoint self) -> double &
        """
        return _simulation.ConstantCurvatureJoint_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(ConstantCurvatureJoint self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(ConstantCurvatureJoint self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ConstantCurvatureJoint_set_length(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience Joint like Constructor

        |

        *Overload 2:*
        Deprecated Joint Constructor
               NOTE(keenon): This constructor seems necessary to compile, but it has a
               comment marking it deprecated in the EllipsoidJoint, so I copied that
               comment over here as well.
        """
        _simulation.ConstantCurvatureJoint_swiginit(self, _simulation.new_ConstantCurvatureJoint(*args))

    def setNeutralAngleXZY(self, neutralAngleXZY):
        r"""
        setNeutralAngleXZY(ConstantCurvatureJoint self, Vec3 neutralAngleXZY)

        Parameters
        ----------
        neutralAngleXZY: SimTK::Vec3 const &

        """
        return _simulation.ConstantCurvatureJoint_setNeutralAngleXZY(self, neutralAngleXZY)

    def setLength(self, length):
        r"""
        setLength(ConstantCurvatureJoint self, double const length)

        Parameters
        ----------
        length: double const

        """
        return _simulation.ConstantCurvatureJoint_setLength(self, length)

    def getCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.ConstantCurvatureJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args):
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.ConstantCurvatureJoint_updCoordinate(self, *args)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(ConstantCurvatureJoint self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.ConstantCurvatureJoint_extendScale(self, s, scaleSet)

    @staticmethod
    def clamp(q):
        r"""
         This method will clamp an input set of joint angles q to the limits of
        the joint, and return the clamped vector.
        """
        return _simulation.ConstantCurvatureJoint_clamp(q)

    @staticmethod
    def eulerXZYToMatrix(_angle):
        r"""
         This method will convert a vector of X,Z,Y rotations into the
        corresponding SO3 rotation matrix.
        """
        return _simulation.ConstantCurvatureJoint_eulerXZYToMatrix(_angle)

    @staticmethod
    def eulerXZYToMatrixGrad(_angle, index):
        r"""
         This method will convert an SO3 rotation matrix into a corresponding
        vector of X,Z,Y rotations.
        """
        return _simulation.ConstantCurvatureJoint_eulerXZYToMatrixGrad(_angle, index)

    @staticmethod
    def getEulerJacobian(q):
        r"""
         This method will return the Jacobian of a pure Euler joint (following
        the XZY convention), where each column gives the derivative of the
        spatial (SE3) coordinates for the joint transform wrt one degree of
        freedom of the joint (so there are 3, and each is of dimension 6).
        """
        return _simulation.ConstantCurvatureJoint_getEulerJacobian(q)

    @staticmethod
    def getEulerJacobianDerivWrtPos(q, index):
        r"""
         This method will return the derivative of the matrix returned by
        getEulerJacobian, with respect to changes to the `index` DOF of the
        joint. This is the same shape as the original matrix, because we take
        the derivative of every entry of the matrix separately.
        """
        return _simulation.ConstantCurvatureJoint_getEulerJacobianDerivWrtPos(q, index)

    @staticmethod
    def getConstantCurveJacobian(pos, d):
        r"""
         This is much like getEulerJacobian(), because the rotational component
        is exactly the same, but the translational component is now non-zero.
        This takes as input the length of the line segment, `d`.
        """
        return _simulation.ConstantCurvatureJoint_getConstantCurveJacobian(pos, d)

    @staticmethod
    def getConstantCurveJacobianDerivWrtPosition(pos, d, index):
        r"""
         This method will return the derivative of the matrix returned by
        getConstantCurveJacobian, with respect to changes to the `index` DOF of
        the joint. This is the same shape as the original matrix, because we
        take the derivative of every entry of the matrix separately.
        """
        return _simulation.ConstantCurvatureJoint_getConstantCurveJacobianDerivWrtPosition(pos, d, index)

    @staticmethod
    def getConstantCurveJacobianDerivWrtTime(pos, dPos, d):
        r"""
         This method will return the derivative of the matrix returned by
        getConstantCurveJacobian, with respect to time (changes to every element
        in `pos` at rate `dPos`). This is the same shape as the original matrix,
        because we take the derivative of every entry of the matrix separately.
        """
        return _simulation.ConstantCurvatureJoint_getConstantCurveJacobianDerivWrtTime(pos, dPos, d)

    @staticmethod
    def getTransform(pos, d):
        r"""
         This computes a transform for a given DOF position (XZY euler rotation)
        and line segment length.
        """
        return _simulation.ConstantCurvatureJoint_getTransform(pos, d)
    __swig_destroy__ = _simulation.delete_ConstantCurvatureJoint

# Register ConstantCurvatureJoint in _simulation:
_simulation.ConstantCurvatureJoint_swigregister(ConstantCurvatureJoint)
class WeldConstraint(TwoFrameLinkerConstraint):
    r"""
    A class implementing a Weld Constraint. A WeldConstraint eliminates up to
    6 dofs of a model by fixing two PhysicalFrames together at their origins
    aligning their axes.  PhysicalFrames are generally Ground, Body, or
    PhysicalOffsetFrame attached to a PhysicalFrame.
    The underlying Constraint in Simbody is a SimTK::Constraint::Weld.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WeldConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WeldConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WeldConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WeldConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WeldConstraint_getClassName()

    def clone(self):
        r"""clone(WeldConstraint self) -> WeldConstraint"""
        return _simulation.WeldConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WeldConstraint self) -> std::string const &"""
        return _simulation.WeldConstraint_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor. Create an unnamed WeldConstraint with frame
               sockets that are unsatisfied.

        |

        *Overload 2:*
        Convenience Constructor.
           Create a WeldConstraint between two PhysicalFrames, frame1 and frame2.
           :type name: string, in
           :param name:         the name of this WeldConstraint
           :type frame1Name: string, in
           :param frame1Name:   the name of the first PhysicalFrame being constrained
           :type frame2Name: string, in
           :param frame2Name:   the name of the second PhysicalFrame being constrained

        |

        *Overload 3:*
        Backwards compatible Convenience Constructor
           Construct a WeldConstraint where the weld frames are specified in terms of their
           location and orientation in their respective PhysicalFrames.

           :type name: string, in
           :param name:             the name of this WeldConstraint
           :type frame1: :py:class:`PhysicalFrame`, in
           :param frame1:           the first PhysicalFrame that the weld constrains
           :type locationInFrame1: :py:class:`Vec3`, in
           :param locationInFrame1:    Vec3 of the location of the weld in the first frame
           :type orientationInFrame1: :py:class:`Vec3`, in
           :param orientationInFrame1: Vec3 of the XYZ body-fixed Euler angles of the
                                              weld frame orientation in frame 1.
           :type frame2: :py:class:`PhysicalFrame`, in
           :param frame2:               the second PhysicalFrame that the weld constrains
           :type locationInFrame2: :py:class:`Vec3`, in
           :param locationInFrame2:    Vec3 of the location of the weld in the second frame
           :type orientationInFrame2: :py:class:`Vec3`, in
           :param orientationInFrame2: Vec3 of the XYZ body-fixed Euler angles
                                              of the weld frame orientation in frame2.

        |

        *Overload 4:*
        Convenience Constructor
           Construct a WeldConstraint where the weld frames are specified in terms of their
           transforms in their respective PhysicalFrames.

           :type name: string, in
           :param name:         the name of this WeldConstraint
           :type frame1: :py:class:`PhysicalFrame`, in
           :param frame1:       the first PhysicalFrame that the weld constrains
           :type transformInFrame1: :py:class:`Transform`, in
           :param transformInFrame1:    Transform of the weld in the first frame
           :type frame2: :py:class:`PhysicalFrame`, in
           :param frame2:       the second PhysicalFrame that the weld constrains
           :type transformInFrame2: :py:class:`Transform`, in
           :param transformInFrame2:    Transform of the weld in the second frame
        """
        _simulation.WeldConstraint_swiginit(self, _simulation.new_WeldConstraint(*args))
    __swig_destroy__ = _simulation.delete_WeldConstraint

    def setContactPointForInducedAccelerations(self, s, point):
        r"""
        Advanced Method for computing induced accelerations given the constraint
               applied at the point of contact specified.
        """
        return _simulation.WeldConstraint_setContactPointForInducedAccelerations(self, s, point)

# Register WeldConstraint in _simulation:
_simulation.WeldConstraint_swigregister(WeldConstraint)
class PointConstraint(Constraint):
    r"""
    A class implementing a Point Constraint. The constraint keeps two points,
    one on each of two separate PhysicalFrame%s, coincident and free to rotate
    about that point.

    The underlying SimTK::Constraint in Simbody is a SimTK::Constraint::Point.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PointConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PointConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PointConstraint_getClassName()

    def clone(self):
        r"""clone(PointConstraint self) -> PointConstraint"""
        return _simulation.PointConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointConstraint self) -> std::string const &"""
        return _simulation.PointConstraint_getConcreteClassName(self)

    def copyProperty_location_body_1(self, source):
        r"""
        copyProperty_location_body_1(PointConstraint self, PointConstraint source)

        Parameters
        ----------
        source: OpenSim::PointConstraint::Self const &

        """
        return _simulation.PointConstraint_copyProperty_location_body_1(self, source)

    def append_location_body_1(self, value):
        r"""
        append_location_body_1(PointConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_append_location_body_1(self, value)

    def constructProperty_location_body_1(self, initValue):
        r"""
        constructProperty_location_body_1(PointConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_constructProperty_location_body_1(self, initValue)

    def get_location_body_1(self, *args):
        r"""
        get_location_body_1(PointConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location_body_1(PointConstraint self) -> Vec3
        """
        return _simulation.PointConstraint_get_location_body_1(self, *args)

    def upd_location_body_1(self, *args):
        r"""
        upd_location_body_1(PointConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location_body_1(PointConstraint self) -> Vec3
        """
        return _simulation.PointConstraint_upd_location_body_1(self, *args)

    def set_location_body_1(self, *args):
        r"""
        set_location_body_1(PointConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location_body_1(PointConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_set_location_body_1(self, *args)

    def copyProperty_location_body_2(self, source):
        r"""
        copyProperty_location_body_2(PointConstraint self, PointConstraint source)

        Parameters
        ----------
        source: OpenSim::PointConstraint::Self const &

        """
        return _simulation.PointConstraint_copyProperty_location_body_2(self, source)

    def append_location_body_2(self, value):
        r"""
        append_location_body_2(PointConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_append_location_body_2(self, value)

    def constructProperty_location_body_2(self, initValue):
        r"""
        constructProperty_location_body_2(PointConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_constructProperty_location_body_2(self, initValue)

    def get_location_body_2(self, *args):
        r"""
        get_location_body_2(PointConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location_body_2(PointConstraint self) -> Vec3
        """
        return _simulation.PointConstraint_get_location_body_2(self, *args)

    def upd_location_body_2(self, *args):
        r"""
        upd_location_body_2(PointConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location_body_2(PointConstraint self) -> Vec3
        """
        return _simulation.PointConstraint_upd_location_body_2(self, *args)

    def set_location_body_2(self, *args):
        r"""
        set_location_body_2(PointConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location_body_2(PointConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointConstraint_set_location_body_2(self, *args)
    PropertyIndex_socket_body_1 = property(_simulation.PointConstraint_PropertyIndex_socket_body_1_get, _simulation.PointConstraint_PropertyIndex_socket_body_1_set, doc=r"""PropertyIndex_socket_body_1 : OpenSim::PropertyIndex""")

    def connectSocket_body_1(self, object):
        r"""
        connectSocket_body_1(PointConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointConstraint_connectSocket_body_1(self, object)
    PropertyIndex_socket_body_2 = property(_simulation.PointConstraint_PropertyIndex_socket_body_2_get, _simulation.PointConstraint_PropertyIndex_socket_body_2_set, doc=r"""PropertyIndex_socket_body_2 : OpenSim::PropertyIndex""")

    def connectSocket_body_2(self, object):
        r"""
        connectSocket_body_2(PointConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointConstraint_connectSocket_body_2(self, object)

    def __init__(self, *args):
        r"""
        Convenience Constructor.

        :type body1: :py:class:`PhysicalFrame`
        :param body1:          first PhysicalFrame connected by the constraint
        :type locationBody1: :py:class:`Vec3`
        :param locationBody1:  point fixed on body1 where the constraint is applied
        :type body2: :py:class:`PhysicalFrame`
        :param body2:          second PhysicalFrame connected by the constraint
        :type locationBody2: :py:class:`Vec3`
        :param locationBody2:: point fixed on body2 where the constraint is applied
        """
        _simulation.PointConstraint_swiginit(self, _simulation.new_PointConstraint(*args))
    __swig_destroy__ = _simulation.delete_PointConstraint

    def setBody1ByName(self, aBodyName):
        r"""
        setBody1ByName(PointConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.PointConstraint_setBody1ByName(self, aBodyName)

    def setBody1PointLocation(self, location):
        r"""
        setBody1PointLocation(PointConstraint self, Vec3 location)

        Parameters
        ----------
        location: SimTK::Vec3

        """
        return _simulation.PointConstraint_setBody1PointLocation(self, location)

    def setBody2ByName(self, aBodyName):
        r"""
        setBody2ByName(PointConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.PointConstraint_setBody2ByName(self, aBodyName)

    def setBody2PointLocation(self, location):
        r"""
        setBody2PointLocation(PointConstraint self, Vec3 location)

        Parameters
        ----------
        location: SimTK::Vec3

        """
        return _simulation.PointConstraint_setBody2PointLocation(self, location)

    def setContactPointForInducedAccelerations(self, s, point):
        r"""
         Method to set point location of contact during an induced acceleration
        analysis
        """
        return _simulation.PointConstraint_setContactPointForInducedAccelerations(self, s, point)

# Register PointConstraint in _simulation:
_simulation.PointConstraint_swigregister(PointConstraint)
class ConstantDistanceConstraint(Constraint):
    r"""
    A class implementing a constraint that maintains a constant distance between
    two points on separate PhysicalFrames.
    The underlying SimTK::Constraint in Simbody is a SimTK::Constraint::Rod.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ConstantDistanceConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ConstantDistanceConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ConstantDistanceConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ConstantDistanceConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ConstantDistanceConstraint_getClassName()

    def clone(self):
        r"""clone(ConstantDistanceConstraint self) -> ConstantDistanceConstraint"""
        return _simulation.ConstantDistanceConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ConstantDistanceConstraint self) -> std::string const &"""
        return _simulation.ConstantDistanceConstraint_getConcreteClassName(self)

    def copyProperty_location_body_1(self, source):
        r"""
        copyProperty_location_body_1(ConstantDistanceConstraint self, ConstantDistanceConstraint source)

        Parameters
        ----------
        source: OpenSim::ConstantDistanceConstraint::Self const &

        """
        return _simulation.ConstantDistanceConstraint_copyProperty_location_body_1(self, source)

    def append_location_body_1(self, value):
        r"""
        append_location_body_1(ConstantDistanceConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_append_location_body_1(self, value)

    def constructProperty_location_body_1(self, initValue):
        r"""
        constructProperty_location_body_1(ConstantDistanceConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_constructProperty_location_body_1(self, initValue)

    def get_location_body_1(self, *args):
        r"""
        get_location_body_1(ConstantDistanceConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location_body_1(ConstantDistanceConstraint self) -> Vec3
        """
        return _simulation.ConstantDistanceConstraint_get_location_body_1(self, *args)

    def upd_location_body_1(self, *args):
        r"""
        upd_location_body_1(ConstantDistanceConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location_body_1(ConstantDistanceConstraint self) -> Vec3
        """
        return _simulation.ConstantDistanceConstraint_upd_location_body_1(self, *args)

    def set_location_body_1(self, *args):
        r"""
        set_location_body_1(ConstantDistanceConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location_body_1(ConstantDistanceConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_set_location_body_1(self, *args)

    def copyProperty_location_body_2(self, source):
        r"""
        copyProperty_location_body_2(ConstantDistanceConstraint self, ConstantDistanceConstraint source)

        Parameters
        ----------
        source: OpenSim::ConstantDistanceConstraint::Self const &

        """
        return _simulation.ConstantDistanceConstraint_copyProperty_location_body_2(self, source)

    def append_location_body_2(self, value):
        r"""
        append_location_body_2(ConstantDistanceConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_append_location_body_2(self, value)

    def constructProperty_location_body_2(self, initValue):
        r"""
        constructProperty_location_body_2(ConstantDistanceConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_constructProperty_location_body_2(self, initValue)

    def get_location_body_2(self, *args):
        r"""
        get_location_body_2(ConstantDistanceConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location_body_2(ConstantDistanceConstraint self) -> Vec3
        """
        return _simulation.ConstantDistanceConstraint_get_location_body_2(self, *args)

    def upd_location_body_2(self, *args):
        r"""
        upd_location_body_2(ConstantDistanceConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location_body_2(ConstantDistanceConstraint self) -> Vec3
        """
        return _simulation.ConstantDistanceConstraint_upd_location_body_2(self, *args)

    def set_location_body_2(self, *args):
        r"""
        set_location_body_2(ConstantDistanceConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location_body_2(ConstantDistanceConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ConstantDistanceConstraint_set_location_body_2(self, *args)

    def copyProperty_constant_distance(self, source):
        r"""
        copyProperty_constant_distance(ConstantDistanceConstraint self, ConstantDistanceConstraint source)

        Parameters
        ----------
        source: OpenSim::ConstantDistanceConstraint::Self const &

        """
        return _simulation.ConstantDistanceConstraint_copyProperty_constant_distance(self, source)

    def append_constant_distance(self, value):
        r"""
        append_constant_distance(ConstantDistanceConstraint self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ConstantDistanceConstraint_append_constant_distance(self, value)

    def constructProperty_constant_distance(self, initValue):
        r"""
        constructProperty_constant_distance(ConstantDistanceConstraint self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ConstantDistanceConstraint_constructProperty_constant_distance(self, initValue)

    def get_constant_distance(self, *args):
        r"""
        get_constant_distance(ConstantDistanceConstraint self, int i) -> double const

        Parameters
        ----------
        i: int

        get_constant_distance(ConstantDistanceConstraint self) -> double const &
        """
        return _simulation.ConstantDistanceConstraint_get_constant_distance(self, *args)

    def upd_constant_distance(self, *args):
        r"""
        upd_constant_distance(ConstantDistanceConstraint self, int i) -> double

        Parameters
        ----------
        i: int

        upd_constant_distance(ConstantDistanceConstraint self) -> double &
        """
        return _simulation.ConstantDistanceConstraint_upd_constant_distance(self, *args)

    def set_constant_distance(self, *args):
        r"""
        set_constant_distance(ConstantDistanceConstraint self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_constant_distance(ConstantDistanceConstraint self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ConstantDistanceConstraint_set_constant_distance(self, *args)
    PropertyIndex_socket_body_1 = property(_simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_1_get, _simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_1_set, doc=r"""PropertyIndex_socket_body_1 : OpenSim::PropertyIndex""")

    def connectSocket_body_1(self, object):
        r"""
        connectSocket_body_1(ConstantDistanceConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.ConstantDistanceConstraint_connectSocket_body_1(self, object)
    PropertyIndex_socket_body_2 = property(_simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_2_get, _simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_2_set, doc=r"""PropertyIndex_socket_body_2 : OpenSim::PropertyIndex""")

    def connectSocket_body_2(self, object):
        r"""
        connectSocket_body_2(ConstantDistanceConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.ConstantDistanceConstraint_connectSocket_body_2(self, object)

    def __init__(self, *args):
        r"""
        Convenience Constructor.

        :type body1: :py:class:`PhysicalFrame`
        :param body1:          first PhysicalFrame connected by the constraint
        :type locationBody1: :py:class:`Vec3`
        :param locationBody1:  point fixed on body1 where the constraint is applied
        :type body2: :py:class:`PhysicalFrame`
        :param body2:          second PhysicalFrame connected by the constraint
        :type locationBody2: :py:class:`Vec3`
        :param locationBody2:: point fixed on body2 where the constraint is applied
        :type distance: float
        :param distance:       nonzero fixed distance between the points
        """
        _simulation.ConstantDistanceConstraint_swiginit(self, _simulation.new_ConstantDistanceConstraint(*args))
    __swig_destroy__ = _simulation.delete_ConstantDistanceConstraint

    def getBody1(self):
        r"""
        The Physical frames that the constraint is connected to are
               accessible after connectToModel() has been called on the Model.
        """
        return _simulation.ConstantDistanceConstraint_getBody1(self)

    def getBody2(self):
        r"""getBody2(ConstantDistanceConstraint self) -> PhysicalFrame"""
        return _simulation.ConstantDistanceConstraint_getBody2(self)

    def setBody1ByName(self, aBodyName):
        r"""
        setBody1ByName(ConstantDistanceConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.ConstantDistanceConstraint_setBody1ByName(self, aBodyName)

    def setBody1PointLocation(self, location):
        r"""
        setBody1PointLocation(ConstantDistanceConstraint self, Vec3 location)

        Parameters
        ----------
        location: SimTK::Vec3

        """
        return _simulation.ConstantDistanceConstraint_setBody1PointLocation(self, location)

    def setBody2ByName(self, aBodyName):
        r"""
        setBody2ByName(ConstantDistanceConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.ConstantDistanceConstraint_setBody2ByName(self, aBodyName)

    def setBody2PointLocation(self, location):
        r"""
        setBody2PointLocation(ConstantDistanceConstraint self, Vec3 location)

        Parameters
        ----------
        location: SimTK::Vec3

        """
        return _simulation.ConstantDistanceConstraint_setBody2PointLocation(self, location)

    def setConstantDistance(self, distance):
        r"""
        setConstantDistance(ConstantDistanceConstraint self, double distance)

        Parameters
        ----------
        distance: double

        """
        return _simulation.ConstantDistanceConstraint_setConstantDistance(self, distance)

# Register ConstantDistanceConstraint in _simulation:
_simulation.ConstantDistanceConstraint_swigregister(ConstantDistanceConstraint)
class CoordinateCouplerConstraint(Constraint):
    r"""Proxy of C++ OpenSim::CoordinateCouplerConstraint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CoordinateCouplerConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.CoordinateCouplerConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CoordinateCouplerConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.CoordinateCouplerConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.CoordinateCouplerConstraint_getClassName()

    def clone(self):
        r"""clone(CoordinateCouplerConstraint self) -> CoordinateCouplerConstraint"""
        return _simulation.CoordinateCouplerConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CoordinateCouplerConstraint self) -> std::string const &"""
        return _simulation.CoordinateCouplerConstraint_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(CoordinateCouplerConstraint self) -> CoordinateCouplerConstraint"""
        _simulation.CoordinateCouplerConstraint_swiginit(self, _simulation.new_CoordinateCouplerConstraint())
    __swig_destroy__ = _simulation.delete_CoordinateCouplerConstraint

    def setIndependentCoordinateNames(self, aCoordNames):
        r"""
        Access the list of names of the right hand side (independent) coordinates.
               Note the constraint function, must be able to handle multiple
               coordinate values if more than one coordinate name is provided.
        """
        return _simulation.CoordinateCouplerConstraint_setIndependentCoordinateNames(self, aCoordNames)

    def getIndependentCoordinateNames(self):
        r"""getIndependentCoordinateNames(CoordinateCouplerConstraint self) -> ArrayStr"""
        return _simulation.CoordinateCouplerConstraint_getIndependentCoordinateNames(self)

    def setDependentCoordinateName(self, aCoordName):
        r"""
        setDependentCoordinateName(CoordinateCouplerConstraint self, std::string const & aCoordName)

        Parameters
        ----------
        aCoordName: std::string const &

        """
        return _simulation.CoordinateCouplerConstraint_setDependentCoordinateName(self, aCoordName)

    def getDependentCoordinateName(self):
        r"""getDependentCoordinateName(CoordinateCouplerConstraint self) -> std::string const &"""
        return _simulation.CoordinateCouplerConstraint_getDependentCoordinateName(self)

    def getFunction(self):
        r"""getFunction(CoordinateCouplerConstraint self) -> Function"""
        return _simulation.CoordinateCouplerConstraint_getFunction(self)

    def setFunction(self, *args):
        r"""
        setFunction(CoordinateCouplerConstraint self, Function aFunction)

        Parameters
        ----------
        aFunction: OpenSim::Function const &

        setFunction(CoordinateCouplerConstraint self, Function aFunction)

        Parameters
        ----------
        aFunction: OpenSim::Function *

        """
        return _simulation.CoordinateCouplerConstraint_setFunction(self, *args)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the CoordinateCouplerConstraint using the scale factors assigned
               to the Body associated with the CoordinateCouplerConstraint's dependent
               coordinate. Scaling is performed only if the dependent coordinate is a
               translation.
        """
        return _simulation.CoordinateCouplerConstraint_extendScale(self, s, scaleSet)

# Register CoordinateCouplerConstraint in _simulation:
_simulation.CoordinateCouplerConstraint_swigregister(CoordinateCouplerConstraint)
class PointOnLineConstraint(Constraint):
    r"""
    A class implementing a Point On Line Constraint.  The underlying Constraint
    in Simbody is a SimTK::Constraint::PointOnLine.

    Author: Samuel Hamner
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointOnLineConstraint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PointOnLineConstraint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointOnLineConstraint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PointOnLineConstraint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PointOnLineConstraint_getClassName()

    def clone(self):
        r"""clone(PointOnLineConstraint self) -> PointOnLineConstraint"""
        return _simulation.PointOnLineConstraint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointOnLineConstraint self) -> std::string const &"""
        return _simulation.PointOnLineConstraint_getConcreteClassName(self)

    def copyProperty_line_direction_vec(self, source):
        r"""
        copyProperty_line_direction_vec(PointOnLineConstraint self, PointOnLineConstraint source)

        Parameters
        ----------
        source: OpenSim::PointOnLineConstraint::Self const &

        """
        return _simulation.PointOnLineConstraint_copyProperty_line_direction_vec(self, source)

    def append_line_direction_vec(self, value):
        r"""
        append_line_direction_vec(PointOnLineConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_append_line_direction_vec(self, value)

    def constructProperty_line_direction_vec(self, initValue):
        r"""
        constructProperty_line_direction_vec(PointOnLineConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_constructProperty_line_direction_vec(self, initValue)

    def get_line_direction_vec(self, *args):
        r"""
        get_line_direction_vec(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_line_direction_vec(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_get_line_direction_vec(self, *args)

    def upd_line_direction_vec(self, *args):
        r"""
        upd_line_direction_vec(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_line_direction_vec(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_upd_line_direction_vec(self, *args)

    def set_line_direction_vec(self, *args):
        r"""
        set_line_direction_vec(PointOnLineConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_line_direction_vec(PointOnLineConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_set_line_direction_vec(self, *args)

    def copyProperty_point_on_line(self, source):
        r"""
        copyProperty_point_on_line(PointOnLineConstraint self, PointOnLineConstraint source)

        Parameters
        ----------
        source: OpenSim::PointOnLineConstraint::Self const &

        """
        return _simulation.PointOnLineConstraint_copyProperty_point_on_line(self, source)

    def append_point_on_line(self, value):
        r"""
        append_point_on_line(PointOnLineConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_append_point_on_line(self, value)

    def constructProperty_point_on_line(self, initValue):
        r"""
        constructProperty_point_on_line(PointOnLineConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_constructProperty_point_on_line(self, initValue)

    def get_point_on_line(self, *args):
        r"""
        get_point_on_line(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point_on_line(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_get_point_on_line(self, *args)

    def upd_point_on_line(self, *args):
        r"""
        upd_point_on_line(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point_on_line(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_upd_point_on_line(self, *args)

    def set_point_on_line(self, *args):
        r"""
        set_point_on_line(PointOnLineConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point_on_line(PointOnLineConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_set_point_on_line(self, *args)

    def copyProperty_point_on_follower(self, source):
        r"""
        copyProperty_point_on_follower(PointOnLineConstraint self, PointOnLineConstraint source)

        Parameters
        ----------
        source: OpenSim::PointOnLineConstraint::Self const &

        """
        return _simulation.PointOnLineConstraint_copyProperty_point_on_follower(self, source)

    def append_point_on_follower(self, value):
        r"""
        append_point_on_follower(PointOnLineConstraint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_append_point_on_follower(self, value)

    def constructProperty_point_on_follower(self, initValue):
        r"""
        constructProperty_point_on_follower(PointOnLineConstraint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_constructProperty_point_on_follower(self, initValue)

    def get_point_on_follower(self, *args):
        r"""
        get_point_on_follower(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point_on_follower(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_get_point_on_follower(self, *args)

    def upd_point_on_follower(self, *args):
        r"""
        upd_point_on_follower(PointOnLineConstraint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point_on_follower(PointOnLineConstraint self) -> Vec3
        """
        return _simulation.PointOnLineConstraint_upd_point_on_follower(self, *args)

    def set_point_on_follower(self, *args):
        r"""
        set_point_on_follower(PointOnLineConstraint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point_on_follower(PointOnLineConstraint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointOnLineConstraint_set_point_on_follower(self, *args)
    PropertyIndex_socket_line_body = property(_simulation.PointOnLineConstraint_PropertyIndex_socket_line_body_get, _simulation.PointOnLineConstraint_PropertyIndex_socket_line_body_set, doc=r"""PropertyIndex_socket_line_body : OpenSim::PropertyIndex""")

    def connectSocket_line_body(self, object):
        r"""
        connectSocket_line_body(PointOnLineConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointOnLineConstraint_connectSocket_line_body(self, object)
    PropertyIndex_socket_follower_body = property(_simulation.PointOnLineConstraint_PropertyIndex_socket_follower_body_get, _simulation.PointOnLineConstraint_PropertyIndex_socket_follower_body_set, doc=r"""PropertyIndex_socket_follower_body : OpenSim::PropertyIndex""")

    def connectSocket_follower_body(self, object):
        r"""
        connectSocket_follower_body(PointOnLineConstraint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointOnLineConstraint_connectSocket_follower_body(self, object)

    def __init__(self, *args):
        r"""
        __init__(PointOnLineConstraint self) -> PointOnLineConstraint
        __init__(PointOnLineConstraint self, PhysicalFrame lineBody, Vec3 lineDirection, Vec3 pointOnLine, PhysicalFrame followerBody, Vec3 followerPoint) -> PointOnLineConstraint

        Parameters
        ----------
        lineBody: OpenSim::PhysicalFrame const &
        lineDirection: SimTK::Vec3 const &
        pointOnLine: SimTK::Vec3
        followerBody: OpenSim::PhysicalFrame const &
        followerPoint: SimTK::Vec3 const &

        """
        _simulation.PointOnLineConstraint_swiginit(self, _simulation.new_PointOnLineConstraint(*args))
    __swig_destroy__ = _simulation.delete_PointOnLineConstraint

    def setLineBodyByName(self, aBodyName):
        r"""
        setLineBodyByName(PointOnLineConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.PointOnLineConstraint_setLineBodyByName(self, aBodyName)

    def setFollowerBodyByName(self, aBodyName):
        r"""
        setFollowerBodyByName(PointOnLineConstraint self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.PointOnLineConstraint_setFollowerBodyByName(self, aBodyName)

    def setLineDirection(self, direction):
        r"""
        setLineDirection(PointOnLineConstraint self, Vec3 direction)

        Parameters
        ----------
        direction: SimTK::Vec3

        """
        return _simulation.PointOnLineConstraint_setLineDirection(self, direction)

    def setPointOnLine(self, point):
        r"""
        setPointOnLine(PointOnLineConstraint self, Vec3 point)

        Parameters
        ----------
        point: SimTK::Vec3

        """
        return _simulation.PointOnLineConstraint_setPointOnLine(self, point)

    def setPointOnFollower(self, point):
        r"""
        setPointOnFollower(PointOnLineConstraint self, Vec3 point)

        Parameters
        ----------
        point: SimTK::Vec3

        """
        return _simulation.PointOnLineConstraint_setPointOnFollower(self, point)

# Register PointOnLineConstraint in _simulation:
_simulation.PointOnLineConstraint_swigregister(PointOnLineConstraint)
class Controller(ModelComponent):
    r"""
    Controller is an abstract ModelComponent that defines the interface for
    an OpenSim Controller. A controller computes and sets the values of the
    controls for the actuators under its control.

    The defining method of a Controller is its computeControls() method. All
    concrete controllers must implement this method.
    See also: computeControls()

    Actuators can be connected to a Controller via the list Socket `actuators`.
    Connection can be made via the `addActuator()` convenience method or through
    the Socket directly:

    .. code-block:: c++

        // Add an actuator to the controller.
        const auto& actuator = model.getComponent<Actuator>("/path/to/actuator");
        controller.addActuator(actuator);

        // Connect an actuator to the controller via the actuators Socket.
        controller.appendSocketConnectee_actuators(actuator);

    Multiple actuators can be connected to a Controller via the `setActuators()`
    convenience methods:

    .. code-block:: c++

        // Add a Model's Set of Actuators to the controller.
        controller.setActuators(model.getActuators());

        // Add a ComponentList of Actuators to the controller.
        controller.setActuators(model.getComponentList<Actuator>());

    Notes: Prior to OpenSim 4.6, controlled actuators were managed via the list
          Property `actuator_list`. This interface is no longer supported, all
          actuators must be connected via the `actuators` list Socket.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Controller

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Controller_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Controller self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Controller_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Controller_getClassName()

    def clone(self):
        r"""clone(Controller self) -> Controller"""
        return _simulation.Controller_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Controller self) -> std::string const &"""
        return _simulation.Controller_getConcreteClassName(self)

    def copyProperty_enabled(self, source):
        r"""
        Controller is enabled (active) by default.
           NOTE: Prior to OpenSim 4.0, this property was named **isDisabled**.
                 If **isDisabled** is **true**, **enabled** is **false**.
                 If **isDisabled** is **false**, **enabled** is **true**.
        """
        return _simulation.Controller_copyProperty_enabled(self, source)

    def append_enabled(self, value):
        r"""
        append_enabled(Controller self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Controller_append_enabled(self, value)

    def constructProperty_enabled(self, initValue):
        r"""
        constructProperty_enabled(Controller self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Controller_constructProperty_enabled(self, initValue)

    def get_enabled(self, *args):
        r"""
        get_enabled(Controller self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_enabled(Controller self) -> bool const &
        """
        return _simulation.Controller_get_enabled(self, *args)

    def upd_enabled(self, *args):
        r"""
        upd_enabled(Controller self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_enabled(Controller self) -> bool &
        """
        return _simulation.Controller_upd_enabled(self, *args)

    def set_enabled(self, *args):
        r"""
        set_enabled(Controller self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_enabled(Controller self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Controller_set_enabled(self, *args)
    PropertyIndex_socket_actuators = property(_simulation.Controller_PropertyIndex_socket_actuators_get, _simulation.Controller_PropertyIndex_socket_actuators_set, doc=r"""PropertyIndex_socket_actuators : OpenSim::PropertyIndex""")

    def appendSocketConnectee_actuators(self, object):
        r"""
        appendSocketConnectee_actuators(Controller self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Controller_appendSocketConnectee_actuators(self, object)
    __swig_destroy__ = _simulation.delete_Controller

    def isEnabled(self):
        r"""
         Get whether or not this controller is enabled.
        :rtype: boolean
        :return: true when controller is enabled.
        """
        return _simulation.Controller_isEnabled(self)

    def setEnabled(self, enableFlag):
        r"""
         Enable this controller.
        :type enableFlag: boolean
        :param enableFlag: Enable the controller if true.
        """
        return _simulation.Controller_setEnabled(self, enableFlag)

    def setActuators(self, *args):
        r"""
        setActuators(Controller self, SetActuators actuators)

        Parameters
        ----------
        actuators: OpenSim::Set< OpenSim::Actuator > const &

        setActuators(Controller self, ActuatorList actuators)

        Parameters
        ----------
        actuators: OpenSim::ComponentList< OpenSim::Actuator const > const &

        """
        return _simulation.Controller_setActuators(self, *args)

    def addActuator(self, actuator):
        r""" Add to the current set of actuators."""
        return _simulation.Controller_addActuator(self, actuator)

    def computeControls(self, s, controls):
        r"""
         Compute the control for actuator
         This method defines the behavior for any concrete controller
         and therefore must be implemented by concrete subclasses.

        :type s: :py:class:`State`
        :param s:         system state
        :type controls: :py:class:`Vector`
        :param controls:  writable model controls (all actuators)
        """
        return _simulation.Controller_computeControls(self, s, controls)

    def getNumControls(self):
        r""" Get the number of controls this controller computes."""
        return _simulation.Controller_getNumControls(self)

    def getNumActuators(self):
        r""" Get the number of actuators that this controller is connected to."""
        return _simulation.Controller_getNumActuators(self)

# Register Controller in _simulation:
_simulation.Controller_swigregister(Controller)
class SetControllers(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetControllers

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetControllers_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetControllers self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetControllers_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetControllers_getClassName()

    def clone(self):
        r"""clone(SetControllers self) -> SetControllers"""
        return _simulation.SetControllers_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetControllers self) -> std::string const &"""
        return _simulation.SetControllers_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetControllers

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Controller,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetControllers_swiginit(self, _simulation.new_SetControllers(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetControllers_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetControllers_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControllers_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControllers_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Controller`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControllers_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetControllers_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Controller`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControllers_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Controller`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControllers_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Controller`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControllers_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Controller`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControllers_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetControllers self)"""
        return _simulation.SetControllers_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Controller`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetControllers_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Controller`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Controller`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControllers_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetControllers_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetControllers_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetControllers_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetControllers_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetControllers_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetControllers_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetControllers_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetControllers_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetControllers_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetControllers in _simulation:
_simulation.SetControllers_swigregister(SetControllers)
class ModelComponentSetControllers(SetControllers):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Controller > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetControllers

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetControllers_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetControllers self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetControllers_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetControllers_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetControllers self) -> ModelComponentSetControllers"""
        return _simulation.ModelComponentSetControllers_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetControllers self) -> std::string const &"""
        return _simulation.ModelComponentSetControllers_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetControllers self)"""
        return _simulation.ModelComponentSetControllers_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetControllers self) -> ModelComponentSetControllers"""
        _simulation.ModelComponentSetControllers_swiginit(self, _simulation.new_ModelComponentSetControllers())
    __swig_destroy__ = _simulation.delete_ModelComponentSetControllers

# Register ModelComponentSetControllers in _simulation:
_simulation.ModelComponentSetControllers_swigregister(ModelComponentSetControllers)
class ControllerSet(ModelComponentSetControllers):
    r"""
    A class for holding and managing a set of controllers for a model.

    Authors: Jack Middleton, Ajay Seth
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ControllerSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ControllerSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ControllerSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ControllerSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ControllerSet_getClassName()

    def clone(self):
        r"""clone(ControllerSet self) -> ControllerSet"""
        return _simulation.ControllerSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ControllerSet self) -> std::string const &"""
        return _simulation.ControllerSet_getConcreteClassName(self)

    def constructStorage(self):
        r"""constructStorage(ControllerSet self)"""
        return _simulation.ControllerSet_constructStorage(self)

    def storeControls(self, s, step):
        r"""
        storeControls(ControllerSet self, State s, int step)

        Parameters
        ----------
        s: SimTK::State const &
        step: int

        """
        return _simulation.ControllerSet_storeControls(self, s, step)

    def printControlStorage(self, fileName):
        r"""
        printControlStorage(ControllerSet self, std::string const & fileName)

        Parameters
        ----------
        fileName: std::string const &

        """
        return _simulation.ControllerSet_printControlStorage(self, fileName)

    def getControlTable(self):
        r"""getControlTable(ControllerSet self) -> TimeSeriesTable"""
        return _simulation.ControllerSet_getControlTable(self)

    def setActuators(self, actuators):
        r"""
        setActuators(ControllerSet self, SetActuators actuators)

        Parameters
        ----------
        actuators: OpenSim::Set< OpenSim::Actuator > &

        """
        return _simulation.ControllerSet_setActuators(self, actuators)

    def setDesiredStates(self, yStore):
        r"""
        setDesiredStates(ControllerSet self, Storage yStore)

        Parameters
        ----------
        yStore: OpenSim::Storage *

        """
        return _simulation.ControllerSet_setDesiredStates(self, yStore)

    def computeControls(self, s, controls):
        r"""
        computeControls(ControllerSet self, State s, Vector controls)

        Parameters
        ----------
        s: SimTK::State const &
        controls: SimTK::Vector &

        """
        return _simulation.ControllerSet_computeControls(self, s, controls)

    def printInfo(self):
        r"""printInfo(ControllerSet self)"""
        return _simulation.ControllerSet_printInfo(self)

    def __init__(self, *args):
        r"""
        __init__(ControllerSet self) -> ControllerSet
        __init__(ControllerSet self, std::string const & file, bool updateFromXML=True) -> ControllerSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.ControllerSet_swiginit(self, _simulation.new_ControllerSet(*args))
    __swig_destroy__ = _simulation.delete_ControllerSet

# Register ControllerSet in _simulation:
_simulation.ControllerSet_swigregister(ControllerSet)
class ExternalLoads(ModelComponentSetExternalForces):
    r"""
    A convenience class for managing ExternaForce(s) to be applied to a model.
    This includes creating instances and manipulating the data source
    of individual ExternalForces so that they satisfy conditions imposed
    by particular Tools. For example, ForwardTool, CMC/RRA, achieve better
    tracking (slower divergence) if the ground reaction forces are applied
    to a point that is expressed in the foot frame according to "ideal"
    kinematics. ExternalLoads provides convenience methods to perform this
    "mapping" which is beyond the scope of an individual ExternalForce, but is
    too much detail to have each Tool implement.

    An individual ExternalForce has a property for its data source name, but
    under the management of ExternalLoads, the data source identified by
    ExternalLoads is used to set the data source on each ExternalForce.
    If multiple data sources are required for different groups of external forces
    then use multiple ExternalLoads.

    Authors: Ajay Seth, Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExternalLoads

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExternalLoads_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExternalLoads self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExternalLoads_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExternalLoads_getClassName()

    def clone(self):
        r"""clone(ExternalLoads self) -> ExternalLoads"""
        return _simulation.ExternalLoads_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExternalLoads self) -> std::string const &"""
        return _simulation.ExternalLoads_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ExternalLoads self) -> ExternalLoads
        __init__(ExternalLoads self, std::string const & fileName, bool aUpdateFromXMLNode) -> ExternalLoads

        Parameters
        ----------
        fileName: std::string const &
        aUpdateFromXMLNode: bool

        __init__(ExternalLoads self, ExternalLoads aExternalLoads) -> ExternalLoads

        Parameters
        ----------
        aExternalLoads: OpenSim::ExternalLoads const &

        """
        _simulation.ExternalLoads_swiginit(self, _simulation.new_ExternalLoads(*args))
    __swig_destroy__ = _simulation.delete_ExternalLoads

    def copyData(self, otherExternalLoads):
        r"""
        copyData(ExternalLoads self, ExternalLoads otherExternalLoads)

        Parameters
        ----------
        otherExternalLoads: OpenSim::ExternalLoads const &

        """
        return _simulation.ExternalLoads_copyData(self, otherExternalLoads)

    def updateFromXMLNode(self, aNode, versionNumber=-1):
        r""" Override of the default implementation to account for versioning."""
        return _simulation.ExternalLoads_updateFromXMLNode(self, aNode, versionNumber)

    def extendConnectToModel(self, aModel):
        r"""
        extendConnectToModel(ExternalLoads self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.ExternalLoads_extendConnectToModel(self, aModel)

    def getDataFileName(self):
        r"""getDataFileName(ExternalLoads self) -> std::string const &"""
        return _simulation.ExternalLoads_getDataFileName(self)

    def setDataFileName(self, aNewFile):
        r"""
        setDataFileName(ExternalLoads self, std::string const & aNewFile)

        Parameters
        ----------
        aNewFile: std::string const &

        """
        return _simulation.ExternalLoads_setDataFileName(self, aNewFile)

    def transformPointsExpressedInGroundToAppliedBodies(self, *args):
        r"""
        transformPointsExpressedInGroundToAppliedBodies(ExternalLoads self, Storage kinematics, double startTime=-SimTK::Infinity, double endTime=SimTK::Infinity)

        Parameters
        ----------
        kinematics: OpenSim::Storage const &
        startTime: double
        endTime: double

        """
        return _simulation.ExternalLoads_transformPointsExpressedInGroundToAppliedBodies(self, *args)

    def transformPointExpressedInGroundToAppliedBody(self, exForce, kinematics, startTime, endTime):
        r"""
        transformPointExpressedInGroundToAppliedBody(ExternalLoads self, ExternalForce exForce, Storage kinematics, double startTime, double endTime) -> ExternalForce

        Parameters
        ----------
        exForce: OpenSim::ExternalForce const &
        kinematics: OpenSim::Storage const &
        startTime: double
        endTime: double

        """
        return _simulation.ExternalLoads_transformPointExpressedInGroundToAppliedBody(self, exForce, kinematics, startTime, endTime)

    def clearLoadedFromFile(self):
        r"""
        ExternalLoads remembers the file it was loaded from, even after being
        copied. This file path is used to find the datafile relative to the
        location of the ExternalLoads file itself. This function can clear
        the memory of the file that the original ExternalLoads came from.
        In general, users should not need to use this function.
        """
        return _simulation.ExternalLoads_clearLoadedFromFile(self)

# Register ExternalLoads in _simulation:
_simulation.ExternalLoads_swigregister(ExternalLoads)
class PrescribedForce(ForceProducer):
    r"""
     This applies to a PhysicalFrame a force and/or torque that is specified as a
    function of time. It is defined by three sets of functions, all of which are
    optional:

      - Three functions that specify the (x,y,z) components of a force vector
        to apply (at a given point) as a function of time. If these functions are
        not provided, no force is applied.

      - Three functions that specify the (x,y,z) components of a point location at
        which the force should be applied. If these functions are not provided, the
        force is applied at the frame's origin.

      - Three functions that specify the (x,y,z) components of a pure torque
        vector to apply. This is in addition to any torque resulting from the
        applied force. If these functions are not provided, no additional torque
        is applied.

    Author: Peter Eastman, Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PrescribedForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PrescribedForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PrescribedForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PrescribedForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PrescribedForce_getClassName()

    def clone(self):
        r"""clone(PrescribedForce self) -> PrescribedForce"""
        return _simulation.PrescribedForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PrescribedForce self) -> std::string const &"""
        return _simulation.PrescribedForce_getConcreteClassName(self)

    def copyProperty_pointIsGlobal(self, source):
        r"""
        "pointIsGlobal" property is a flag indicating whether the point
           calculated by the Functions in pointFunctions are returned in the global
           frame rather than in the body frame which is the default. *
        """
        return _simulation.PrescribedForce_copyProperty_pointIsGlobal(self, source)

    def append_pointIsGlobal(self, value):
        r"""
        append_pointIsGlobal(PrescribedForce self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PrescribedForce_append_pointIsGlobal(self, value)

    def constructProperty_pointIsGlobal(self, initValue):
        r"""
        constructProperty_pointIsGlobal(PrescribedForce self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.PrescribedForce_constructProperty_pointIsGlobal(self, initValue)

    def get_pointIsGlobal(self, *args):
        r"""
        get_pointIsGlobal(PrescribedForce self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_pointIsGlobal(PrescribedForce self) -> bool const &
        """
        return _simulation.PrescribedForce_get_pointIsGlobal(self, *args)

    def upd_pointIsGlobal(self, *args):
        r"""
        upd_pointIsGlobal(PrescribedForce self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_pointIsGlobal(PrescribedForce self) -> bool &
        """
        return _simulation.PrescribedForce_upd_pointIsGlobal(self, *args)

    def set_pointIsGlobal(self, *args):
        r"""
        set_pointIsGlobal(PrescribedForce self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_pointIsGlobal(PrescribedForce self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PrescribedForce_set_pointIsGlobal(self, *args)

    def copyProperty_forceIsGlobal(self, source):
        r"""
        "forceIsGlobal" property is a flag indicating whether the force and
           torque returned by the Functions in forceFunctions and torqueFunctions,
           resp., are returned in the global frame (the default). Otherwise they
           are returned in the body frame. *
        """
        return _simulation.PrescribedForce_copyProperty_forceIsGlobal(self, source)

    def append_forceIsGlobal(self, value):
        r"""
        append_forceIsGlobal(PrescribedForce self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PrescribedForce_append_forceIsGlobal(self, value)

    def constructProperty_forceIsGlobal(self, initValue):
        r"""
        constructProperty_forceIsGlobal(PrescribedForce self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.PrescribedForce_constructProperty_forceIsGlobal(self, initValue)

    def get_forceIsGlobal(self, *args):
        r"""
        get_forceIsGlobal(PrescribedForce self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_forceIsGlobal(PrescribedForce self) -> bool const &
        """
        return _simulation.PrescribedForce_get_forceIsGlobal(self, *args)

    def upd_forceIsGlobal(self, *args):
        r"""
        upd_forceIsGlobal(PrescribedForce self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_forceIsGlobal(PrescribedForce self) -> bool &
        """
        return _simulation.PrescribedForce_upd_forceIsGlobal(self, *args)

    def set_forceIsGlobal(self, *args):
        r"""
        set_forceIsGlobal(PrescribedForce self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_forceIsGlobal(PrescribedForce self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PrescribedForce_set_forceIsGlobal(self, *args)

    def copyProperty_forceFunctions(self, source):
        r"""
        These are three functions providing the x,y,z measure numbers of the
           force vector being applied to the body. The coordinate frame in which
           this vector is interpreted depends on the "forceIsGlobal" property. *
        """
        return _simulation.PrescribedForce_copyProperty_forceFunctions(self, source)

    def append_forceFunctions(self, value):
        r"""
        append_forceFunctions(PrescribedForce self, FunctionSet value) -> int

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_append_forceFunctions(self, value)

    def constructProperty_forceFunctions(self, initValue):
        r"""
        constructProperty_forceFunctions(PrescribedForce self, FunctionSet initValue)

        Parameters
        ----------
        initValue: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_constructProperty_forceFunctions(self, initValue)

    def get_forceFunctions(self, *args):
        r"""
        get_forceFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        get_forceFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_get_forceFunctions(self, *args)

    def upd_forceFunctions(self, *args):
        r"""
        upd_forceFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        upd_forceFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_upd_forceFunctions(self, *args)

    def set_forceFunctions(self, *args):
        r"""
        set_forceFunctions(PrescribedForce self, int i, FunctionSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::FunctionSet const &

        set_forceFunctions(PrescribedForce self, FunctionSet value)

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_set_forceFunctions(self, *args)

    def copyProperty_pointFunctions(self, source):
        r"""
        These are three functions providing the x,y,z measure numbers of the
           point at which the force should be applied. The coordinate frame in which
           this position vector is interpreted depends on the "pointIsGlobal"
           property. *
        """
        return _simulation.PrescribedForce_copyProperty_pointFunctions(self, source)

    def append_pointFunctions(self, value):
        r"""
        append_pointFunctions(PrescribedForce self, FunctionSet value) -> int

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_append_pointFunctions(self, value)

    def constructProperty_pointFunctions(self, initValue):
        r"""
        constructProperty_pointFunctions(PrescribedForce self, FunctionSet initValue)

        Parameters
        ----------
        initValue: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_constructProperty_pointFunctions(self, initValue)

    def get_pointFunctions(self, *args):
        r"""
        get_pointFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        get_pointFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_get_pointFunctions(self, *args)

    def upd_pointFunctions(self, *args):
        r"""
        upd_pointFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        upd_pointFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_upd_pointFunctions(self, *args)

    def set_pointFunctions(self, *args):
        r"""
        set_pointFunctions(PrescribedForce self, int i, FunctionSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::FunctionSet const &

        set_pointFunctions(PrescribedForce self, FunctionSet value)

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_set_pointFunctions(self, *args)

    def copyProperty_torqueFunctions(self, source):
        r"""
        These are three functions providing the x,y,z measure numbers of the
           torque vector being applied to the body. The coordinate frame in which
           this vector is interpreted depends on the "torqueIsGlobal" property. *
        """
        return _simulation.PrescribedForce_copyProperty_torqueFunctions(self, source)

    def append_torqueFunctions(self, value):
        r"""
        append_torqueFunctions(PrescribedForce self, FunctionSet value) -> int

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_append_torqueFunctions(self, value)

    def constructProperty_torqueFunctions(self, initValue):
        r"""
        constructProperty_torqueFunctions(PrescribedForce self, FunctionSet initValue)

        Parameters
        ----------
        initValue: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_constructProperty_torqueFunctions(self, initValue)

    def get_torqueFunctions(self, *args):
        r"""
        get_torqueFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        get_torqueFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_get_torqueFunctions(self, *args)

    def upd_torqueFunctions(self, *args):
        r"""
        upd_torqueFunctions(PrescribedForce self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        upd_torqueFunctions(PrescribedForce self) -> FunctionSet
        """
        return _simulation.PrescribedForce_upd_torqueFunctions(self, *args)

    def set_torqueFunctions(self, *args):
        r"""
        set_torqueFunctions(PrescribedForce self, int i, FunctionSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::FunctionSet const &

        set_torqueFunctions(PrescribedForce self, FunctionSet value)

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedForce_set_torqueFunctions(self, *args)
    PropertyIndex_socket_frame = property(_simulation.PrescribedForce_PropertyIndex_socket_frame_get, _simulation.PrescribedForce_PropertyIndex_socket_frame_set, doc=r"""PropertyIndex_socket_frame : OpenSim::PropertyIndex""")

    def connectSocket_frame(self, object):
        r"""
        connectSocket_frame(PrescribedForce self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PrescribedForce_connectSocket_frame(self, object)
    _has_output_force_applied = property(_simulation.PrescribedForce__has_output_force_applied_get, _simulation.PrescribedForce__has_output_force_applied_set, doc=r"""
    The force applied by the PrescribedForce, this depends only on time.
       The frame in which this vector is interpreted depends on the "forceIsGlobal" property.
    """)
    _has_output_torque_applied = property(_simulation.PrescribedForce__has_output_torque_applied_get, _simulation.PrescribedForce__has_output_torque_applied_set, doc=r"""
    The torque applied by the PrescribedForce, this depends only on time.
       The frame in which this vector is interpreted depends on the "forceIsGlobal" property.
    """)
    _has_output_point_of_application = property(_simulation.PrescribedForce__has_output_point_of_application_get, _simulation.PrescribedForce__has_output_point_of_application_set, doc=r"""
    The point where force is applied by the PrescribedForce, this depends only on time.
       The frame of this vector depends on the "pointIsGlobal" property.
    """)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct a PrescribedForce. By default, the force, torque, and point
        functions are all unspecified, meaning that it applies no force or
        torque.  To specify them, call setForceFunctions(), setTorqueFunctions(),
        and setPointFunctions().

        :type name: string
        :param name:      the name of the PrescribedForce
        :type frame: :py:class:`PhysicalFrame`
        :param frame:     the PhysicalFrame to apply the force to

        |

        *Overload 2:*
         Construct from an XML element. *
        """
        _simulation.PrescribedForce_swiginit(self, _simulation.new_PrescribedForce(*args))

    def updateFromXMLNode(self, aNode, versionNumber=-1):
        r""" Copy in properties from XML. *"""
        return _simulation.PrescribedForce_updateFromXMLNode(self, aNode, versionNumber)

    def setFrameName(self, aBodyName):
        r"""
        setFrameName(PrescribedForce self, std::string const & aBodyName)

        Parameters
        ----------
        aBodyName: std::string const &

        """
        return _simulation.PrescribedForce_setFrameName(self, aBodyName)

    def getFrameName(self):
        r"""getFrameName(PrescribedForce self) -> std::string const &"""
        return _simulation.PrescribedForce_getFrameName(self)

    def setBodyName(self, aBodyName):
        r""" Backward compatibility pre 4.0 *"""
        return _simulation.PrescribedForce_setBodyName(self, aBodyName)

    def getBodyName(self):
        r"""getBodyName(PrescribedForce self) -> std::string const &"""
        return _simulation.PrescribedForce_getBodyName(self)

    def setForceFunctions(self, forceX, forceY, forceZ):
        r"""
        %Set the functions which specify the force to apply.  By default the
        force is specified in inertial coordinates.
        This can be changed by calling setForceIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type forceX: :py:class:`Function`
        :param forceX:   a function of time which calculates the X component of
                                 the force to apply
        :type forceY: :py:class:`Function`
        :param forceY:   a function of time which calculates the Y component of
                                 the force to apply
        :type forceZ: :py:class:`Function`
        :param forceZ:   a function of time which calculates the Z component of
                                 the force to apply
        """
        return _simulation.PrescribedForce_setForceFunctions(self, forceX, forceY, forceZ)

    def getForceFunctions(self):
        r"""getForceFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_getForceFunctions(self)

    def updForceFunctions(self):
        r"""updForceFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_updForceFunctions(self)

    def getForceFunctionNames(self, aFunctionNames):
        r"""
        getForceFunctionNames(PrescribedForce self, ArrayStr aFunctionNames)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > &

        """
        return _simulation.PrescribedForce_getForceFunctionNames(self, aFunctionNames)

    def setForceFunctionNames(self, aFunctionNames, kineticsStore):
        r"""
        setForceFunctionNames(PrescribedForce self, ArrayStr aFunctionNames, Storage kineticsStore)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > const &
        kineticsStore: OpenSim::Storage const &

        """
        return _simulation.PrescribedForce_setForceFunctionNames(self, aFunctionNames, kineticsStore)

    def clearForceFunctions(self):
        r"""clearForceFunctions(PrescribedForce self)"""
        return _simulation.PrescribedForce_clearForceFunctions(self)

    def setPointFunctions(self, pointX, pointY, pointZ):
        r"""
        %Set the functions which specify the point at which to apply the force.
        By default the point is specified in the body's local coordinates.
        This can be changed by calling setPointIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type pointX: :py:class:`Function`
        :param pointX:   a function of time which calculates the X coordinate of
                                 the point at which to apply the force
        :type pointY: :py:class:`Function`
        :param pointY:   a function of time which calculates the Y coordinate of
                                 the point at which to apply the force
        :type pointZ: :py:class:`Function`
        :param pointZ:   a function of time which calculates the Z coordinate of
                                 the point at which to apply the force
        """
        return _simulation.PrescribedForce_setPointFunctions(self, pointX, pointY, pointZ)

    def getPointFunctions(self):
        r"""getPointFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_getPointFunctions(self)

    def updPointFunctions(self):
        r"""updPointFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_updPointFunctions(self)

    def getPointFunctionNames(self, aFunctionNames):
        r"""
        getPointFunctionNames(PrescribedForce self, ArrayStr aFunctionNames)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > &

        """
        return _simulation.PrescribedForce_getPointFunctionNames(self, aFunctionNames)

    def setPointFunctionNames(self, aFunctionNames, kineticsStore):
        r"""
        setPointFunctionNames(PrescribedForce self, ArrayStr aFunctionNames, Storage kineticsStore)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > const &
        kineticsStore: OpenSim::Storage const &

        """
        return _simulation.PrescribedForce_setPointFunctionNames(self, aFunctionNames, kineticsStore)

    def clearPointFunctions(self):
        r"""clearPointFunctions(PrescribedForce self)"""
        return _simulation.PrescribedForce_clearPointFunctions(self)

    def setTorqueFunctions(self, torqueX, torqueY, torqueZ):
        r"""
        %Set the functions which specify the torque to apply. By default the
        torque is specified in inertial coordinates.
        This can be changed by calling setForceIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type torqueX: :py:class:`Function`
        :param torqueX:   a function of time which calculates the X component of
                                 the torque to apply
        :type torqueY: :py:class:`Function`
        :param torqueY:   a function of time which calculates the Y component of
                                 the torque to apply
        :type torqueZ: :py:class:`Function`
        :param torqueZ:   a function of time which calculates the Z component of
                                 the torque to apply
        """
        return _simulation.PrescribedForce_setTorqueFunctions(self, torqueX, torqueY, torqueZ)

    def getTorqueFunctions(self):
        r"""getTorqueFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_getTorqueFunctions(self)

    def updTorqueFunctions(self):
        r"""updTorqueFunctions(PrescribedForce self) -> FunctionSet"""
        return _simulation.PrescribedForce_updTorqueFunctions(self)

    def getTorqueFunctionNames(self, aFunctionNames):
        r"""
        getTorqueFunctionNames(PrescribedForce self, ArrayStr aFunctionNames)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > &

        """
        return _simulation.PrescribedForce_getTorqueFunctionNames(self, aFunctionNames)

    def setTorqueFunctionNames(self, aFunctionNames, kineticsStore):
        r"""
        setTorqueFunctionNames(PrescribedForce self, ArrayStr aFunctionNames, Storage kineticsStore)

        Parameters
        ----------
        aFunctionNames: OpenSim::Array< std::string > const &
        kineticsStore: OpenSim::Storage const &

        """
        return _simulation.PrescribedForce_setTorqueFunctionNames(self, aFunctionNames, kineticsStore)

    def clearTorqueFunctions(self):
        r"""clearTorqueFunctions(PrescribedForce self)"""
        return _simulation.PrescribedForce_clearTorqueFunctions(self)

    def getForceIsInGlobalFrame(self):
        r"""
        Get whether the force and torque are specified in inertial coordinates
           or in the body's local coordinates. *
        """
        return _simulation.PrescribedForce_getForceIsInGlobalFrame(self)

    def setForceIsInGlobalFrame(self, isGlobal):
        r"""
        %Set whether the force and torque are specified in inertial coordinates
           or in the body's local coordinates. *
        """
        return _simulation.PrescribedForce_setForceIsInGlobalFrame(self, isGlobal)

    def getPointIsInGlobalFrame(self):
        r"""
        Get whether the point is specified in inertial coordinates or in the
           body's local coordinates. *
        """
        return _simulation.PrescribedForce_getPointIsInGlobalFrame(self)

    def setPointIsInGlobalFrame(self, isGlobal):
        r"""
        %Set whether the point is specified in inertial coordinates or in the
           body's local coordinates. *
        """
        return _simulation.PrescribedForce_setPointIsInGlobalFrame(self, isGlobal)

    def getFrame(self):
        r""" Get the frame that the prescribed force is acting upon. *"""
        return _simulation.PrescribedForce_getFrame(self)

    def getForceAtTime(self, aTime):
        r"""
        Convenience method to evaluate the prescribed force functions at
           an arbitrary time. Returns zero if there aren't three functions defined. *
        """
        return _simulation.PrescribedForce_getForceAtTime(self, aTime)

    def getPointAtTime(self, aTime):
        r"""
        Convenience method to evaluate the prescribed force application point
           functions at an arbitrary time. Returns zero if there aren't three
           functions defined. *
        """
        return _simulation.PrescribedForce_getPointAtTime(self, aTime)

    def getTorqueAtTime(self, aTime):
        r"""
        Convenience method to evaluate the prescribed torque functions at
           an arbitrary time. Returns zero if there aren't three functions defined. *
        """
        return _simulation.PrescribedForce_getTorqueAtTime(self, aTime)

    def getRecordLabels(self):
        r"""Methods used for reporting"""
        return _simulation.PrescribedForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels() and should return same size Array.
        """
        return _simulation.PrescribedForce_getRecordValues(self, state)

    def getForceApplied(self, state):
        r""" Methods to support outputs"""
        return _simulation.PrescribedForce_getForceApplied(self, state)

    def getTorqueApplied(self, state):
        r"""
        getTorqueApplied(PrescribedForce self, State state) -> Vec3

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.PrescribedForce_getTorqueApplied(self, state)

    def getApplicationPoint(self, state):
        r"""
        getApplicationPoint(PrescribedForce self, State state) -> Vec3

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.PrescribedForce_getApplicationPoint(self, state)
    __swig_destroy__ = _simulation.delete_PrescribedForce

# Register PrescribedForce in _simulation:
_simulation.PrescribedForce_swigregister(PrescribedForce)
class CoordinateLimitForce(ForceProducer):
    r"""
    Generate a force that acts to limit the range of motion of a coordinate.
    Force is experienced at upper and lower limits of the coordinate value
    according to constant stiffnesses K_upper and K_lower, with a C2-continuous
    transition from 0 to K. The transition parameter defines how far beyond the
    limit the stiffness becomes constant. The integrator will like smoother
    (i.e. larger) transition regions.

    Damping factor is also phased in through the transition region from 0 to the
    value provided.

    Limiting force is guaranteed to be zero within the upper and lower limits.

    The potential energy stored in the spring component of the force is
    accessible as well as the power (and, optionally, energy) dissipated.
    The function has the following shape:

    Image: coordinate_limit_force.png

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CoordinateLimitForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.CoordinateLimitForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CoordinateLimitForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.CoordinateLimitForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.CoordinateLimitForce_getClassName()

    def clone(self):
        r"""clone(CoordinateLimitForce self) -> CoordinateLimitForce"""
        return _simulation.CoordinateLimitForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CoordinateLimitForce self) -> std::string const &"""
        return _simulation.CoordinateLimitForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source):
        r"""
        copyProperty_coordinate(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value):
        r"""
        append_coordinate(CoordinateLimitForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.CoordinateLimitForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, initValue):
        r"""
        constructProperty_coordinate(CoordinateLimitForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_coordinate(self, initValue)

    def get_coordinate(self, *args):
        r"""
        get_coordinate(CoordinateLimitForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_coordinate(CoordinateLimitForce self) -> std::string const &
        """
        return _simulation.CoordinateLimitForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args):
        r"""
        upd_coordinate(CoordinateLimitForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_coordinate(CoordinateLimitForce self) -> std::string &
        """
        return _simulation.CoordinateLimitForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args):
        r"""
        set_coordinate(CoordinateLimitForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_coordinate(CoordinateLimitForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.CoordinateLimitForce_set_coordinate(self, *args)

    def copyProperty_upper_stiffness(self, source):
        r"""
        copyProperty_upper_stiffness(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_upper_stiffness(self, source)

    def append_upper_stiffness(self, value):
        r"""
        append_upper_stiffness(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_upper_stiffness(self, value)

    def constructProperty_upper_stiffness(self, initValue):
        r"""
        constructProperty_upper_stiffness(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_upper_stiffness(self, initValue)

    def get_upper_stiffness(self, *args):
        r"""
        get_upper_stiffness(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_upper_stiffness(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_upper_stiffness(self, *args)

    def upd_upper_stiffness(self, *args):
        r"""
        upd_upper_stiffness(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_upper_stiffness(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_upper_stiffness(self, *args)

    def set_upper_stiffness(self, *args):
        r"""
        set_upper_stiffness(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_upper_stiffness(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_upper_stiffness(self, *args)

    def copyProperty_upper_limit(self, source):
        r"""
        copyProperty_upper_limit(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_upper_limit(self, source)

    def append_upper_limit(self, value):
        r"""
        append_upper_limit(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_upper_limit(self, value)

    def constructProperty_upper_limit(self, initValue):
        r"""
        constructProperty_upper_limit(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_upper_limit(self, initValue)

    def get_upper_limit(self, *args):
        r"""
        get_upper_limit(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_upper_limit(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_upper_limit(self, *args)

    def upd_upper_limit(self, *args):
        r"""
        upd_upper_limit(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_upper_limit(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_upper_limit(self, *args)

    def set_upper_limit(self, *args):
        r"""
        set_upper_limit(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_upper_limit(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_upper_limit(self, *args)

    def copyProperty_lower_stiffness(self, source):
        r"""
        copyProperty_lower_stiffness(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_lower_stiffness(self, source)

    def append_lower_stiffness(self, value):
        r"""
        append_lower_stiffness(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_lower_stiffness(self, value)

    def constructProperty_lower_stiffness(self, initValue):
        r"""
        constructProperty_lower_stiffness(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_lower_stiffness(self, initValue)

    def get_lower_stiffness(self, *args):
        r"""
        get_lower_stiffness(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_lower_stiffness(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_lower_stiffness(self, *args)

    def upd_lower_stiffness(self, *args):
        r"""
        upd_lower_stiffness(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_lower_stiffness(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_lower_stiffness(self, *args)

    def set_lower_stiffness(self, *args):
        r"""
        set_lower_stiffness(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_lower_stiffness(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_lower_stiffness(self, *args)

    def copyProperty_lower_limit(self, source):
        r"""
        copyProperty_lower_limit(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_lower_limit(self, source)

    def append_lower_limit(self, value):
        r"""
        append_lower_limit(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_lower_limit(self, value)

    def constructProperty_lower_limit(self, initValue):
        r"""
        constructProperty_lower_limit(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_lower_limit(self, initValue)

    def get_lower_limit(self, *args):
        r"""
        get_lower_limit(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_lower_limit(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_lower_limit(self, *args)

    def upd_lower_limit(self, *args):
        r"""
        upd_lower_limit(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_lower_limit(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_lower_limit(self, *args)

    def set_lower_limit(self, *args):
        r"""
        set_lower_limit(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_lower_limit(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_lower_limit(self, *args)

    def copyProperty_damping(self, source):
        r"""
        copyProperty_damping(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_damping(self, source)

    def append_damping(self, value):
        r"""
        append_damping(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_damping(self, value)

    def constructProperty_damping(self, initValue):
        r"""
        constructProperty_damping(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_damping(self, initValue)

    def get_damping(self, *args):
        r"""
        get_damping(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_damping(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_damping(self, *args)

    def upd_damping(self, *args):
        r"""
        upd_damping(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_damping(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_damping(self, *args)

    def set_damping(self, *args):
        r"""
        set_damping(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_damping(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_damping(self, *args)

    def copyProperty_transition(self, source):
        r"""
        copyProperty_transition(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_transition(self, source)

    def append_transition(self, value):
        r"""
        append_transition(CoordinateLimitForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_append_transition(self, value)

    def constructProperty_transition(self, initValue):
        r"""
        constructProperty_transition(CoordinateLimitForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_transition(self, initValue)

    def get_transition(self, *args):
        r"""
        get_transition(CoordinateLimitForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition(CoordinateLimitForce self) -> double const &
        """
        return _simulation.CoordinateLimitForce_get_transition(self, *args)

    def upd_transition(self, *args):
        r"""
        upd_transition(CoordinateLimitForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition(CoordinateLimitForce self) -> double &
        """
        return _simulation.CoordinateLimitForce_upd_transition(self, *args)

    def set_transition(self, *args):
        r"""
        set_transition(CoordinateLimitForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition(CoordinateLimitForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.CoordinateLimitForce_set_transition(self, *args)

    def copyProperty_compute_dissipation_energy(self, source):
        r"""
        copyProperty_compute_dissipation_energy(CoordinateLimitForce self, CoordinateLimitForce source)

        Parameters
        ----------
        source: OpenSim::CoordinateLimitForce::Self const &

        """
        return _simulation.CoordinateLimitForce_copyProperty_compute_dissipation_energy(self, source)

    def append_compute_dissipation_energy(self, value):
        r"""
        append_compute_dissipation_energy(CoordinateLimitForce self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.CoordinateLimitForce_append_compute_dissipation_energy(self, value)

    def constructProperty_compute_dissipation_energy(self, initValue):
        r"""
        constructProperty_compute_dissipation_energy(CoordinateLimitForce self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.CoordinateLimitForce_constructProperty_compute_dissipation_energy(self, initValue)

    def get_compute_dissipation_energy(self, *args):
        r"""
        get_compute_dissipation_energy(CoordinateLimitForce self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_compute_dissipation_energy(CoordinateLimitForce self) -> bool const &
        """
        return _simulation.CoordinateLimitForce_get_compute_dissipation_energy(self, *args)

    def upd_compute_dissipation_energy(self, *args):
        r"""
        upd_compute_dissipation_energy(CoordinateLimitForce self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_compute_dissipation_energy(CoordinateLimitForce self) -> bool &
        """
        return _simulation.CoordinateLimitForce_upd_compute_dissipation_energy(self, *args)

    def set_compute_dissipation_energy(self, *args):
        r"""
        set_compute_dissipation_energy(CoordinateLimitForce self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_compute_dissipation_energy(CoordinateLimitForce self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.CoordinateLimitForce_set_compute_dissipation_energy(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor.
           Generate a force that acts to limit the range of motion of a coordinate
           Force experienced at upper and lower limits of the coordinate (q) value
           is according to a linear stiffnesses K_upper and K_lower, with a C2 continuous
           transition from 0 to K. The transition parameter (dq) defines how far
           beyond the limit the stiffness becomes purely linear. The integrator will
           like smoother (i.e. larger transition regions).
           :type coordName: string, in
           :param coordName:   Coordinate whose range is to be limited.
           :type q_upper: float, in
           :param q_upper:     Coordinate's upper limit value.
           :type K_upper: float, in
           :param K_upper:     Upper limit stiffness when coordinate > q_upper
           :type q_lower: float, in
           :param q_lower:     Coordinate's lower limit value.
           :type K_lower: float, in
           :param K_lower:     Lower limit stiffness when coordinate < q_lower
           :type damping: float, in
           :param damping:     Damping factor when coordinate is beyond the limits
           :type dq: float, in
           :param dq:          Transition region (displacement) for force to be
                                       engaged.
           :type computeDissipationEnergy: boolean, in, optional
           :param computeDissipationEnergy:
                                       Whether to compute dissipated energy (false).


        |

        *Overload 3:*
        Convenience constructor.
           Generate a force that acts to limit the range of motion of a coordinate
           Force experienced at upper and lower limits of the coordinate (q) value
           is according to a linear stiffnesses K_upper and K_lower, with a C2 continuous
           transition from 0 to K. The transition parameter (dq) defines how far
           beyond the limit the stiffness becomes purely linear. The integrator will
           like smoother (i.e. larger transition regions).
           :type coordName: string, in
           :param coordName:   Coordinate whose range is to be limited.
           :type q_upper: float, in
           :param q_upper:     Coordinate's upper limit value.
           :type K_upper: float, in
           :param K_upper:     Upper limit stiffness when coordinate > q_upper
           :type q_lower: float, in
           :param q_lower:     Coordinate's lower limit value.
           :type K_lower: float, in
           :param K_lower:     Lower limit stiffness when coordinate < q_lower
           :type damping: float, in
           :param damping:     Damping factor when coordinate is beyond the limits
           :type dq: float, in
           :param dq:          Transition region (displacement) for force to be
                                       engaged.
           :param computeDissipationEnergy:
                                       Whether to compute dissipated energy (false).
        """
        _simulation.CoordinateLimitForce_swiginit(self, _simulation.new_CoordinateLimitForce(*args))
    __swig_destroy__ = _simulation.delete_CoordinateLimitForce

    def setUpperStiffness(self, aUpperStiffness):
        r"""
        Stiffness of the passive limit force when coordinate exceeds upper
           limit. Note, rotational stiffness expected in N*m/degree.
        """
        return _simulation.CoordinateLimitForce_setUpperStiffness(self, aUpperStiffness)

    def getUpperStiffness(self):
        r"""getUpperStiffness(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getUpperStiffness(self)

    def setUpperLimit(self, aUpperLimit):
        r""" Upper limit of the coordinate range of motion (rotations in degrees)."""
        return _simulation.CoordinateLimitForce_setUpperLimit(self, aUpperLimit)

    def getUpperLimit(self):
        r"""getUpperLimit(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getUpperLimit(self)

    def setLowerStiffness(self, aLowerStiffness):
        r"""
        Stiffness of the passive limit force when coordinate exceeds lower
           limit. Note, rotational stiffness expected in N*m/degree.
        """
        return _simulation.CoordinateLimitForce_setLowerStiffness(self, aLowerStiffness)

    def getLowerStiffness(self):
        r"""getLowerStiffness(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getLowerStiffness(self)

    def setLowerLimit(self, aLowerLimit):
        r""" Lower limit of the coordinate range of motion (rotations in degrees)."""
        return _simulation.CoordinateLimitForce_setLowerLimit(self, aLowerLimit)

    def getLowerLimit(self):
        r"""getLowerLimit(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getLowerLimit(self)

    def setDamping(self, aDamping):
        r"""
        Damping factor on the coordinate's speed applied only when limit is
           exceeded. For translational has units N/(m/s) and rotational has
           Nm/(degree/s).
        """
        return _simulation.CoordinateLimitForce_setDamping(self, aDamping)

    def getDamping(self):
        r"""getDamping(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getDamping(self)

    def setTransition(self, aTransition):
        r"""
        Transition region width with lengths is m and angles in degrees).
           Specifies the transition from zero to a constant stiffness as
           coordinate exceeds its limit.
        """
        return _simulation.CoordinateLimitForce_setTransition(self, aTransition)

    def getTransition(self):
        r"""getTransition(CoordinateLimitForce self) -> double"""
        return _simulation.CoordinateLimitForce_getTransition(self)

    def setComputeDissipationEnergy(self, flag):
        r"""
        Option to compute the dissipation energy due to damping in the
           CoordinateLimitForce. If true the dissipation power is automatically
           integrated to provide energy. Default is false.
        """
        return _simulation.CoordinateLimitForce_setComputeDissipationEnergy(self, flag)

    def isComputingDissipationEnergy(self):
        r"""isComputingDissipationEnergy(CoordinateLimitForce self) -> bool"""
        return _simulation.CoordinateLimitForce_isComputingDissipationEnergy(self)

    def getPowerDissipation(self, s):
        r"""
        Obtain the rate at which energy is being dissipated by this
           CoordinateLimit, that is, the power being lost. This is in units of
           energy/time which is watts in J/s.
           :type s: :py:class:`State`, in
           :param s:
                   The State from which to obtain the current value of the power
                   dissipation.
           :rtype: float
           :return: 
                   The dissipated power (a nonnegative scalar).
           See also: getDissipatedEnergy() for the time-integrated power loss *
        """
        return _simulation.CoordinateLimitForce_getPowerDissipation(self, s)

    def getDissipatedEnergy(self, s):
        r"""
        Obtain energy dissipated by this CoordinateLimitForce over time
           in units of energy in J.
           :type s: :py:class:`State`, in
           :param s:
                   The State from which to obtain the current value of
                   dissipated energy
           :rtype: float
           :return: 
                   The dissipated energy (a nonnegative scalar). *
        """
        return _simulation.CoordinateLimitForce_getDissipatedEnergy(self, s)

    def calcLimitForce(self, s):
        r""" Force calculation operator. *"""
        return _simulation.CoordinateLimitForce_calcLimitForce(self, s)

    def computePotentialEnergy(self, s):
        r"""
        Contribute this Force component's potential energy to the accounting
           of the total system energy. *
        """
        return _simulation.CoordinateLimitForce_computePotentialEnergy(self, s)

    def getRecordLabels(self):
        r"""
        Methods to query a Force for the value actually applied during simulation
        The names of quantities (column labels) are  returned by getRecordLabels()
        """
        return _simulation.CoordinateLimitForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report forces, application location
        frame, etc. used in conjunction with getRecordLabels and should return same size Array
        """
        return _simulation.CoordinateLimitForce_getRecordValues(self, state)

# Register CoordinateLimitForce in _simulation:
_simulation.CoordinateLimitForce_swigregister(CoordinateLimitForce)
class ContactGeometry(ModelComponent):
    r"""
     This class represents the physical shape of an object for use in contact
    modeling.  It is an abstract class, with subclasses for particular geometric
    representations. The geometry is attached to a PhysicalFrame, which is
    specified using a Socket named "frame".

    Note that ContactGeometry is not scaled with the Model.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ContactGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ContactGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ContactGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ContactGeometry_getClassName()

    def clone(self):
        r"""clone(ContactGeometry self) -> ContactGeometry"""
        return _simulation.ContactGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ContactGeometry self) -> std::string const &"""
        return _simulation.ContactGeometry_getConcreteClassName(self)

    def copyProperty_location(self, source):
        r"""
        copyProperty_location(ContactGeometry self, ContactGeometry source)

        Parameters
        ----------
        source: OpenSim::ContactGeometry::Self const &

        """
        return _simulation.ContactGeometry_copyProperty_location(self, source)

    def append_location(self, value):
        r"""
        append_location(ContactGeometry self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_append_location(self, value)

    def constructProperty_location(self, initValue):
        r"""
        constructProperty_location(ContactGeometry self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_constructProperty_location(self, initValue)

    def get_location(self, *args):
        r"""
        get_location(ContactGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location(ContactGeometry self) -> Vec3
        """
        return _simulation.ContactGeometry_get_location(self, *args)

    def upd_location(self, *args):
        r"""
        upd_location(ContactGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location(ContactGeometry self) -> Vec3
        """
        return _simulation.ContactGeometry_upd_location(self, *args)

    def set_location(self, *args):
        r"""
        set_location(ContactGeometry self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location(ContactGeometry self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_set_location(self, *args)

    def copyProperty_orientation(self, source):
        r"""
        copyProperty_orientation(ContactGeometry self, ContactGeometry source)

        Parameters
        ----------
        source: OpenSim::ContactGeometry::Self const &

        """
        return _simulation.ContactGeometry_copyProperty_orientation(self, source)

    def append_orientation(self, value):
        r"""
        append_orientation(ContactGeometry self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_append_orientation(self, value)

    def constructProperty_orientation(self, initValue):
        r"""
        constructProperty_orientation(ContactGeometry self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_constructProperty_orientation(self, initValue)

    def get_orientation(self, *args):
        r"""
        get_orientation(ContactGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_orientation(ContactGeometry self) -> Vec3
        """
        return _simulation.ContactGeometry_get_orientation(self, *args)

    def upd_orientation(self, *args):
        r"""
        upd_orientation(ContactGeometry self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_orientation(ContactGeometry self) -> Vec3
        """
        return _simulation.ContactGeometry_upd_orientation(self, *args)

    def set_orientation(self, *args):
        r"""
        set_orientation(ContactGeometry self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_orientation(ContactGeometry self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ContactGeometry_set_orientation(self, *args)

    def copyProperty_Appearance(self, source):
        r"""
        copyProperty_Appearance(ContactGeometry self, ContactGeometry source)

        Parameters
        ----------
        source: OpenSim::ContactGeometry::Self const &

        """
        return _simulation.ContactGeometry_copyProperty_Appearance(self, source)

    def append_Appearance(self, value):
        r"""
        append_Appearance(ContactGeometry self, Appearance value) -> int

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.ContactGeometry_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue):
        r"""
        constructProperty_Appearance(ContactGeometry self, Appearance initValue)

        Parameters
        ----------
        initValue: OpenSim::Appearance const &

        """
        return _simulation.ContactGeometry_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args):
        r"""
        get_Appearance(ContactGeometry self, int i) -> Appearance

        Parameters
        ----------
        i: int

        get_Appearance(ContactGeometry self) -> Appearance
        """
        return _simulation.ContactGeometry_get_Appearance(self, *args)

    def upd_Appearance(self, *args):
        r"""
        upd_Appearance(ContactGeometry self, int i) -> Appearance

        Parameters
        ----------
        i: int

        upd_Appearance(ContactGeometry self) -> Appearance
        """
        return _simulation.ContactGeometry_upd_Appearance(self, *args)

    def set_Appearance(self, *args):
        r"""
        set_Appearance(ContactGeometry self, int i, Appearance value)

        Parameters
        ----------
        i: int
        value: OpenSim::Appearance const &

        set_Appearance(ContactGeometry self, Appearance value)

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.ContactGeometry_set_Appearance(self, *args)
    PropertyIndex_socket_frame = property(_simulation.ContactGeometry_PropertyIndex_socket_frame_get, _simulation.ContactGeometry_PropertyIndex_socket_frame_set, doc=r"""PropertyIndex_socket_frame : OpenSim::PropertyIndex""")

    def connectSocket_frame(self, object):
        r"""
        connectSocket_frame(ContactGeometry self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.ContactGeometry_connectSocket_frame(self, object)

    def getFrame(self):
        r""" Get the PhysicalFrame this geometry is attached to."""
        return _simulation.ContactGeometry_getFrame(self)

    def setFrame(self, frame):
        r""" %Set the PhysicalFrame this geometry is attached to."""
        return _simulation.ContactGeometry_setFrame(self, frame)

    def createSimTKContactGeometry(self):
        r""" Create a new SimTK::ContactGeometry based on this object."""
        return _simulation.ContactGeometry_createSimTKContactGeometry(self)

    def getTransform(self):
        r"""
         Get a Transform representing the position and orientation of the
        geometry relative to the PhysicalFrame `F` to which this geometry is
        connected.

        If you want the transform of this geometry relative to the Frame (or
        Ground) `B` in which this geometry is fixed, you can use the following
        code:

        .. code-block:: c++

            const auto& X_BF = geom.getFrame().findTransformInBaseFrame();
            const auto X_FP = geom.getTransform();
            const auto X_BP = X_BF * X_FP;

        Prior to OpenSim 4.0, there wwas no intermediate PhysicalFrame `F`, so
        this method essentially returned `X_BP`.
        """
        return _simulation.ContactGeometry_getTransform(self)

    def scale(self, aScaleSet):
        r"""
        Scale a ContactGeometry based on XYZ scale factors for the bodies.

        :type aScaleSet: :py:class:`ScaleSet`
        :param aScaleSet: Set of XYZ scale factors for the bodies.
        """
        return _simulation.ContactGeometry_scale(self, aScaleSet)

    def getLocation(self):
        r""" **(Deprecated)** Use get_location() instead."""
        return _simulation.ContactGeometry_getLocation(self)

    def setLocation(self, location):
        r""" **(Deprecated)** Use set_location() instead."""
        return _simulation.ContactGeometry_setLocation(self, location)

    def getOrientation(self):
        r""" **(Deprecated)** Use get_orientation() instead."""
        return _simulation.ContactGeometry_getOrientation(self)

    def setOrientation(self, orientation):
        r""" **(Deprecated)** Use set_orientation() instead."""
        return _simulation.ContactGeometry_setOrientation(self, orientation)

    def getBody(self):
        r"""
         **(Deprecated)** Use getFrame() instead.
        Get the Body this geometry is attached to.
        """
        return _simulation.ContactGeometry_getBody(self)

    def setBody(self, body):
        r"""
         **(Deprecated)** Use setFrame() instead.
        %Set the Body this geometry is attached to.
        """
        return _simulation.ContactGeometry_setBody(self, body)
    __swig_destroy__ = _simulation.delete_ContactGeometry

# Register ContactGeometry in _simulation:
_simulation.ContactGeometry_swigregister(ContactGeometry)
class SetContactGeometry(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetContactGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetContactGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetContactGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetContactGeometry_getClassName()

    def clone(self):
        r"""clone(SetContactGeometry self) -> SetContactGeometry"""
        return _simulation.SetContactGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetContactGeometry self) -> std::string const &"""
        return _simulation.SetContactGeometry_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetContactGeometry

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ContactGeometry,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetContactGeometry_swiginit(self, _simulation.new_SetContactGeometry(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetContactGeometry_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetContactGeometry_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetContactGeometry_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetContactGeometry_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetContactGeometry_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetContactGeometry_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetContactGeometry self)"""
        return _simulation.SetContactGeometry_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ContactGeometry`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ContactGeometry`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetContactGeometry_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetContactGeometry_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetContactGeometry_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetContactGeometry_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetContactGeometry_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetContactGeometry_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetContactGeometry_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetContactGeometry_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetContactGeometry_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetContactGeometry_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetContactGeometry in _simulation:
_simulation.SetContactGeometry_swigregister(SetContactGeometry)
class ModelComponentSetContactGeometry(SetContactGeometry):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::ContactGeometry > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetContactGeometry

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetContactGeometry_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetContactGeometry self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetContactGeometry_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetContactGeometry self) -> ModelComponentSetContactGeometry"""
        return _simulation.ModelComponentSetContactGeometry_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetContactGeometry self) -> std::string const &"""
        return _simulation.ModelComponentSetContactGeometry_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetContactGeometry self)"""
        return _simulation.ModelComponentSetContactGeometry_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetContactGeometry self) -> ModelComponentSetContactGeometry"""
        _simulation.ModelComponentSetContactGeometry_swiginit(self, _simulation.new_ModelComponentSetContactGeometry())
    __swig_destroy__ = _simulation.delete_ModelComponentSetContactGeometry

# Register ModelComponentSetContactGeometry in _simulation:
_simulation.ModelComponentSetContactGeometry_swigregister(ModelComponentSetContactGeometry)
class ContactGeometrySet(ModelComponentSetContactGeometry):
    r"""
    A class for holding a set of ContactGeometry components.

    Authors: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ContactGeometrySet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ContactGeometrySet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ContactGeometrySet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ContactGeometrySet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ContactGeometrySet_getClassName()

    def clone(self):
        r"""clone(ContactGeometrySet self) -> ContactGeometrySet"""
        return _simulation.ContactGeometrySet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ContactGeometrySet self) -> std::string const &"""
        return _simulation.ContactGeometrySet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ContactGeometrySet self) -> ContactGeometrySet
        __init__(ContactGeometrySet self, std::string const & file, bool updateFromXML=True) -> ContactGeometrySet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.ContactGeometrySet_swiginit(self, _simulation.new_ContactGeometrySet(*args))
    __swig_destroy__ = _simulation.delete_ContactGeometrySet

# Register ContactGeometrySet in _simulation:
_simulation.ContactGeometrySet_swigregister(ContactGeometrySet)
class ContactHalfSpace(ContactGeometry):
    r"""
    This class represents a half space (that is, everything to one side of an
    infinite plane) for use in contact modeling.  In its local coordinate
    system, all points for which x>0 are considered to be inside the geometry.
    Its location and orientation properties can be used to move and rotate it to
    represent other half spaces.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ContactHalfSpace

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ContactHalfSpace_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ContactHalfSpace self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ContactHalfSpace_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ContactHalfSpace_getClassName()

    def clone(self):
        r"""clone(ContactHalfSpace self) -> ContactHalfSpace"""
        return _simulation.ContactHalfSpace_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ContactHalfSpace self) -> std::string const &"""
        return _simulation.ContactHalfSpace_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactHalfSpace.

        |

        *Overload 2:*

        Construct a ContactHalfSpace.  All points in its local coordinate system
        for which x>0 are considered to be inside the geometry.

        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to

        |

        *Overload 3:*

        Construct a ContactHalfSpace.  All points in its local coordinate system
        for which x>0 are considered to be inside the geometry.

        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactHalfSpace_swiginit(self, _simulation.new_ContactHalfSpace(*args))

    def createSimTKContactGeometry(self):
        r"""createSimTKContactGeometry(ContactHalfSpace self) -> SimTK::ContactGeometry"""
        return _simulation.ContactHalfSpace_createSimTKContactGeometry(self)

    def generateDecorations(self, fixed, hints, s, geometry):
        r"""
        generateDecorations(ContactHalfSpace self, bool fixed, ModelDisplayHints hints, State s, ArrayDecorativeGeometry geometry)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        s: SimTK::State const &
        geometry: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.ContactHalfSpace_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactHalfSpace

# Register ContactHalfSpace in _simulation:
_simulation.ContactHalfSpace_swigregister(ContactHalfSpace)
class ContactMesh(ContactGeometry):
    r"""
    This class represents a polygonal mesh for use in contact modeling.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ContactMesh

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ContactMesh_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ContactMesh self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ContactMesh_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ContactMesh_getClassName()

    def clone(self):
        r"""clone(ContactMesh self) -> ContactMesh"""
        return _simulation.ContactMesh_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ContactMesh self) -> std::string const &"""
        return _simulation.ContactMesh_getConcreteClassName(self)

    def copyProperty_filename(self, source):
        r"""
        copyProperty_filename(ContactMesh self, ContactMesh source)

        Parameters
        ----------
        source: OpenSim::ContactMesh::Self const &

        """
        return _simulation.ContactMesh_copyProperty_filename(self, source)

    def append_filename(self, value):
        r"""
        append_filename(ContactMesh self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ContactMesh_append_filename(self, value)

    def constructProperty_filename(self, initValue):
        r"""
        constructProperty_filename(ContactMesh self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ContactMesh_constructProperty_filename(self, initValue)

    def get_filename(self, *args):
        r"""
        get_filename(ContactMesh self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_filename(ContactMesh self) -> std::string const &
        """
        return _simulation.ContactMesh_get_filename(self, *args)

    def upd_filename(self, *args):
        r"""
        upd_filename(ContactMesh self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_filename(ContactMesh self) -> std::string &
        """
        return _simulation.ContactMesh_upd_filename(self, *args)

    def set_filename(self, *args):
        r"""
        set_filename(ContactMesh self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_filename(ContactMesh self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ContactMesh_set_filename(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactMesh.

        |

        *Overload 2:*

        Construct a ContactMesh.

        :type filename: string
        :param filename:     the name of the file to load the mesh from
        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to

        |

        *Overload 3:*

        Construct a ContactMesh.

        :type filename: string
        :param filename:     the name of the file to load the mesh from
        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactMesh_swiginit(self, _simulation.new_ContactMesh(*args))

    def createSimTKContactGeometry(self):
        r"""createSimTKContactGeometry(ContactMesh self) -> SimTK::ContactGeometry"""
        return _simulation.ContactMesh_createSimTKContactGeometry(self)

    def getFilename(self):
        r"""Get the name of the file the mesh is loaded from."""
        return _simulation.ContactMesh_getFilename(self)

    def setFilename(self, filename):
        r"""%Set the name of the file to load the mesh from."""
        return _simulation.ContactMesh_setFilename(self, filename)

    def generateDecorations(self, fixed, hints, s, geometry):
        r"""
        generateDecorations(ContactMesh self, bool fixed, ModelDisplayHints hints, State s, ArrayDecorativeGeometry geometry)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        s: SimTK::State const &
        geometry: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.ContactMesh_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactMesh

# Register ContactMesh in _simulation:
_simulation.ContactMesh_swigregister(ContactMesh)
class ContactSphere(ContactGeometry):
    r"""
    This class represents a spherical object for use in contact modeling.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ContactSphere

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ContactSphere_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ContactSphere self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ContactSphere_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ContactSphere_getClassName()

    def clone(self):
        r"""clone(ContactSphere self) -> ContactSphere"""
        return _simulation.ContactSphere_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ContactSphere self) -> std::string const &"""
        return _simulation.ContactSphere_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactSphere.

        |

        *Overload 2:*

        Construct a ContactSphere.

        :type radius: float
        :param radius:       the radius of the sphere
        :type location: :py:class:`Vec3`
        :param location:     the location of the center of the sphere expressed
                                in `frame`.
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this geometry is attached to;
                                this constructor connects this ContactSphere to
                                the provided `frame`.

        |

        *Overload 3:*

        Construct a ContactSphere.

        :type radius: float
        :param radius:       the radius of the sphere
        :type location: :py:class:`Vec3`
        :param location:     the location of the center of the sphere expressed
                                in `frame`.
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this geometry is attached to;
                                this constructor connects this ContactSphere to
                                the provided `frame`.
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactSphere_swiginit(self, _simulation.new_ContactSphere(*args))

    def createSimTKContactGeometry(self):
        r"""createSimTKContactGeometry(ContactSphere self) -> SimTK::ContactGeometry"""
        return _simulation.ContactSphere_createSimTKContactGeometry(self)

    def getRadius(self):
        r"""Get the radius of the sphere."""
        return _simulation.ContactSphere_getRadius(self)

    def setRadius(self, radius):
        r"""%Set the radius of the sphere."""
        return _simulation.ContactSphere_setRadius(self, radius)

    def generateDecorations(self, fixed, hints, s, geometry):
        r"""
        generateDecorations(ContactSphere self, bool fixed, ModelDisplayHints hints, State s, ArrayDecorativeGeometry geometry)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        s: SimTK::State const &
        geometry: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.ContactSphere_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactSphere

# Register ContactSphere in _simulation:
_simulation.ContactSphere_swigregister(ContactSphere)
class ElasticFoundationForce(Force):
    r"""
     This Force subclass implements an elastic foundation contact model. It
    places a spring at the center of each face of each ContactMesh it acts on.
    Those springs interact with all objects (both meshes and other objects) the
    mesh comes in contact with.

    Author: Peter Eastman *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ElasticFoundationForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ElasticFoundationForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ElasticFoundationForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ElasticFoundationForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ElasticFoundationForce_getClassName()

    def clone(self):
        r"""clone(ElasticFoundationForce self) -> ElasticFoundationForce"""
        return _simulation.ElasticFoundationForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ElasticFoundationForce self) -> std::string const &"""
        return _simulation.ElasticFoundationForce_getConcreteClassName(self)

    def copyProperty_contact_parameters(self, source):
        r"""
        copyProperty_contact_parameters(ElasticFoundationForce self, ElasticFoundationForce source)

        Parameters
        ----------
        source: OpenSim::ElasticFoundationForce::Self const &

        """
        return _simulation.ElasticFoundationForce_copyProperty_contact_parameters(self, source)

    def append_contact_parameters(self, value):
        r"""
        append_contact_parameters(ElasticFoundationForce self, OpenSim::ElasticFoundationForce::ContactParametersSet const & value) -> int

        Parameters
        ----------
        value: OpenSim::ElasticFoundationForce::ContactParametersSet const &

        """
        return _simulation.ElasticFoundationForce_append_contact_parameters(self, value)

    def constructProperty_contact_parameters(self, initValue):
        r"""
        constructProperty_contact_parameters(ElasticFoundationForce self, OpenSim::ElasticFoundationForce::ContactParametersSet const & initValue)

        Parameters
        ----------
        initValue: OpenSim::ElasticFoundationForce::ContactParametersSet const &

        """
        return _simulation.ElasticFoundationForce_constructProperty_contact_parameters(self, initValue)

    def get_contact_parameters(self, *args):
        r"""
        get_contact_parameters(ElasticFoundationForce self, int i) -> OpenSim::ElasticFoundationForce::ContactParametersSet const

        Parameters
        ----------
        i: int

        get_contact_parameters(ElasticFoundationForce self) -> OpenSim::ElasticFoundationForce::ContactParametersSet const &
        """
        return _simulation.ElasticFoundationForce_get_contact_parameters(self, *args)

    def upd_contact_parameters(self, *args):
        r"""
        upd_contact_parameters(ElasticFoundationForce self, int i) -> OpenSim::ElasticFoundationForce::ContactParametersSet

        Parameters
        ----------
        i: int

        upd_contact_parameters(ElasticFoundationForce self) -> OpenSim::ElasticFoundationForce::ContactParametersSet &
        """
        return _simulation.ElasticFoundationForce_upd_contact_parameters(self, *args)

    def set_contact_parameters(self, *args):
        r"""
        set_contact_parameters(ElasticFoundationForce self, int i, OpenSim::ElasticFoundationForce::ContactParametersSet const & value)

        Parameters
        ----------
        i: int
        value: OpenSim::ElasticFoundationForce::ContactParametersSet const &

        set_contact_parameters(ElasticFoundationForce self, OpenSim::ElasticFoundationForce::ContactParametersSet const & value)

        Parameters
        ----------
        value: OpenSim::ElasticFoundationForce::ContactParametersSet const &

        """
        return _simulation.ElasticFoundationForce_set_contact_parameters(self, *args)

    def copyProperty_transition_velocity(self, source):
        r"""
        copyProperty_transition_velocity(ElasticFoundationForce self, ElasticFoundationForce source)

        Parameters
        ----------
        source: OpenSim::ElasticFoundationForce::Self const &

        """
        return _simulation.ElasticFoundationForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value):
        r"""
        append_transition_velocity(ElasticFoundationForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ElasticFoundationForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue):
        r"""
        constructProperty_transition_velocity(ElasticFoundationForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ElasticFoundationForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args):
        r"""
        get_transition_velocity(ElasticFoundationForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition_velocity(ElasticFoundationForce self) -> double const &
        """
        return _simulation.ElasticFoundationForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args):
        r"""
        upd_transition_velocity(ElasticFoundationForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition_velocity(ElasticFoundationForce self) -> double &
        """
        return _simulation.ElasticFoundationForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args):
        r"""
        set_transition_velocity(ElasticFoundationForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition_velocity(ElasticFoundationForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ElasticFoundationForce_set_transition_velocity(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ElasticFoundationForce self) -> ElasticFoundationForce
        __init__(ElasticFoundationForce self, OpenSim::ElasticFoundationForce::ContactParameters * params) -> ElasticFoundationForce

        Parameters
        ----------
        params: OpenSim::ElasticFoundationForce::ContactParameters *

        """
        _simulation.ElasticFoundationForce_swiginit(self, _simulation.new_ElasticFoundationForce(*args))

    def extendAddToSystem(self, system):
        r"""Create a SimTK::Force which implements this Force."""
        return _simulation.ElasticFoundationForce_extendAddToSystem(self, system)

    def updContactParametersSet(self):
        r"""updContactParametersSet(ElasticFoundationForce self) -> OpenSim::ElasticFoundationForce::ContactParametersSet &"""
        return _simulation.ElasticFoundationForce_updContactParametersSet(self)

    def getContactParametersSet(self):
        r"""getContactParametersSet(ElasticFoundationForce self) -> OpenSim::ElasticFoundationForce::ContactParametersSet const &"""
        return _simulation.ElasticFoundationForce_getContactParametersSet(self)

    def addContactParameters(self, params):
        r""" Takes over ownership of the passed-in object. *"""
        return _simulation.ElasticFoundationForce_addContactParameters(self, params)

    def getTransitionVelocity(self):
        r"""Get the transition velocity for switching between static and dynamic friction."""
        return _simulation.ElasticFoundationForce_getTransitionVelocity(self)

    def setTransitionVelocity(self, velocity):
        r"""%Set the transition velocity for switching between static and dynamic friction."""
        return _simulation.ElasticFoundationForce_setTransitionVelocity(self, velocity)

    def getStiffness(self):
        r"""Access to ContactParameters. Methods assume size 1 of ContactParametersSet and add one ContactParameter if needed"""
        return _simulation.ElasticFoundationForce_getStiffness(self)

    def setStiffness(self, stiffness):
        r"""
        setStiffness(ElasticFoundationForce self, double stiffness)

        Parameters
        ----------
        stiffness: double

        """
        return _simulation.ElasticFoundationForce_setStiffness(self, stiffness)

    def getDissipation(self):
        r"""getDissipation(ElasticFoundationForce self) -> double"""
        return _simulation.ElasticFoundationForce_getDissipation(self)

    def setDissipation(self, dissipation):
        r"""
        setDissipation(ElasticFoundationForce self, double dissipation)

        Parameters
        ----------
        dissipation: double

        """
        return _simulation.ElasticFoundationForce_setDissipation(self, dissipation)

    def getStaticFriction(self):
        r"""getStaticFriction(ElasticFoundationForce self) -> double"""
        return _simulation.ElasticFoundationForce_getStaticFriction(self)

    def setStaticFriction(self, friction):
        r"""
        setStaticFriction(ElasticFoundationForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.ElasticFoundationForce_setStaticFriction(self, friction)

    def getDynamicFriction(self):
        r"""getDynamicFriction(ElasticFoundationForce self) -> double"""
        return _simulation.ElasticFoundationForce_getDynamicFriction(self)

    def setDynamicFriction(self, friction):
        r"""
        setDynamicFriction(ElasticFoundationForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.ElasticFoundationForce_setDynamicFriction(self, friction)

    def getViscousFriction(self):
        r"""getViscousFriction(ElasticFoundationForce self) -> double"""
        return _simulation.ElasticFoundationForce_getViscousFriction(self)

    def setViscousFriction(self, friction):
        r"""
        setViscousFriction(ElasticFoundationForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.ElasticFoundationForce_setViscousFriction(self, friction)

    def addGeometry(self, name):
        r"""
        addGeometry(ElasticFoundationForce self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.ElasticFoundationForce_addGeometry(self, name)

    def getRecordLabels(self):
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ElasticFoundationForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ElasticFoundationForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ElasticFoundationForce

# Register ElasticFoundationForce in _simulation:
_simulation.ElasticFoundationForce_swigregister(ElasticFoundationForce)
class HuntCrossleyForce(Force):
    r"""
     This force subclass implements a Hunt-Crossley contact model. It uses Hertz
    contact theory to model the interactions between a set of ContactSpheres and
    ContactHalfSpaces.

    Author: Peter Eastman *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> HuntCrossleyForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.HuntCrossleyForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(HuntCrossleyForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.HuntCrossleyForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.HuntCrossleyForce_getClassName()

    def clone(self):
        r"""clone(HuntCrossleyForce self) -> HuntCrossleyForce"""
        return _simulation.HuntCrossleyForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(HuntCrossleyForce self) -> std::string const &"""
        return _simulation.HuntCrossleyForce_getConcreteClassName(self)

    def copyProperty_contact_parameters(self, source):
        r"""
        copyProperty_contact_parameters(HuntCrossleyForce self, HuntCrossleyForce source)

        Parameters
        ----------
        source: OpenSim::HuntCrossleyForce::Self const &

        """
        return _simulation.HuntCrossleyForce_copyProperty_contact_parameters(self, source)

    def append_contact_parameters(self, value):
        r"""
        append_contact_parameters(HuntCrossleyForce self, OpenSim::HuntCrossleyForce::ContactParametersSet const & value) -> int

        Parameters
        ----------
        value: OpenSim::HuntCrossleyForce::ContactParametersSet const &

        """
        return _simulation.HuntCrossleyForce_append_contact_parameters(self, value)

    def constructProperty_contact_parameters(self, initValue):
        r"""
        constructProperty_contact_parameters(HuntCrossleyForce self, OpenSim::HuntCrossleyForce::ContactParametersSet const & initValue)

        Parameters
        ----------
        initValue: OpenSim::HuntCrossleyForce::ContactParametersSet const &

        """
        return _simulation.HuntCrossleyForce_constructProperty_contact_parameters(self, initValue)

    def get_contact_parameters(self, *args):
        r"""
        get_contact_parameters(HuntCrossleyForce self, int i) -> OpenSim::HuntCrossleyForce::ContactParametersSet const

        Parameters
        ----------
        i: int

        get_contact_parameters(HuntCrossleyForce self) -> OpenSim::HuntCrossleyForce::ContactParametersSet const &
        """
        return _simulation.HuntCrossleyForce_get_contact_parameters(self, *args)

    def upd_contact_parameters(self, *args):
        r"""
        upd_contact_parameters(HuntCrossleyForce self, int i) -> OpenSim::HuntCrossleyForce::ContactParametersSet

        Parameters
        ----------
        i: int

        upd_contact_parameters(HuntCrossleyForce self) -> OpenSim::HuntCrossleyForce::ContactParametersSet &
        """
        return _simulation.HuntCrossleyForce_upd_contact_parameters(self, *args)

    def set_contact_parameters(self, *args):
        r"""
        set_contact_parameters(HuntCrossleyForce self, int i, OpenSim::HuntCrossleyForce::ContactParametersSet const & value)

        Parameters
        ----------
        i: int
        value: OpenSim::HuntCrossleyForce::ContactParametersSet const &

        set_contact_parameters(HuntCrossleyForce self, OpenSim::HuntCrossleyForce::ContactParametersSet const & value)

        Parameters
        ----------
        value: OpenSim::HuntCrossleyForce::ContactParametersSet const &

        """
        return _simulation.HuntCrossleyForce_set_contact_parameters(self, *args)

    def copyProperty_transition_velocity(self, source):
        r"""
        copyProperty_transition_velocity(HuntCrossleyForce self, HuntCrossleyForce source)

        Parameters
        ----------
        source: OpenSim::HuntCrossleyForce::Self const &

        """
        return _simulation.HuntCrossleyForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value):
        r"""
        append_transition_velocity(HuntCrossleyForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.HuntCrossleyForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue):
        r"""
        constructProperty_transition_velocity(HuntCrossleyForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.HuntCrossleyForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args):
        r"""
        get_transition_velocity(HuntCrossleyForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition_velocity(HuntCrossleyForce self) -> double const &
        """
        return _simulation.HuntCrossleyForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args):
        r"""
        upd_transition_velocity(HuntCrossleyForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition_velocity(HuntCrossleyForce self) -> double &
        """
        return _simulation.HuntCrossleyForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args):
        r"""
        set_transition_velocity(HuntCrossleyForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition_velocity(HuntCrossleyForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.HuntCrossleyForce_set_transition_velocity(self, *args)

    def __init__(self):
        r"""__init__(HuntCrossleyForce self) -> HuntCrossleyForce"""
        _simulation.HuntCrossleyForce_swiginit(self, _simulation.new_HuntCrossleyForce())

    def updContactParametersSet(self):
        r"""updContactParametersSet(HuntCrossleyForce self) -> OpenSim::HuntCrossleyForce::ContactParametersSet &"""
        return _simulation.HuntCrossleyForce_updContactParametersSet(self)

    def getContactParametersSet(self):
        r"""getContactParametersSet(HuntCrossleyForce self) -> OpenSim::HuntCrossleyForce::ContactParametersSet const &"""
        return _simulation.HuntCrossleyForce_getContactParametersSet(self)

    def addContactParameters(self, params):
        r""" Takes over ownership of the passed-in object. *"""
        return _simulation.HuntCrossleyForce_addContactParameters(self, params)

    def getTransitionVelocity(self):
        r"""Get the transition velocity for switching between static and dynamic friction."""
        return _simulation.HuntCrossleyForce_getTransitionVelocity(self)

    def setTransitionVelocity(self, velocity):
        r"""%Set the transition velocity for switching between static and dynamic friction."""
        return _simulation.HuntCrossleyForce_setTransitionVelocity(self, velocity)

    def getStiffness(self):
        r"""Access to ContactParameters. Methods assume size 1 of ContactParametersSet and add one ContactParameter if needed"""
        return _simulation.HuntCrossleyForce_getStiffness(self)

    def setStiffness(self, stiffness):
        r"""
        setStiffness(HuntCrossleyForce self, double stiffness)

        Parameters
        ----------
        stiffness: double

        """
        return _simulation.HuntCrossleyForce_setStiffness(self, stiffness)

    def getDissipation(self):
        r"""getDissipation(HuntCrossleyForce self) -> double"""
        return _simulation.HuntCrossleyForce_getDissipation(self)

    def setDissipation(self, dissipation):
        r"""
        setDissipation(HuntCrossleyForce self, double dissipation)

        Parameters
        ----------
        dissipation: double

        """
        return _simulation.HuntCrossleyForce_setDissipation(self, dissipation)

    def getStaticFriction(self):
        r"""getStaticFriction(HuntCrossleyForce self) -> double"""
        return _simulation.HuntCrossleyForce_getStaticFriction(self)

    def setStaticFriction(self, friction):
        r"""
        setStaticFriction(HuntCrossleyForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.HuntCrossleyForce_setStaticFriction(self, friction)

    def getDynamicFriction(self):
        r"""getDynamicFriction(HuntCrossleyForce self) -> double"""
        return _simulation.HuntCrossleyForce_getDynamicFriction(self)

    def setDynamicFriction(self, friction):
        r"""
        setDynamicFriction(HuntCrossleyForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.HuntCrossleyForce_setDynamicFriction(self, friction)

    def getViscousFriction(self):
        r"""getViscousFriction(HuntCrossleyForce self) -> double"""
        return _simulation.HuntCrossleyForce_getViscousFriction(self)

    def setViscousFriction(self, friction):
        r"""
        setViscousFriction(HuntCrossleyForce self, double friction)

        Parameters
        ----------
        friction: double

        """
        return _simulation.HuntCrossleyForce_setViscousFriction(self, friction)

    def addGeometry(self, name):
        r"""
        addGeometry(HuntCrossleyForce self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.HuntCrossleyForce_addGeometry(self, name)

    def getRecordLabels(self):
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.HuntCrossleyForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.HuntCrossleyForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_HuntCrossleyForce

# Register HuntCrossleyForce in _simulation:
_simulation.HuntCrossleyForce_swigregister(HuntCrossleyForce)
class SmoothSphereHalfSpaceForce(Force):
    r"""
     This compliant contact force model is similar to HuntCrossleyForce, except
    that this model applies force even when not in contact. Unlike
    HuntCrossleyForce, the normal force is differentiable as a function of
    penetration depth. This component is designed for use in gradient-based
    optimizations, in which the model is required to be differentiable. This
    component models contact between a single sphere and a single half space.
    This force uses a ContactSphere (via the Socket 'sphere') and a ContactHalfSpace
    (via the Socket 'half_space') to define the contact geometry.



    This force applies a constant contact force even when the sphere and half-space
    are not contacting. This constant force is set with the constant_contact_force
    property. Its default value is appropriate for walking; the value may need to
    be adjusted for different contact scenarios or models with a very light mass.

    See also: SimTK::SmoothSphereHalfSpaceForce

    The graph below compares the smooth approximation of the Hertz force to that
    from HuntCrossleyForce.

     <style>div.image
    img[src="SmoothSphereHalfSpaceForce_HertzForce.png"]{width:750px;}</style>

    Image: SmoothSphereHalfSpaceForce_HertzForce.png("Curves produced using E=1e6, R=0.8, cf=1e-5, and bd=300")

    The graph below compares the smooth approximation of the dissipative force to
     that from HuntCrossleyForce.

     <style>div.image
    img[src="SmoothSphereHalfSpaceForce_HuntCrossleyForce.png"]{width:750px;}</style>

    Image: SmoothSphereHalfSpaceForce_HuntCrossleyForce.png("Curves produced using x=0.1, E=1e6, R=0.8, c=2, cf=1e-5, bd=300, and bv=50")

    Serrancoli, G., Falisse, A., Dembia, C., Vantilt, J., Tanghe, K., Lefeber, D.,
    Jonkers, I., De Schutter, J., De Groote, F. (2019). Subject-exoskeleton contact
    model calibration leads to accurate interaction force predictions. IEEE
    Transactions on Neural Systems and Rehabilitation Engineering, 1–1.
    doi:10.1109/tnsre.2019.2924536
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SmoothSphereHalfSpaceForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SmoothSphereHalfSpaceForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SmoothSphereHalfSpaceForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SmoothSphereHalfSpaceForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SmoothSphereHalfSpaceForce_getClassName()

    def clone(self):
        r"""clone(SmoothSphereHalfSpaceForce self) -> SmoothSphereHalfSpaceForce"""
        return _simulation.SmoothSphereHalfSpaceForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SmoothSphereHalfSpaceForce self) -> std::string const &"""
        return _simulation.SmoothSphereHalfSpaceForce_getConcreteClassName(self)

    def copyProperty_stiffness(self, source):
        r"""
        copyProperty_stiffness(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_stiffness(self, source)

    def append_stiffness(self, value):
        r"""
        append_stiffness(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue):
        r"""
        constructProperty_stiffness(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args):
        r"""
        get_stiffness(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_stiffness(self, *args)

    def upd_stiffness(self, *args):
        r"""
        upd_stiffness(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_stiffness(self, *args)

    def set_stiffness(self, *args):
        r"""
        set_stiffness(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source):
        r"""
        copyProperty_dissipation(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_dissipation(self, source)

    def append_dissipation(self, value):
        r"""
        append_dissipation(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue):
        r"""
        constructProperty_dissipation(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args):
        r"""
        get_dissipation(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_dissipation(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_dissipation(self, *args)

    def upd_dissipation(self, *args):
        r"""
        upd_dissipation(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_dissipation(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_dissipation(self, *args)

    def set_dissipation(self, *args):
        r"""
        set_dissipation(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_dissipation(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_dissipation(self, *args)

    def copyProperty_static_friction(self, source):
        r"""
        copyProperty_static_friction(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_static_friction(self, source)

    def append_static_friction(self, value):
        r"""
        append_static_friction(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_static_friction(self, value)

    def constructProperty_static_friction(self, initValue):
        r"""
        constructProperty_static_friction(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_static_friction(self, initValue)

    def get_static_friction(self, *args):
        r"""
        get_static_friction(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_static_friction(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_static_friction(self, *args)

    def upd_static_friction(self, *args):
        r"""
        upd_static_friction(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_static_friction(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_static_friction(self, *args)

    def set_static_friction(self, *args):
        r"""
        set_static_friction(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_static_friction(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_static_friction(self, *args)

    def copyProperty_dynamic_friction(self, source):
        r"""
        copyProperty_dynamic_friction(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_dynamic_friction(self, source)

    def append_dynamic_friction(self, value):
        r"""
        append_dynamic_friction(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_dynamic_friction(self, value)

    def constructProperty_dynamic_friction(self, initValue):
        r"""
        constructProperty_dynamic_friction(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_dynamic_friction(self, initValue)

    def get_dynamic_friction(self, *args):
        r"""
        get_dynamic_friction(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_dynamic_friction(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_dynamic_friction(self, *args)

    def upd_dynamic_friction(self, *args):
        r"""
        upd_dynamic_friction(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_dynamic_friction(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_dynamic_friction(self, *args)

    def set_dynamic_friction(self, *args):
        r"""
        set_dynamic_friction(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_dynamic_friction(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_dynamic_friction(self, *args)

    def copyProperty_viscous_friction(self, source):
        r"""
        copyProperty_viscous_friction(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_viscous_friction(self, source)

    def append_viscous_friction(self, value):
        r"""
        append_viscous_friction(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_viscous_friction(self, value)

    def constructProperty_viscous_friction(self, initValue):
        r"""
        constructProperty_viscous_friction(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_viscous_friction(self, initValue)

    def get_viscous_friction(self, *args):
        r"""
        get_viscous_friction(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_viscous_friction(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_viscous_friction(self, *args)

    def upd_viscous_friction(self, *args):
        r"""
        upd_viscous_friction(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_viscous_friction(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_viscous_friction(self, *args)

    def set_viscous_friction(self, *args):
        r"""
        set_viscous_friction(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_viscous_friction(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_viscous_friction(self, *args)

    def copyProperty_transition_velocity(self, source):
        r"""
        copyProperty_transition_velocity(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value):
        r"""
        append_transition_velocity(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue):
        r"""
        constructProperty_transition_velocity(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args):
        r"""
        get_transition_velocity(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition_velocity(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args):
        r"""
        upd_transition_velocity(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition_velocity(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args):
        r"""
        set_transition_velocity(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition_velocity(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_transition_velocity(self, *args)

    def copyProperty_constant_contact_force(self, source):
        r"""
        copyProperty_constant_contact_force(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_constant_contact_force(self, source)

    def append_constant_contact_force(self, value):
        r"""
        append_constant_contact_force(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_constant_contact_force(self, value)

    def constructProperty_constant_contact_force(self, initValue):
        r"""
        constructProperty_constant_contact_force(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_constant_contact_force(self, initValue)

    def get_constant_contact_force(self, *args):
        r"""
        get_constant_contact_force(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_constant_contact_force(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_constant_contact_force(self, *args)

    def upd_constant_contact_force(self, *args):
        r"""
        upd_constant_contact_force(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_constant_contact_force(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_constant_contact_force(self, *args)

    def set_constant_contact_force(self, *args):
        r"""
        set_constant_contact_force(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_constant_contact_force(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_constant_contact_force(self, *args)

    def copyProperty_hertz_smoothing(self, source):
        r"""
        copyProperty_hertz_smoothing(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_hertz_smoothing(self, source)

    def append_hertz_smoothing(self, value):
        r"""
        append_hertz_smoothing(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_hertz_smoothing(self, value)

    def constructProperty_hertz_smoothing(self, initValue):
        r"""
        constructProperty_hertz_smoothing(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_hertz_smoothing(self, initValue)

    def get_hertz_smoothing(self, *args):
        r"""
        get_hertz_smoothing(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_hertz_smoothing(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_hertz_smoothing(self, *args)

    def upd_hertz_smoothing(self, *args):
        r"""
        upd_hertz_smoothing(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_hertz_smoothing(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_hertz_smoothing(self, *args)

    def set_hertz_smoothing(self, *args):
        r"""
        set_hertz_smoothing(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_hertz_smoothing(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_hertz_smoothing(self, *args)

    def copyProperty_hunt_crossley_smoothing(self, source):
        r"""
        copyProperty_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_hunt_crossley_smoothing(self, source)

    def append_hunt_crossley_smoothing(self, value):
        r"""
        append_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_hunt_crossley_smoothing(self, value)

    def constructProperty_hunt_crossley_smoothing(self, initValue):
        r"""
        constructProperty_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_hunt_crossley_smoothing(self, initValue)

    def get_hunt_crossley_smoothing(self, *args):
        r"""
        get_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_hunt_crossley_smoothing(self, *args)

    def upd_hunt_crossley_smoothing(self, *args):
        r"""
        upd_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_hunt_crossley_smoothing(self, *args)

    def set_hunt_crossley_smoothing(self, *args):
        r"""
        set_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_hunt_crossley_smoothing(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_hunt_crossley_smoothing(self, *args)

    def copyProperty_force_visualization_radius(self, source):
        r"""
        copyProperty_force_visualization_radius(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_force_visualization_radius(self, source)

    def append_force_visualization_radius(self, value):
        r"""
        append_force_visualization_radius(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_force_visualization_radius(self, value)

    def constructProperty_force_visualization_radius(self, initValue):
        r"""
        constructProperty_force_visualization_radius(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_force_visualization_radius(self, initValue)

    def get_force_visualization_radius(self, *args):
        r"""
        get_force_visualization_radius(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_force_visualization_radius(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_force_visualization_radius(self, *args)

    def upd_force_visualization_radius(self, *args):
        r"""
        upd_force_visualization_radius(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_force_visualization_radius(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_force_visualization_radius(self, *args)

    def set_force_visualization_radius(self, *args):
        r"""
        set_force_visualization_radius(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_force_visualization_radius(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_force_visualization_radius(self, *args)

    def copyProperty_force_visualization_scale_factor(self, source):
        r"""
        copyProperty_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, SmoothSphereHalfSpaceForce source)

        Parameters
        ----------
        source: OpenSim::SmoothSphereHalfSpaceForce::Self const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_force_visualization_scale_factor(self, source)

    def append_force_visualization_scale_factor(self, value):
        r"""
        append_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_append_force_visualization_scale_factor(self, value)

    def constructProperty_force_visualization_scale_factor(self, *args):
        r"""
        constructProperty_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self)
        constructProperty_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_force_visualization_scale_factor(self, *args)

    def get_force_visualization_scale_factor(self, *args):
        r"""
        get_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self) -> double const &
        """
        return _simulation.SmoothSphereHalfSpaceForce_get_force_visualization_scale_factor(self, *args)

    def upd_force_visualization_scale_factor(self, *args):
        r"""
        upd_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self) -> double &
        """
        return _simulation.SmoothSphereHalfSpaceForce_upd_force_visualization_scale_factor(self, *args)

    def set_force_visualization_scale_factor(self, *args):
        r"""
        set_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_force_visualization_scale_factor(SmoothSphereHalfSpaceForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_set_force_visualization_scale_factor(self, *args)
    PropertyIndex_socket_sphere = property(_simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_sphere_get, _simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_sphere_set, doc=r"""PropertyIndex_socket_sphere : OpenSim::PropertyIndex""")

    def connectSocket_sphere(self, object):
        r"""
        connectSocket_sphere(SmoothSphereHalfSpaceForce self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_connectSocket_sphere(self, object)
    PropertyIndex_socket_half_space = property(_simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_half_space_get, _simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_half_space_set, doc=r"""PropertyIndex_socket_half_space : OpenSim::PropertyIndex""")

    def connectSocket_half_space(self, object):
        r"""
        connectSocket_half_space(SmoothSphereHalfSpaceForce self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.SmoothSphereHalfSpaceForce_connectSocket_half_space(self, object)
    _has_output_sphere_force = property(_simulation.SmoothSphereHalfSpaceForce__has_output_sphere_force_get, _simulation.SmoothSphereHalfSpaceForce__has_output_sphere_force_set, doc=r"""_has_output_sphere_force : bool""")
    _has_output_half_space_force = property(_simulation.SmoothSphereHalfSpaceForce__has_output_half_space_force_get, _simulation.SmoothSphereHalfSpaceForce__has_output_half_space_force_set, doc=r"""_has_output_half_space_force : bool""")

    def __init__(self, *args):
        r"""
        __init__(SmoothSphereHalfSpaceForce self) -> SmoothSphereHalfSpaceForce
        __init__(SmoothSphereHalfSpaceForce self, std::string const & name, ContactSphere contactSphere, ContactHalfSpace contactHalfSpace) -> SmoothSphereHalfSpaceForce

        Parameters
        ----------
        name: std::string const &
        contactSphere: OpenSim::ContactSphere const &
        contactHalfSpace: OpenSim::ContactHalfSpace const &

        """
        _simulation.SmoothSphereHalfSpaceForce_swiginit(self, _simulation.new_SmoothSphereHalfSpaceForce(*args))

    def getRecordLabels(self):
        r"""
        Obtain names of the quantities (column labels) of the force values to
        be reported. The order is the three forces (XYZ) and three torques (XYZ)
        applied on the sphere followed by the three forces (XYZ) and three
        torques (XYZ) applied on the half space. Forces and torques are
        expressed in the ground frame.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Obtain the values to be reported that correspond to the labels. The
        values are expressed in the ground frame.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getRecordValues(self, state)

    def getSphereForce(self, s):
        r"""
        Get a SimTK::SpatialVec containing the forces and torques applied to
        the contact sphere.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getSphereForce(self, s)

    def getHalfSpaceForce(self, s):
        r"""
        Get a SimTK::SpatialVec containing the forces and torques applied to
        the contact half space.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getHalfSpaceForce(self, s)
    __swig_destroy__ = _simulation.delete_SmoothSphereHalfSpaceForce

# Register SmoothSphereHalfSpaceForce in _simulation:
_simulation.SmoothSphereHalfSpaceForce_swigregister(SmoothSphereHalfSpaceForce)
class Actuator(ForceProducer):
    r"""
    Base class for an actuator (e.g., a torque motor, muscle, ...) that requires
    a generic external input (a vector of controls) to generate force. This class
    therefore covers scalarActautor as a special case with scalar control value.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Actuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Actuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Actuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Actuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Actuator_getClassName()

    def clone(self):
        r"""clone(Actuator self) -> Actuator"""
        return _simulation.Actuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Actuator self) -> std::string const &"""
        return _simulation.Actuator_getConcreteClassName(self)

    def numControls(self):
        r"""numControls(Actuator self) -> int"""
        return _simulation.Actuator_numControls(self)

    def getDefaultControls(self):
        r""" Actuator default controls are zero"""
        return _simulation.Actuator_getDefaultControls(self)

    def getControls(self, modelControls, actuatorControls):
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Actuator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls, modelControls):
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Actuator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls, modelControls):
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Actuator_addInControls(self, actuatorControls, modelControls)

    def getPower(self, s):
        r"""
        getPower(Actuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Actuator_getPower(self, s)

    def computeEquilibrium(self, s):
        r"""
        computeEquilibrium(Actuator self, State s)

        Parameters
        ----------
        s: SimTK::State &

        """
        return _simulation.Actuator_computeEquilibrium(self, s)
    __swig_destroy__ = _simulation.delete_Actuator

# Register Actuator in _simulation:
_simulation.Actuator_swigregister(Actuator)
class ScalarActuator(Actuator):
    r"""
    This is a derived class from the base class actuator (e.g., a torque motor,
    muscle, ...) that requires exactly one external input (control) to generate
    a scalar value force, such as a torque/force magnitude or a tension.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ScalarActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ScalarActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ScalarActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ScalarActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ScalarActuator_getClassName()

    def clone(self):
        r"""clone(ScalarActuator self) -> ScalarActuator"""
        return _simulation.ScalarActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ScalarActuator self) -> std::string const &"""
        return _simulation.ScalarActuator_getConcreteClassName(self)

    def copyProperty_min_control(self, source):
        r""" Default is -Infinity (no limit). *"""
        return _simulation.ScalarActuator_copyProperty_min_control(self, source)

    def append_min_control(self, value):
        r"""
        append_min_control(ScalarActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScalarActuator_append_min_control(self, value)

    def constructProperty_min_control(self, initValue):
        r"""
        constructProperty_min_control(ScalarActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ScalarActuator_constructProperty_min_control(self, initValue)

    def get_min_control(self, *args):
        r"""
        get_min_control(ScalarActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_min_control(ScalarActuator self) -> double const &
        """
        return _simulation.ScalarActuator_get_min_control(self, *args)

    def upd_min_control(self, *args):
        r"""
        upd_min_control(ScalarActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_min_control(ScalarActuator self) -> double &
        """
        return _simulation.ScalarActuator_upd_min_control(self, *args)

    def set_min_control(self, *args):
        r"""
        set_min_control(ScalarActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_min_control(ScalarActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScalarActuator_set_min_control(self, *args)

    def copyProperty_max_control(self, source):
        r""" Default is Infinity (no limit). *"""
        return _simulation.ScalarActuator_copyProperty_max_control(self, source)

    def append_max_control(self, value):
        r"""
        append_max_control(ScalarActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScalarActuator_append_max_control(self, value)

    def constructProperty_max_control(self, initValue):
        r"""
        constructProperty_max_control(ScalarActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ScalarActuator_constructProperty_max_control(self, initValue)

    def get_max_control(self, *args):
        r"""
        get_max_control(ScalarActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_control(ScalarActuator self) -> double const &
        """
        return _simulation.ScalarActuator_get_max_control(self, *args)

    def upd_max_control(self, *args):
        r"""
        upd_max_control(ScalarActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_control(ScalarActuator self) -> double &
        """
        return _simulation.ScalarActuator_upd_max_control(self, *args)

    def set_max_control(self, *args):
        r"""
        set_max_control(ScalarActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_control(ScalarActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ScalarActuator_set_max_control(self, *args)
    _has_output_actuation = property(_simulation.ScalarActuator__has_output_actuation_get, _simulation.ScalarActuator__has_output_actuation_set, doc=r"""_has_output_actuation : bool""")
    _has_output_speed = property(_simulation.ScalarActuator__has_output_speed_get, _simulation.ScalarActuator__has_output_speed_set, doc=r"""_has_output_speed : bool""")

    def getControl(self, s):
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.ScalarActuator_getControl(self, s)

    def numControls(self):
        r"""numControls(ScalarActuator self) -> int"""
        return _simulation.ScalarActuator_numControls(self)

    def setActuation(self, s, aActuation):
        r"""
        setActuation(ScalarActuator self, State s, double aActuation)

        Parameters
        ----------
        s: SimTK::State const &
        aActuation: double

        """
        return _simulation.ScalarActuator_setActuation(self, s, aActuation)

    def getActuation(self, s):
        r"""
        getActuation(ScalarActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ScalarActuator_getActuation(self, s)

    def getSpeed(self, s):
        r"""
        getSpeed(ScalarActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ScalarActuator_getSpeed(self, s)

    def getPower(self, s):
        r"""
        getPower(ScalarActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ScalarActuator_getPower(self, s)

    def getStress(self, s):
        r"""
        getStress(ScalarActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ScalarActuator_getStress(self, s)

    def getOptimalForce(self):
        r"""getOptimalForce(ScalarActuator self) -> double"""
        return _simulation.ScalarActuator_getOptimalForce(self)

    def setMinControl(self, aMinControl):
        r""" Methods to manage the bounds on ScalarActuator's control"""
        return _simulation.ScalarActuator_setMinControl(self, aMinControl)

    def getMinControl(self):
        r"""getMinControl(ScalarActuator self) -> double"""
        return _simulation.ScalarActuator_getMinControl(self)

    def setMaxControl(self, aMaxControl):
        r"""
        setMaxControl(ScalarActuator self, double const & aMaxControl)

        Parameters
        ----------
        aMaxControl: double const &

        """
        return _simulation.ScalarActuator_setMaxControl(self, aMaxControl)

    def getMaxControl(self):
        r"""getMaxControl(ScalarActuator self) -> double"""
        return _simulation.ScalarActuator_getMaxControl(self)

    def overrideActuation(self, s, flag):
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.ScalarActuator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s):
        r""" return ScalarActuator's override status"""
        return _simulation.ScalarActuator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s, value):
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.ScalarActuator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s):
        r"""return override actuation"""
        return _simulation.ScalarActuator_getOverrideActuation(self, s)
    __swig_destroy__ = _simulation.delete_ScalarActuator

# Register ScalarActuator in _simulation:
_simulation.ScalarActuator_swigregister(ScalarActuator)
class SetActuators(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetActuators

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetActuators_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetActuators self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetActuators_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetActuators_getClassName()

    def clone(self):
        r"""clone(SetActuators self) -> SetActuators"""
        return _simulation.SetActuators_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetActuators self) -> std::string const &"""
        return _simulation.SetActuators_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetActuators

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Actuator,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetActuators_swiginit(self, _simulation.new_SetActuators(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetActuators_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetActuators_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetActuators_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetActuators_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Actuator`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetActuators_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetActuators_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetActuators_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Actuator`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetActuators_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetActuators_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetActuators_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetActuators self)"""
        return _simulation.SetActuators_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetActuators_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Actuator`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Actuator`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetActuators_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetActuators_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetActuators_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetActuators_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetActuators_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetActuators_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetActuators_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetActuators_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetActuators_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetActuators_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetActuators in _simulation:
_simulation.SetActuators_swigregister(SetActuators)
class Analysis(opensim.common.OpenSimObject):
    r"""
    An abstract class for specifying the interface for an analysis
    plugin.

    Author: Frank C. Anderson, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Analysis

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Analysis_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Analysis self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Analysis_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Analysis_getClassName()

    def clone(self):
        r"""clone(Analysis self) -> Analysis"""
        return _simulation.Analysis_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Analysis self) -> std::string const &"""
        return _simulation.Analysis_getConcreteClassName(self)
    _model = property(_simulation.Analysis__model_get, _simulation.Analysis__model_set, doc=r"""_model : p.OpenSim::Model""")
    _statesStore = property(_simulation.Analysis__statesStore_get, _simulation.Analysis__statesStore_set, doc=r"""_statesStore : p.q(const).OpenSim::Storage""")
    __swig_destroy__ = _simulation.delete_Analysis

    def begin(self, s):
        r"""
        begin(Analysis self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Analysis_begin(self, s)

    def step(self, s, stepNumber):
        r"""
        step(Analysis self, State s, int stepNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        stepNumber: int

        """
        return _simulation.Analysis_step(self, s, stepNumber)

    def end(self, s):
        r"""
        end(Analysis self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Analysis_end(self, s)

    def setModel(self, aModel):
        r"""
        set pointer to model to be analyzed.
        :type aModel: :py:class:`Model`
        :param aModel:
        """
        return _simulation.Analysis_setModel(self, aModel)

    def setStatesStore(self, aStatesStore):
        r"""
        set states storage for analysis.
        :type aStatesStore: :py:class:`Storage`
        :param aStatesStore:
        """
        return _simulation.Analysis_setStatesStore(self, aStatesStore)

    def setOn(self, aTrueFalse):
        r"""
        setOn(Analysis self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        """
        return _simulation.Analysis_setOn(self, aTrueFalse)

    def getOn(self):
        r"""getOn(Analysis self) -> bool"""
        return _simulation.Analysis_getOn(self)

    def setStartTime(self, aStartTime):
        r"""
        setStartTime(Analysis self, double aStartTime)

        Parameters
        ----------
        aStartTime: double

        """
        return _simulation.Analysis_setStartTime(self, aStartTime)

    def getStartTime(self):
        r"""getStartTime(Analysis self) -> double"""
        return _simulation.Analysis_getStartTime(self)

    def setEndTime(self, aEndTime):
        r"""
        setEndTime(Analysis self, double aEndTime)

        Parameters
        ----------
        aEndTime: double

        """
        return _simulation.Analysis_setEndTime(self, aEndTime)

    def getEndTime(self):
        r"""getEndTime(Analysis self) -> double"""
        return _simulation.Analysis_getEndTime(self)

    def setInDegrees(self, aTrueFalse):
        r"""
        %Set whether or not to write the output of angles in degrees.
        This flag must be set before an analysis is performed to ensure that
        the results are in the proper format.
        :type aTrueFalse: boolean
        :param aTrueFalse: Output will be in degrees if "true" and in radians
            if "false".
        """
        return _simulation.Analysis_setInDegrees(self, aTrueFalse)

    def getInDegrees(self):
        r"""getInDegrees(Analysis self) -> bool"""
        return _simulation.Analysis_getInDegrees(self)

    def proceed(self, aStep=0):
        r"""
        proceed(Analysis self, int aStep=0) -> bool

        Parameters
        ----------
        aStep: int

        """
        return _simulation.Analysis_proceed(self, aStep)

    def setStepInterval(self, aStepInterval):
        r"""
        setStepInterval(Analysis self, int aStepInterval)

        Parameters
        ----------
        aStepInterval: int

        """
        return _simulation.Analysis_setStepInterval(self, aStepInterval)

    def getStepInterval(self):
        r"""getStepInterval(Analysis self) -> int"""
        return _simulation.Analysis_getStepInterval(self)

    def setColumnLabels(self, aLabels):
        r"""
        %Set the column labels for this analysis.
        :type aLabels: OpenSim::Array< std::string >
        :param aLabels: an Array of strings (labels).
        """
        return _simulation.Analysis_setColumnLabels(self, aLabels)

    def getColumnLabels(self):
        r"""getColumnLabels(Analysis self) -> ArrayStr"""
        return _simulation.Analysis_getColumnLabels(self)

    def getStorageList(self):
        r"""getStorageList(Analysis self) -> ArrayStorage"""
        return _simulation.Analysis_getStorageList(self)

    def setPrintResultFiles(self, aToWrite):
        r"""
        setPrintResultFiles(Analysis self, bool aToWrite)

        Parameters
        ----------
        aToWrite: bool

        """
        return _simulation.Analysis_setPrintResultFiles(self, aToWrite)

    def getPrintResultFiles(self):
        r"""getPrintResultFiles(Analysis self) -> bool"""
        return _simulation.Analysis_getPrintResultFiles(self)

    def printResults(self, *args):
        r"""
        Print the results of the analysis.

        :type aBaseName: string
        :param aBaseName: Base name of file to which to print the data.
        :type aDir: string, optional
        :param aDir:      Directory name.
        :type aDT: float, optional
        :param aDT:       Time interval between results (linear interpolation
                             is used). If not supplied as an argument or negative,
                             all time steps are printed without interpolation.
        :type aExtension: string, optional
        :param aExtension:    File extension if not the default ".sto".

        :rtype: int
        :return: -1 on error, 0 otherwise.
        """
        return _simulation.Analysis_printResults(self, *args)

# Register Analysis in _simulation:
_simulation.Analysis_swigregister(Analysis)
class SetAnalysis(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetAnalysis

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetAnalysis_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetAnalysis self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetAnalysis_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetAnalysis_getClassName()

    def clone(self):
        r"""clone(SetAnalysis self) -> SetAnalysis"""
        return _simulation.SetAnalysis_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetAnalysis self) -> std::string const &"""
        return _simulation.SetAnalysis_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetAnalysis

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Analysis,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetAnalysis_swiginit(self, _simulation.new_SetAnalysis(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetAnalysis_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetAnalysis_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetAnalysis_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetAnalysis_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Analysis`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetAnalysis_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetAnalysis_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetAnalysis_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Analysis`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetAnalysis_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetAnalysis_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetAnalysis_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetAnalysis self)"""
        return _simulation.SetAnalysis_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetAnalysis_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Analysis`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Analysis`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetAnalysis_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetAnalysis_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetAnalysis_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetAnalysis_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetAnalysis_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetAnalysis_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetAnalysis_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetAnalysis_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetAnalysis_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetAnalysis_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetAnalysis in _simulation:
_simulation.SetAnalysis_swigregister(SetAnalysis)
class AnalysisSet(SetAnalysis):
    r"""
    A class for holding and managing a set of integration callbacks for
    a model.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AnalysisSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AnalysisSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AnalysisSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AnalysisSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AnalysisSet_getClassName()

    def clone(self):
        r"""clone(AnalysisSet self) -> AnalysisSet"""
        return _simulation.AnalysisSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AnalysisSet self) -> std::string const &"""
        return _simulation.AnalysisSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(AnalysisSet self) -> AnalysisSet
        __init__(AnalysisSet self, Model aModel) -> AnalysisSet

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(AnalysisSet self, std::string const & aFileName) -> AnalysisSet

        Parameters
        ----------
        aFileName: std::string const &

        __init__(AnalysisSet self, AnalysisSet aSet) -> AnalysisSet

        Parameters
        ----------
        aSet: OpenSim::AnalysisSet const &

        """
        _simulation.AnalysisSet_swiginit(self, _simulation.new_AnalysisSet(*args))
    __swig_destroy__ = _simulation.delete_AnalysisSet

    def setModel(self, aModel):
        r"""
        setModel(AnalysisSet self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.AnalysisSet_setModel(self, aModel)

    def getModel(self):
        r"""getModel(AnalysisSet self) -> Model"""
        return _simulation.AnalysisSet_getModel(self)

    def setOn(self, *args):
        r"""
        setOn(AnalysisSet self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        setOn(AnalysisSet self, ArrayBool aOn)

        Parameters
        ----------
        aOn: OpenSim::Array< bool > const &

        """
        return _simulation.AnalysisSet_setOn(self, *args)

    def getOn(self):
        r"""getOn(AnalysisSet self) -> ArrayBool"""
        return _simulation.AnalysisSet_getOn(self)

    def begin(self, s):
        r"""
        begin(AnalysisSet self, State s)

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.AnalysisSet_begin(self, s)

    def step(self, s, stepNumber):
        r"""
        step(AnalysisSet self, State s, int stepNumber)

        Parameters
        ----------
        s: SimTK::State const &
        stepNumber: int

        """
        return _simulation.AnalysisSet_step(self, s, stepNumber)

    def end(self, s):
        r"""
        end(AnalysisSet self, State s)

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.AnalysisSet_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(AnalysisSet self, std::string const & aBaseName, std::string const & aPath="", double aDT=-1.0, std::string const & aExtension=".sto")

        Parameters
        ----------
        aBaseName: std::string const &
        aPath: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _simulation.AnalysisSet_printResults(self, *args)

    @staticmethod
    def getAvailableAnalyses(analysisset):
        r"""
        getAvailableAnalyses(AnalysisSet analysisset)

        Parameters
        ----------
        analysisset: OpenSim::AnalysisSet &

        """
        return _simulation.AnalysisSet_getAvailableAnalyses(analysisset)

    def adoptAndAppend(self, aAnalysis):
        aAnalysis._markAdopted()
        return super(AnalysisSet, self).adoptAndAppend(aAnalysis)


# Register AnalysisSet in _simulation:
_simulation.AnalysisSet_swigregister(AnalysisSet)
class Control(opensim.common.OpenSimObject):
    r"""
    A class that represents a control in a dynamic simulation.

    This class is intended to be the base class for different types of controls,
    so many of its methods are virtual.

    In general, a control consists of a set of parameters.  These parameters
    are used to reconstruct a control curve.  For example, a control may be
    represented by a constant, a series of step functions, a set of linearly
    interpolated values, a set of spline control points, coefficients in
    a Fourier series, etc.

    Because there is not necessarily a 1-to-1 correspondence between the
    parameters used to represent a control curve and the value of the
    control curve, there are two basic ways to access the content of a control:
    getParameter() gets the value of a parameter, and getValue() gets the
    value at a particular time.

    A distinction is also made between controls that control a model and
    controls that control some other aspect of a simulation.  For example,
    a control for the excitation level of a muscle is a "model"
    control.  The value of this type of control is queried during the
    course of a simulation.  On the other hand, a control for
    the final time of a simulation is not usually a "model" control.
    Nor is a control for the initial value of a state variable, even if that
    state variable is the initial value of a muscle activation.  These
    "non-model" controls are used to set things before a simulation ever
    begins and are not queried during the course of a simulation.  The
    number of model controls can be queried by a call to
    Model::getNumControls().

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Control

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Control_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Control self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Control_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Control_getClassName()

    def clone(self):
        r"""clone(Control self) -> Control"""
        return _simulation.Control_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Control self) -> std::string const &"""
        return _simulation.Control_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_Control

    def setIsModelControl(self, aTrueFalse):
        r"""
        Sets whether or not this control is a model control.  A model control is
        a control that is expected by a model. Controls that are not model
        controls may be, for example, controls that are used to set up a
        simulation.  Such examples might include an initial state of a model
        (e.g., joint angle, joint angular velocity, ...) or the final time of
        a simulation.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, the control is treated as a model control.
            If false, the control is not treated as a model control.
        """
        return _simulation.Control_setIsModelControl(self, aTrueFalse)

    def getIsModelControl(self):
        r""" See also: setIsModelControl()"""
        return _simulation.Control_getIsModelControl(self)

    def setExtrapolate(self, aTrueFalse):
        r"""
        Sets whether or not to extrapolate for control curve evaluations that
        are outside the region of confidence for a control.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, extrapolate when needed and possible to
            determine the value of the control curve.
        """
        return _simulation.Control_setExtrapolate(self, aTrueFalse)

    def getExtrapolate(self):
        r""" See also: setExtrapolate()"""
        return _simulation.Control_getExtrapolate(self)

    def setFilterOn(self, aTrueFalse):
        r"""
        Sets whether or not to apply a PD (proportional-derivative)
        filter to the control values.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, will apply a filter to the control
            values.  If false, a filter will not be used.
        """
        return _simulation.Control_setFilterOn(self, aTrueFalse)

    def getFilterOn(self):
        r""" See also: setFilterOn()"""
        return _simulation.Control_getFilterOn(self)

    def getNumParameters(self):
        r"""
        Returns the number of parameters that are used to specify the
        control curve.
        """
        return _simulation.Control_getNumParameters(self)

    def setDefaultParameterMin(self, aMin):
        r"""
        Sets the default minimum value of a control parameter.
        The default minimum is used when no minimum value is specified.

        :type aMin: float
        :param aMin: Minimum value.
        """
        return _simulation.Control_setDefaultParameterMin(self, aMin)

    def getDefaultParameterMin(self):
        r""" See also: setDefaultParameterMin()"""
        return _simulation.Control_getDefaultParameterMin(self)

    def setDefaultParameterMax(self, aMax):
        r"""
        Sets the default maximum value of a control parameter.
        The default maximum is used when no maximum value is specified.

        :type aMax: float
        :param aMax: Maximum value.
        """
        return _simulation.Control_setDefaultParameterMax(self, aMax)

    def getDefaultParameterMax(self):
        r""" See also: setDefaultParameterMax()"""
        return _simulation.Control_getDefaultParameterMax(self)

    def setParameterMin(self, aI, aMin):
        r"""
        Sets the minimum value that a control parameter  can take on.

        :type aI: int
        :param aI: Index of the parameter.
        :type aMin: float
        :param aMin: Minimum value the parameter can have.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI):
        r"""
        See also: setParameterMin()
        :type aI: int
        :param aI: Index of the parameter for which the minimum value is desired.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterMin(self, aI)

    def setParameterMax(self, aI, aMax):
        r"""
        %Set the maximum value that a control parameter can take on.

        :type aI: int
        :param aI: Index of the parameter.
        :type aMax: float
        :param aMax: Maximum value the parameter can have.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI):
        r"""
        See also: setParameterMax()
        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterMax(self, aI)

    def getParameterTime(self, aI):
        r"""
        Gets the time at which a parameter is specified.

        Parameters for some types of control curves do not have a time at which
        they are specified.  For example, in a Fourier series the control
        parameters are the coefficients in the expansion, and each term in
        the expansion corresponds not to a specific time but to a frequency.
        Another example is a constant that has the same value for all times.
        In these cases, this method returns SimTK::NaN.

        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI, rTLower, rTUpper):
        r"""
        Gets the time neighborhood (i.e., the lower and upper bounds of time)
        in which a control parameter affects the value of the control curve.

        Changes in the specified parameter are guaranteed not to change the value
        of the control curve below the lower bound time or above the upper bound
        time.  If a parameter influences the value of the control curve for all
        times, -%SimTK::Infinity and %SimTK::Infinity are returned for
        the upper and lower bound times, respectively.

        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: Time below which the curve is not affected by the
            specified parameter.
        :type rTUpper: float
        :param rTUpper: Time above which the curve is not affected by the
            specified parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args):
        r"""
        *Overload 1:*

        Gets the list of parameters that affect the control curve at a
        specified time.

        :type aT: float
        :param aT: Time in question.
        :type rList: OpenSim::Array< int >
        :param rList: The returned list of parameters.
        :rtype: int
        :return: Length of rList.

        |

        *Overload 2:*

        Gets the list of parameters that affect the control curve between two
        specified times and that do NOT affect the control curve below the lower
        of these two times.

        This method is useful when solving for a set of controls for a dynamic
        simulation.  When solving for a set of controls, one always wants to
        go forward in time.  Therefore, one does not want to change control
        parameters that affect the control curve at past times.

        A control parameter is included in the list only if it affects
        the control curve in the specified time interval AND does NOT
        affect the control curve below the lower bound of the
        specified time interval.  So, it is possible that some of the
        parameters on the returned list could affect the control curve at
        times greater than the upper bound of the specified time interval.

        :type aTLower: float
        :param aTLower: Lower time bound.
        :type aTUpper: float
        :param aTUpper: Upper time bound.
        :type rList: OpenSim::Array< int >
        :param rList: List of indices of the control parameters that
            affect the curve between aTLower and aTUpper but not before aTLower.
        :rtype: int
        :return: Length of rList.
        """
        return _simulation.Control_getParameterList(self, *args)

    def getParameterValue(self, aI):
        r""" See also: setParameterValue()"""
        return _simulation.Control_getParameterValue(self, aI)

    def setParameterValue(self, aI, aX):
        r"""
        Sets the value of a control parameter.

        :type aI: int
        :param aI: Index of the parameter.
        :type aX: float
        :param aX: Value of the parameter. Meaning depends on the subclass.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterValue(self, aI, aX)

    def getControlValue(self, aT=0.0):
        r"""
        Gets the value of this control at time aT.
        If the value of the curve is not defined,
        SimTK::NaN is returned.  If the control is set to extrapolate,
        (see getExtrapolate()), and the time is before that of the first node or
        after that of the last node, then an extrapolation is performed to
        determine the value of the control curve.  Otherwise, the value of
        either the first control node or last control node is returned.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        """
        return _simulation.Control_getControlValue(self, aT)

    def setControlValue(self, aT, aX):
        r"""
        Sets the value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aX: float
        :param aX: Control value.
        """
        return _simulation.Control_setControlValue(self, aT, aX)

    def getControlValueMin(self, aT=0.0):
        r"""
        Gets the minimum allowed value of this control at time aT.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        :rtype: float
        :return: Minimum allowed control value.  If the value of the curve
            is not defined,
            _defaultMin is returned.  If the control is set to extrapolate,
            (see getExtraplate()), and the time is before the first node or
            after the last node, then an extrapolation is performed to determine
            the value of the control curve.  Otherwise, the value of either the
            first control node or last control node is returned.
        """
        return _simulation.Control_getControlValueMin(self, aT)

    def setControlValueMin(self, aT, aMin):
        r"""
        Sets the minimum value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aMin: float
        :param aMin: Minimum allowed control value at time aT.
        """
        return _simulation.Control_setControlValueMin(self, aT, aMin)

    def getControlValueMax(self, aT=0.0):
        r"""
        Gets the maximum allowed value of this control at time aT.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        :rtype: float
        :return: Maximum allowed control value.  If the value of the curve is not defined,
            _defaultMax is returned.  If the control is set to extrapolate,
            getExtraplate, and the time is before the first node or
            after the last node, then an extrapolation is performed to determine
            the value of the control curve.  Otherwise, the value of either the
            first control node or last control node is returned.
        """
        return _simulation.Control_getControlValueMax(self, aT)

    def setControlValueMax(self, aT, aMax):
        r"""
        Sets the maximum value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aMax: float
        :param aMax: Maximum allowed control value.
        """
        return _simulation.Control_setControlValueMax(self, aT, aMax)

    def getFirstTime(self):
        r"""
        Gets the first time for which a parameter is specified. Should be
        overridden by derived classes that have a defined min time.

        :rtype: float
        :return: 0.
        """
        return _simulation.Control_getFirstTime(self)

    def getLastTime(self):
        r"""
        Gets the last time for which a parameter is specified. Should be overridden
        by derived classes that have a defined max time.

        :rtype: float
        :return: 0.
        """
        return _simulation.Control_getLastTime(self)

    def simplify(self, aProperties):
        r"""
        Simplify the control (e.g., reduce the number of points in the control
        curve) based on a set of specified properties.  Each implementation
        is free to require whatever properties are needed to perform
        the simplification.  Refer to the documentation in derived classes
        to see what properties are required.

        :type aProperties: PropertySet
        :param aProperties: PropertySet used to perform the simplify
            operation.
        :raises: Exception This method does nothing.  It must be overridden
            in derived classes.
        """
        return _simulation.Control_simplify(self, aProperties)

    def filter(self, aT):
        r"""
        Filter the control curve at a particular time.

        :type aT: float
        :param aT: Time at which to compute a new, filtered control value
        """
        return _simulation.Control_filter(self, aT)

# Register Control in _simulation:
_simulation.Control_swigregister(Control)
class SetControls(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetControls

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetControls_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetControls self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetControls_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetControls_getClassName()

    def clone(self):
        r"""clone(SetControls self) -> SetControls"""
        return _simulation.SetControls_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetControls self) -> std::string const &"""
        return _simulation.SetControls_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetControls

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Control,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetControls_swiginit(self, _simulation.new_SetControls(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetControls_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetControls_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControls_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControls_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Control`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControls_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetControls_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Control`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControls_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Control`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControls_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Control`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControls_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Control`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControls_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetControls self)"""
        return _simulation.SetControls_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Control`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetControls_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Control`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Control`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControls_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetControls_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetControls_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetControls_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetControls_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetControls_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetControls_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetControls_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetControls_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetControls_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetControls in _simulation:
_simulation.SetControls_swigregister(SetControls)
class ControlSet(SetControls):
    r"""
    A class for holding and managing a set of controls for a dynamic
    simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ControlSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ControlSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ControlSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ControlSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ControlSet_getClassName()

    def clone(self):
        r"""clone(ControlSet self) -> ControlSet"""
        return _simulation.ControlSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ControlSet self) -> std::string const &"""
        return _simulation.ControlSet_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ControlSet

    def __init__(self, *args):
        r"""
        __init__(ControlSet self) -> ControlSet
        __init__(ControlSet self, std::string const & aFileName) -> ControlSet

        Parameters
        ----------
        aFileName: std::string const &

        __init__(ControlSet self, ControlSet aSet) -> ControlSet

        Parameters
        ----------
        aSet: OpenSim::ControlSet const &

        __init__(ControlSet self, Storage aStorage, int nControlsToConvert=0, int aStartIndex=0) -> ControlSet

        Parameters
        ----------
        aStorage: OpenSim::Storage const &
        nControlsToConvert: int
        aStartIndex: int

        """
        _simulation.ControlSet_swiginit(self, _simulation.new_ControlSet(*args))

    def getSize(self, aForModelControls=True):
        r"""
        getSize(ControlSet self, bool aForModelControls=True) -> int

        Parameters
        ----------
        aForModelControls: bool

        """
        return _simulation.ControlSet_getSize(self, aForModelControls)

    def getControlList(self, aType, rList, aForModelControls=True):
        r"""
        getControlList(ControlSet self, char const * aType, ArrayInt rList, bool aForModelControls=True)

        Parameters
        ----------
        aType: char const *
        rList: OpenSim::Array< int > &
        aForModelControls: bool

        """
        return _simulation.ControlSet_getControlList(self, aType, rList, aForModelControls)

    def getControlValues(self, aT, rX, aForModelControls=True):
        r"""
        getControlValues(ControlSet self, double aT, ArrayDouble rX, bool aForModelControls=True)

        Parameters
        ----------
        aT: double
        rX: OpenSim::Array< double > &
        aForModelControls: bool

        """
        return _simulation.ControlSet_getControlValues(self, aT, rX, aForModelControls)

    def setControlValues(self, aT, aX, aForModelControls=True):
        r"""
        setControlValues(ControlSet self, double aT, ArrayDouble aX, bool aForModelControls=True)

        Parameters
        ----------
        aT: double
        aX: OpenSim::Array< double > const &
        aForModelControls: bool

        """
        return _simulation.ControlSet_setControlValues(self, aT, aX, aForModelControls)

    def getNumParameters(self, aForModelControls=True):
        r"""
        getNumParameters(ControlSet self, bool aForModelControls=True) -> int

        Parameters
        ----------
        aForModelControls: bool

        """
        return _simulation.ControlSet_getNumParameters(self, aForModelControls)

    def getParameterList(self, *args):
        r"""
        getParameterList(ControlSet self, ArrayInt rList, bool aForModelControls=True)

        Parameters
        ----------
        rList: OpenSim::Array< int > &
        aForModelControls: bool

        getParameterList(ControlSet self, double aT, ArrayInt rList, bool aForModelControls=True)

        Parameters
        ----------
        aT: double
        rList: OpenSim::Array< int > &
        aForModelControls: bool

        getParameterList(ControlSet self, double aTLower, double aTUpper, ArrayInt rList, bool aForModelControls=True)

        Parameters
        ----------
        aTLower: double
        aTUpper: double
        rList: OpenSim::Array< int > &
        aForModelControls: bool

        """
        return _simulation.ControlSet_getParameterList(self, *args)

    def getParameterMins(self, rMins, aList=None):
        r"""
        getParameterMins(ControlSet self, ArrayDouble rMins, ArrayInt aList=None)

        Parameters
        ----------
        rMins: OpenSim::Array< double > &
        aList: OpenSim::Array< int > const *

        """
        return _simulation.ControlSet_getParameterMins(self, rMins, aList)

    def getParameterMaxs(self, rMaxs, aList=None):
        r"""
        getParameterMaxs(ControlSet self, ArrayDouble rMaxs, ArrayInt aList=None)

        Parameters
        ----------
        rMaxs: OpenSim::Array< double > &
        aList: OpenSim::Array< int > const *

        """
        return _simulation.ControlSet_getParameterMaxs(self, rMaxs, aList)

    def getParameterValues(self, rP, aList=None):
        r"""
        getParameterValues(ControlSet self, ArrayDouble rP, ArrayInt aList=None)

        Parameters
        ----------
        rP: OpenSim::Array< double > &
        aList: OpenSim::Array< int > const *

        """
        return _simulation.ControlSet_getParameterValues(self, rP, aList)

    def setParameterValues(self, aP, aList=None):
        r"""
        setParameterValues(ControlSet self, ArrayDouble aP, ArrayInt aList=None)

        Parameters
        ----------
        aP: OpenSim::Array< double > const &
        aList: OpenSim::Array< int > const *

        """
        return _simulation.ControlSet_setParameterValues(self, aP, aList)

    def simplify(self, aProperties):
        r"""
        simplify(ControlSet self, PropertySet const & aProperties)

        Parameters
        ----------
        aProperties: PropertySet const &

        """
        return _simulation.ControlSet_simplify(self, aProperties)

    def filter(self, aT):
        r"""
        filter(ControlSet self, double aT)

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlSet_filter(self, aT)

    def constructStorage(self, aN, aT1, aT2, aForModelControls):
        r"""
        constructStorage(ControlSet self, int aN, double aT1, double aT2, bool aForModelControls) -> Storage

        Parameters
        ----------
        aN: int
        aT1: double
        aT2: double
        aForModelControls: bool

        """
        return _simulation.ControlSet_constructStorage(self, aN, aT1, aT2, aForModelControls)

    def mapParameterToControl(self, aIndex):
        r"""
        mapParameterToControl(ControlSet self, int aIndex) -> int

        Parameters
        ----------
        aIndex: int

        """
        return _simulation.ControlSet_mapParameterToControl(self, aIndex)

    def mapParameterToParameter(self, aIndex):
        r"""
        mapParameterToParameter(ControlSet self, int aIndex) -> int

        Parameters
        ----------
        aIndex: int

        """
        return _simulation.ControlSet_mapParameterToParameter(self, aIndex)

    def generateParameterMaps(self):
        r"""generateParameterMaps(ControlSet self)"""
        return _simulation.ControlSet_generateParameterMaps(self)

    def adoptAndAppend(self, aControl):
        aControl._markAdopted()
        return super(ControlSet, self).adoptAndAppend(aControl)


# Register ControlSet in _simulation:
_simulation.ControlSet_swigregister(ControlSet)
class ControlConstant(Control):
    r"""
    A class that represents a constant control curve.  That is, the value
    of the control curve is the same at any value of time.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ControlConstant

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ControlConstant_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ControlConstant self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ControlConstant_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ControlConstant_getClassName()

    def clone(self):
        r"""clone(ControlConstant self) -> ControlConstant"""
        return _simulation.ControlConstant_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ControlConstant self) -> std::string const &"""
        return _simulation.ControlConstant_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ControlConstant

    def getNumParameters(self):
        r"""getNumParameters(ControlConstant self) -> int"""
        return _simulation.ControlConstant_getNumParameters(self)

    def setParameterMin(self, aI, aMin):
        r"""
        setParameterMin(ControlConstant self, int aI, double aMin)

        Parameters
        ----------
        aI: int
        aMin: double

        """
        return _simulation.ControlConstant_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI):
        r"""
        getParameterMin(ControlConstant self, int aI) -> double

        Parameters
        ----------
        aI: int

        """
        return _simulation.ControlConstant_getParameterMin(self, aI)

    def setParameterMax(self, aI, aMax):
        r"""
        setParameterMax(ControlConstant self, int aI, double aMax)

        Parameters
        ----------
        aI: int
        aMax: double

        """
        return _simulation.ControlConstant_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI):
        r"""
        getParameterMax(ControlConstant self, int aI) -> double

        Parameters
        ----------
        aI: int

        """
        return _simulation.ControlConstant_getParameterMax(self, aI)

    def getParameterTime(self, aI):
        r"""
        For ControlConstant, parameters are not associated with any specific time.

        :type aI: int
        :param aI: Index of the parameter.
        :rtype: float
        :return: SimTK::NaN
        """
        return _simulation.ControlConstant_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI, rTLower, rTUpper):
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: -%SimTK::Infinity
        :type rTUpper: float
        :param rTUpper: %SimTK::Infinity
        """
        return _simulation.ControlConstant_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args):
        r"""
        getParameterList(ControlConstant self, double aT, ArrayInt rList) -> int

        Parameters
        ----------
        aT: double
        rList: OpenSim::Array< int > &

        getParameterList(ControlConstant self, double aT1, double aT2, ArrayInt rList) -> int

        Parameters
        ----------
        aT1: double
        aT2: double
        rList: OpenSim::Array< int > &

        """
        return _simulation.ControlConstant_getParameterList(self, *args)

    def setParameterValue(self, aI, aX):
        r"""
        :type aI: int
        :param aI: Only 0 is valid for ControlConstant.
        :type aX: float
        :param aX: The constant value of this control curve.
        """
        return _simulation.ControlConstant_setParameterValue(self, aI, aX)

    def getParameterValue(self, aI):
        r"""
        See also: setParameterValue()
        :type aI: int
        :param aI: Only 0 is valid for ControlConstant.
        :rtype: float
        :return: The constant value of this control curve.
        """
        return _simulation.ControlConstant_getParameterValue(self, aI)

    def setControlValue(self, aT, aX):
        r"""
        :type aT: float
        :param aT: Not used since the control value is constant in time.
        :type aX: float
        :param aX: Control value.
        """
        return _simulation.ControlConstant_setControlValue(self, aT, aX)

    def getControlValue(self, aT):
        r"""
        :type aT: float
        :param aT: Not used since the control value is constant in time.
        """
        return _simulation.ControlConstant_getControlValue(self, aT)

    def getControlValueMin(self, aT=0.0):
        r"""
        getControlValueMin(ControlConstant self, double aT=0.0) -> double

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlConstant_getControlValueMin(self, aT)

    def setControlValueMin(self, aT, aX):
        r"""
        setControlValueMin(ControlConstant self, double aT, double aX)

        Parameters
        ----------
        aT: double
        aX: double

        """
        return _simulation.ControlConstant_setControlValueMin(self, aT, aX)

    def getControlValueMax(self, aT=0.0):
        r"""
        getControlValueMax(ControlConstant self, double aT=0.0) -> double

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlConstant_getControlValueMax(self, aT)

    def setControlValueMax(self, aT, aX):
        r"""
        setControlValueMax(ControlConstant self, double aT, double aX)

        Parameters
        ----------
        aT: double
        aX: double

        """
        return _simulation.ControlConstant_setControlValueMax(self, aT, aX)

# Register ControlConstant in _simulation:
_simulation.ControlConstant_swigregister(ControlConstant)
class ControlLinearNode(opensim.common.OpenSimObject):
    r"""
    A control node used to reconstruct a piecewise linear control.

    The member variables consist of a time, a value, a minimum value, and
    a maximum value.  So that an Array<T> can be instantiated for
    ControlLinearNode, this class implements a default constructor, a copy
    constructor, the assignment operator (=), the equality operator (==),
    and the less than operator (<).  The time at which a control node
    occurs is used to determine the results of the operators == and <.

    Author: Frank C. Anderson
    Version: 1.0
    See also: ControlLinear
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ControlLinearNode

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ControlLinearNode_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ControlLinearNode self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ControlLinearNode_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ControlLinearNode_getClassName()

    def clone(self):
        r"""clone(ControlLinearNode self) -> ControlLinearNode"""
        return _simulation.ControlLinearNode_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ControlLinearNode self) -> std::string const &"""
        return _simulation.ControlLinearNode_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ControlLinearNode self, double aT=0.0, double aValue=0.0) -> ControlLinearNode

        Parameters
        ----------
        aT: double
        aValue: double

        __init__(ControlLinearNode self, ControlLinearNode aNode) -> ControlLinearNode

        Parameters
        ----------
        aNode: OpenSim::ControlLinearNode const &

        """
        _simulation.ControlLinearNode_swiginit(self, _simulation.new_ControlLinearNode(*args))
    __swig_destroy__ = _simulation.delete_ControlLinearNode

    def setTime(self, aT):
        r"""
        setTime(ControlLinearNode self, double aT)

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlLinearNode_setTime(self, aT)

    def getTime(self):
        r"""getTime(ControlLinearNode self) -> double"""
        return _simulation.ControlLinearNode_getTime(self)

    def setValue(self, aValue):
        r"""
        setValue(ControlLinearNode self, double aValue)

        Parameters
        ----------
        aValue: double

        """
        return _simulation.ControlLinearNode_setValue(self, aValue)

    def getValue(self):
        r"""getValue(ControlLinearNode self) -> double"""
        return _simulation.ControlLinearNode_getValue(self)

    def toString(self):
        r"""toString(ControlLinearNode self) -> char *"""
        return _simulation.ControlLinearNode_toString(self)

# Register ControlLinearNode in _simulation:
_simulation.ControlLinearNode_swigregister(ControlLinearNode)
class SetControlNodes(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_SetControlNodes

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >
        :param aArray: Array to be copied.
        """
        _simulation.SetControlNodes_swiginit(self, _simulation.new_SetControlNodes(*args))

    def clearAndDestroy(self):
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _simulation.SetControlNodes_clearAndDestroy(self)

    def setSize(self, aSize):
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControlNodes_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControlNodes_getSize(self)

    def size(self):
        r""" Alternate name for getSize(). *"""
        return _simulation.SetControlNodes_size(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControlNodes_getIndex(self, *args)

    def append(self, *args):
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControlNodes_append(self, *args)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControlNodes_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControlNodes_remove(self, *args)

    def set(self, aIndex, aObject):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _simulation.SetControlNodes_set(self, aIndex, aObject)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControlNodes_get(self, *args)

    def getLast(self):
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`ControlLinearNode`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.SetControlNodes_getLast(self)

    def searchBinary(self, aObject, aFindFirst=False, aLo=-1, aHi=-1):
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _simulation.SetControlNodes_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register SetControlNodes in _simulation:
_simulation.SetControlNodes_swigregister(SetControlNodes)
class ControlLinear(Control):
    r"""
    A class that represents a piece-wise linear control curve.

    The curve is specified by an array of control nodes (see class
    ControlLinearNode) that occur at monotonically increasing times.
    The value of the control curve is computed by linearly interpolating
    the values of the appropriate control nodes.

    For this Control, *parameters* are the values of the
    ControlLinearNode's.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ControlLinear

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ControlLinear_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ControlLinear self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ControlLinear_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ControlLinear_getClassName()

    def clone(self):
        r"""clone(ControlLinear self) -> ControlLinear"""
        return _simulation.ControlLinear_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ControlLinear self) -> std::string const &"""
        return _simulation.ControlLinear_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ControlLinear self) -> ControlLinear
        __init__(ControlLinear self, ControlLinear aControl) -> ControlLinear

        Parameters
        ----------
        aControl: OpenSim::ControlLinear const &

        """
        _simulation.ControlLinear_swiginit(self, _simulation.new_ControlLinear(*args))
    __swig_destroy__ = _simulation.delete_ControlLinear

    def copyData(self, aControl):
        r"""
        Copy the member variables of the specified ControlLinear over
        to this ControlLinear.
        """
        return _simulation.ControlLinear_copyData(self, aControl)

    def setUseSteps(self, aTrueFalse):
        r"""
        Sets whether or not step functions are used between control nodes or
        linear interpolation.  When step functions are used, the value of the
        control curve between two nodes is the value of the node that occurs
        **later** in time.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, step functions will be used to determine the
            value between adjacent nodes.  If false, linear interpolation will be used.
        """
        return _simulation.ControlLinear_setUseSteps(self, aTrueFalse)

    def getUseSteps(self):
        r"""See also: setUseSteps()"""
        return _simulation.ControlLinear_getUseSteps(self)

    def setKp(self, aKp):
        r"""
        Sets the position gain for PD follower filter.  This value is relevant
        only if the PD follower filter will be used.

        See also: setFilterOn()

        :type aKp: float
        :param aKp: Value of position gain for the PD follower filter.
        """
        return _simulation.ControlLinear_setKp(self, aKp)

    def getKp(self):
        r""" See also: setKp()"""
        return _simulation.ControlLinear_getKp(self)

    def setKv(self, aKv):
        r"""
        Sets the velocity gain for PD follower filter.  This value is relevant
        only if the PD follower filter will be used.

        See also: setFilterOn()

        :type aKv: float
        :param aKv: Value of velocity gain for the PD follower filter.
        """
        return _simulation.ControlLinear_setKv(self, aKv)

    def getKv(self):
        r""" See also: setKv()"""
        return _simulation.ControlLinear_getKv(self)

    def getNumParameters(self):
        r"""getNumParameters(ControlLinear self) -> int"""
        return _simulation.ControlLinear_getNumParameters(self)

    def setParameterMin(self, aI, aMin):
        r"""
        setParameterMin(ControlLinear self, int aI, double aMin)

        Parameters
        ----------
        aI: int
        aMin: double

        """
        return _simulation.ControlLinear_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI):
        r"""
        getParameterMin(ControlLinear self, int aI) -> double

        Parameters
        ----------
        aI: int

        """
        return _simulation.ControlLinear_getParameterMin(self, aI)

    def setParameterMax(self, aI, aMax):
        r"""
        setParameterMax(ControlLinear self, int aI, double aMax)

        Parameters
        ----------
        aI: int
        aMax: double

        """
        return _simulation.ControlLinear_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI):
        r"""
        getParameterMax(ControlLinear self, int aI) -> double

        Parameters
        ----------
        aI: int

        """
        return _simulation.ControlLinear_getParameterMax(self, aI)

    def getParameterTime(self, aI):
        r"""
        Get the time at which a parameter (control curve value) is specified.

        Not for minimum or maximum values of parameters; only for specified
        values of the control curve, as set via setParameterValue() or
        setControlValue().

        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.ControlLinear_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI, rTLower, rTUpper):
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: The time of parameter aI-1 or of
            aI if there is no parameter aI-1.  If there are no ControlLinearNode's
            at all or if aI is invalid, rTLower is given the value SimTK::NaN.
        :type rTUpper: float
        :param rTUpper: The time of parameter aI+1 or of
            aI if there is no parameter aI+1.  If there are no ControlLinearNode's
            at all or if aI is invalid, rTUpper is given the value SimTK::NaN.
        """
        return _simulation.ControlLinear_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args):
        r"""
        getParameterList(ControlLinear self, double aT, ArrayInt rList) -> int

        Parameters
        ----------
        aT: double
        rList: OpenSim::Array< int > &

        getParameterList(ControlLinear self, double aT1, double aT2, ArrayInt rList) -> int

        Parameters
        ----------
        aT1: double
        aT2: double
        rList: OpenSim::Array< int > &

        """
        return _simulation.ControlLinear_getParameterList(self, *args)

    def setParameterValue(self, aI, aP):
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type aP: float
        :param aP: The parameter value is simply the value of
            the aI-th ControlLinearNode (which is the value of the control curve).
        """
        return _simulation.ControlLinear_setParameterValue(self, aI, aP)

    def getParameterValue(self, aI):
        r""" See also: setParameterValue()"""
        return _simulation.ControlLinear_getParameterValue(self, aI)

    def setControlValue(self, aT, aX):
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing ControlLinearNode,
        in which case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValue(self, aT, aX)

    def getControlValue(self, aT):
        r"""
        getControlValue(ControlLinear self, double aT) -> double

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlLinear_getControlValue(self, aT)

    def getControlValueMin(self, aT=0.0):
        r"""
        getControlValueMin(ControlLinear self, double aT=0.0) -> double

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlLinear_getControlValueMin(self, aT)

    def setControlValueMin(self, aT, aX):
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing control node, in which
        case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValueMin(self, aT, aX)

    def getControlValueMax(self, aT=0.0):
        r"""
        getControlValueMax(ControlLinear self, double aT=0.0) -> double

        Parameters
        ----------
        aT: double

        """
        return _simulation.ControlLinear_getControlValueMax(self, aT)

    def setControlValueMax(self, aT, aX):
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing control node, in which
        case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValueMax(self, aT, aX)

    def clearControlNodes(self):
        r"""clearControlNodes(ControlLinear self)"""
        return _simulation.ControlLinear_clearControlNodes(self)

    def getControlValues(self):
        r"""getControlValues(ControlLinear self) -> SetControlNodes"""
        return _simulation.ControlLinear_getControlValues(self)

    def getControlMinValues(self):
        r"""getControlMinValues(ControlLinear self) -> SetControlNodes"""
        return _simulation.ControlLinear_getControlMinValues(self)

    def getControlMaxValues(self):
        r"""getControlMaxValues(ControlLinear self) -> SetControlNodes"""
        return _simulation.ControlLinear_getControlMaxValues(self)

    def insertNewValueNode(self, index, newNode):
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewValueNode(self, index, newNode)

    def insertNewMinNode(self, index, newNode):
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewMinNode(self, index, newNode)

    def insertNewMaxNode(self, index, newNode):
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewMaxNode(self, index, newNode)

    def getFirstTime(self):
        r"""The time corresponding to the first ControlLinearNode."""
        return _simulation.ControlLinear_getFirstTime(self)

    def getLastTime(self):
        r"""The time corresponding to the last ControlLinearNode"""
        return _simulation.ControlLinear_getLastTime(self)

    def simplify(self, *args):
        r"""
        *Overload 1:*

        The number of control nodes is reduced by first applying a lowpass filter
        to the sequence of control nodes using a specified cutoff frequency and
        then removing nodes that keep the curve within a specified distance
        to the low-pass filtered curve.

        The PropertySet should contain:


        |TYPE|NAME|
        |PropertyDbl|cutoff_frequency|
        |PropertyDbl|distance|


        :type aProperties: PropertySet
        :param aProperties: PropertySet containing the needed properties for
            this method.
        :raises: Exception if an error is encountered.

        |

        *Overload 2:*

        Another interface to simplify that:
        (1) does not require properties, and (2) returns bool on failure
        for a more graceful batch simplification.
        """
        return _simulation.ControlLinear_simplify(self, *args)

    def filter(self, aT):
        r"""
        Filter the control curve at a particular time using a PD follower filter.

        See also: setFilterOn()

        :type aT: float
        :param aT: Time at which to compute a new, filtered control value
        """
        return _simulation.ControlLinear_filter(self, aT)

    @staticmethod
    def Interpolate(aX1, aY1, aX2, aY2, aX):
        r"""
        Linearly interpolate or extrapolate given two points.

        :type aX1: float
        :param aX1: X coordinate of point 1.
        :type aY1: float
        :param aY1: Y coordinate of point 1.
        :type aX2: float
        :param aX2: X coordinate of point 2.
        :type aY2: float
        :param aY2: Y coordinate of point 2.
        :type aX: float
        :param aX: X coordinate whose corresponding Y coordinate is desired.
        :rtype: float
        :return: Y value corresponding to aX.
        """
        return _simulation.ControlLinear_Interpolate(aX1, aY1, aX2, aY2, aX)

# Register ControlLinear in _simulation:
_simulation.ControlLinear_swigregister(ControlLinear)
class PrescribedController(Controller):
    r"""
    PrescribedController is a concrete Controller that specifies functions that
    prescribe the control values of its actuators as a function of time.

    The control functions are specified in the `ControlFunctions` property. Use
    `prescribeControlForActuator()` to assign a control function to an actuator
    based on the name or path of the actuator. After connecting the controller to
    the model, the added control function will be placed at the correct index in
    the `ControlFunctions` property. If modifying the `ControlFunctions` property
    directly, the number and order of functions must match the number and order
    of actuators connected to the controller. However, it is recommended to use
    `prescribeControlForActuator()` to ensure the correct mapping between
    actuator and control function.

    When loading from file, the order of the control functions in the file must
    match the order of actuators connected to the controller. If
    `prescribeControlForActuator()` is used to assign control functions, the
    control functions will be stored in the correct order in the
    `ControlFunctions` when saving the controller to file (since they are
    reordered as described above).

    A controls storage file can be specified in the `controls_file` property.
    Each column must be either the name or path of an actuator in the model. If
    the actuator name is used as the column label, the first actuator with a
    matching name will be connected to the controller and assigned a control
    function based on the column data. Using actuator paths in the column labels
    is recommended to avoid ambiguity. Finally, any actuators with existing
    control functions will be ignored when setting controls from file.

    Notes: Prior to OpenSim 4.6, PrescribedController support setting a prescribed
          control based on the actuator's index in the `ControlFunctions`
          property. This interface is deprecated and will be removed in a future
          release.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PrescribedController

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PrescribedController_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PrescribedController self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PrescribedController_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PrescribedController_getClassName()

    def clone(self):
        r"""clone(PrescribedController self) -> PrescribedController"""
        return _simulation.PrescribedController_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PrescribedController self) -> std::string const &"""
        return _simulation.PrescribedController_getConcreteClassName(self)

    def copyProperty_ControlFunctions(self, source):
        r"""
        copyProperty_ControlFunctions(PrescribedController self, PrescribedController source)

        Parameters
        ----------
        source: OpenSim::PrescribedController::Self const &

        """
        return _simulation.PrescribedController_copyProperty_ControlFunctions(self, source)

    def append_ControlFunctions(self, value):
        r"""
        append_ControlFunctions(PrescribedController self, FunctionSet value) -> int

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedController_append_ControlFunctions(self, value)

    def constructProperty_ControlFunctions(self, initValue):
        r"""
        constructProperty_ControlFunctions(PrescribedController self, FunctionSet initValue)

        Parameters
        ----------
        initValue: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedController_constructProperty_ControlFunctions(self, initValue)

    def get_ControlFunctions(self, *args):
        r"""
        get_ControlFunctions(PrescribedController self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        get_ControlFunctions(PrescribedController self) -> FunctionSet
        """
        return _simulation.PrescribedController_get_ControlFunctions(self, *args)

    def upd_ControlFunctions(self, *args):
        r"""
        upd_ControlFunctions(PrescribedController self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        upd_ControlFunctions(PrescribedController self) -> FunctionSet
        """
        return _simulation.PrescribedController_upd_ControlFunctions(self, *args)

    def set_ControlFunctions(self, *args):
        r"""
        set_ControlFunctions(PrescribedController self, int i, FunctionSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::FunctionSet const &

        set_ControlFunctions(PrescribedController self, FunctionSet value)

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PrescribedController_set_ControlFunctions(self, *args)

    def copyProperty_controls_file(self, source):
        r"""
        copyProperty_controls_file(PrescribedController self, PrescribedController source)

        Parameters
        ----------
        source: OpenSim::PrescribedController::Self const &

        """
        return _simulation.PrescribedController_copyProperty_controls_file(self, source)

    def append_controls_file(self, value):
        r"""
        append_controls_file(PrescribedController self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PrescribedController_append_controls_file(self, value)

    def constructProperty_controls_file(self, *args):
        r"""
        constructProperty_controls_file(PrescribedController self)
        constructProperty_controls_file(PrescribedController self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.PrescribedController_constructProperty_controls_file(self, *args)

    def get_controls_file(self, *args):
        r"""
        get_controls_file(PrescribedController self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_controls_file(PrescribedController self) -> std::string const &
        """
        return _simulation.PrescribedController_get_controls_file(self, *args)

    def upd_controls_file(self, *args):
        r"""
        upd_controls_file(PrescribedController self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_controls_file(PrescribedController self) -> std::string &
        """
        return _simulation.PrescribedController_upd_controls_file(self, *args)

    def set_controls_file(self, *args):
        r"""
        set_controls_file(PrescribedController self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_controls_file(PrescribedController self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PrescribedController_set_controls_file(self, *args)

    def copyProperty_interpolation_method(self, source):
        r"""
        copyProperty_interpolation_method(PrescribedController self, PrescribedController source)

        Parameters
        ----------
        source: OpenSim::PrescribedController::Self const &

        """
        return _simulation.PrescribedController_copyProperty_interpolation_method(self, source)

    def append_interpolation_method(self, value):
        r"""
        append_interpolation_method(PrescribedController self, int const & value) -> int

        Parameters
        ----------
        value: int const &

        """
        return _simulation.PrescribedController_append_interpolation_method(self, value)

    def constructProperty_interpolation_method(self, *args):
        r"""
        constructProperty_interpolation_method(PrescribedController self)
        constructProperty_interpolation_method(PrescribedController self, int const & initValue)

        Parameters
        ----------
        initValue: int const &

        """
        return _simulation.PrescribedController_constructProperty_interpolation_method(self, *args)

    def get_interpolation_method(self, *args):
        r"""
        get_interpolation_method(PrescribedController self, int i) -> int const

        Parameters
        ----------
        i: int

        get_interpolation_method(PrescribedController self) -> int const &
        """
        return _simulation.PrescribedController_get_interpolation_method(self, *args)

    def upd_interpolation_method(self, *args):
        r"""
        upd_interpolation_method(PrescribedController self, int i) -> int

        Parameters
        ----------
        i: int

        upd_interpolation_method(PrescribedController self) -> int &
        """
        return _simulation.PrescribedController_upd_interpolation_method(self, *args)

    def set_interpolation_method(self, *args):
        r"""
        set_interpolation_method(PrescribedController self, int i, int const & value)

        Parameters
        ----------
        i: int
        value: int const &

        set_interpolation_method(PrescribedController self, int const & value)

        Parameters
        ----------
        value: int const &

        """
        return _simulation.PrescribedController_set_interpolation_method(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor

        |

        *Overload 2:*
         Convenience constructor get controls from file
        :type controlsFileName: string
        :param controlsFileName:  string containing the controls storage (.sto)
        :type interpMethodType: int, optional
        :param interpMethodType:  int 0-constant, 1-linear, 3-cubic, 5-quintic
                                     defaults to linear.

        |

        *Overload 3:*
         Convenience constructor get controls from file
        :type controlsFileName: string
        :param controlsFileName:  string containing the controls storage (.sto)
        :param interpMethodType:  int 0-constant, 1-linear, 3-cubic, 5-quintic
                                     defaults to linear.
        """
        _simulation.PrescribedController_swiginit(self, _simulation.new_PrescribedController(*args))
    __swig_destroy__ = _simulation.delete_PrescribedController

    def computeControls(self, s, controls):
        r"""
        Compute the control values for all actuators under the control of this
        Controller.

        :type s: :py:class:`State`
        :param s:             system state
        :type controls: :py:class:`Vector`
        :param controls:      model controls
        """
        return _simulation.PrescribedController_computeControls(self, s, controls)

    def prescribeControlForActuator(self, *args):
        r"""
        prescribeControlForActuator(PrescribedController self, std::string const & actuLabel, Function prescribedFunction)

        Parameters
        ----------
        actuLabel: std::string const &
        prescribedFunction: OpenSim::Function const &

        prescribeControlForActuator(PrescribedController self, int index, Function prescribedFunction)

        Parameters
        ----------
        index: int
        prescribedFunction: OpenSim::Function *

        """
        val = _simulation.PrescribedController_prescribeControlForActuator(self, *args)

        args[1]._markAdopted()


        return val


# Register PrescribedController in _simulation:
_simulation.PrescribedController_swigregister(PrescribedController)
class InputController(Controller):
    r"""
    InputController is a simple intermediate abstract class for a Controller that
    computes controls based on scalar values defined via a list Input.

    Concrete implementations of InputController must provide a relevant
    implementation for the computeControlsImpl() method. This method is called by
    computeControls() only if the InputController has the correct number of
    connected Input controls. Otherwise, computeControls() does modify the
    model controls vector. It is up to each concrete implementation class to
    define how the scalar values from the list Input are mapped to the controls
    for the actuators in the controller's ActuatorSet. Additionally, concrete
    implementations must implement getInputControlLabels() to provide a vector of
    labels denoting the order and length of the scalar Input values expected by
    the controller. These labels may be useful in simulation tools (e.g., Moco)
    to make connections between control signals from other sources
    (e.g., ControlDistributor) and the Input controls of the controller.

    InputController provides convenience methods for getting the names and
    indexes of the controls for the actuators in the controller's ActuatorSet.
    Non-scalar actuators will have multiple controls, and therefore have multiple
    control names and indexes. Control information is only available after
    calling Model::finalizeConnections().

    Actuator control names and indexes are based on the convention used by the
    utility function SimulationUtilities::createControlNamesFromModel(), which
    returns control names and indexes based on the order of the actuators stored
    in the model. However, we do not check if the order of the actuators stored
    in the model matches the order of the controls in the underlying system. Use
    the utility function SimulationUtilities::checkOrderSystemControls() to
    perform this check when using this controller.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> InputController

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.InputController_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(InputController self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.InputController_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.InputController_getClassName()

    def clone(self):
        r"""clone(InputController self) -> InputController"""
        return _simulation.InputController_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(InputController self) -> std::string const &"""
        return _simulation.InputController_getConcreteClassName(self)
    PropertyIndex_input_controls = property(_simulation.InputController_PropertyIndex_input_controls_get, _simulation.InputController_PropertyIndex_input_controls_set, doc=r"""PropertyIndex_input_controls : OpenSim::PropertyIndex""")

    def connectInput_controls(self, *args):
        r"""
        connectInput_controls(InputController self, AbstractOutput output, std::string const & alias="")

        Parameters
        ----------
        output: OpenSim::AbstractOutput const &
        alias: std::string const &

        connectInput_controls(InputController self, AbstractChannel channel, std::string const & alias="")

        Parameters
        ----------
        channel: OpenSim::AbstractChannel const &
        alias: std::string const &

        """
        return _simulation.InputController_connectInput_controls(self, *args)
    __swig_destroy__ = _simulation.delete_InputController

    def getInputControlLabels(self):
        r"""
        Get the vector of labels for the Input controls expected by the
        controller.

        The connected Input controls must match the length and order of the
        labels returned by this method. These labels may be useful in simulation
        tools (e.g., Moco) for mapping control signals from another source to
        the Input controls of the controller.
        """
        return _simulation.InputController_getInputControlLabels(self)

    def computeControlsImpl(self, state, controls):
        r"""
        Compute the controls for the actuators in the controller's ActuatorSet
        based on the scalar values provided by the Input controls.

        This method is only called by computeControls() if the InputController
        has the correct number of connected Input controls. Concrete
        implementations of this class must provide a relevant implementation.
        """
        return _simulation.InputController_computeControlsImpl(self, state, controls)

    def computeControls(self, state, controls):
        r"""
        computeControls(InputController self, State state, Vector controls)

        Parameters
        ----------
        state: SimTK::State const &
        controls: SimTK::Vector &

        """
        return _simulation.InputController_computeControls(self, state, controls)

    def getNumInputControls(self):
        r"""Get the number of Input controls expected by the controller."""
        return _simulation.InputController_getNumInputControls(self)

    def getControlNames(self):
        r"""
        Get the names of the controls for the actuators in the controller's
        ActuatorSet.

        For scalar actuators, these names are simply the paths of
        the actuators in the model. For non-scalar actuators, these names are
        actuator path plus an additional suffix representing the index of the
        control in the actuator's control vector (e.g., "/actuator_0").

        Notes: Only valid after actuators are connected and
              Model::finalizeConnections() has been called.

        This does *not* check if the order of the actuators stored in the
              model matches the order of the controls in the underlying system.
              Use SimulationUtilities::checkOrderSystemControls() to perform
              this check.
        """
        return _simulation.InputController_getControlNames(self)

    def getControlIndexes(self):
        r"""
        Get the model control indexes for the controls associated with the
        actuators in the controller's ActuatorSet.

        The control indexes are based on the order of the actuators stored in the
        model. Non-scalar actuators will have multiple controls, and therefore
        have multiple control indexes. The order of the returned indexes matches
        the order of the control names returned by getControlNames().

        Notes: Only valid after actuators are connected and
              Model::finalizeConnections() has been called.

        This does *not* check if the order of the actuators stored in the
              model matches the order of the controls in the underlying system.
              Use SimulationUtilities::checkOrderSystemControls() to perform
              this check.
        """
        return _simulation.InputController_getControlIndexes(self)

# Register InputController in _simulation:
_simulation.InputController_swigregister(InputController)
class SynergyVector(opensim.common.OpenSimObject):
    r"""
    A vector that represents the control weights for a single synergy in a
    SynergyController. The size of the vector should be equal to the number of
    actuators connected to the controller.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SynergyVector

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SynergyVector_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SynergyVector self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SynergyVector_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SynergyVector_getClassName()

    def clone(self):
        r"""clone(SynergyVector self) -> SynergyVector"""
        return _simulation.SynergyVector_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SynergyVector self) -> std::string const &"""
        return _simulation.SynergyVector_getConcreteClassName(self)

    def copyProperty_synergy_weights(self, source):
        r"""
        copyProperty_synergy_weights(SynergyVector self, SynergyVector source)

        Parameters
        ----------
        source: OpenSim::SynergyVector::Self const &

        """
        return _simulation.SynergyVector_copyProperty_synergy_weights(self, source)

    def append_synergy_weights(self, value):
        r"""
        append_synergy_weights(SynergyVector self, Vector value) -> int

        Parameters
        ----------
        value: SimTK::Vector const &

        """
        return _simulation.SynergyVector_append_synergy_weights(self, value)

    def constructProperty_synergy_weights(self, initValue):
        r"""
        constructProperty_synergy_weights(SynergyVector self, Vector initValue)

        Parameters
        ----------
        initValue: SimTK::Vector const &

        """
        return _simulation.SynergyVector_constructProperty_synergy_weights(self, initValue)

    def get_synergy_weights(self, *args):
        r"""
        get_synergy_weights(SynergyVector self, int i) -> Vector

        Parameters
        ----------
        i: int

        get_synergy_weights(SynergyVector self) -> Vector
        """
        return _simulation.SynergyVector_get_synergy_weights(self, *args)

    def upd_synergy_weights(self, *args):
        r"""
        upd_synergy_weights(SynergyVector self, int i) -> Vector

        Parameters
        ----------
        i: int

        upd_synergy_weights(SynergyVector self) -> Vector
        """
        return _simulation.SynergyVector_upd_synergy_weights(self, *args)

    def set_synergy_weights(self, *args):
        r"""
        set_synergy_weights(SynergyVector self, int i, Vector value)

        Parameters
        ----------
        i: int
        value: SimTK::Vector const &

        set_synergy_weights(SynergyVector self, Vector value)

        Parameters
        ----------
        value: SimTK::Vector const &

        """
        return _simulation.SynergyVector_set_synergy_weights(self, *args)

    def __init__(self, *args):
        r"""
        __init__(SynergyVector self) -> SynergyVector
        __init__(SynergyVector self, std::string name, Vector weights) -> SynergyVector

        Parameters
        ----------
        name: std::string
        weights: SimTK::Vector

        """
        _simulation.SynergyVector_swiginit(self, _simulation.new_SynergyVector(*args))
    __swig_destroy__ = _simulation.delete_SynergyVector

# Register SynergyVector in _simulation:
_simulation.SynergyVector_swigregister(SynergyVector)
class SynergyController(InputController):
    r"""
    A controller that computes controls for a model based on a linear combination
    of a set of Input control signals and a set of synergy vectors.

    Each synergy vector represents a set of control weights that are multiplied
    by the Input control signals to compute the contribution to the total control
    signal for that synergy. The synergy vectors should have the same size as the
    number of actuators connected to the controller, and the controller expects
    the number Input controls to be equal to the number of synergy vectors.

    Added synergy vectors are named "synergy_vector_<index>", where <index> is
    the index of the vector in the controller (e.g., "synergy_vector_0",
    "synergy_vector_1", etc.). Similarly, the Input control labels are named
    "synergy_excitation_<index>" (e.g., "synergy_excitation_0",
    "synergy_excitation_1", etc.).

    Notes: In Moco, SynergyController%s in a model provided to MocoProblem will
    be automatically detected. The Input controls for each SynergyController will
    be given variable names based on the path to the controller appended with the
    Input control labels (e.g., "/path/to/controller/synergy_excitation_0").
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SynergyController

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SynergyController_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SynergyController self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SynergyController_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SynergyController_getClassName()

    def clone(self):
        r"""clone(SynergyController self) -> SynergyController"""
        return _simulation.SynergyController_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SynergyController self) -> std::string const &"""
        return _simulation.SynergyController_getConcreteClassName(self)

    def copyProperty_synergy_vectors(self, source):
        r"""
        copyProperty_synergy_vectors(SynergyController self, SynergyController source)

        Parameters
        ----------
        source: OpenSim::SynergyController::Self const &

        """
        return _simulation.SynergyController_copyProperty_synergy_vectors(self, source)

    def get_synergy_vectors(self, i):
        r"""
        get_synergy_vectors(SynergyController self, int i) -> SynergyVector

        Parameters
        ----------
        i: int

        """
        return _simulation.SynergyController_get_synergy_vectors(self, i)

    def upd_synergy_vectors(self, i):
        r"""
        upd_synergy_vectors(SynergyController self, int i) -> SynergyVector

        Parameters
        ----------
        i: int

        """
        return _simulation.SynergyController_upd_synergy_vectors(self, i)

    def set_synergy_vectors(self, i, value):
        r"""
        set_synergy_vectors(SynergyController self, int i, SynergyVector value)

        Parameters
        ----------
        i: int
        value: OpenSim::SynergyVector const &

        """
        return _simulation.SynergyController_set_synergy_vectors(self, i, value)

    def append_synergy_vectors(self, value):
        r"""
        append_synergy_vectors(SynergyController self, SynergyVector value) -> int

        Parameters
        ----------
        value: OpenSim::SynergyVector const &

        """
        return _simulation.SynergyController_append_synergy_vectors(self, value)

    def constructProperty_synergy_vectors(self):
        r"""constructProperty_synergy_vectors(SynergyController self)"""
        return _simulation.SynergyController_constructProperty_synergy_vectors(self)
    __swig_destroy__ = _simulation.delete_SynergyController

    def __init__(self, *args):
        r"""
        __init__(SynergyController self) -> SynergyController
        __init__(SynergyController self, SynergyController other) -> SynergyController

        Parameters
        ----------
        other: OpenSim::SynergyController const &

        __init__(SynergyController self, SynergyController other) -> SynergyController

        Parameters
        ----------
        other: OpenSim::SynergyController &&

        """
        _simulation.SynergyController_swiginit(self, _simulation.new_SynergyController(*args))

    def addSynergyVector(self, vector):
        r"""
        Add a synergy vector to the controller.

        The size of the vector should be equal to the number of actuators
        connected to the controller. Adding a synergy vector increases the number
        of control inputs expected by the controller by one.
        """
        return _simulation.SynergyController_addSynergyVector(self, vector)

    def updSynergyVector(self, index, vector):
        r"""
        Update an existing synergy vector in the controller.

        The size of the vector should be equal to the number of actuators
        connected to the controller.
        """
        return _simulation.SynergyController_updSynergyVector(self, index, vector)

    def getSynergyVector(self, index):
        r"""Get a synergy vector by index."""
        return _simulation.SynergyController_getSynergyVector(self, index)

    def getNumSynergies(self):
        r"""
        Get the number of synergies vectors in the controller.

        The controller expects this number of control Inputs to be connected when
        the connections are finalized in the model.
        """
        return _simulation.SynergyController_getNumSynergies(self)

    def getSynergyVectorsAsMatrix(self):
        r"""
        Get all synergy vectors as a matrix.

        The number of rows in the matrix is equal to the number of actuators
        connected to the controller, and the number of columns is equal to the
        number of synergy vectors in the controller.
        """
        return _simulation.SynergyController_getSynergyVectorsAsMatrix(self)

    def getInputControlLabels(self):
        r"""getInputControlLabels(SynergyController self) -> StdVectorString"""
        return _simulation.SynergyController_getInputControlLabels(self)

    def computeControlsImpl(self, s, controls):
        r"""
        computeControlsImpl(SynergyController self, State s, Vector controls)

        Parameters
        ----------
        s: SimTK::State const &
        controls: SimTK::Vector &

        """
        return _simulation.SynergyController_computeControlsImpl(self, s, controls)

# Register SynergyController in _simulation:
_simulation.SynergyController_swigregister(SynergyController)
class Manager(object):
    r"""
    A class that manages the execution of a simulation. This class uses a
    SimTK::Integrator and SimTK::TimeStepper to perform the simulation. By
    default, a Runge-Kutta-Merson integrator is used, but can be changed by
    using setIntegratorMethod().

    In order to prevent an inconsistency between the Integrator and TimeStepper,
    we only create a TimeStepper once, specifically when we call
    initialize(). To ensure this, the Manager will throw
    an exception if initialize() is called more than once. Note
    that editing the SimTK::State after calling initialize()
    will not affect the simulation.

    Note that this interface means that you cannot "reinitialize" a Manager.
    If you make changes to the SimTK::State, a new Manager must be created
    before integrating again.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor that takes a model only and internally uses a
        SimTK::RungeKuttaMersonIntegrator with default settings (accuracy,
        constraint tolerance, etc.).

        |

        *Overload 2:*
         Convenience constructor for creating and initializing a Manager (by
        calling initialize()).
        Do not use this constructor if you intend to change integrator settings;
        changes to the integrator may not take effect after initializing.

        |

        *Overload 3:*
         **(Deprecated)** A Constructor that does not take a model or
        controllerSet. This constructor also does not set an integrator; you
        must call setIntegrator() on your own. You should use one of the other
        constructors.
        """
        _simulation.Manager_swiginit(self, _simulation.new_Manager(*args))

    def setSessionName(self, name):
        r"""
        setSessionName(Manager self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.Manager_setSessionName(self, name)

    def setModel(self, model):
        r"""
        setModel(Manager self, Model model)

        Parameters
        ----------
        model: OpenSim::Model &

        """
        return _simulation.Manager_setModel(self, model)

    def getSessionName(self):
        r"""getSessionName(Manager self) -> std::string const &"""
        return _simulation.Manager_getSessionName(self)

    def toString(self):
        r"""toString(Manager self) -> std::string const &"""
        return _simulation.Manager_toString(self)

    def setPerformAnalyses(self, performAnalyses):
        r"""
        setPerformAnalyses(Manager self, bool performAnalyses)

        Parameters
        ----------
        performAnalyses: bool

        """
        return _simulation.Manager_setPerformAnalyses(self, performAnalyses)

    def setWriteToStorage(self, writeToStorage):
        r"""
        setWriteToStorage(Manager self, bool writeToStorage)

        Parameters
        ----------
        writeToStorage: bool

        """
        return _simulation.Manager_setWriteToStorage(self, writeToStorage)
    IntegratorMethod_ExplicitEuler = _simulation.Manager_IntegratorMethod_ExplicitEuler
    r""" 0 : For details, see SimTK::ExplicitEulerIntegrator."""
    IntegratorMethod_RungeKutta2 = _simulation.Manager_IntegratorMethod_RungeKutta2
    r""" 1 : For details, see SimTK::RungeKutta2Integrator."""
    IntegratorMethod_RungeKutta3 = _simulation.Manager_IntegratorMethod_RungeKutta3
    r""" 2 : For details, see SimTK::RungeKutta3Integrator."""
    IntegratorMethod_RungeKuttaFeldberg = _simulation.Manager_IntegratorMethod_RungeKuttaFeldberg
    r""" 3 : For details, see SimTK::RungeKuttaFeldbergIntegrator."""
    IntegratorMethod_RungeKuttaMerson = _simulation.Manager_IntegratorMethod_RungeKuttaMerson
    r""" 4 : For details, see SimTK::RungeKuttaMersonIntegrator."""
    IntegratorMethod_SemiExplicitEuler2 = _simulation.Manager_IntegratorMethod_SemiExplicitEuler2
    r""" 5 : For details, see SimTK::SemiExplicitEuler2Integrator."""
    IntegratorMethod_Verlet = _simulation.Manager_IntegratorMethod_Verlet
    r""" 6 : For details, see SimTK::VerletIntegrator."""

    def setIntegratorMethod(self, integMethod):
        r"""
         Sets the integrator method used via IntegratorMethod enum. The
        integrator will be set to its default options, even if the caller
        requests the same integrator method. Note that this function must
        be called before `Manager::initialize()`.

              **C++ example**

              .. code-block:: c++

                  auto manager = Manager(model);
                  manager.setIntegratorMethod(Manager::IntegratorMethod::SemiExplicitEuler2);

              **Python example**

              .. code-block:: python

                  import opensim
                  manager = opensim.Manager(model)
                  manager.setIntegratorMethod(opensim.Manager.IntegratorMethod_SemiExplicitEuler2)

              **MATLAB example**

              .. code-block:: c++

                  import org.opensim.modeling.*
                  manager = Manager(model);
                  manager.setIntegratorMethod(5);
        """
        return _simulation.Manager_setIntegratorMethod(self, integMethod)

    def getIntegrator(self):
        r"""getIntegrator(Manager self) -> SimTK::Integrator &"""
        return _simulation.Manager_getIntegrator(self)

    def setIntegratorAccuracy(self, accuracy):
        r"""
         Sets the accuracy of the integrator.
        For more details, see `SimTK::Integrator::setAccuracy(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorAccuracy(self, accuracy)

    def setIntegratorMinimumStepSize(self, hmin):
        r"""
         Sets the minimum step size of the integrator.
        For more details, see `SimTK::Integrator::setMinimumStepSize(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorMinimumStepSize(self, hmin)

    def setIntegratorMaximumStepSize(self, hmax):
        r"""
         Sets the maximum step size of the integrator.
        For more details, see `SimTK::Integrator::setMaximumStepSize(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorMaximumStepSize(self, hmax)

    def setIntegratorInternalStepLimit(self, nSteps):
        r"""
         Sets the limit of steps the integrator can take per call of `stepTo()`.
        Note that Manager::integrate() calls `stepTo()` for each interval when a fixed
        step size is used.
        For more details, see SimTK::Integrator::setInternalStepLimit(int).
        """
        return _simulation.Manager_setIntegratorInternalStepLimit(self, nSteps)

    def setUseSpecifiedDT(self, aTrueFalse):
        
        return _simulation.Manager_setUseSpecifiedDT(self, aTrueFalse)

    def getUseSpecifiedDT(self):
        r"""getUseSpecifiedDT(Manager self) -> bool"""
        return _simulation.Manager_getUseSpecifiedDT(self)

    def setUseConstantDT(self, aTrueFalse):
        r"""
        setUseConstantDT(Manager self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        """
        return _simulation.Manager_setUseConstantDT(self, aTrueFalse)

    def getUseConstantDT(self):
        r"""getUseConstantDT(Manager self) -> bool"""
        return _simulation.Manager_getUseConstantDT(self)

    def getDTArray(self):
        r"""getDTArray(Manager self) -> ArrayDouble"""
        return _simulation.Manager_getDTArray(self)

    def setDTArray(self, aDT, aTI=0.0):
        r"""
        setDTArray(Manager self, Vector aDT, double aTI=0.0)

        Parameters
        ----------
        aDT: SimTK::Vector_< double > const &
        aTI: double

        """
        return _simulation.Manager_setDTArray(self, aDT, aTI)

    def getDTArrayDT(self, aStep):
        r"""
        getDTArrayDT(Manager self, int aStep) -> double

        Parameters
        ----------
        aStep: int

        """
        return _simulation.Manager_getDTArrayDT(self, aStep)

    def printDTArray(self, aFileName=None):
        r"""
        printDTArray(Manager self, char const * aFileName=None)

        Parameters
        ----------
        aFileName: char const *

        """
        return _simulation.Manager_printDTArray(self, aFileName)

    def getTimeArray(self):
        r"""getTimeArray(Manager self) -> ArrayDouble"""
        return _simulation.Manager_getTimeArray(self)

    def getTimeArrayTime(self, aStep):
        r"""
        getTimeArrayTime(Manager self, int aStep) -> double

        Parameters
        ----------
        aStep: int

        """
        return _simulation.Manager_getTimeArrayTime(self, aStep)

    def getTimeArrayStep(self, aTime):
        r"""
        getTimeArrayStep(Manager self, double aTime) -> int

        Parameters
        ----------
        aTime: double

        """
        return _simulation.Manager_getTimeArrayStep(self, aTime)

    def printTimeArray(self, aFileName=None):
        r"""
        printTimeArray(Manager self, char const * aFileName=None)

        Parameters
        ----------
        aFileName: char const *

        """
        return _simulation.Manager_printTimeArray(self, aFileName)

    def resetTimeAndDTArrays(self, aTime):
        r"""
        resetTimeAndDTArrays(Manager self, double aTime)

        Parameters
        ----------
        aTime: double

        """
        return _simulation.Manager_resetTimeAndDTArrays(self, aTime)

    def getNextTimeArrayTime(self, aTime):
        r"""
        getNextTimeArrayTime(Manager self, double aTime) -> double

        Parameters
        ----------
        aTime: double

        """
        return _simulation.Manager_getNextTimeArrayTime(self, aTime)

    def initialize(self, s):
        r"""
        Initializes the Manager by creating and initializing the underlying
        SimTK::TimeStepper. This must be called before calling
        Manager::integrate() Subsequent changes to the State object passed in
        here will not affect the simulation. Calling this function multiple
        times with the same Manager will trigger an Exception.

        Changes to the integrator (e.g., setIntegratorAccuracy()) after calling
        initialize() may not have any effect.
        """
        return _simulation.Manager_initialize(self, s)

    def integrate(self, finalTime):
        r"""
        Integrate the equations of motion for the specified model, given the current
        state (at which the integration will start) and a finalTime. You must call
        Manager::initialize() before calling this function.

        If you must update states or controls in a loop, you must recreate the
        manager within the loop (such discontinuous changes are considered "events"
        and cannot be handled during integration of the otherwise continuous system).
        The proper way to handle this situation is to create a SimTK::EventHandler.

        Example: Integrating from time = 1s to time = 2s

        .. code-block:: c++

            SimTK::State state = model.initSystem();
            Manager manager(model);
            state.setTime(1.0);
            manager.initialize(state);
            state = manager.integrate(2.0);

        Example: Integrating from time = 1s to time = 2s using the
                 convenience constructor

        .. code-block:: c++

            SimTK::State state = model.initSystem();
            state.setTime(1.0);
            Manager manager(model, state);
            state = manager.integrate(2.0);

        Example: Integrate from time = 0s to time = 10s, in 2s increments

        .. code-block:: c++

            dTime = 2.0;
            finalTime = 10.0;
            int n = int(round(finalTime/dTime));
            state.setTime(0.0);
            manager.initialize(state);
            for (int i = 1; i <= n; ++i) {
                state = manager.integrate(i*dTime);
            }

        Example: Integrate from time = 0s to time = 10s, updating the state
                 (e.g., the model's first coordinate value) every 2s

        .. code-block:: c++

            dTime = 2.0;
            finalTime = 10.0;
            int n = int(round(finalTime/dTime));
            state.setTime(0.0);
            for (int i = 0; i < n; ++i) {
                model.getCoordinateSet().get(0).setValue(state, 0.1*i);
                Manager manager(model);
                state.setTime(i*dTime);
                manager.initialize(state);
                state = manager.integrate((i+1)*dTime);
            }
        """
        return _simulation.Manager_integrate(self, finalTime)

    def getState(self):
        r"""
         Get the current State from the Integrator associated with this
        Manager.
        """
        return _simulation.Manager_getState(self)

    def getFixedStepSize(self, tArrayStep):
        r"""
        getFixedStepSize(Manager self, int tArrayStep) -> double

        Parameters
        ----------
        tArrayStep: int

        """
        return _simulation.Manager_getFixedStepSize(self, tArrayStep)

    def hasStateStorage(self):
        r"""hasStateStorage(Manager self) -> bool"""
        return _simulation.Manager_hasStateStorage(self)

    def setStateStorage(self, aStorage):
        r"""
        Set the Storage object to be used for storing states. The Manager takes
           ownership of the passed-in Storage.
        """
        return _simulation.Manager_setStateStorage(self, aStorage)

    def getStateStorage(self):
        r"""getStateStorage(Manager self) -> Storage"""
        return _simulation.Manager_getStateStorage(self)

    def getStatesTable(self):
        r"""getStatesTable(Manager self) -> TimeSeriesTable"""
        return _simulation.Manager_getStatesTable(self)

    def halt(self):
        r"""halt(Manager self)"""
        return _simulation.Manager_halt(self)

    def clearHalt(self):
        r"""clearHalt(Manager self)"""
        return _simulation.Manager_clearHalt(self)

    def checkHalt(self):
        r"""checkHalt(Manager self) -> bool"""
        return _simulation.Manager_checkHalt(self)
    __swig_destroy__ = _simulation.delete_Manager

# Register Manager in _simulation:
_simulation.Manager_swigregister(Manager)
class AbstractTool(opensim.common.OpenSimObject):
    r"""
    An abstract class for specifying the interface for an investigation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AbstractTool

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AbstractTool_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AbstractTool self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AbstractTool_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AbstractTool_getClassName()

    def clone(self):
        r"""clone(AbstractTool self) -> AbstractTool"""
        return _simulation.AbstractTool_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AbstractTool self) -> std::string const &"""
        return _simulation.AbstractTool_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_AbstractTool

    def setModel(self, aModel):
        r"""
        %Set the model to be investigated.
        NOTE: setup() should have been called on the model prior to calling this method
        """
        return _simulation.AbstractTool_setModel(self, aModel)

    def getModel(self):
        r"""Get the model to be investigated."""
        return _simulation.AbstractTool_getModel(self)

    def getReplaceForceSet(self):
        r"""getReplaceForceSet(AbstractTool self) -> bool"""
        return _simulation.AbstractTool_getReplaceForceSet(self)

    def setReplaceForceSet(self, aReplace):
        r"""
        setReplaceForceSet(AbstractTool self, bool aReplace)

        Parameters
        ----------
        aReplace: bool

        """
        return _simulation.AbstractTool_setReplaceForceSet(self, aReplace)

    def getNextAvailableForceName(self, *args):
        r"""
        getNextAvailableForceName(AbstractTool self, std::string const prefix="Force") -> std::string

        Parameters
        ----------
        prefix: std::string const

        """
        return _simulation.AbstractTool_getNextAvailableForceName(self, *args)

    def getExternalLoads(self):
        r"""getExternalLoads(AbstractTool self) -> ExternalLoads"""
        return _simulation.AbstractTool_getExternalLoads(self)

    def updExternalLoads(self):
        r"""updExternalLoads(AbstractTool self) -> ExternalLoads"""
        return _simulation.AbstractTool_updExternalLoads(self)

    def setExternalLoads(self, el):
        r"""
        setExternalLoads(AbstractTool self, ExternalLoads el)

        Parameters
        ----------
        el: OpenSim::ExternalLoads &

        """
        return _simulation.AbstractTool_setExternalLoads(self, el)

    def modelHasExternalLoads(self):
        r"""modelHasExternalLoads(AbstractTool self) -> bool"""
        return _simulation.AbstractTool_modelHasExternalLoads(self)

    def getExternalLoadsFileName(self):
        r"""getExternalLoadsFileName(AbstractTool self) -> std::string const &"""
        return _simulation.AbstractTool_getExternalLoadsFileName(self)

    def setExternalLoadsFileName(self, aFileName):
        r"""
        setExternalLoadsFileName(AbstractTool self, std::string const & aFileName)

        Parameters
        ----------
        aFileName: std::string const &

        """
        return _simulation.AbstractTool_setExternalLoadsFileName(self, aFileName)

    def getForceSetFiles(self):
        r"""getForceSetFiles(AbstractTool self) -> ArrayStr"""
        return _simulation.AbstractTool_getForceSetFiles(self)

    def setForceSetFiles(self, aForceSetFiles):
        r"""
        setForceSetFiles(AbstractTool self, ArrayStr aForceSetFiles)

        Parameters
        ----------
        aForceSetFiles: OpenSim::Array< std::string > const &

        """
        return _simulation.AbstractTool_setForceSetFiles(self, aForceSetFiles)

    def getOutputPrecision(self):
        r"""getOutputPrecision(AbstractTool self) -> int"""
        return _simulation.AbstractTool_getOutputPrecision(self)

    def setOutputPrecision(self, aPrecision):
        r"""
        setOutputPrecision(AbstractTool self, int aPrecision)

        Parameters
        ----------
        aPrecision: int

        """
        return _simulation.AbstractTool_setOutputPrecision(self, aPrecision)

    def getAnalysisSet(self):
        r"""getAnalysisSet(AbstractTool self) -> AnalysisSet"""
        return _simulation.AbstractTool_getAnalysisSet(self)

    def updAnalysisSet(self):
        r"""updAnalysisSet(AbstractTool self) -> AnalysisSet"""
        return _simulation.AbstractTool_updAnalysisSet(self)

    def getControllerSet(self):
        r"""getControllerSet(AbstractTool self) -> ControllerSet"""
        return _simulation.AbstractTool_getControllerSet(self)

    def updControllerSet(self):
        r"""updControllerSet(AbstractTool self) -> ControllerSet"""
        return _simulation.AbstractTool_updControllerSet(self)

    def getResultsDir(self):
        r"""Get Results Directory"""
        return _simulation.AbstractTool_getResultsDir(self)

    def setResultsDir(self, aString):
        r"""
        setResultsDir(AbstractTool self, std::string const & aString)

        Parameters
        ----------
        aString: std::string const &

        """
        return _simulation.AbstractTool_setResultsDir(self, aString)

    def getInitialTime(self):
        r"""getInitialTime(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getInitialTime(self)

    def getFinalTime(self):
        r"""getFinalTime(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getFinalTime(self)

    def setInitialTime(self, aInitialTime):
        r"""
        setInitialTime(AbstractTool self, double const aInitialTime)

        Parameters
        ----------
        aInitialTime: double const

        """
        return _simulation.AbstractTool_setInitialTime(self, aInitialTime)

    def setFinalTime(self, aFinalTime):
        r"""
        setFinalTime(AbstractTool self, double const aFinalTime)

        Parameters
        ----------
        aFinalTime: double const

        """
        return _simulation.AbstractTool_setFinalTime(self, aFinalTime)

    def getStartTime(self):
        r"""getStartTime(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getStartTime(self)

    def setStartTime(self, aStartTime):
        r"""
        setStartTime(AbstractTool self, double const aStartTime)

        Parameters
        ----------
        aStartTime: double const

        """
        return _simulation.AbstractTool_setStartTime(self, aStartTime)

    def getMaximumNumberOfSteps(self):
        r"""getMaximumNumberOfSteps(AbstractTool self) -> int"""
        return _simulation.AbstractTool_getMaximumNumberOfSteps(self)

    def setMaximumNumberOfSteps(self, aMaxSteps):
        r"""
        setMaximumNumberOfSteps(AbstractTool self, int aMaxSteps)

        Parameters
        ----------
        aMaxSteps: int

        """
        return _simulation.AbstractTool_setMaximumNumberOfSteps(self, aMaxSteps)

    def getMaxDT(self):
        r"""getMaxDT(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getMaxDT(self)

    def setMaxDT(self, aMaxDT):
        r"""
        setMaxDT(AbstractTool self, double aMaxDT)

        Parameters
        ----------
        aMaxDT: double

        """
        return _simulation.AbstractTool_setMaxDT(self, aMaxDT)

    def getMinDT(self):
        r"""getMinDT(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getMinDT(self)

    def setMinDT(self, aMinDT):
        r"""
        setMinDT(AbstractTool self, double aMinDT)

        Parameters
        ----------
        aMinDT: double

        """
        return _simulation.AbstractTool_setMinDT(self, aMinDT)

    def getErrorTolerance(self):
        r"""getErrorTolerance(AbstractTool self) -> double"""
        return _simulation.AbstractTool_getErrorTolerance(self)

    def setErrorTolerance(self, aErrorTolerance):
        r"""
        setErrorTolerance(AbstractTool self, double aErrorTolerance)

        Parameters
        ----------
        aErrorTolerance: double

        """
        return _simulation.AbstractTool_setErrorTolerance(self, aErrorTolerance)

    def getModelFilename(self):
        r"""getModelFilename(AbstractTool self) -> std::string const &"""
        return _simulation.AbstractTool_getModelFilename(self)

    def setModelFilename(self, aModelFile):
        r"""
        setModelFilename(AbstractTool self, std::string const & aModelFile)

        Parameters
        ----------
        aModelFile: std::string const &

        """
        return _simulation.AbstractTool_setModelFilename(self, aModelFile)

    def getSolveForEquilibrium(self):
        r"""getSolveForEquilibrium(AbstractTool self) -> bool"""
        return _simulation.AbstractTool_getSolveForEquilibrium(self)

    def setSolveForEquilibrium(self, aSolve):
        r"""
        setSolveForEquilibrium(AbstractTool self, bool aSolve)

        Parameters
        ----------
        aSolve: bool

        """
        return _simulation.AbstractTool_setSolveForEquilibrium(self, aSolve)

    def loadModel(self, aToolSetupFileName, rOriginalForceSet=None):
        r"""
        Load and construct a model based on the property settings of
        this investigation.
        """
        return _simulation.AbstractTool_loadModel(self, aToolSetupFileName, rOriginalForceSet)

    def updateModelForces(self, model, aToolSetupFileName, rOriginalForceSet=None):
        r"""Update the forces applied to a model."""
        return _simulation.AbstractTool_updateModelForces(self, model, aToolSetupFileName, rOriginalForceSet)

    def addAnalysisSetToModel(self):
        r"""
        Adds Analysis objects from analysis set to model.

        NOTE: Makes copies of analyses.  Also, both this tool and the model have ownership of their analysis
        objects, therefore making a copy is necessary so a single analysis won't be deleted twice.

        To avoid leaking when the tool is run from the GUI, pointers to the model's copy of the analyses
        are kept around so that they can be removed at the end of tool execution.
         _analysisCopies is used to do this book keeping.
        """
        return _simulation.AbstractTool_addAnalysisSetToModel(self)

    def addControllerSetToModel(self):
        r"""addControllerSetToModel(AbstractTool self)"""
        return _simulation.AbstractTool_addControllerSetToModel(self)

    def removeControllerSetFromModel(self):
        r"""Remove Analysis objects that were added earlier from analysis set to model."""
        return _simulation.AbstractTool_removeControllerSetFromModel(self)

    def removeAnalysisSetFromModel(self):
        r"""removeAnalysisSetFromModel(AbstractTool self)"""
        return _simulation.AbstractTool_removeAnalysisSetFromModel(self)

    def setToolOwnsModel(self, trueFalse):
        r"""
        setToolOwnsModel(AbstractTool self, bool const trueFalse)

        Parameters
        ----------
        trueFalse: bool const

        """
        return _simulation.AbstractTool_setToolOwnsModel(self, trueFalse)

    def getToolOwnsModel(self):
        r"""getToolOwnsModel(AbstractTool self) -> bool"""
        return _simulation.AbstractTool_getToolOwnsModel(self)

    def getControlsFileName(self):
        r"""getControlsFileName(AbstractTool self) -> std::string"""
        return _simulation.AbstractTool_getControlsFileName(self)

    def setControlsFileName(self, controlsFilename):
        r"""
        setControlsFileName(AbstractTool self, std::string const & controlsFilename)

        Parameters
        ----------
        controlsFilename: std::string const &

        """
        return _simulation.AbstractTool_setControlsFileName(self, controlsFilename)

    def run(self):
        r"""run(AbstractTool self) -> bool"""
        return _simulation.AbstractTool_run(self)

    def printResults(self, *args):
        r"""
        Print the results of the analysis.

        :type aBaseName: string
        :param aBaseName: Basename file to which to print the data.
        :type aDir: string, optional
        :param aDir: Directory to which to print the data into.
        :type aDT: float, optional
        :param aDT: Time interval between results (linear interpolation is used).
            If not included as an argument or negative, all time steps are printed
            without interpolation.
        :type aExtension: string, optional
        :param aExtension: Extension for written files.
        """
        return _simulation.AbstractTool_printResults(self, *args)

    def createExternalLoads(self, externalLoadsFileName, model):
        r"""
        createExternalLoads(AbstractTool self, std::string const & externalLoadsFileName, Model model) -> bool

        Parameters
        ----------
        externalLoadsFileName: std::string const &
        model: OpenSim::Model &

        """
        return _simulation.AbstractTool_createExternalLoads(self, externalLoadsFileName, model)

    def removeExternalLoadsFromModel(self):
        r"""removeExternalLoadsFromModel(AbstractTool self)"""
        return _simulation.AbstractTool_removeExternalLoadsFromModel(self)

    def updateFromXMLNode(self, aNode, versionNumber):
        r"""
        updateFromXMLNode(AbstractTool self, SimTK::Xml::Element & aNode, int versionNumber)

        Parameters
        ----------
        aNode: SimTK::Xml::Element &
        versionNumber: int

        """
        return _simulation.AbstractTool_updateFromXMLNode(self, aNode, versionNumber)

    def loadQStorage(self, statesFileName, rQStore):
        r"""
        loadQStorage(AbstractTool self, std::string const & statesFileName, Storage rQStore)

        Parameters
        ----------
        statesFileName: std::string const &
        rQStore: OpenSim::Storage &

        """
        return _simulation.AbstractTool_loadQStorage(self, statesFileName, rQStore)

# Register AbstractTool in _simulation:
_simulation.AbstractTool_swigregister(AbstractTool)
class Point(ModelComponent):
    r"""
    A Point is an OpenSim abstraction for any location in space. Points
    are intended to locate physical structures (such as points of constraints
    and points of muscle attachments) as well as embody the results of spatial
    calculations. For example, if your system involves contact, you can define
    a Point that describes the location of the center-of-pressure as one
    element rolls over another.

    A Point provides its location, velocity and acceleration in the Ground frame
    as a function of the Model's (SimTK::MultibodySystem's) state, which is
    accessible when the state has been realized to the corresponding
    SimTK::Stage (i.e. Position, Velocity and Acceleration).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Point

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Point_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Point self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Point_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Point_getClassName()

    def clone(self):
        r"""clone(Point self) -> Point"""
        return _simulation.Point_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Point self) -> std::string const &"""
        return _simulation.Point_getConcreteClassName(self)
    _has_output_location = property(_simulation.Point__has_output_location_get, _simulation.Point__has_output_location_set, doc=r"""_has_output_location : bool""")
    _has_output_velocity = property(_simulation.Point__has_output_velocity_get, _simulation.Point__has_output_velocity_set, doc=r"""_has_output_velocity : bool""")
    _has_output_acceleration = property(_simulation.Point__has_output_acceleration_get, _simulation.Point__has_output_acceleration_set, doc=r"""_has_output_acceleration : bool""")
    __swig_destroy__ = _simulation.delete_Point

    def getLocationInGround(self, state):
        r"""
        *
            Get the location, r_GP, of this Point, P, relative to and expressed in
            the Ground. Point position only valid at Stage::Position or higher.
            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   location of the Point.
            :rtype: :py:class:`Vec3`
            :return: location   The location of the point expressed in the Ground.
        """
        return _simulation.Point_getLocationInGround(self, state)

    def getVelocityInGround(self, state):
        r"""
        The velocity v_GP of this Point, P, relative to and expressed in Ground.
               Point's velocity is only valid at Stage::Velocity or higher.
           :type state: :py:class:`State`
           :param state:       The state applied to the model when determining the
                                  velocity of the Point.
           :rtype: :py:class:`Vec3`
           :return: velocity   The velocity of the point expressed in the Ground.
        """
        return _simulation.Point_getVelocityInGround(self, state)

    def getAccelerationInGround(self, state):
        r"""
        The acceleration a_GP, of this Point, P, relative to and expressed in
           Ground. Point's acceleration is only valid at Stage::Acceleration or higher.
           :type state: :py:class:`State`
           :param state:       The state applied to the model when determining the
                                  acceleration of the Point.
           :rtype: :py:class:`Vec3`
           :return: velocity   The acceleration of the point expressed in Ground
        """
        return _simulation.Point_getAccelerationInGround(self, state)

    def calcDistanceBetween(self, *args):
        r"""
        *Overload 1:*
        Calculate the distance between this Point and some other Point
            :type state: :py:class:`State`
            :param state:      The current State of the model.
            :type other: :py:class:`Point`
            :param other:      The other Point to which we want to get the distance between.
            :rtype: float
            :return: distance  The distance (positive scalar).

        |

        *Overload 2:*
         Calculate the distance between this Point and some other described as a
            location in some other frame.
            :type state: :py:class:`State`
            :param state:      The current State of the model.
            :type frame: :py:class:`Frame`
            :param frame:      The other frame in which the location is defined.
            :type location: :py:class:`Vec3`
            :param location:   The location in the other frame.
            :rtype: float
            :return: distance  The distance (positive scalar).
        """
        return _simulation.Point_calcDistanceBetween(self, *args)

    def calcSpeedBetween(self, state, other):
        r"""
        Calculate the relative speed between this Point and some other Point.
           It is the derivative of the distance with respect to time.
           A positive speed is growing the distance and negative is coming closer.
           :type state: :py:class:`State`
           :param state:      The current State of the model.
           :type other: :py:class:`Point`
           :param other:      The other Point to which we want to get the speed between.
           :rtype: float
           :return: speed     The speed (distance time derivative) which is a scalar.
        """
        return _simulation.Point_calcSpeedBetween(self, state, other)

# Register Point in _simulation:
_simulation.Point_swigregister(Point)
class Station(Point):
    r"""
    A Station is a Point fixed to and located on a PhysicalFrame, which can be
    a Body, Ground or any PhysicalOffsetFrame. Stations are analogous to
    PhyscialOffsetFrames where joints, constraints and forces can be attached
    and/or applied.

    Author: Ayman Habib, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Station

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Station_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Station self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Station_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Station_getClassName()

    def clone(self):
        r"""clone(Station self) -> Station"""
        return _simulation.Station_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Station self) -> std::string const &"""
        return _simulation.Station_getConcreteClassName(self)

    def copyProperty_location(self, source):
        r"""
        copyProperty_location(Station self, Station source)

        Parameters
        ----------
        source: OpenSim::Station::Self const &

        """
        return _simulation.Station_copyProperty_location(self, source)

    def append_location(self, value):
        r"""
        append_location(Station self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Station_append_location(self, value)

    def constructProperty_location(self, initValue):
        r"""
        constructProperty_location(Station self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Station_constructProperty_location(self, initValue)

    def get_location(self, *args):
        r"""
        get_location(Station self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location(Station self) -> Vec3
        """
        return _simulation.Station_get_location(self, *args)

    def upd_location(self, *args):
        r"""
        upd_location(Station self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location(Station self) -> Vec3
        """
        return _simulation.Station_upd_location(self, *args)

    def set_location(self, *args):
        r"""
        set_location(Station self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location(Station self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Station_set_location(self, *args)
    PropertyIndex_socket_parent_frame = property(_simulation.Station_PropertyIndex_socket_parent_frame_get, _simulation.Station_PropertyIndex_socket_parent_frame_set, doc=r"""PropertyIndex_socket_parent_frame : OpenSim::PropertyIndex""")

    def connectSocket_parent_frame(self, object):
        r"""
        connectSocket_parent_frame(Station self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Station_connectSocket_parent_frame(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
           :type frame: :py:class:`PhysicalFrame`, in
           :param frame:     PhysicalFrame in which the Station is located.
           :type location: :py:class:`Vec3`, in
           :param location:  Vec3 location of the station in its PhysicalFrame
        """
        _simulation.Station_swiginit(self, _simulation.new_Station(*args))
    __swig_destroy__ = _simulation.delete_Station

    def getParentFrame(self):
        r""" get the parent PhysicalFrame in which the Station is defined"""
        return _simulation.Station_getParentFrame(self)

    def setParentFrame(self, aFrame):
        r""" set the parent PhysicalFrame in which the Station is defined"""
        return _simulation.Station_setParentFrame(self, aFrame)

    def findLocationInFrame(self, s, frame):
        r""" Find this Station's location in any Frame"""
        return _simulation.Station_findLocationInFrame(self, s, frame)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(Station self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.Station_extendScale(self, s, scaleSet)

# Register Station in _simulation:
_simulation.Station_swigregister(Station)
class Marker(Station):
    r"""
    A class implementing a Mocap marker.

    Author: Ayman Habib, Peter Loan
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Marker

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Marker_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Marker self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Marker_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Marker_getClassName()

    def clone(self):
        r"""clone(Marker self) -> Marker"""
        return _simulation.Marker_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Marker self) -> std::string const &"""
        return _simulation.Marker_getConcreteClassName(self)

    def copyProperty_fixed(self, source):
        r"""
        copyProperty_fixed(Marker self, Marker source)

        Parameters
        ----------
        source: OpenSim::Marker::Self const &

        """
        return _simulation.Marker_copyProperty_fixed(self, source)

    def append_fixed(self, value):
        r"""
        append_fixed(Marker self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Marker_append_fixed(self, value)

    def constructProperty_fixed(self, initValue):
        r"""
        constructProperty_fixed(Marker self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Marker_constructProperty_fixed(self, initValue)

    def get_fixed(self, *args):
        r"""
        get_fixed(Marker self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_fixed(Marker self) -> bool const &
        """
        return _simulation.Marker_get_fixed(self, *args)

    def upd_fixed(self, *args):
        r"""
        upd_fixed(Marker self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_fixed(Marker self) -> bool &
        """
        return _simulation.Marker_upd_fixed(self, *args)

    def set_fixed(self, *args):
        r"""
        set_fixed(Marker self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_fixed(Marker self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Marker_set_fixed(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
           :type name: string, in
           :param name:      Marker name string.
           :type frame: :py:class:`PhysicalFrame`, in
           :param frame:     PhysicalFrame in which the Marker is located.
           :type location: :py:class:`Vec3`, in
           :param location:  Vec3 location of the station in its PhysicalFrame
        """
        _simulation.Marker_swiginit(self, _simulation.new_Marker(*args))
    __swig_destroy__ = _simulation.delete_Marker

    def getParentFrameName(self):
        r""" Convenience method to get the 'parent_frame' Socket's connectee_name"""
        return _simulation.Marker_getParentFrameName(self)

    def setParentFrameName(self, parentFrameName):
        r"""
        Convenience method to set the 'parent_frame' Socket's connectee_name.
               The the named parent frame is not connected and finalizeConnections()
               must be invoked to establish the connection.
        """
        return _simulation.Marker_setParentFrameName(self, parentFrameName)

    def changeFrame(self, parentFrame):
        r""" Change the parent PhysicalFrame that this marker is attached to."""
        return _simulation.Marker_changeFrame(self, parentFrame)

    def changeFramePreserveLocation(self, s, newParentFrame):
        r"""
        Change the parent PhysicalFrame that this marker is attached to. In
               addition, preserve the marker location in the inertial (Ground) frame
               by using the state to compute the location in the new parent frame and
               to set its location property.
        """
        return _simulation.Marker_changeFramePreserveLocation(self, s, newParentFrame)

    def updateFromXMLNode(self, aNode, versionNumber=-1):
        r""" Override of the default implementation to account for versioning."""
        return _simulation.Marker_updateFromXMLNode(self, aNode, versionNumber)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        generateDecorations(Marker self, bool fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        state: SimTK::State const &
        appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.Marker_generateDecorations(self, fixed, hints, state, appendToThis)

# Register Marker in _simulation:
_simulation.Marker_swigregister(Marker)
class SetMarkers(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetMarkers

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetMarkers_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetMarkers self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetMarkers_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetMarkers_getClassName()

    def clone(self):
        r"""clone(SetMarkers self) -> SetMarkers"""
        return _simulation.SetMarkers_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetMarkers self) -> std::string const &"""
        return _simulation.SetMarkers_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMarkers

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Marker,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetMarkers_swiginit(self, _simulation.new_SetMarkers(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMarkers_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMarkers_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMarkers_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMarkers_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Marker`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMarkers_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetMarkers_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Marker`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkers_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Marker`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkers_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Marker`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMarkers_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Marker`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMarkers_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetMarkers self)"""
        return _simulation.SetMarkers_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Marker`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMarkers_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Marker`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Marker`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMarkers_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMarkers_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMarkers_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetMarkers_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetMarkers_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMarkers_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetMarkers_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetMarkers_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetMarkers_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMarkers_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMarkers in _simulation:
_simulation.SetMarkers_swigregister(SetMarkers)
class ModelComponentSetMarkers(SetMarkers):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Marker > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetMarkers

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetMarkers_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetMarkers self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetMarkers_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetMarkers_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetMarkers self) -> ModelComponentSetMarkers"""
        return _simulation.ModelComponentSetMarkers_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetMarkers self) -> std::string const &"""
        return _simulation.ModelComponentSetMarkers_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetMarkers self)"""
        return _simulation.ModelComponentSetMarkers_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetMarkers self) -> ModelComponentSetMarkers"""
        _simulation.ModelComponentSetMarkers_swiginit(self, _simulation.new_ModelComponentSetMarkers())
    __swig_destroy__ = _simulation.delete_ModelComponentSetMarkers

# Register ModelComponentSetMarkers in _simulation:
_simulation.ModelComponentSetMarkers_swigregister(ModelComponentSetMarkers)
class MarkerSet(ModelComponentSetMarkers):
    r"""
    A class for holding a set of markers.

    Authors: Ayman Habib, Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MarkerSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MarkerSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MarkerSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MarkerSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MarkerSet_getClassName()

    def clone(self):
        r"""clone(MarkerSet self) -> MarkerSet"""
        return _simulation.MarkerSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MarkerSet self) -> std::string const &"""
        return _simulation.MarkerSet_getConcreteClassName(self)

    def getMarkerNames(self, aMarkerNamesArray):
        r"""
        getMarkerNames(MarkerSet self, ArrayStr aMarkerNamesArray)

        Parameters
        ----------
        aMarkerNamesArray: OpenSim::Array< std::string > &

        """
        return _simulation.MarkerSet_getMarkerNames(self, aMarkerNamesArray)

    def addNamePrefix(self, prefix):
        r""" Add a prefix to marker names for all markers in the set*"""
        return _simulation.MarkerSet_addNamePrefix(self, prefix)

    def __init__(self, *args):
        r"""
        __init__(MarkerSet self) -> MarkerSet
        __init__(MarkerSet self, std::string const & file, bool updateFromXML=True) -> MarkerSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.MarkerSet_swiginit(self, _simulation.new_MarkerSet(*args))

    def adoptAndAppend(self, aMarker):
        aMarker._markAdopted()
        return super(MarkerSet, self).adoptAndAppend(aMarker)

    __swig_destroy__ = _simulation.delete_MarkerSet

# Register MarkerSet in _simulation:
_simulation.MarkerSet_swigregister(MarkerSet)
class WrapSphere(WrapObject):
    r"""
    A class implementing a sphere for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapSphere

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapSphere_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapSphere self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapSphere_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapSphere_getClassName()

    def clone(self):
        r"""clone(WrapSphere self) -> WrapSphere"""
        return _simulation.WrapSphere_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapSphere self) -> std::string const &"""
        return _simulation.WrapSphere_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(WrapSphere self, WrapSphere source)

        Parameters
        ----------
        source: OpenSim::WrapSphere::Self const &

        """
        return _simulation.WrapSphere_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(WrapSphere self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphere_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(WrapSphere self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapSphere_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(WrapSphere self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(WrapSphere self) -> double const &
        """
        return _simulation.WrapSphere_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(WrapSphere self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(WrapSphere self) -> double &
        """
        return _simulation.WrapSphere_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(WrapSphere self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(WrapSphere self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphere_set_radius(self, *args)

    def __init__(self):
        r"""__init__(WrapSphere self) -> WrapSphere"""
        _simulation.WrapSphere_swiginit(self, _simulation.new_WrapSphere())
    __swig_destroy__ = _simulation.delete_WrapSphere

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapSphere self) -> char const *"""
        return _simulation.WrapSphere_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapSphere self) -> std::string"""
        return _simulation.WrapSphere_getDimensionsString(self)

    def getRadius(self):
        r"""getRadius(WrapSphere self) -> double"""
        return _simulation.WrapSphere_getRadius(self)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the sphere by the average of the scale factors in each direction.
               The base class (WrapObject) scales the origin of the sphere in the
               body's reference frame.
        """
        return _simulation.WrapSphere_extendScale(self, s, scaleSet)

# Register WrapSphere in _simulation:
_simulation.WrapSphere_swigregister(WrapSphere)
class WrapCylinder(WrapObject):
    r"""
    A class implementing a cylinder for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapCylinder

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapCylinder_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapCylinder self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapCylinder_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapCylinder_getClassName()

    def clone(self):
        r"""clone(WrapCylinder self) -> WrapCylinder"""
        return _simulation.WrapCylinder_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapCylinder self) -> std::string const &"""
        return _simulation.WrapCylinder_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(WrapCylinder self, WrapCylinder source)

        Parameters
        ----------
        source: OpenSim::WrapCylinder::Self const &

        """
        return _simulation.WrapCylinder_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(WrapCylinder self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinder_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(WrapCylinder self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapCylinder_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(WrapCylinder self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(WrapCylinder self) -> double const &
        """
        return _simulation.WrapCylinder_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(WrapCylinder self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(WrapCylinder self) -> double &
        """
        return _simulation.WrapCylinder_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(WrapCylinder self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(WrapCylinder self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinder_set_radius(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(WrapCylinder self, WrapCylinder source)

        Parameters
        ----------
        source: OpenSim::WrapCylinder::Self const &

        """
        return _simulation.WrapCylinder_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(WrapCylinder self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinder_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(WrapCylinder self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapCylinder_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(WrapCylinder self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(WrapCylinder self) -> double const &
        """
        return _simulation.WrapCylinder_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(WrapCylinder self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(WrapCylinder self) -> double &
        """
        return _simulation.WrapCylinder_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(WrapCylinder self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(WrapCylinder self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinder_set_length(self, *args)

    def __init__(self):
        r"""__init__(WrapCylinder self) -> WrapCylinder"""
        _simulation.WrapCylinder_swiginit(self, _simulation.new_WrapCylinder())
    __swig_destroy__ = _simulation.delete_WrapCylinder

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapCylinder self) -> char const *"""
        return _simulation.WrapCylinder_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapCylinder self) -> std::string"""
        return _simulation.WrapCylinder_getDimensionsString(self)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the cylinder's dimensions. The base class (WrapObject) scales the
               origin of the cylinder in the body's reference frame.
        """
        return _simulation.WrapCylinder_extendScale(self, s, scaleSet)

# Register WrapCylinder in _simulation:
_simulation.WrapCylinder_swigregister(WrapCylinder)
class WrapTorus(WrapObject):
    r"""
    A class implementing a torus for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapTorus

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapTorus_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapTorus self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapTorus_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapTorus_getClassName()

    def clone(self):
        r"""clone(WrapTorus self) -> WrapTorus"""
        return _simulation.WrapTorus_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapTorus self) -> std::string const &"""
        return _simulation.WrapTorus_getConcreteClassName(self)

    def copyProperty_inner_radius(self, source):
        r"""
        copyProperty_inner_radius(WrapTorus self, WrapTorus source)

        Parameters
        ----------
        source: OpenSim::WrapTorus::Self const &

        """
        return _simulation.WrapTorus_copyProperty_inner_radius(self, source)

    def append_inner_radius(self, value):
        r"""
        append_inner_radius(WrapTorus self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapTorus_append_inner_radius(self, value)

    def constructProperty_inner_radius(self, initValue):
        r"""
        constructProperty_inner_radius(WrapTorus self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapTorus_constructProperty_inner_radius(self, initValue)

    def get_inner_radius(self, *args):
        r"""
        get_inner_radius(WrapTorus self, int i) -> double const

        Parameters
        ----------
        i: int

        get_inner_radius(WrapTorus self) -> double const &
        """
        return _simulation.WrapTorus_get_inner_radius(self, *args)

    def upd_inner_radius(self, *args):
        r"""
        upd_inner_radius(WrapTorus self, int i) -> double

        Parameters
        ----------
        i: int

        upd_inner_radius(WrapTorus self) -> double &
        """
        return _simulation.WrapTorus_upd_inner_radius(self, *args)

    def set_inner_radius(self, *args):
        r"""
        set_inner_radius(WrapTorus self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_inner_radius(WrapTorus self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapTorus_set_inner_radius(self, *args)

    def copyProperty_outer_radius(self, source):
        r"""
        copyProperty_outer_radius(WrapTorus self, WrapTorus source)

        Parameters
        ----------
        source: OpenSim::WrapTorus::Self const &

        """
        return _simulation.WrapTorus_copyProperty_outer_radius(self, source)

    def append_outer_radius(self, value):
        r"""
        append_outer_radius(WrapTorus self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapTorus_append_outer_radius(self, value)

    def constructProperty_outer_radius(self, initValue):
        r"""
        constructProperty_outer_radius(WrapTorus self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapTorus_constructProperty_outer_radius(self, initValue)

    def get_outer_radius(self, *args):
        r"""
        get_outer_radius(WrapTorus self, int i) -> double const

        Parameters
        ----------
        i: int

        get_outer_radius(WrapTorus self) -> double const &
        """
        return _simulation.WrapTorus_get_outer_radius(self, *args)

    def upd_outer_radius(self, *args):
        r"""
        upd_outer_radius(WrapTorus self, int i) -> double

        Parameters
        ----------
        i: int

        upd_outer_radius(WrapTorus self) -> double &
        """
        return _simulation.WrapTorus_upd_outer_radius(self, *args)

    def set_outer_radius(self, *args):
        r"""
        set_outer_radius(WrapTorus self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_outer_radius(WrapTorus self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapTorus_set_outer_radius(self, *args)

    def __init__(self):
        r"""__init__(WrapTorus self) -> WrapTorus"""
        _simulation.WrapTorus_swiginit(self, _simulation.new_WrapTorus())
    __swig_destroy__ = _simulation.delete_WrapTorus

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapTorus self) -> char const *"""
        return _simulation.WrapTorus_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapTorus self) -> std::string"""
        return _simulation.WrapTorus_getDimensionsString(self)

    def getInnerRadius(self):
        r"""getInnerRadius(WrapTorus self) -> SimTK::Real"""
        return _simulation.WrapTorus_getInnerRadius(self)

    def getOuterRadius(self):
        r"""getOuterRadius(WrapTorus self) -> SimTK::Real"""
        return _simulation.WrapTorus_getOuterRadius(self)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the torus's dimensions. The base class (WrapObject) scales the
               origin of the torus in the body's reference frame.
        """
        return _simulation.WrapTorus_extendScale(self, s, scaleSet)

# Register WrapTorus in _simulation:
_simulation.WrapTorus_swigregister(WrapTorus)
class WrapEllipsoid(WrapObject):
    r"""
    A class implementing an ellipsoid for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapEllipsoid

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapEllipsoid_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapEllipsoid self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapEllipsoid_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapEllipsoid_getClassName()

    def clone(self):
        r"""clone(WrapEllipsoid self) -> WrapEllipsoid"""
        return _simulation.WrapEllipsoid_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapEllipsoid self) -> std::string const &"""
        return _simulation.WrapEllipsoid_getConcreteClassName(self)

    def copyProperty_dimensions(self, source):
        r"""
        copyProperty_dimensions(WrapEllipsoid self, WrapEllipsoid source)

        Parameters
        ----------
        source: OpenSim::WrapEllipsoid::Self const &

        """
        return _simulation.WrapEllipsoid_copyProperty_dimensions(self, source)

    def append_dimensions(self, value):
        r"""
        append_dimensions(WrapEllipsoid self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapEllipsoid_append_dimensions(self, value)

    def constructProperty_dimensions(self, initValue):
        r"""
        constructProperty_dimensions(WrapEllipsoid self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.WrapEllipsoid_constructProperty_dimensions(self, initValue)

    def get_dimensions(self, *args):
        r"""
        get_dimensions(WrapEllipsoid self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_dimensions(WrapEllipsoid self) -> Vec3
        """
        return _simulation.WrapEllipsoid_get_dimensions(self, *args)

    def upd_dimensions(self, *args):
        r"""
        upd_dimensions(WrapEllipsoid self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_dimensions(WrapEllipsoid self) -> Vec3
        """
        return _simulation.WrapEllipsoid_upd_dimensions(self, *args)

    def set_dimensions(self, *args):
        r"""
        set_dimensions(WrapEllipsoid self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_dimensions(WrapEllipsoid self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapEllipsoid_set_dimensions(self, *args)

    def __init__(self):
        r"""__init__(WrapEllipsoid self) -> WrapEllipsoid"""
        _simulation.WrapEllipsoid_swiginit(self, _simulation.new_WrapEllipsoid())
    __swig_destroy__ = _simulation.delete_WrapEllipsoid

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapEllipsoid self) -> char const *"""
        return _simulation.WrapEllipsoid_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapEllipsoid self) -> std::string"""
        return _simulation.WrapEllipsoid_getDimensionsString(self)

    def getRadii(self):
        r"""getRadii(WrapEllipsoid self) -> Vec3"""
        return _simulation.WrapEllipsoid_getRadii(self)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the ellipsoid's dimensions. The base class (WrapObject) scales the
               origin of the ellipsoid in the body's reference frame.
        """
        return _simulation.WrapEllipsoid_extendScale(self, s, scaleSet)

# Register WrapEllipsoid in _simulation:
_simulation.WrapEllipsoid_swigregister(WrapEllipsoid)
class PathWrap(ModelComponent):
    r"""
     Conditional comment: *
    A class implementing an instance of muscle wrapping. That is, it is owned
    by a particular muscle, and contains parameters for wrapping that muscle
    over a particular wrap object.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathWrap

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathWrap_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathWrap self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathWrap_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathWrap_getClassName()

    def clone(self):
        r"""clone(PathWrap self) -> PathWrap"""
        return _simulation.PathWrap_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathWrap self) -> std::string const &"""
        return _simulation.PathWrap_getConcreteClassName(self)

    def copyProperty_wrap_object(self, source):
        r"""
        copyProperty_wrap_object(PathWrap self, PathWrap source)

        Parameters
        ----------
        source: OpenSim::PathWrap::Self const &

        """
        return _simulation.PathWrap_copyProperty_wrap_object(self, source)

    def append_wrap_object(self, value):
        r"""
        append_wrap_object(PathWrap self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PathWrap_append_wrap_object(self, value)

    def constructProperty_wrap_object(self, initValue):
        r"""
        constructProperty_wrap_object(PathWrap self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.PathWrap_constructProperty_wrap_object(self, initValue)

    def get_wrap_object(self, *args):
        r"""
        get_wrap_object(PathWrap self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_wrap_object(PathWrap self) -> std::string const &
        """
        return _simulation.PathWrap_get_wrap_object(self, *args)

    def upd_wrap_object(self, *args):
        r"""
        upd_wrap_object(PathWrap self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_wrap_object(PathWrap self) -> std::string &
        """
        return _simulation.PathWrap_upd_wrap_object(self, *args)

    def set_wrap_object(self, *args):
        r"""
        set_wrap_object(PathWrap self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_wrap_object(PathWrap self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PathWrap_set_wrap_object(self, *args)

    def copyProperty_method(self, source):
        r"""
        copyProperty_method(PathWrap self, PathWrap source)

        Parameters
        ----------
        source: OpenSim::PathWrap::Self const &

        """
        return _simulation.PathWrap_copyProperty_method(self, source)

    def append_method(self, value):
        r"""
        append_method(PathWrap self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PathWrap_append_method(self, value)

    def constructProperty_method(self, initValue):
        r"""
        constructProperty_method(PathWrap self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.PathWrap_constructProperty_method(self, initValue)

    def get_method(self, *args):
        r"""
        get_method(PathWrap self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_method(PathWrap self) -> std::string const &
        """
        return _simulation.PathWrap_get_method(self, *args)

    def upd_method(self, *args):
        r"""
        upd_method(PathWrap self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_method(PathWrap self) -> std::string &
        """
        return _simulation.PathWrap_upd_method(self, *args)

    def set_method(self, *args):
        r"""
        set_method(PathWrap self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_method(PathWrap self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.PathWrap_set_method(self, *args)

    def copyProperty_range(self, source):
        r"""
        copyProperty_range(PathWrap self, PathWrap source)

        Parameters
        ----------
        source: OpenSim::PathWrap::Self const &

        """
        return _simulation.PathWrap_copyProperty_range(self, source)

    def get_range(self, i):
        r"""
        get_range(PathWrap self, int i) -> int const &

        Parameters
        ----------
        i: int

        """
        return _simulation.PathWrap_get_range(self, i)

    def upd_range(self, i):
        r"""
        upd_range(PathWrap self, int i) -> int &

        Parameters
        ----------
        i: int

        """
        return _simulation.PathWrap_upd_range(self, i)

    def set_range(self, i, value):
        r"""
        set_range(PathWrap self, int i, int const & value)

        Parameters
        ----------
        i: int
        value: int const &

        """
        return _simulation.PathWrap_set_range(self, i, value)

    def append_range(self, value):
        r"""
        append_range(PathWrap self, int const & value) -> int

        Parameters
        ----------
        value: int const &

        """
        return _simulation.PathWrap_append_range(self, value)
    hybrid = _simulation.PathWrap_hybrid
    
    midpoint = _simulation.PathWrap_midpoint
    
    axial = _simulation.PathWrap_axial
    

    def __init__(self):
        r"""__init__(PathWrap self) -> PathWrap"""
        _simulation.PathWrap_swiginit(self, _simulation.new_PathWrap())
    __swig_destroy__ = _simulation.delete_PathWrap

    def getStartPoint(self):
        r"""getStartPoint(PathWrap self) -> int"""
        return _simulation.PathWrap_getStartPoint(self)

    def getEndPoint(self):
        r"""getEndPoint(PathWrap self) -> int"""
        return _simulation.PathWrap_getEndPoint(self)

    def getWrapObjectName(self):
        r"""getWrapObjectName(PathWrap self) -> std::string const &"""
        return _simulation.PathWrap_getWrapObjectName(self)

    def getWrapObject(self):
        r"""getWrapObject(PathWrap self) -> WrapObject"""
        return _simulation.PathWrap_getWrapObject(self)

    def setWrapObject(self, aWrapObject):
        r"""
        setWrapObject(PathWrap self, WrapObject aWrapObject)

        Parameters
        ----------
        aWrapObject: OpenSim::WrapObject &

        """
        return _simulation.PathWrap_setWrapObject(self, aWrapObject)

    def getWrapPoint1(self):
        r"""getWrapPoint1(PathWrap self) -> PathWrapPoint const &"""
        return _simulation.PathWrap_getWrapPoint1(self)

    def getWrapPoint2(self):
        r"""getWrapPoint2(PathWrap self) -> PathWrapPoint const &"""
        return _simulation.PathWrap_getWrapPoint2(self)

    def updWrapPoint1(self):
        r"""updWrapPoint1(PathWrap self) -> PathWrapPoint &"""
        return _simulation.PathWrap_updWrapPoint1(self)

    def updWrapPoint2(self):
        r"""updWrapPoint2(PathWrap self) -> PathWrapPoint &"""
        return _simulation.PathWrap_updWrapPoint2(self)

    def getMethod(self):
        r"""getMethod(PathWrap self) -> OpenSim::PathWrap::WrapMethod"""
        return _simulation.PathWrap_getMethod(self)

    def setMethod(self, aMethod):
        r"""
        setMethod(PathWrap self, OpenSim::PathWrap::WrapMethod aMethod)

        Parameters
        ----------
        aMethod: enum OpenSim::PathWrap::WrapMethod

        """
        return _simulation.PathWrap_setMethod(self, aMethod)

    def getMethodName(self):
        r"""getMethodName(PathWrap self) -> std::string const &"""
        return _simulation.PathWrap_getMethodName(self)

    def getPreviousWrap(self):
        r"""getPreviousWrap(PathWrap self) -> OpenSim::WrapResult const &"""
        return _simulation.PathWrap_getPreviousWrap(self)

    def setPreviousWrap(self, aWrapResult):
        r"""
        setPreviousWrap(PathWrap self, OpenSim::WrapResult const & aWrapResult)

        Parameters
        ----------
        aWrapResult: OpenSim::WrapResult const &

        """
        return _simulation.PathWrap_setPreviousWrap(self, aWrapResult)

    def resetPreviousWrap(self):
        r"""resetPreviousWrap(PathWrap self)"""
        return _simulation.PathWrap_resetPreviousWrap(self)

# Register PathWrap in _simulation:
_simulation.PathWrap_swigregister(PathWrap)
class SetPathWrap(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetPathWrap

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetPathWrap_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetPathWrap self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetPathWrap_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetPathWrap_getClassName()

    def clone(self):
        r"""clone(SetPathWrap self) -> SetPathWrap"""
        return _simulation.SetPathWrap_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetPathWrap self) -> std::string const &"""
        return _simulation.SetPathWrap_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetPathWrap

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::PathWrap,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetPathWrap_swiginit(self, _simulation.new_SetPathWrap(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetPathWrap_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetPathWrap_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetPathWrap_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetPathWrap_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetPathWrap_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetPathWrap_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetPathWrap_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetPathWrap_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetPathWrap_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetPathWrap_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetPathWrap self)"""
        return _simulation.SetPathWrap_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetPathWrap_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`PathWrap`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`PathWrap`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetPathWrap_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetPathWrap_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetPathWrap_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetPathWrap_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetPathWrap_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetPathWrap_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetPathWrap_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetPathWrap_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetPathWrap_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetPathWrap_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetPathWrap in _simulation:
_simulation.SetPathWrap_swigregister(SetPathWrap)
class PathWrapSet(SetPathWrap):
    r"""
     Conditional comment: *
    A class for holding a set of muscle wrap instances.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathWrapSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathWrapSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathWrapSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathWrapSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathWrapSet_getClassName()

    def clone(self):
        r"""clone(PathWrapSet self) -> PathWrapSet"""
        return _simulation.PathWrapSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathWrapSet self) -> std::string const &"""
        return _simulation.PathWrapSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(PathWrapSet self) -> PathWrapSet
        __init__(PathWrapSet self, PathWrapSet aPathWrapSet) -> PathWrapSet

        Parameters
        ----------
        aPathWrapSet: OpenSim::PathWrapSet const &

        """
        _simulation.PathWrapSet_swiginit(self, _simulation.new_PathWrapSet(*args))
    __swig_destroy__ = _simulation.delete_PathWrapSet

# Register PathWrapSet in _simulation:
_simulation.PathWrapSet_swigregister(PathWrapSet)
class WrapCylinderObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a cylinder obstacle for muscle wrapping, based on
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapCylinderObst

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapCylinderObst_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapCylinderObst self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapCylinderObst_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapCylinderObst_getClassName()

    def clone(self):
        r"""clone(WrapCylinderObst self) -> WrapCylinderObst"""
        return _simulation.WrapCylinderObst_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapCylinderObst self) -> std::string const &"""
        return _simulation.WrapCylinderObst_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(WrapCylinderObst self, WrapCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapCylinderObst::Self const &

        """
        return _simulation.WrapCylinderObst_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(WrapCylinderObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinderObst_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(WrapCylinderObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapCylinderObst_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(WrapCylinderObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(WrapCylinderObst self) -> double const &
        """
        return _simulation.WrapCylinderObst_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(WrapCylinderObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(WrapCylinderObst self) -> double &
        """
        return _simulation.WrapCylinderObst_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(WrapCylinderObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(WrapCylinderObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinderObst_set_radius(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(WrapCylinderObst self, WrapCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapCylinderObst::Self const &

        """
        return _simulation.WrapCylinderObst_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(WrapCylinderObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinderObst_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(WrapCylinderObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapCylinderObst_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(WrapCylinderObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(WrapCylinderObst self) -> double const &
        """
        return _simulation.WrapCylinderObst_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(WrapCylinderObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(WrapCylinderObst self) -> double &
        """
        return _simulation.WrapCylinderObst_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(WrapCylinderObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(WrapCylinderObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapCylinderObst_set_length(self, *args)

    def copyProperty_wrapDirection(self, source):
        r"""
        copyProperty_wrapDirection(WrapCylinderObst self, WrapCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapCylinderObst::Self const &

        """
        return _simulation.WrapCylinderObst_copyProperty_wrapDirection(self, source)

    def append_wrapDirection(self, value):
        r"""
        append_wrapDirection(WrapCylinderObst self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapCylinderObst_append_wrapDirection(self, value)

    def constructProperty_wrapDirection(self, initValue):
        r"""
        constructProperty_wrapDirection(WrapCylinderObst self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.WrapCylinderObst_constructProperty_wrapDirection(self, initValue)

    def get_wrapDirection(self, *args):
        r"""
        get_wrapDirection(WrapCylinderObst self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_wrapDirection(WrapCylinderObst self) -> std::string const &
        """
        return _simulation.WrapCylinderObst_get_wrapDirection(self, *args)

    def upd_wrapDirection(self, *args):
        r"""
        upd_wrapDirection(WrapCylinderObst self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_wrapDirection(WrapCylinderObst self) -> std::string &
        """
        return _simulation.WrapCylinderObst_upd_wrapDirection(self, *args)

    def set_wrapDirection(self, *args):
        r"""
        set_wrapDirection(WrapCylinderObst self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_wrapDirection(WrapCylinderObst self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapCylinderObst_set_wrapDirection(self, *args)

    def __init__(self):
        r"""__init__(WrapCylinderObst self) -> WrapCylinderObst"""
        _simulation.WrapCylinderObst_swiginit(self, _simulation.new_WrapCylinderObst())
    __swig_destroy__ = _simulation.delete_WrapCylinderObst

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapCylinderObst self) -> char const *"""
        return _simulation.WrapCylinderObst_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapCylinderObst self) -> std::string"""
        return _simulation.WrapCylinderObst_getDimensionsString(self)

    def getRadius(self):
        r"""getRadius(WrapCylinderObst self) -> double"""
        return _simulation.WrapCylinderObst_getRadius(self)

    def setRadius(self, aRadius):
        r"""
        setRadius(WrapCylinderObst self, double aRadius)

        Parameters
        ----------
        aRadius: double

        """
        return _simulation.WrapCylinderObst_setRadius(self, aRadius)

    def getLength(self):
        r"""getLength(WrapCylinderObst self) -> double"""
        return _simulation.WrapCylinderObst_getLength(self)

    def setLength(self, aLength):
        r"""
        setLength(WrapCylinderObst self, double aLength)

        Parameters
        ----------
        aLength: double

        """
        return _simulation.WrapCylinderObst_setLength(self, aLength)

    def getWrapDirection(self):
        r"""getWrapDirection(WrapCylinderObst self) -> int"""
        return _simulation.WrapCylinderObst_getWrapDirection(self)

# Register WrapCylinderObst in _simulation:
_simulation.WrapCylinderObst_swigregister(WrapCylinderObst)
class WrapSphereObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a sphere obstacle for muscle wrapping, based on the
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapSphereObst

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapSphereObst_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapSphereObst self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapSphereObst_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapSphereObst_getClassName()

    def clone(self):
        r"""clone(WrapSphereObst self) -> WrapSphereObst"""
        return _simulation.WrapSphereObst_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapSphereObst self) -> std::string const &"""
        return _simulation.WrapSphereObst_getConcreteClassName(self)

    def copyProperty_radius(self, source):
        r"""
        copyProperty_radius(WrapSphereObst self, WrapSphereObst source)

        Parameters
        ----------
        source: OpenSim::WrapSphereObst::Self const &

        """
        return _simulation.WrapSphereObst_copyProperty_radius(self, source)

    def append_radius(self, value):
        r"""
        append_radius(WrapSphereObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphereObst_append_radius(self, value)

    def constructProperty_radius(self, initValue):
        r"""
        constructProperty_radius(WrapSphereObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapSphereObst_constructProperty_radius(self, initValue)

    def get_radius(self, *args):
        r"""
        get_radius(WrapSphereObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radius(WrapSphereObst self) -> double const &
        """
        return _simulation.WrapSphereObst_get_radius(self, *args)

    def upd_radius(self, *args):
        r"""
        upd_radius(WrapSphereObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radius(WrapSphereObst self) -> double &
        """
        return _simulation.WrapSphereObst_upd_radius(self, *args)

    def set_radius(self, *args):
        r"""
        set_radius(WrapSphereObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radius(WrapSphereObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphereObst_set_radius(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(WrapSphereObst self, WrapSphereObst source)

        Parameters
        ----------
        source: OpenSim::WrapSphereObst::Self const &

        """
        return _simulation.WrapSphereObst_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(WrapSphereObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphereObst_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(WrapSphereObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapSphereObst_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(WrapSphereObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(WrapSphereObst self) -> double const &
        """
        return _simulation.WrapSphereObst_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(WrapSphereObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(WrapSphereObst self) -> double &
        """
        return _simulation.WrapSphereObst_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(WrapSphereObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(WrapSphereObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapSphereObst_set_length(self, *args)

    def __init__(self):
        r"""__init__(WrapSphereObst self) -> WrapSphereObst"""
        _simulation.WrapSphereObst_swiginit(self, _simulation.new_WrapSphereObst())
    __swig_destroy__ = _simulation.delete_WrapSphereObst

    def getRadius(self):
        r"""getRadius(WrapSphereObst self) -> double"""
        return _simulation.WrapSphereObst_getRadius(self)

    def setRadius(self, aRadius):
        r"""
        setRadius(WrapSphereObst self, double aRadius)

        Parameters
        ----------
        aRadius: double

        """
        return _simulation.WrapSphereObst_setRadius(self, aRadius)

    def getLength(self):
        r"""getLength(WrapSphereObst self) -> double"""
        return _simulation.WrapSphereObst_getLength(self)

    def setLength(self, aLength):
        r"""
        setLength(WrapSphereObst self, double aLength)

        Parameters
        ----------
        aLength: double

        """
        return _simulation.WrapSphereObst_setLength(self, aLength)

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapSphereObst self) -> char const *"""
        return _simulation.WrapSphereObst_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapSphereObst self) -> std::string"""
        return _simulation.WrapSphereObst_getDimensionsString(self)

# Register WrapSphereObst in _simulation:
_simulation.WrapSphereObst_swigregister(WrapSphereObst)
class WrapDoubleCylinderObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a cylinder obstacle for muscle wrapping, based on
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> WrapDoubleCylinderObst

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.WrapDoubleCylinderObst_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(WrapDoubleCylinderObst self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.WrapDoubleCylinderObst_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.WrapDoubleCylinderObst_getClassName()

    def clone(self):
        r"""clone(WrapDoubleCylinderObst self) -> WrapDoubleCylinderObst"""
        return _simulation.WrapDoubleCylinderObst_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(WrapDoubleCylinderObst self) -> std::string const &"""
        return _simulation.WrapDoubleCylinderObst_getConcreteClassName(self)

    def copyProperty_wrapVcylHomeBodyName(self, source):
        r"""
        copyProperty_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapVcylHomeBodyName(self, source)

    def append_wrapVcylHomeBodyName(self, value):
        r"""
        append_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_append_wrapVcylHomeBodyName(self, value)

    def constructProperty_wrapVcylHomeBodyName(self, initValue):
        r"""
        constructProperty_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapVcylHomeBodyName(self, initValue)

    def get_wrapVcylHomeBodyName(self, *args):
        r"""
        get_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_wrapVcylHomeBodyName(WrapDoubleCylinderObst self) -> std::string const &
        """
        return _simulation.WrapDoubleCylinderObst_get_wrapVcylHomeBodyName(self, *args)

    def upd_wrapVcylHomeBodyName(self, *args):
        r"""
        upd_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_wrapVcylHomeBodyName(WrapDoubleCylinderObst self) -> std::string &
        """
        return _simulation.WrapDoubleCylinderObst_upd_wrapVcylHomeBodyName(self, *args)

    def set_wrapVcylHomeBodyName(self, *args):
        r"""
        set_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_wrapVcylHomeBodyName(WrapDoubleCylinderObst self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_set_wrapVcylHomeBodyName(self, *args)

    def copyProperty_radiusUcyl(self, source):
        r"""
        copyProperty_radiusUcyl(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_radiusUcyl(self, source)

    def append_radiusUcyl(self, value):
        r"""
        append_radiusUcyl(WrapDoubleCylinderObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_append_radiusUcyl(self, value)

    def constructProperty_radiusUcyl(self, initValue):
        r"""
        constructProperty_radiusUcyl(WrapDoubleCylinderObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_radiusUcyl(self, initValue)

    def get_radiusUcyl(self, *args):
        r"""
        get_radiusUcyl(WrapDoubleCylinderObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radiusUcyl(WrapDoubleCylinderObst self) -> double const &
        """
        return _simulation.WrapDoubleCylinderObst_get_radiusUcyl(self, *args)

    def upd_radiusUcyl(self, *args):
        r"""
        upd_radiusUcyl(WrapDoubleCylinderObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radiusUcyl(WrapDoubleCylinderObst self) -> double &
        """
        return _simulation.WrapDoubleCylinderObst_upd_radiusUcyl(self, *args)

    def set_radiusUcyl(self, *args):
        r"""
        set_radiusUcyl(WrapDoubleCylinderObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radiusUcyl(WrapDoubleCylinderObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_set_radiusUcyl(self, *args)

    def copyProperty_radiusVcyl(self, source):
        r"""
        copyProperty_radiusVcyl(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_radiusVcyl(self, source)

    def append_radiusVcyl(self, value):
        r"""
        append_radiusVcyl(WrapDoubleCylinderObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_append_radiusVcyl(self, value)

    def constructProperty_radiusVcyl(self, initValue):
        r"""
        constructProperty_radiusVcyl(WrapDoubleCylinderObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_radiusVcyl(self, initValue)

    def get_radiusVcyl(self, *args):
        r"""
        get_radiusVcyl(WrapDoubleCylinderObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_radiusVcyl(WrapDoubleCylinderObst self) -> double const &
        """
        return _simulation.WrapDoubleCylinderObst_get_radiusVcyl(self, *args)

    def upd_radiusVcyl(self, *args):
        r"""
        upd_radiusVcyl(WrapDoubleCylinderObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_radiusVcyl(WrapDoubleCylinderObst self) -> double &
        """
        return _simulation.WrapDoubleCylinderObst_upd_radiusVcyl(self, *args)

    def set_radiusVcyl(self, *args):
        r"""
        set_radiusVcyl(WrapDoubleCylinderObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_radiusVcyl(WrapDoubleCylinderObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_set_radiusVcyl(self, *args)

    def copyProperty_wrapUcylDirection(self, source):
        r"""
        copyProperty_wrapUcylDirection(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapUcylDirection(self, source)

    def append_wrapUcylDirection(self, value):
        r"""
        append_wrapUcylDirection(WrapDoubleCylinderObst self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_append_wrapUcylDirection(self, value)

    def constructProperty_wrapUcylDirection(self, initValue):
        r"""
        constructProperty_wrapUcylDirection(WrapDoubleCylinderObst self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapUcylDirection(self, initValue)

    def get_wrapUcylDirection(self, *args):
        r"""
        get_wrapUcylDirection(WrapDoubleCylinderObst self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_wrapUcylDirection(WrapDoubleCylinderObst self) -> std::string const &
        """
        return _simulation.WrapDoubleCylinderObst_get_wrapUcylDirection(self, *args)

    def upd_wrapUcylDirection(self, *args):
        r"""
        upd_wrapUcylDirection(WrapDoubleCylinderObst self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_wrapUcylDirection(WrapDoubleCylinderObst self) -> std::string &
        """
        return _simulation.WrapDoubleCylinderObst_upd_wrapUcylDirection(self, *args)

    def set_wrapUcylDirection(self, *args):
        r"""
        set_wrapUcylDirection(WrapDoubleCylinderObst self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_wrapUcylDirection(WrapDoubleCylinderObst self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_set_wrapUcylDirection(self, *args)

    def copyProperty_wrapVcylDirection(self, source):
        r"""
        copyProperty_wrapVcylDirection(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapVcylDirection(self, source)

    def append_wrapVcylDirection(self, value):
        r"""
        append_wrapVcylDirection(WrapDoubleCylinderObst self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_append_wrapVcylDirection(self, value)

    def constructProperty_wrapVcylDirection(self, initValue):
        r"""
        constructProperty_wrapVcylDirection(WrapDoubleCylinderObst self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapVcylDirection(self, initValue)

    def get_wrapVcylDirection(self, *args):
        r"""
        get_wrapVcylDirection(WrapDoubleCylinderObst self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_wrapVcylDirection(WrapDoubleCylinderObst self) -> std::string const &
        """
        return _simulation.WrapDoubleCylinderObst_get_wrapVcylDirection(self, *args)

    def upd_wrapVcylDirection(self, *args):
        r"""
        upd_wrapVcylDirection(WrapDoubleCylinderObst self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_wrapVcylDirection(WrapDoubleCylinderObst self) -> std::string &
        """
        return _simulation.WrapDoubleCylinderObst_upd_wrapVcylDirection(self, *args)

    def set_wrapVcylDirection(self, *args):
        r"""
        set_wrapVcylDirection(WrapDoubleCylinderObst self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_wrapVcylDirection(WrapDoubleCylinderObst self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.WrapDoubleCylinderObst_set_wrapVcylDirection(self, *args)

    def copyProperty_translationVcyl(self, source):
        r"""
        copyProperty_translationVcyl(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_translationVcyl(self, source)

    def append_translationVcyl(self, value):
        r"""
        append_translationVcyl(WrapDoubleCylinderObst self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_append_translationVcyl(self, value)

    def constructProperty_translationVcyl(self, initValue):
        r"""
        constructProperty_translationVcyl(WrapDoubleCylinderObst self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_translationVcyl(self, initValue)

    def get_translationVcyl(self, *args):
        r"""
        get_translationVcyl(WrapDoubleCylinderObst self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translationVcyl(WrapDoubleCylinderObst self) -> Vec3
        """
        return _simulation.WrapDoubleCylinderObst_get_translationVcyl(self, *args)

    def upd_translationVcyl(self, *args):
        r"""
        upd_translationVcyl(WrapDoubleCylinderObst self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translationVcyl(WrapDoubleCylinderObst self) -> Vec3
        """
        return _simulation.WrapDoubleCylinderObst_upd_translationVcyl(self, *args)

    def set_translationVcyl(self, *args):
        r"""
        set_translationVcyl(WrapDoubleCylinderObst self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translationVcyl(WrapDoubleCylinderObst self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_set_translationVcyl(self, *args)

    def copyProperty_xyz_body_rotationVcyl(self, source):
        r"""
        copyProperty_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_xyz_body_rotationVcyl(self, source)

    def append_xyz_body_rotationVcyl(self, value):
        r"""
        append_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_append_xyz_body_rotationVcyl(self, value)

    def constructProperty_xyz_body_rotationVcyl(self, initValue):
        r"""
        constructProperty_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_xyz_body_rotationVcyl(self, initValue)

    def get_xyz_body_rotationVcyl(self, *args):
        r"""
        get_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_xyz_body_rotationVcyl(WrapDoubleCylinderObst self) -> Vec3
        """
        return _simulation.WrapDoubleCylinderObst_get_xyz_body_rotationVcyl(self, *args)

    def upd_xyz_body_rotationVcyl(self, *args):
        r"""
        upd_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_xyz_body_rotationVcyl(WrapDoubleCylinderObst self) -> Vec3
        """
        return _simulation.WrapDoubleCylinderObst_upd_xyz_body_rotationVcyl(self, *args)

    def set_xyz_body_rotationVcyl(self, *args):
        r"""
        set_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_xyz_body_rotationVcyl(WrapDoubleCylinderObst self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.WrapDoubleCylinderObst_set_xyz_body_rotationVcyl(self, *args)

    def copyProperty_length(self, source):
        r"""
        copyProperty_length(WrapDoubleCylinderObst self, WrapDoubleCylinderObst source)

        Parameters
        ----------
        source: OpenSim::WrapDoubleCylinderObst::Self const &

        """
        return _simulation.WrapDoubleCylinderObst_copyProperty_length(self, source)

    def append_length(self, value):
        r"""
        append_length(WrapDoubleCylinderObst self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_append_length(self, value)

    def constructProperty_length(self, initValue):
        r"""
        constructProperty_length(WrapDoubleCylinderObst self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.WrapDoubleCylinderObst_constructProperty_length(self, initValue)

    def get_length(self, *args):
        r"""
        get_length(WrapDoubleCylinderObst self, int i) -> double const

        Parameters
        ----------
        i: int

        get_length(WrapDoubleCylinderObst self) -> double const &
        """
        return _simulation.WrapDoubleCylinderObst_get_length(self, *args)

    def upd_length(self, *args):
        r"""
        upd_length(WrapDoubleCylinderObst self, int i) -> double

        Parameters
        ----------
        i: int

        upd_length(WrapDoubleCylinderObst self) -> double &
        """
        return _simulation.WrapDoubleCylinderObst_upd_length(self, *args)

    def set_length(self, *args):
        r"""
        set_length(WrapDoubleCylinderObst self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_length(WrapDoubleCylinderObst self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.WrapDoubleCylinderObst_set_length(self, *args)

    def __init__(self):
        r"""__init__(WrapDoubleCylinderObst self) -> WrapDoubleCylinderObst"""
        _simulation.WrapDoubleCylinderObst_swiginit(self, _simulation.new_WrapDoubleCylinderObst())
    __swig_destroy__ = _simulation.delete_WrapDoubleCylinderObst

    def getWrapTypeName(self):
        r"""getWrapTypeName(WrapDoubleCylinderObst self) -> char const *"""
        return _simulation.WrapDoubleCylinderObst_getWrapTypeName(self)

    def getDimensionsString(self):
        r"""getDimensionsString(WrapDoubleCylinderObst self) -> std::string"""
        return _simulation.WrapDoubleCylinderObst_getDimensionsString(self)

    def connectToModelAndBody(self, aModel, aBody):
        r"""
        connectToModelAndBody(WrapDoubleCylinderObst self, Model aModel, PhysicalFrame aBody)

        Parameters
        ----------
        aModel: OpenSim::Model &
        aBody: OpenSim::PhysicalFrame &

        """
        return _simulation.WrapDoubleCylinderObst_connectToModelAndBody(self, aModel, aBody)

# Register WrapDoubleCylinderObst in _simulation:
_simulation.WrapDoubleCylinderObst_swigregister(WrapDoubleCylinderObst)
class Probe(ModelComponent):
    r"""
    This class represents a Probe which is designed to query a Vector of model
    values given system state. This model quantity is specified as a
    SimTK::Vector by the pure virtual method computeProbeInputs(), which must be
    specified for each child Probe.  In addition, the Probe model component
    interface allows * operations * to be performed on this value
    (specified by the property: probe_operation), and then have this result
    scaled (by the scalar property: 'scale_factor').

    The data flow of the Probe is shown below:

      .. code-block:: c++


          ===========================
          |  SimTK::Vector          |       DEVELOPER NEEDS TO IMPLEMENT THIS
          |  computeProbeInputs(s)  |
          ===========================
                       |
                       |
                       |                    THIS FUNCTIONALITY BELOW IS
                       |                    PROVIDED BY THE PROBE INTERFACE
          |------------|---------------------------------------------------------|
          |            V                                                         |
          |   =========================         ======================           |
          |   |  Apply the operation  |  ---->  |  Scale the output  |           |
          |   |   'probe_operation'   |         |      'gain'        |           |
          |   =========================         ======================           |
          |                                               |                      |
          |                                               V                      |
          |                                     ========================         |
          |                                     |  SimTK::Vector       |         |
          |                                     |  getProbeOutputs(s)  |---------------->
          |                                     ========================         |
          |                                    This method is called by the      |
          |                                   ProbeReporter, or alternatively    |
          |                                        by the API developer          |
          |----------------------------------------------------------------------|

    The model query is performed at Stage::Report, so that model values are up
    to date and is based on the specific Probe's overridden method
    computeProbeInputs(s).  The final output of the probe is available by
    accessing getProbeOutputs(s).  Note that all queries, operations, and
    scaling are performed by SimTK::Measures.  Note also that to define a new
    child Probe class, three methods which are declared as pure virtual in this
    Probe abstract class need to be overridden:

    - computeProbeInputs()     ---   returns the input probe values (i.e., model
                                     queries).
    - getNumProbeInputs()      ---   returns the size of the vector of input
                                     probe values (i.e., model queries).
    - getProbeOutputLabels()   ---   returns the labels that correspond to each
                                     probe value.

    ** Available probe operations: **
    - 'value' (default): returns the probe input value.
    - 'integrate'      : returns the integral of the probe input value.
    - 'differentiate'  : returns the derivative of the probe input value.
    - 'minimum'        : returns the minimum of the probe input value.
    - 'minabs'         : returns the absolute minimum of the probe input value
                         (always positive).
    - 'maximum'        : returns the maximum of the probe input value.
    - 'maxabs'         : returns the absolute maximum of the probe input value
                         (always positive).

    The Probe interface differs from the Analysis interface in two fundamental
    ways:
    -  (1) Operations can be performed on probes (i.e., in addition to simply
           reporting a model value, model values (probe input values) may have
           operations performed on them such as integration and
           differentiation).

    -  (2) Analyses are not formally part of the model structure (i.e. they are
           not ModelComponents), and because of this, analysis results can not
           be accessed with the model and state value -- they can only be
           accessed by file at the end of a simulation. Probes, on the other
           hand, are ModelComponents and therefore can be accessed at any time
           during a simulation from the API, and can also be used to compute
           model values that are fed back into the system via custom
           designed Controllers. Note that Probe values can also be reported to
           file at the end of a simulation by attaching a ProbeReporter analysis
           to the simulation.


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Probe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Probe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Probe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Probe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Probe_getClassName()

    def clone(self):
        r"""clone(Probe self) -> Probe"""
        return _simulation.Probe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Probe self) -> std::string const &"""
        return _simulation.Probe_getConcreteClassName(self)

    def copyProperty_enabled(self, source):
        r""" Enabled (true) by default. *"""
        return _simulation.Probe_copyProperty_enabled(self, source)

    def append_enabled(self, value):
        r"""
        append_enabled(Probe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Probe_append_enabled(self, value)

    def constructProperty_enabled(self, initValue):
        r"""
        constructProperty_enabled(Probe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Probe_constructProperty_enabled(self, initValue)

    def get_enabled(self, *args):
        r"""
        get_enabled(Probe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_enabled(Probe self) -> bool const &
        """
        return _simulation.Probe_get_enabled(self, *args)

    def upd_enabled(self, *args):
        r"""
        upd_enabled(Probe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_enabled(Probe self) -> bool &
        """
        return _simulation.Probe_upd_enabled(self, *args)

    def set_enabled(self, *args):
        r"""
        set_enabled(Probe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_enabled(Probe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Probe_set_enabled(self, *args)

    def copyProperty_probe_operation(self, source):
        r"""
        copyProperty_probe_operation(Probe self, Probe source)

        Parameters
        ----------
        source: OpenSim::Probe::Self const &

        """
        return _simulation.Probe_copyProperty_probe_operation(self, source)

    def append_probe_operation(self, value):
        r"""
        append_probe_operation(Probe self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Probe_append_probe_operation(self, value)

    def constructProperty_probe_operation(self, initValue):
        r"""
        constructProperty_probe_operation(Probe self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Probe_constructProperty_probe_operation(self, initValue)

    def get_probe_operation(self, *args):
        r"""
        get_probe_operation(Probe self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_probe_operation(Probe self) -> std::string const &
        """
        return _simulation.Probe_get_probe_operation(self, *args)

    def upd_probe_operation(self, *args):
        r"""
        upd_probe_operation(Probe self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_probe_operation(Probe self) -> std::string &
        """
        return _simulation.Probe_upd_probe_operation(self, *args)

    def set_probe_operation(self, *args):
        r"""
        set_probe_operation(Probe self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_probe_operation(Probe self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Probe_set_probe_operation(self, *args)

    def copyProperty_initial_conditions_for_integration(self, source):
        r"""
        copyProperty_initial_conditions_for_integration(Probe self, Probe source)

        Parameters
        ----------
        source: OpenSim::Probe::Self const &

        """
        return _simulation.Probe_copyProperty_initial_conditions_for_integration(self, source)

    def get_initial_conditions_for_integration(self, i):
        r"""
        get_initial_conditions_for_integration(Probe self, int i) -> double const &

        Parameters
        ----------
        i: int

        """
        return _simulation.Probe_get_initial_conditions_for_integration(self, i)

    def upd_initial_conditions_for_integration(self, i):
        r"""
        upd_initial_conditions_for_integration(Probe self, int i) -> double &

        Parameters
        ----------
        i: int

        """
        return _simulation.Probe_upd_initial_conditions_for_integration(self, i)

    def set_initial_conditions_for_integration(self, i, value):
        r"""
        set_initial_conditions_for_integration(Probe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        """
        return _simulation.Probe_set_initial_conditions_for_integration(self, i, value)

    def append_initial_conditions_for_integration(self, value):
        r"""
        append_initial_conditions_for_integration(Probe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Probe_append_initial_conditions_for_integration(self, value)

    def constructProperty_initial_conditions_for_integration(self):
        r"""constructProperty_initial_conditions_for_integration(Probe self)"""
        return _simulation.Probe_constructProperty_initial_conditions_for_integration(self)

    def copyProperty_gain(self, source):
        r"""
        copyProperty_gain(Probe self, Probe source)

        Parameters
        ----------
        source: OpenSim::Probe::Self const &

        """
        return _simulation.Probe_copyProperty_gain(self, source)

    def append_gain(self, value):
        r"""
        append_gain(Probe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Probe_append_gain(self, value)

    def constructProperty_gain(self, initValue):
        r"""
        constructProperty_gain(Probe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Probe_constructProperty_gain(self, initValue)

    def get_gain(self, *args):
        r"""
        get_gain(Probe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_gain(Probe self) -> double const &
        """
        return _simulation.Probe_get_gain(self, *args)

    def upd_gain(self, *args):
        r"""
        upd_gain(Probe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_gain(Probe self) -> double &
        """
        return _simulation.Probe_upd_gain(self, *args)

    def set_gain(self, *args):
        r"""
        set_gain(Probe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_gain(Probe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Probe_set_gain(self, *args)
    _has_output_probe_outputs = property(_simulation.Probe__has_output_probe_outputs_get, _simulation.Probe__has_output_probe_outputs_set, doc=r"""_has_output_probe_outputs : bool""")

    def reset(self, s):
        r""" Reset (initialize) the underlying Probe SimTK::Measure."""
        return _simulation.Probe_reset(self, s)

    def getNumInternalMeasureStates(self):
        r""" Get the number of states in the underlying SimTK::Measure."""
        return _simulation.Probe_getNumInternalMeasureStates(self)

    def isEnabled(self):
        r"""
        Returns true if the Probe is enabled and false if the probe is
               disabled.
        """
        return _simulation.Probe_isEnabled(self)

    def setEnabled(self, enabled):
        r""" %Set the Probe as enabled (true) or disabled (false)."""
        return _simulation.Probe_setEnabled(self, enabled)

    def getOperation(self):
        r""" Return the operation being performed on the probe value."""
        return _simulation.Probe_getOperation(self)

    def setOperation(self, probe_operation):
        r""" %Set the operation being performed on the probe value."""
        return _simulation.Probe_setOperation(self, probe_operation)

    def getInitialConditions(self):
        r""" Return the initial conditions (when the probe_operation is set to 'integrate')."""
        return _simulation.Probe_getInitialConditions(self)

    def setInitialConditions(self, initial_conditions_for_integration):
        r""" %Set the initial conditions (when the probe_operation is set to 'integrate')."""
        return _simulation.Probe_setInitialConditions(self, initial_conditions_for_integration)

    def getGain(self):
        r""" Return the gain to apply to the probe output."""
        return _simulation.Probe_getGain(self)

    def setGain(self, gain):
        r""" %Set the gain to apply to the probe output."""
        return _simulation.Probe_setGain(self, gain)

    def getProbeOutputs(self, state):
        r"""
        Returns the values of the probe after the operation has been performed.

           :type state: :py:class:`State`
           :param state:   System state from which value is computed.
           :rtype: :py:class:`Vector`
           :return: The SimTK::Vector of probe output values.*
        """
        return _simulation.Probe_getProbeOutputs(self, state)

    def updateFromXMLNode(self, node, versionNumber):
        r"""
        updateFromXMLNode(Probe self, SimTK::Xml::Element & node, int versionNumber)

        Parameters
        ----------
        node: SimTK::Xml::Element &
        versionNumber: int

        """
        return _simulation.Probe_updateFromXMLNode(self, node, versionNumber)
    __swig_destroy__ = _simulation.delete_Probe

# Register Probe in _simulation:
_simulation.Probe_swigregister(Probe)
class SetProbes(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetProbes

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetProbes_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetProbes self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetProbes_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetProbes_getClassName()

    def clone(self):
        r"""clone(SetProbes self) -> SetProbes"""
        return _simulation.SetProbes_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetProbes self) -> std::string const &"""
        return _simulation.SetProbes_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetProbes

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Probe,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetProbes_swiginit(self, _simulation.new_SetProbes(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetProbes_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetProbes_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetProbes_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetProbes_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Probe`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetProbes_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetProbes_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Probe`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetProbes_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Probe`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetProbes_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Probe`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetProbes_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Probe`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetProbes_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetProbes self)"""
        return _simulation.SetProbes_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Probe`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetProbes_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Probe`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Probe`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetProbes_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetProbes_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetProbes_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetProbes_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetProbes_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetProbes_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetProbes_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetProbes_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetProbes_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetProbes_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetProbes in _simulation:
_simulation.SetProbes_swigregister(SetProbes)
class ModelComponentSetProbes(SetProbes):
    r"""Proxy of C++ OpenSim::ModelComponentSet< OpenSim::Probe > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelComponentSetProbes

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelComponentSetProbes_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelComponentSetProbes self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelComponentSetProbes_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelComponentSetProbes_getClassName()

    def clone(self):
        r"""clone(ModelComponentSetProbes self) -> ModelComponentSetProbes"""
        return _simulation.ModelComponentSetProbes_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentSetProbes self) -> std::string const &"""
        return _simulation.ModelComponentSetProbes_getConcreteClassName(self)

    def extendFinalizeFromProperties(self):
        r"""extendFinalizeFromProperties(ModelComponentSetProbes self)"""
        return _simulation.ModelComponentSetProbes_extendFinalizeFromProperties(self)

    def __init__(self):
        r"""__init__(ModelComponentSetProbes self) -> ModelComponentSetProbes"""
        _simulation.ModelComponentSetProbes_swiginit(self, _simulation.new_ModelComponentSetProbes())
    __swig_destroy__ = _simulation.delete_ModelComponentSetProbes

# Register ModelComponentSetProbes in _simulation:
_simulation.ModelComponentSetProbes_swigregister(ModelComponentSetProbes)
class ProbeSet(ModelComponentSetProbes):
    r"""
    A class for holding a set of probes.

    Authors: Tim Dorn
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ProbeSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ProbeSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ProbeSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ProbeSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ProbeSet_getClassName()

    def clone(self):
        r"""clone(ProbeSet self) -> ProbeSet"""
        return _simulation.ProbeSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ProbeSet self) -> std::string const &"""
        return _simulation.ProbeSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ProbeSet self) -> ProbeSet
        __init__(ProbeSet self, std::string const & file, bool updateFromXML=True) -> ProbeSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.ProbeSet_swiginit(self, _simulation.new_ProbeSet(*args))

    def adoptAndAppend(self, aProbe):
        aProbe._markAdopted()
        return super(ProbeSet, self).adoptAndAppend(aProbe)

    __swig_destroy__ = _simulation.delete_ProbeSet

# Register ProbeSet in _simulation:
_simulation.ProbeSet_swigregister(ProbeSet)
class SystemEnergyProbe(Probe):
    r"""
    SystemEnergyProbe is a ModelComponent Probe for computing an operation on a
    total system energy during a simulation.
    E.g. Work is the integral of power with respect to time.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SystemEnergyProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SystemEnergyProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SystemEnergyProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SystemEnergyProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SystemEnergyProbe_getClassName()

    def clone(self):
        r"""clone(SystemEnergyProbe self) -> SystemEnergyProbe"""
        return _simulation.SystemEnergyProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SystemEnergyProbe self) -> std::string const &"""
        return _simulation.SystemEnergyProbe_getConcreteClassName(self)

    def copyProperty_compute_kinetic_energy(self, source):
        r""" Default is true. *"""
        return _simulation.SystemEnergyProbe_copyProperty_compute_kinetic_energy(self, source)

    def append_compute_kinetic_energy(self, value):
        r"""
        append_compute_kinetic_energy(SystemEnergyProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.SystemEnergyProbe_append_compute_kinetic_energy(self, value)

    def constructProperty_compute_kinetic_energy(self, initValue):
        r"""
        constructProperty_compute_kinetic_energy(SystemEnergyProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.SystemEnergyProbe_constructProperty_compute_kinetic_energy(self, initValue)

    def get_compute_kinetic_energy(self, *args):
        r"""
        get_compute_kinetic_energy(SystemEnergyProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_compute_kinetic_energy(SystemEnergyProbe self) -> bool const &
        """
        return _simulation.SystemEnergyProbe_get_compute_kinetic_energy(self, *args)

    def upd_compute_kinetic_energy(self, *args):
        r"""
        upd_compute_kinetic_energy(SystemEnergyProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_compute_kinetic_energy(SystemEnergyProbe self) -> bool &
        """
        return _simulation.SystemEnergyProbe_upd_compute_kinetic_energy(self, *args)

    def set_compute_kinetic_energy(self, *args):
        r"""
        set_compute_kinetic_energy(SystemEnergyProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_compute_kinetic_energy(SystemEnergyProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.SystemEnergyProbe_set_compute_kinetic_energy(self, *args)

    def copyProperty_compute_potential_energy(self, source):
        r""" Default is true. *"""
        return _simulation.SystemEnergyProbe_copyProperty_compute_potential_energy(self, source)

    def append_compute_potential_energy(self, value):
        r"""
        append_compute_potential_energy(SystemEnergyProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.SystemEnergyProbe_append_compute_potential_energy(self, value)

    def constructProperty_compute_potential_energy(self, initValue):
        r"""
        constructProperty_compute_potential_energy(SystemEnergyProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.SystemEnergyProbe_constructProperty_compute_potential_energy(self, initValue)

    def get_compute_potential_energy(self, *args):
        r"""
        get_compute_potential_energy(SystemEnergyProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_compute_potential_energy(SystemEnergyProbe self) -> bool const &
        """
        return _simulation.SystemEnergyProbe_get_compute_potential_energy(self, *args)

    def upd_compute_potential_energy(self, *args):
        r"""
        upd_compute_potential_energy(SystemEnergyProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_compute_potential_energy(SystemEnergyProbe self) -> bool &
        """
        return _simulation.SystemEnergyProbe_upd_compute_potential_energy(self, *args)

    def set_compute_potential_energy(self, *args):
        r"""
        set_compute_potential_energy(SystemEnergyProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_compute_potential_energy(SystemEnergyProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.SystemEnergyProbe_set_compute_potential_energy(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.SystemEnergyProbe_swiginit(self, _simulation.new_SystemEnergyProbe(*args))

    def getComputeKineticEnergy(self):
        r"""
        Returns whether kinetic energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_getComputeKineticEnergy(self)

    def getComputePotentialEnergy(self):
        r"""
        Returns whether potential energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_getComputePotentialEnergy(self)

    def setComputeKineticEnergy(self, c):
        r"""
        Sets whether kinetic energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_setComputeKineticEnergy(self, c)

    def setComputePotentialEnergy(self, c):
        r"""
        Sets whether potential energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_setComputePotentialEnergy(self, c)

    def computeProbeInputs(self, state):
        r""" Compute the System energy which the Probe operation will be based on."""
        return _simulation.SystemEnergyProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.SystemEnergyProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.SystemEnergyProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_SystemEnergyProbe

# Register SystemEnergyProbe in _simulation:
_simulation.SystemEnergyProbe_swigregister(SystemEnergyProbe)
class JointInternalPowerProbe(Probe):
    r"""
    JointInternalPowerProbe is a ModelComponent Probe for computing an operation on
    internal joint power or sum of joint powers in the model during a simulation.
    E.g. Joint internal work is the integral of joint internal power with respect to time,
    so by using the JointInternalPowerProbe with the 'integrate' operation, Joint internal
    work may be computed.

    Author: Tim Dorn
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> JointInternalPowerProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.JointInternalPowerProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(JointInternalPowerProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.JointInternalPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.JointInternalPowerProbe_getClassName()

    def clone(self):
        r"""clone(JointInternalPowerProbe self) -> JointInternalPowerProbe"""
        return _simulation.JointInternalPowerProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(JointInternalPowerProbe self) -> std::string const &"""
        return _simulation.JointInternalPowerProbe_getConcreteClassName(self)

    def copyProperty_joint_names(self, source):
        r""" List of Joints to probe.  *"""
        return _simulation.JointInternalPowerProbe_copyProperty_joint_names(self, source)

    def get_joint_names(self, i):
        r"""
        get_joint_names(JointInternalPowerProbe self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.JointInternalPowerProbe_get_joint_names(self, i)

    def upd_joint_names(self, i):
        r"""
        upd_joint_names(JointInternalPowerProbe self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.JointInternalPowerProbe_upd_joint_names(self, i)

    def set_joint_names(self, i, value):
        r"""
        set_joint_names(JointInternalPowerProbe self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.JointInternalPowerProbe_set_joint_names(self, i, value)

    def append_joint_names(self, value):
        r"""
        append_joint_names(JointInternalPowerProbe self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.JointInternalPowerProbe_append_joint_names(self, value)

    def constructProperty_joint_names(self):
        r"""constructProperty_joint_names(JointInternalPowerProbe self)"""
        return _simulation.JointInternalPowerProbe_constructProperty_joint_names(self)

    def copyProperty_sum_powers_together(self, source):
        r"""
        Flag to specify whether to report the sum of all powers,
               or report each power value separately.  *
        """
        return _simulation.JointInternalPowerProbe_copyProperty_sum_powers_together(self, source)

    def append_sum_powers_together(self, value):
        r"""
        append_sum_powers_together(JointInternalPowerProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.JointInternalPowerProbe_append_sum_powers_together(self, value)

    def constructProperty_sum_powers_together(self, initValue):
        r"""
        constructProperty_sum_powers_together(JointInternalPowerProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.JointInternalPowerProbe_constructProperty_sum_powers_together(self, initValue)

    def get_sum_powers_together(self, *args):
        r"""
        get_sum_powers_together(JointInternalPowerProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_sum_powers_together(JointInternalPowerProbe self) -> bool const &
        """
        return _simulation.JointInternalPowerProbe_get_sum_powers_together(self, *args)

    def upd_sum_powers_together(self, *args):
        r"""
        upd_sum_powers_together(JointInternalPowerProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_sum_powers_together(JointInternalPowerProbe self) -> bool &
        """
        return _simulation.JointInternalPowerProbe_upd_sum_powers_together(self, *args)

    def set_sum_powers_together(self, *args):
        r"""
        set_sum_powers_together(JointInternalPowerProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_sum_powers_together(JointInternalPowerProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.JointInternalPowerProbe_set_sum_powers_together(self, *args)

    def copyProperty_exponent(self, source):
        r"""
        Element-wise power exponent to apply to each joint power prior to the Probe operation.
           For example, if two joints J1 and J2 are given in joint_names, then the
           Probe value will be equal to JointPower_J1^exponent + JointPower_J2^exponent.  *
        """
        return _simulation.JointInternalPowerProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value):
        r"""
        append_exponent(JointInternalPowerProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.JointInternalPowerProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue):
        r"""
        constructProperty_exponent(JointInternalPowerProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.JointInternalPowerProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args):
        r"""
        get_exponent(JointInternalPowerProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_exponent(JointInternalPowerProbe self) -> double const &
        """
        return _simulation.JointInternalPowerProbe_get_exponent(self, *args)

    def upd_exponent(self, *args):
        r"""
        upd_exponent(JointInternalPowerProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_exponent(JointInternalPowerProbe self) -> double &
        """
        return _simulation.JointInternalPowerProbe_upd_exponent(self, *args)

    def set_exponent(self, *args):
        r"""
        set_exponent(JointInternalPowerProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_exponent(JointInternalPowerProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.JointInternalPowerProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.JointInternalPowerProbe_swiginit(self, _simulation.new_JointInternalPowerProbe(*args))

    def getJointNames(self):
        r""" Returns the names of the Joints being probed."""
        return _simulation.JointInternalPowerProbe_getJointNames(self)

    def getSumPowersTogether(self):
        r"""
        Returns whether to report sum of all joint powers together
               or report the joint powers individually.
        """
        return _simulation.JointInternalPowerProbe_getSumPowersTogether(self)

    def getExponent(self):
        r""" Returns the exponent to apply to each joint power."""
        return _simulation.JointInternalPowerProbe_getExponent(self)

    def setJointNames(self, aJointNames):
        r""" Sets the names of the Joints being probed."""
        return _simulation.JointInternalPowerProbe_setJointNames(self, aJointNames)

    def setSumPowersTogether(self, sum_powers_together):
        r"""
        Sets whether to report sum of all joint powers together
               or report the joint powers individually.
        """
        return _simulation.JointInternalPowerProbe_setSumPowersTogether(self, sum_powers_together)

    def setExponent(self, exponent):
        r""" Sets the exponent to apply to each joint power."""
        return _simulation.JointInternalPowerProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state):
        r""" Compute the Joint power. *"""
        return _simulation.JointInternalPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.JointInternalPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.JointInternalPowerProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_JointInternalPowerProbe

# Register JointInternalPowerProbe in _simulation:
_simulation.JointInternalPowerProbe_swigregister(JointInternalPowerProbe)
class ActuatorPowerProbe(Probe):
    r"""
    ActuatorPowerProbe is a ModelComponent Probe for computing an operation on a
    actuator power or sum of actuator powers in the model during a simulation.
    E.g. Actuator work is the integral of actuator power with respect to time, so by using the
    ActuatorPowerProbe with the 'integrate' operation, Actuator work may be computed.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ActuatorPowerProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ActuatorPowerProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ActuatorPowerProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ActuatorPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ActuatorPowerProbe_getClassName()

    def clone(self):
        r"""clone(ActuatorPowerProbe self) -> ActuatorPowerProbe"""
        return _simulation.ActuatorPowerProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActuatorPowerProbe self) -> std::string const &"""
        return _simulation.ActuatorPowerProbe_getConcreteClassName(self)

    def copyProperty_actuator_names(self, source):
        r""" List of Actuators to probe.  *"""
        return _simulation.ActuatorPowerProbe_copyProperty_actuator_names(self, source)

    def get_actuator_names(self, i):
        r"""
        get_actuator_names(ActuatorPowerProbe self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.ActuatorPowerProbe_get_actuator_names(self, i)

    def upd_actuator_names(self, i):
        r"""
        upd_actuator_names(ActuatorPowerProbe self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.ActuatorPowerProbe_upd_actuator_names(self, i)

    def set_actuator_names(self, i, value):
        r"""
        set_actuator_names(ActuatorPowerProbe self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.ActuatorPowerProbe_set_actuator_names(self, i, value)

    def append_actuator_names(self, value):
        r"""
        append_actuator_names(ActuatorPowerProbe self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ActuatorPowerProbe_append_actuator_names(self, value)

    def constructProperty_actuator_names(self):
        r"""constructProperty_actuator_names(ActuatorPowerProbe self)"""
        return _simulation.ActuatorPowerProbe_constructProperty_actuator_names(self)

    def copyProperty_sum_powers_together(self, source):
        r"""
        Flag to specify whether to report the sum of all powers,
           or report each power value separately.  *
        """
        return _simulation.ActuatorPowerProbe_copyProperty_sum_powers_together(self, source)

    def append_sum_powers_together(self, value):
        r"""
        append_sum_powers_together(ActuatorPowerProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ActuatorPowerProbe_append_sum_powers_together(self, value)

    def constructProperty_sum_powers_together(self, initValue):
        r"""
        constructProperty_sum_powers_together(ActuatorPowerProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.ActuatorPowerProbe_constructProperty_sum_powers_together(self, initValue)

    def get_sum_powers_together(self, *args):
        r"""
        get_sum_powers_together(ActuatorPowerProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_sum_powers_together(ActuatorPowerProbe self) -> bool const &
        """
        return _simulation.ActuatorPowerProbe_get_sum_powers_together(self, *args)

    def upd_sum_powers_together(self, *args):
        r"""
        upd_sum_powers_together(ActuatorPowerProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_sum_powers_together(ActuatorPowerProbe self) -> bool &
        """
        return _simulation.ActuatorPowerProbe_upd_sum_powers_together(self, *args)

    def set_sum_powers_together(self, *args):
        r"""
        set_sum_powers_together(ActuatorPowerProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_sum_powers_together(ActuatorPowerProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ActuatorPowerProbe_set_sum_powers_together(self, *args)

    def copyProperty_exponent(self, source):
        r"""
        Element-wise power exponent to apply to each actuator power prior to
           the Probe operation.  For example, if two actuators A1 and A2 are given in
           actuator_names, then the Probe value will be equal to Power_A1^exponent +
           Power_A2^exponent.
        """
        return _simulation.ActuatorPowerProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value):
        r"""
        append_exponent(ActuatorPowerProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActuatorPowerProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue):
        r"""
        constructProperty_exponent(ActuatorPowerProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActuatorPowerProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args):
        r"""
        get_exponent(ActuatorPowerProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_exponent(ActuatorPowerProbe self) -> double const &
        """
        return _simulation.ActuatorPowerProbe_get_exponent(self, *args)

    def upd_exponent(self, *args):
        r"""
        upd_exponent(ActuatorPowerProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_exponent(ActuatorPowerProbe self) -> double &
        """
        return _simulation.ActuatorPowerProbe_upd_exponent(self, *args)

    def set_exponent(self, *args):
        r"""
        set_exponent(ActuatorPowerProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_exponent(ActuatorPowerProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActuatorPowerProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.ActuatorPowerProbe_swiginit(self, _simulation.new_ActuatorPowerProbe(*args))

    def getActuatorNames(self):
        r""" Returns the names of the Actuators being probed."""
        return _simulation.ActuatorPowerProbe_getActuatorNames(self)

    def getSumPowersTogether(self):
        r"""
        Returns whether to report sum of all actuator powers together
           or report the actuator powers individually.
        """
        return _simulation.ActuatorPowerProbe_getSumPowersTogether(self)

    def getExponent(self):
        r""" Returns the exponent to apply to each actuator power."""
        return _simulation.ActuatorPowerProbe_getExponent(self)

    def setActuatorNames(self, actuatorNames):
        r""" Sets the names of the Actuators being probed."""
        return _simulation.ActuatorPowerProbe_setActuatorNames(self, actuatorNames)

    def setSumPowersTogether(self, sum_powers_together):
        r"""
        Sets whether to report sum of all actuator powers together
           or report the actuator powers individually.
        """
        return _simulation.ActuatorPowerProbe_setSumPowersTogether(self, sum_powers_together)

    def setExponent(self, exponent):
        r""" Sets the exponent to apply to each actuator power."""
        return _simulation.ActuatorPowerProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state):
        r""" Compute the Actuator power."""
        return _simulation.ActuatorPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r"""
         Returns the number of probe inputs in the vector returned by
        computeProbeInputs().
        """
        return _simulation.ActuatorPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
           Currently uses the Probe name as the column label, so be sure
           to name your probe appropriately!
        """
        return _simulation.ActuatorPowerProbe_getProbeOutputLabels(self)

    def extendConnectToModel(self, aModel):
        r"""
        extendConnectToModel(ActuatorPowerProbe self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.ActuatorPowerProbe_extendConnectToModel(self, aModel)
    __swig_destroy__ = _simulation.delete_ActuatorPowerProbe

# Register ActuatorPowerProbe in _simulation:
_simulation.ActuatorPowerProbe_swigregister(ActuatorPowerProbe)
class ActuatorForceProbe(Probe):
    r"""
    ActuatorForceProbe is a ModelComponent Probe for computing an operation on a
    force or sum of forces in the model during a simulation.
    E.g. Impulse is the integral of force with respect to time.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ActuatorForceProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ActuatorForceProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ActuatorForceProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ActuatorForceProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ActuatorForceProbe_getClassName()

    def clone(self):
        r"""clone(ActuatorForceProbe self) -> ActuatorForceProbe"""
        return _simulation.ActuatorForceProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActuatorForceProbe self) -> std::string const &"""
        return _simulation.ActuatorForceProbe_getConcreteClassName(self)

    def copyProperty_actuator_names(self, source):
        r""" List of Actuator forces to probe.  *"""
        return _simulation.ActuatorForceProbe_copyProperty_actuator_names(self, source)

    def get_actuator_names(self, i):
        r"""
        get_actuator_names(ActuatorForceProbe self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.ActuatorForceProbe_get_actuator_names(self, i)

    def upd_actuator_names(self, i):
        r"""
        upd_actuator_names(ActuatorForceProbe self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.ActuatorForceProbe_upd_actuator_names(self, i)

    def set_actuator_names(self, i, value):
        r"""
        set_actuator_names(ActuatorForceProbe self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.ActuatorForceProbe_set_actuator_names(self, i, value)

    def append_actuator_names(self, value):
        r"""
        append_actuator_names(ActuatorForceProbe self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ActuatorForceProbe_append_actuator_names(self, value)

    def constructProperty_actuator_names(self):
        r"""constructProperty_actuator_names(ActuatorForceProbe self)"""
        return _simulation.ActuatorForceProbe_constructProperty_actuator_names(self)

    def copyProperty_sum_forces_together(self, source):
        r"""
        Flag to specify whether to report the sum of all forces,
           or report each force value separately.  *
        """
        return _simulation.ActuatorForceProbe_copyProperty_sum_forces_together(self, source)

    def append_sum_forces_together(self, value):
        r"""
        append_sum_forces_together(ActuatorForceProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ActuatorForceProbe_append_sum_forces_together(self, value)

    def constructProperty_sum_forces_together(self, initValue):
        r"""
        constructProperty_sum_forces_together(ActuatorForceProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.ActuatorForceProbe_constructProperty_sum_forces_together(self, initValue)

    def get_sum_forces_together(self, *args):
        r"""
        get_sum_forces_together(ActuatorForceProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_sum_forces_together(ActuatorForceProbe self) -> bool const &
        """
        return _simulation.ActuatorForceProbe_get_sum_forces_together(self, *args)

    def upd_sum_forces_together(self, *args):
        r"""
        upd_sum_forces_together(ActuatorForceProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_sum_forces_together(ActuatorForceProbe self) -> bool &
        """
        return _simulation.ActuatorForceProbe_upd_sum_forces_together(self, *args)

    def set_sum_forces_together(self, *args):
        r"""
        set_sum_forces_together(ActuatorForceProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_sum_forces_together(ActuatorForceProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ActuatorForceProbe_set_sum_forces_together(self, *args)

    def copyProperty_exponent(self, source):
        r"""
        Element-wise power exponent to apply to each force prior to the Probe operation.
           For example, if two actuators A1 and A2 are given in actuator_names, then the
           Probe value will be equal to Force_A1^exponent + Force_A2^exponent.  *
        """
        return _simulation.ActuatorForceProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value):
        r"""
        append_exponent(ActuatorForceProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActuatorForceProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue):
        r"""
        constructProperty_exponent(ActuatorForceProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActuatorForceProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args):
        r"""
        get_exponent(ActuatorForceProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_exponent(ActuatorForceProbe self) -> double const &
        """
        return _simulation.ActuatorForceProbe_get_exponent(self, *args)

    def upd_exponent(self, *args):
        r"""
        upd_exponent(ActuatorForceProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_exponent(ActuatorForceProbe self) -> double &
        """
        return _simulation.ActuatorForceProbe_upd_exponent(self, *args)

    def set_exponent(self, *args):
        r"""
        set_exponent(ActuatorForceProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_exponent(ActuatorForceProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActuatorForceProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.ActuatorForceProbe_swiginit(self, _simulation.new_ActuatorForceProbe(*args))

    def getActuatorNames(self):
        r""" Returns the name(s) of the Actuator forces being probed."""
        return _simulation.ActuatorForceProbe_getActuatorNames(self)

    def getSumForcesTogether(self):
        r"""
        Returns whether to report sum of all Actuator forces together
           or report the forces individually.
        """
        return _simulation.ActuatorForceProbe_getSumForcesTogether(self)

    def getExponent(self):
        r""" Returns the exponent to apply to each Actuator force."""
        return _simulation.ActuatorForceProbe_getExponent(self)

    def setActuatorNames(self, actuatorNames):
        r""" Sets the name(s) of the Actuator forces being probed."""
        return _simulation.ActuatorForceProbe_setActuatorNames(self, actuatorNames)

    def setSumForcesTogether(self, sum_forces_together):
        r"""
        Sets whether to report sum of all Actuator force values together
           or report the force values individually.
        """
        return _simulation.ActuatorForceProbe_setSumForcesTogether(self, sum_forces_together)

    def setExponent(self, exponent):
        r""" Sets the exponent to apply to each Actuator force."""
        return _simulation.ActuatorForceProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state):
        r""" Compute the Force"""
        return _simulation.ActuatorForceProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.ActuatorForceProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
           Currently uses the Probe name as the column label, so be sure
           to name your probe appropriately!
        """
        return _simulation.ActuatorForceProbe_getProbeOutputLabels(self)

    def extendConnectToModel(self, model):
        r"""
        extendConnectToModel(ActuatorForceProbe self, Model model)

        Parameters
        ----------
        model: OpenSim::Model &

        """
        return _simulation.ActuatorForceProbe_extendConnectToModel(self, model)
    __swig_destroy__ = _simulation.delete_ActuatorForceProbe

# Register ActuatorForceProbe in _simulation:
_simulation.ActuatorForceProbe_swigregister(ActuatorForceProbe)
class MuscleActiveFiberPowerProbe(Probe):
    r"""
    MuscleActiveFiberPowerProbe is a ModelComponent probe for computing an
    operation on the active fiber power of a muscle.

      Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MuscleActiveFiberPowerProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MuscleActiveFiberPowerProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MuscleActiveFiberPowerProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MuscleActiveFiberPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MuscleActiveFiberPowerProbe_getClassName()

    def clone(self):
        r"""clone(MuscleActiveFiberPowerProbe self) -> MuscleActiveFiberPowerProbe"""
        return _simulation.MuscleActiveFiberPowerProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MuscleActiveFiberPowerProbe self) -> std::string const &"""
        return _simulation.MuscleActiveFiberPowerProbe_getConcreteClassName(self)

    def copyProperty_muscle_names(self, source):
        r""" List of Muscles to probe.  *"""
        return _simulation.MuscleActiveFiberPowerProbe_copyProperty_muscle_names(self, source)

    def get_muscle_names(self, i):
        r"""
        get_muscle_names(MuscleActiveFiberPowerProbe self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.MuscleActiveFiberPowerProbe_get_muscle_names(self, i)

    def upd_muscle_names(self, i):
        r"""
        upd_muscle_names(MuscleActiveFiberPowerProbe self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.MuscleActiveFiberPowerProbe_upd_muscle_names(self, i)

    def set_muscle_names(self, i, value):
        r"""
        set_muscle_names(MuscleActiveFiberPowerProbe self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.MuscleActiveFiberPowerProbe_set_muscle_names(self, i, value)

    def append_muscle_names(self, value):
        r"""
        append_muscle_names(MuscleActiveFiberPowerProbe self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.MuscleActiveFiberPowerProbe_append_muscle_names(self, value)

    def constructProperty_muscle_names(self):
        r"""constructProperty_muscle_names(MuscleActiveFiberPowerProbe self)"""
        return _simulation.MuscleActiveFiberPowerProbe_constructProperty_muscle_names(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.MuscleActiveFiberPowerProbe_swiginit(self, _simulation.new_MuscleActiveFiberPowerProbe(*args))

    def getMuscleNames(self):
        r""" Returns the names of the Actuators being probed."""
        return _simulation.MuscleActiveFiberPowerProbe_getMuscleNames(self)

    def setMuscleNames(self, muscleNames):
        r""" Sets the names of the Actuators being probed."""
        return _simulation.MuscleActiveFiberPowerProbe_setMuscleNames(self, muscleNames)

    def computeProbeInputs(self, state):
        r""" Compute the Actuator power upon which the Probe operation will be based."""
        return _simulation.MuscleActiveFiberPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.MuscleActiveFiberPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.MuscleActiveFiberPowerProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_MuscleActiveFiberPowerProbe

# Register MuscleActiveFiberPowerProbe in _simulation:
_simulation.MuscleActiveFiberPowerProbe_swigregister(MuscleActiveFiberPowerProbe)
class Bhargava2004MuscleMetabolicsProbe(Probe):
    r"""
    %Bhargava2004MuscleMetabolicsProbe is a Probe ModelComponent for computing
    the net metabolic energy rate of a set of Muscles in the model during a
    simulation.

    # %Bhargava2004MuscleMetabolicsProbe Theory

    The discussion here is based on the following paper:


    Bhargava, L. J., Pandy, M. G. and Anderson, F. C. (2004).
    A phenomenological model for estimating metabolic energy consumption
    in muscle contraction. J Biomech 37, 81-8. ("http://www.ncbi.nlm.nih.gov/pubmed/14672571")

    *Note that the equations below that describe the particular implementation of
    %Bhargava2004MuscleMetabolicsProbe may slightly differ from the equations
    described in the representative publication above. Note also that we define
    positive muscle velocity to indicate lengthening (eccentric contraction) and
    negative muscle velocity to indicate shortening (concentric contraction).*


    %Muscle metabolic power (or rate of metabolic energy consumption) is equal to the
    rate at which heat is liberated plus the rate at which work is done:

    **Edot = Bdot + sumOfAllMuscles(Adot + Mdot + Sdot + Wdot).**

          - Bdot is the basal heat rate (W).
          - Adot is the activation heat rate (W).
          - Mdot is the maintenance heat rate (W).
          - Sdot is the shortening heat rate (W).
          - Wdot is the mechanical work rate (W).


    This probe also uses muscle parameters stored in the MetabolicMuscle object for each muscle.
    The full set of all MetabolicMuscles (MetabolicMuscleSet) is a property of this probe:

    - m = The mass of the muscle (kg).
    - r = Ratio of slow twitch fibers in the muscle (between 0 and 1).
    - Adot_slow = Activation constant for slow twitch fibers (W/kg).
    - Adot_fast = Activation constant for fast twitch fibers (W/kg).
    - Mdot_slow = Maintenance constant for slow twitch fibers (W/kg).
    - Mdot_fast = Maintenance constant for slow twitch fibers (W/kg).


    ## ** BASAL HEAT RATE (W) **
    If *basal_rate_on* is set to true, then Bdot is calculated as follows:

    **Bdot = basal_coefficient * (m_body^basal_exponent)**
        - m_body = mass of the entire model
        - basal_coefficient and basal_exponent are defined by their respective properties.

    *Note that this quantity is muscle independent. Rather it is calculated on a whole body level.*


    ## ** ACTIVATION HEAT RATE (W) **
    If *activation_rate_on* is set to true, then Adot is calculated as follows:

    **Adot = phi * m * [ Adot_slow * r * sin((pi/2)*u) +
                          Adot_fast * (1-r) * (1-cos((pi/2)*u)) ]**
        - u = muscle excitation at the current time.
        - phi = decay function. Bhargava et al. (2004) use a function to model
                the observation that the rate of heat generation is greatest
                immediately after the muscle is excited and then decays. We
                follow the work of Anderson and Pandy, who set this value to 1.0.


    ## ** MAINTENANCE HEAT RATE (W) **
    If *maintenance_rate_on* is set to true, then Mdot is calculated as follows:

    **Mdot = m * f * [ Mdot_slow * r * sin((pi/2)*u)    +    Mdot_fast * (1-r) * (1-cos((pi/2)*u)) ]**
    - u = muscle excitation at the current time.
    - f is a piecewise linear function that describes the normalized fiber length dependence
    of the maintenance heat rate (default curve is shown below):
    Image: fig_NormalizedFiberLengthDependenceOfMaintenanceHeatRateBhargava2004.png


    ## ** SHORTENING HEAT RATE (W) **
    If *shortening_rate_on* is set to true, then Sdot is calculated as follows:

    **Sdot = -alpha * v_CE**

    If use_force_dependent_shortening_prop_constant = true,
        - **alpha = (0.16 * F_CE_iso) + (0.18 * F_CE)   **,   *v_CE >= 0 (concentric / isometric contraction)*
        - **alpha = 0.157 * F_CE                        **,   *v_CE <  0 (eccentric contraction)*

        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile (active) element of muscle at the current time.
        - F_CE_iso = force that would be developed by the contractile element of muscle under isometric conditions with the current activation and fiber length.

    If use_force_dependent_shortening_prop_constant = false,
        - **alpha = 0.25 * (F_CE + F_PASSIVE),   **,   *v_CE >= 0 (concentric / isometric contraction)*
        - **alpha = 0.00                         **,   *v_CE <  0 (eccentric contraction)*

         where F_PASSIVE = passive force developed by the muscle fiber velocity at the current time.


    ## ** MECHANICAL WORK RATE (W) **
    If *mechanical_work_rate_on* is set to true, then Wdot is calculated as follows:

    **Wdot = -F_CE * v_CE       **
        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile element of muscle at the current time.


    If we draw a control volume around the fiber, the first law of thermodynamics
    suggests that negative mechanical work should be included in Wdot. As such,
    we include negative mechanical work in Wdot by default. To exclude negative
    mechanical work from Wdot, set the 'include_negative_mechanical_work'
    property to false.

    During eccentric contraction, the magnitude of the (negative) mechanical work
    rate can exceed that of the total (positive) heat rate, resulting in a flow
    of energy into the fiber. Experiments indicate that the chemical processes
    involved in fiber contraction cannot be reversed, and most of the energy that
    is absorbed during eccentric contraction (in increased cross-bridge
    potentials, for example) is eventually converted into heat. Thus, we increase
    Sdot (if necessary) to ensure Edot > 0 for each muscle. See
    Constable, J.K.,
    Barclay, C.J., Gibbs, C.L. (1997) Energetics of lengthening in mouse and toad
    skeletal muscles. J Physiol 505:205-215 ("http://www.ncbi.nlm.nih.gov/pubmed/9409483"). To allow muscles to have
    negative total power, set the 'forbid_negative_total_power' property to false.


    Note that if enforce_minimum_heat_rate_per_muscle == true AND
    activation_rate_on == shortening_rate_on == maintenance_rate_on == true, then the total heat
    rate (AMdot + Mdot + Sdot) will be capped to a minimum value of 1.0 W/kg (Umberger(2003), page 104).




    # Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

    Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter is an Object class that
    holds the metabolic parameters required to calculate metabolic power for a single muscle.

    ## ** Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter Properties **

    REQUIRED PROPERTIES
    - **specific_tension** = The specific tension of the muscle (Pascals (N/m^2)).
    - **density** = The density of the muscle (kg/m^3).
    - **ratio_slow_twitch_fibers** = Ratio of slow twitch fibers in the muscle (must be between 0 and 1).
    - **activation_constant_slow_twitch**  = Activation constant for slow twitch fibers (W/kg).
    - **activation_constant_fast_twitch**  = Activation constant for fast twitch fibers (W/kg).
    - **maintenance_constant_slow_twitch** = Maintenance constant for slow twitch fibers (W/kg).
    - **maintenance_constant_fast_twitch** = Maintenance constant for slow twitch fibers (W/kg).

    OPTIONAL PROPERTIES
    - **use_provided_muscle_mass** = An optional flag that allows the user to
         explicitly specify a muscle mass. If set to true, the "provided_muscle_mass"
         property must be specified. The default setting is false, in which case, the
         muscle mass is calculated from the following formula:
             m = (Fmax/specific_tension)*density*Lm_opt, where
                 specific_tension and density are properties defined above
                     (note that their default values are set based on mammalian muscle,
                     0.25e6 N/m^2 and 1059.7 kg/m^3, respectively);
                 Fmax and Lm_opt are the maximum isometric force and optimal
                     fiber length, respectively, of the muscle.

    - **provided_muscle_mass** = The user specified muscle mass (kg).


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Bhargava2004MuscleMetabolicsProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Bhargava2004MuscleMetabolicsProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getClassName()

    def clone(self):
        r"""clone(Bhargava2004MuscleMetabolicsProbe self) -> Bhargava2004MuscleMetabolicsProbe"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Bhargava2004MuscleMetabolicsProbe self) -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getConcreteClassName(self)

    def copyProperty_activation_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_activation_rate_on(self, source)

    def append_activation_rate_on(self, value):
        r"""
        append_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_activation_rate_on(self, value)

    def constructProperty_activation_rate_on(self, initValue):
        r"""
        constructProperty_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_activation_rate_on(self, initValue)

    def get_activation_rate_on(self, *args):
        r"""
        get_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_activation_rate_on(self, *args)

    def upd_activation_rate_on(self, *args):
        r"""
        upd_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_activation_rate_on(self, *args)

    def set_activation_rate_on(self, *args):
        r"""
        set_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_activation_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_activation_rate_on(self, *args)

    def copyProperty_maintenance_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_maintenance_rate_on(self, source)

    def append_maintenance_rate_on(self, value):
        r"""
        append_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_maintenance_rate_on(self, value)

    def constructProperty_maintenance_rate_on(self, initValue):
        r"""
        constructProperty_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_maintenance_rate_on(self, initValue)

    def get_maintenance_rate_on(self, *args):
        r"""
        get_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_maintenance_rate_on(self, *args)

    def upd_maintenance_rate_on(self, *args):
        r"""
        upd_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_maintenance_rate_on(self, *args)

    def set_maintenance_rate_on(self, *args):
        r"""
        set_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_maintenance_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_maintenance_rate_on(self, *args)

    def copyProperty_shortening_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_shortening_rate_on(self, source)

    def append_shortening_rate_on(self, value):
        r"""
        append_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_shortening_rate_on(self, value)

    def constructProperty_shortening_rate_on(self, initValue):
        r"""
        constructProperty_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_shortening_rate_on(self, initValue)

    def get_shortening_rate_on(self, *args):
        r"""
        get_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_shortening_rate_on(self, *args)

    def upd_shortening_rate_on(self, *args):
        r"""
        upd_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_shortening_rate_on(self, *args)

    def set_shortening_rate_on(self, *args):
        r"""
        set_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_shortening_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_shortening_rate_on(self, *args)

    def copyProperty_basal_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_rate_on(self, source)

    def append_basal_rate_on(self, value):
        r"""
        append_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_rate_on(self, value)

    def constructProperty_basal_rate_on(self, initValue):
        r"""
        constructProperty_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_rate_on(self, initValue)

    def get_basal_rate_on(self, *args):
        r"""
        get_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_rate_on(self, *args)

    def upd_basal_rate_on(self, *args):
        r"""
        upd_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_rate_on(self, *args)

    def set_basal_rate_on(self, *args):
        r"""
        set_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_basal_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_rate_on(self, *args)

    def copyProperty_mechanical_work_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_mechanical_work_rate_on(self, source)

    def append_mechanical_work_rate_on(self, value):
        r"""
        append_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_mechanical_work_rate_on(self, value)

    def constructProperty_mechanical_work_rate_on(self, initValue):
        r"""
        constructProperty_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_mechanical_work_rate_on(self, initValue)

    def get_mechanical_work_rate_on(self, *args):
        r"""
        get_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_mechanical_work_rate_on(self, *args)

    def upd_mechanical_work_rate_on(self, *args):
        r"""
        upd_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_mechanical_work_rate_on(self, *args)

    def set_mechanical_work_rate_on(self, *args):
        r"""
        set_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_mechanical_work_rate_on(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_mechanical_work_rate_on(self, *args)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value):
        r"""
        append_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue):
        r"""
        constructProperty_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        get_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        upd_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        set_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_enforce_minimum_heat_rate_per_muscle(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, source):
        r""" Default curve shown in doxygen. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, source)

    def append_normalized_fiber_length_dependence_on_maintenance_rate(self, value):
        r"""
        append_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, PiecewiseLinearFunction value) -> int

        Parameters
        ----------
        value: OpenSim::PiecewiseLinearFunction const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_normalized_fiber_length_dependence_on_maintenance_rate(self, value)

    def constructProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, initValue):
        r"""
        constructProperty_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, PiecewiseLinearFunction initValue)

        Parameters
        ----------
        initValue: OpenSim::PiecewiseLinearFunction const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, initValue)

    def get_normalized_fiber_length_dependence_on_maintenance_rate(self, *args):
        r"""
        get_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, int i) -> PiecewiseLinearFunction

        Parameters
        ----------
        i: int

        get_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self) -> PiecewiseLinearFunction
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def upd_normalized_fiber_length_dependence_on_maintenance_rate(self, *args):
        r"""
        upd_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, int i) -> PiecewiseLinearFunction

        Parameters
        ----------
        i: int

        upd_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self) -> PiecewiseLinearFunction
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def set_normalized_fiber_length_dependence_on_maintenance_rate(self, *args):
        r"""
        set_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, int i, PiecewiseLinearFunction value)

        Parameters
        ----------
        i: int
        value: OpenSim::PiecewiseLinearFunction const &

        set_normalized_fiber_length_dependence_on_maintenance_rate(Bhargava2004MuscleMetabolicsProbe self, PiecewiseLinearFunction value)

        Parameters
        ----------
        value: OpenSim::PiecewiseLinearFunction const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def copyProperty_use_force_dependent_shortening_prop_constant(self, source):
        r""" Disabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_use_force_dependent_shortening_prop_constant(self, source)

    def append_use_force_dependent_shortening_prop_constant(self, value):
        r"""
        append_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_use_force_dependent_shortening_prop_constant(self, value)

    def constructProperty_use_force_dependent_shortening_prop_constant(self, initValue):
        r"""
        constructProperty_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_use_force_dependent_shortening_prop_constant(self, initValue)

    def get_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        get_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_use_force_dependent_shortening_prop_constant(self, *args)

    def upd_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        upd_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_use_force_dependent_shortening_prop_constant(self, *args)

    def set_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        set_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_force_dependent_shortening_prop_constant(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_use_force_dependent_shortening_prop_constant(self, *args)

    def copyProperty_basal_coefficient(self, source):
        r""" Default value = 1.2. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value):
        r"""
        append_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue):
        r"""
        constructProperty_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args):
        r"""
        get_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args):
        r"""
        upd_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args):
        r"""
        set_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_coefficient(Bhargava2004MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source):
        r""" Default value = 1.0. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value):
        r"""
        append_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue):
        r"""
        constructProperty_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args):
        r"""
        get_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_exponent(Bhargava2004MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args):
        r"""
        upd_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_exponent(Bhargava2004MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args):
        r"""
        set_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_exponent(Bhargava2004MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source):
        r""" Default value = 1.0. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value):
        r"""
        append_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue):
        r"""
        constructProperty_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args):
        r"""
        get_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args):
        r"""
        upd_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args):
        r"""
        set_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_muscle_effort_scaling_factor(Bhargava2004MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value):
        r"""
        append_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue):
        r"""
        constructProperty_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args):
        r"""
        get_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args):
        r"""
        upd_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args):
        r"""
        set_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_include_negative_mechanical_work(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source):
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value):
        r"""
        append_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue):
        r"""
        constructProperty_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args):
        r"""
        get_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args):
        r"""
        upd_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args):
        r"""
        set_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_forbid_negative_total_power(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_forbid_negative_total_power(self, *args)

    def copyProperty_report_total_metabolics_only(self, source):
        r""" Default value = true *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_report_total_metabolics_only(self, source)

    def append_report_total_metabolics_only(self, value):
        r"""
        append_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_report_total_metabolics_only(self, value)

    def constructProperty_report_total_metabolics_only(self, initValue):
        r"""
        constructProperty_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_report_total_metabolics_only(self, initValue)

    def get_report_total_metabolics_only(self, *args):
        r"""
        get_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_report_total_metabolics_only(self, *args)

    def upd_report_total_metabolics_only(self, *args):
        r"""
        upd_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_report_total_metabolics_only(self, *args)

    def set_report_total_metabolics_only(self, *args):
        r"""
        set_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_report_total_metabolics_only(Bhargava2004MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_report_total_metabolics_only(self, *args)

    def copyProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source):
        r"""
        copyProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, Bhargava2004MuscleMetabolicsProbe source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source)

    def append_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value):
        r"""
        append_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet value) -> int

        Parameters
        ----------
        value: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value)

    def constructProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue):
        r"""
        constructProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet initValue)

        Parameters
        ----------
        initValue: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue)

    def get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, int i) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        i: int

        get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, int i) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        i: int

        upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, int i, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Bhargava2004MuscleMetabolicsProbe self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet value)

        Parameters
        ----------
        value: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Bhargava2004MuscleMetabolicsProbe_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe(*args))

    def computeProbeInputs(self, state):
        r""" Compute muscle metabolic power."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getProbeOutputLabels(self)

    def getNumMetabolicMuscles(self):
        r"""getNumMetabolicMuscles(Bhargava2004MuscleMetabolicsProbe self) -> int"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getNumMetabolicMuscles(self)

    def addMuscle(self, *args):
        r"""
        *Overload 1:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.

        |

        *Overload 2:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_addMuscle(self, *args)

    def removeMuscle(self, muscleName):
        r""" Remove a muscle from the metabolic analysis."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_removeMuscle(self, muscleName)

    def useProvidedMass(self, muscleName, providedMass):
        r""" %Set an existing muscle to use a provided muscle mass."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_useProvidedMass(self, muscleName, providedMass)

    def useCalculatedMass(self, muscleName):
        r""" %Set an existing muscle to calculate its own mass."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_useCalculatedMass(self, muscleName)

    def isUsingProvidedMass(self, muscleName):
        r"""
        Get whether the muscle mass is being explicitly provided.
              True means that it is using the property 'provided_muscle_mass'
              False means that the muscle mass is being calculated from muscle properties.
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_isUsingProvidedMass(self, muscleName)

    def getMuscleMass(self, muscleName):
        r"""
        Get the muscle mass used in the metabolic analysis. The value
               returned will depend on if the muscle mass is explicitly provided
               (i.e. isUsingProvidedMass = true), or if it is being automatically
               calculated from muscle data already present in the model
               (i.e. isUsingProvidedMass = true).
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMuscleMass(self, muscleName)

    def getRatioSlowTwitchFibers(self, muscleName):
        r""" Get the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getRatioSlowTwitchFibers(self, muscleName)

    def setRatioSlowTwitchFibers(self, muscleName, ratio):
        r""" %Set the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setRatioSlowTwitchFibers(self, muscleName, ratio)

    def getDensity(self, muscleName):
        r""" Get the density for an existing muscle (kg/m^3)."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getDensity(self, muscleName)

    def setDensity(self, muscleName, density):
        r""" %Set the density for an existing muscle (kg/m^3)."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setDensity(self, muscleName, density)

    def getSpecificTension(self, muscleName):
        r""" Get the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getSpecificTension(self, muscleName)

    def setSpecificTension(self, muscleName, specificTension):
        r""" %Set the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setSpecificTension(self, muscleName, specificTension)

    def getActivationConstantSlowTwitch(self, muscleName):
        r""" Get the activation constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getActivationConstantSlowTwitch(self, muscleName)

    def setActivationConstantSlowTwitch(self, muscleName, c):
        r""" %Set the activation constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setActivationConstantSlowTwitch(self, muscleName, c)

    def getActivationConstantFastTwitch(self, muscleName):
        r""" Get the activation constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getActivationConstantFastTwitch(self, muscleName)

    def setActivationConstantFastTwitch(self, muscleName, c):
        r""" %Set the activation constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setActivationConstantFastTwitch(self, muscleName, c)

    def getMaintenanceConstantSlowTwitch(self, muscleName):
        r""" Get the maintenance constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMaintenanceConstantSlowTwitch(self, muscleName)

    def setMaintenanceConstantSlowTwitch(self, muscleName, c):
        r""" %Set the maintenance constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setMaintenanceConstantSlowTwitch(self, muscleName, c)

    def getMaintenanceConstantFastTwitch(self, muscleName):
        r""" Get the maintenance constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMaintenanceConstantFastTwitch(self, muscleName)

    def setMaintenanceConstantFastTwitch(self, muscleName, c):
        r""" %Set the maintenance constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setMaintenanceConstantFastTwitch(self, muscleName, c)
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe

# Register Bhargava2004MuscleMetabolicsProbe in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_swigregister(Bhargava2004MuscleMetabolicsProbe)
class Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter(opensim.common.OpenSimObject):
    r"""
    Documentation for this class has been provided with the documentation for the
    Bhargava2004MuscleMetabolicsProbe class.

    See also: Bhargava2004MuscleMetabolicsProbe
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

    def clone(self):
        r"""clone(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source):
        r"""
        copyProperty_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value):
        r"""
        append_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue):
        r"""
        constructProperty_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args):
        r"""
        get_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args):
        r"""
        upd_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args):
        r"""
        set_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_specific_tension(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_specific_tension(self, *args)

    def copyProperty_density(self, source):
        r"""
        copyProperty_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_density(self, source)

    def append_density(self, value):
        r"""
        append_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_density(self, value)

    def constructProperty_density(self, initValue):
        r"""
        constructProperty_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_density(self, initValue)

    def get_density(self, *args):
        r"""
        get_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_density(self, *args)

    def upd_density(self, *args):
        r"""
        upd_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_density(self, *args)

    def set_density(self, *args):
        r"""
        set_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_density(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source):
        r"""
        copyProperty_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value):
        r"""
        append_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue):
        r"""
        constructProperty_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args):
        r"""
        get_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args):
        r"""
        upd_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args):
        r"""
        set_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_ratio_slow_twitch_fibers(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source):
        r"""
        copyProperty_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value):
        r"""
        append_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, *args):
        r"""
        constructProperty_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self)
        constructProperty_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_use_provided_muscle_mass(self, *args)

    def get_use_provided_muscle_mass(self, *args):
        r"""
        get_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> bool const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args):
        r"""
        upd_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> bool &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args):
        r"""
        set_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source):
        r"""
        copyProperty_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value):
        r"""
        append_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, *args):
        r"""
        constructProperty_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self)
        constructProperty_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_provided_muscle_mass(self, *args)

    def get_provided_muscle_mass(self, *args):
        r"""
        get_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args):
        r"""
        upd_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args):
        r"""
        set_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_provided_muscle_mass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_provided_muscle_mass(self, *args)

    def copyProperty_activation_constant_slow_twitch(self, source):
        r"""
        copyProperty_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_activation_constant_slow_twitch(self, source)

    def append_activation_constant_slow_twitch(self, value):
        r"""
        append_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_activation_constant_slow_twitch(self, value)

    def constructProperty_activation_constant_slow_twitch(self, initValue):
        r"""
        constructProperty_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_activation_constant_slow_twitch(self, initValue)

    def get_activation_constant_slow_twitch(self, *args):
        r"""
        get_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_activation_constant_slow_twitch(self, *args)

    def upd_activation_constant_slow_twitch(self, *args):
        r"""
        upd_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_activation_constant_slow_twitch(self, *args)

    def set_activation_constant_slow_twitch(self, *args):
        r"""
        set_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_activation_constant_slow_twitch(self, *args)

    def copyProperty_activation_constant_fast_twitch(self, source):
        r"""
        copyProperty_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_activation_constant_fast_twitch(self, source)

    def append_activation_constant_fast_twitch(self, value):
        r"""
        append_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_activation_constant_fast_twitch(self, value)

    def constructProperty_activation_constant_fast_twitch(self, initValue):
        r"""
        constructProperty_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_activation_constant_fast_twitch(self, initValue)

    def get_activation_constant_fast_twitch(self, *args):
        r"""
        get_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_activation_constant_fast_twitch(self, *args)

    def upd_activation_constant_fast_twitch(self, *args):
        r"""
        upd_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_activation_constant_fast_twitch(self, *args)

    def set_activation_constant_fast_twitch(self, *args):
        r"""
        set_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_activation_constant_fast_twitch(self, *args)

    def copyProperty_maintenance_constant_slow_twitch(self, source):
        r"""
        copyProperty_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_maintenance_constant_slow_twitch(self, source)

    def append_maintenance_constant_slow_twitch(self, value):
        r"""
        append_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_maintenance_constant_slow_twitch(self, value)

    def constructProperty_maintenance_constant_slow_twitch(self, initValue):
        r"""
        constructProperty_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_maintenance_constant_slow_twitch(self, initValue)

    def get_maintenance_constant_slow_twitch(self, *args):
        r"""
        get_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_maintenance_constant_slow_twitch(self, *args)

    def upd_maintenance_constant_slow_twitch(self, *args):
        r"""
        upd_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_maintenance_constant_slow_twitch(self, *args)

    def set_maintenance_constant_slow_twitch(self, *args):
        r"""
        set_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maintenance_constant_slow_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_maintenance_constant_slow_twitch(self, *args)

    def copyProperty_maintenance_constant_fast_twitch(self, source):
        r"""
        copyProperty_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_maintenance_constant_fast_twitch(self, source)

    def append_maintenance_constant_fast_twitch(self, value):
        r"""
        append_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_maintenance_constant_fast_twitch(self, value)

    def constructProperty_maintenance_constant_fast_twitch(self, initValue):
        r"""
        constructProperty_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_maintenance_constant_fast_twitch(self, initValue)

    def get_maintenance_constant_fast_twitch(self, *args):
        r"""
        get_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_maintenance_constant_fast_twitch(self, *args)

    def upd_maintenance_constant_fast_twitch(self, *args):
        r"""
        upd_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_maintenance_constant_fast_twitch(self, *args)

    def set_maintenance_constant_fast_twitch(self, *args):
        r"""
        set_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maintenance_constant_fast_twitch(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_maintenance_constant_fast_twitch(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter
        __init__(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, std::string const & muscleName, double ratio_slow_twitch_fibers, double muscle_mass=SimTK::NaN) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

        Parameters
        ----------
        muscleName: std::string const &
        ratio_slow_twitch_fibers: double
        muscle_mass: double

        __init__(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, std::string const & muscleName, double ratio_slow_twitch_fibers, double activation_constant_slow_twitch, double activation_constant_fast_twitch, double maintenance_constant_slow_twitch, double maintenance_constant_fast_twitch, double muscle_mass=SimTK::NaN) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

        Parameters
        ----------
        muscleName: std::string const &
        ratio_slow_twitch_fibers: double
        activation_constant_slow_twitch: double
        activation_constant_fast_twitch: double
        maintenance_constant_slow_twitch: double
        maintenance_constant_fast_twitch: double
        muscle_mass: double

        """
        _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter(*args))

    def getMuscleMass(self):
        r"""getMuscleMass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscleMass(self)

    def setMuscleMass(self):
        r"""setMuscleMass(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self)"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscleMass(self)

    def getMuscle(self):
        r"""getMuscle(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Muscle"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscle(self)

    def setMuscle(self, m):
        r"""
        setMuscle(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter self, Muscle m)

        Parameters
        ----------
        m: OpenSim::Muscle *

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscle(self, m)
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

# Register Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_swigregister(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter)
class Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(object):
    r"""
    MetabolicMuscleParameterSet is a class that holds the set of
    MetabolicMuscleParameters for each muscle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

    def clone(self):
        r"""clone(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> std::string const &"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet"""
        _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet())
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet

# Register Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swigregister(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet)
class Bhargava2004SmoothedMuscleMetabolics_MuscleParameters(opensim.common.Component):
    r"""
     Object class that holds the metabolic parameters required to calculate
    metabolic power for a single muscle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Bhargava2004SmoothedMuscleMetabolics_MuscleParameters

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getClassName()

    def clone(self):
        r"""clone(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> Bhargava2004SmoothedMuscleMetabolics_MuscleParameters"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> std::string const &"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source):
        r"""
        copyProperty_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value):
        r"""
        append_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue):
        r"""
        constructProperty_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args):
        r"""
        get_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args):
        r"""
        upd_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args):
        r"""
        set_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_specific_tension(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_specific_tension(self, *args)

    def copyProperty_density(self, source):
        r"""
        copyProperty_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_density(self, source)

    def append_density(self, value):
        r"""
        append_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_density(self, value)

    def constructProperty_density(self, initValue):
        r"""
        constructProperty_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_density(self, initValue)

    def get_density(self, *args):
        r"""
        get_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_density(self, *args)

    def upd_density(self, *args):
        r"""
        upd_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_density(self, *args)

    def set_density(self, *args):
        r"""
        set_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_density(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source):
        r"""
        copyProperty_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value):
        r"""
        append_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue):
        r"""
        constructProperty_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args):
        r"""
        get_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args):
        r"""
        upd_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args):
        r"""
        set_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_ratio_slow_twitch_fibers(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source):
        r"""
        copyProperty_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value):
        r"""
        append_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, *args):
        r"""
        constructProperty_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self)
        constructProperty_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_use_provided_muscle_mass(self, *args)

    def get_use_provided_muscle_mass(self, *args):
        r"""
        get_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args):
        r"""
        upd_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args):
        r"""
        set_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source):
        r"""
        copyProperty_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value):
        r"""
        append_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, *args):
        r"""
        constructProperty_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self)
        constructProperty_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_provided_muscle_mass(self, *args)

    def get_provided_muscle_mass(self, *args):
        r"""
        get_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args):
        r"""
        upd_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args):
        r"""
        set_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_provided_muscle_mass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_provided_muscle_mass(self, *args)

    def copyProperty_activation_constant_slow_twitch(self, source):
        r"""
        copyProperty_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_activation_constant_slow_twitch(self, source)

    def append_activation_constant_slow_twitch(self, value):
        r"""
        append_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_activation_constant_slow_twitch(self, value)

    def constructProperty_activation_constant_slow_twitch(self, initValue):
        r"""
        constructProperty_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_activation_constant_slow_twitch(self, initValue)

    def get_activation_constant_slow_twitch(self, *args):
        r"""
        get_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_activation_constant_slow_twitch(self, *args)

    def upd_activation_constant_slow_twitch(self, *args):
        r"""
        upd_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_activation_constant_slow_twitch(self, *args)

    def set_activation_constant_slow_twitch(self, *args):
        r"""
        set_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_activation_constant_slow_twitch(self, *args)

    def copyProperty_activation_constant_fast_twitch(self, source):
        r"""
        copyProperty_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_activation_constant_fast_twitch(self, source)

    def append_activation_constant_fast_twitch(self, value):
        r"""
        append_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_activation_constant_fast_twitch(self, value)

    def constructProperty_activation_constant_fast_twitch(self, initValue):
        r"""
        constructProperty_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_activation_constant_fast_twitch(self, initValue)

    def get_activation_constant_fast_twitch(self, *args):
        r"""
        get_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_activation_constant_fast_twitch(self, *args)

    def upd_activation_constant_fast_twitch(self, *args):
        r"""
        upd_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_activation_constant_fast_twitch(self, *args)

    def set_activation_constant_fast_twitch(self, *args):
        r"""
        set_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_activation_constant_fast_twitch(self, *args)

    def copyProperty_maintenance_constant_slow_twitch(self, source):
        r"""
        copyProperty_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_maintenance_constant_slow_twitch(self, source)

    def append_maintenance_constant_slow_twitch(self, value):
        r"""
        append_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_maintenance_constant_slow_twitch(self, value)

    def constructProperty_maintenance_constant_slow_twitch(self, initValue):
        r"""
        constructProperty_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_maintenance_constant_slow_twitch(self, initValue)

    def get_maintenance_constant_slow_twitch(self, *args):
        r"""
        get_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_maintenance_constant_slow_twitch(self, *args)

    def upd_maintenance_constant_slow_twitch(self, *args):
        r"""
        upd_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_maintenance_constant_slow_twitch(self, *args)

    def set_maintenance_constant_slow_twitch(self, *args):
        r"""
        set_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maintenance_constant_slow_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_maintenance_constant_slow_twitch(self, *args)

    def copyProperty_maintenance_constant_fast_twitch(self, source):
        r"""
        copyProperty_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_maintenance_constant_fast_twitch(self, source)

    def append_maintenance_constant_fast_twitch(self, value):
        r"""
        append_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_maintenance_constant_fast_twitch(self, value)

    def constructProperty_maintenance_constant_fast_twitch(self, initValue):
        r"""
        constructProperty_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_maintenance_constant_fast_twitch(self, initValue)

    def get_maintenance_constant_fast_twitch(self, *args):
        r"""
        get_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_maintenance_constant_fast_twitch(self, *args)

    def upd_maintenance_constant_fast_twitch(self, *args):
        r"""
        upd_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_maintenance_constant_fast_twitch(self, *args)

    def set_maintenance_constant_fast_twitch(self, *args):
        r"""
        set_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maintenance_constant_fast_twitch(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_maintenance_constant_fast_twitch(self, *args)
    PropertyIndex_socket_muscle = property(_simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_PropertyIndex_socket_muscle_get, _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_PropertyIndex_socket_muscle_set, doc=r"""PropertyIndex_socket_muscle : OpenSim::PropertyIndex""")

    def connectSocket_muscle(self, object):
        r"""
        connectSocket_muscle(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_connectSocket_muscle(self, object)

    def __init__(self):
        r"""__init__(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> Bhargava2004SmoothedMuscleMetabolics_MuscleParameters"""
        _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_swiginit(self, _simulation.new_Bhargava2004SmoothedMuscleMetabolics_MuscleParameters())

    def getMuscleMass(self):
        r"""getMuscleMass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> double"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getMuscleMass(self)

    def setMuscleMass(self):
        r"""setMuscleMass(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self)"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_setMuscleMass(self)

    def getMuscle(self):
        r"""getMuscle(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters self) -> Muscle"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getMuscle(self)
    __swig_destroy__ = _simulation.delete_Bhargava2004SmoothedMuscleMetabolics_MuscleParameters

# Register Bhargava2004SmoothedMuscleMetabolics_MuscleParameters in _simulation:
_simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_swigregister(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters)
class Bhargava2004SmoothedMuscleMetabolics(ModelComponent):
    r"""
     This class implements the metabolic energy model of Bhargava et al (2004)
    and provides an option to use smooth (i.e., twice continuously
    differentiable) approximations. These approximations might be better suited
    for gradient-based optimization algorithms.

    We propose two smooth implementations.

    In the first implementation, conditional if statements were approximated by
    using hyperbolic tangent functions (tanh). For example, the following if
    statement:
         y = a, if x <= d
         y = b, if x > d
    can be approximated by:
         f = 0.5 + 0.5 tanh(b(x-d))
         y = a + (-a + b) f
    where b is a parameter that determines the smoothness of the transition.

    In the second implementation, conditional if statements were approximated
    by using Huber loss functions, which have the following form:
         L(f(x)) = 0.5 f(x)^2, if f(x) <= delta
         L(f(x)) = delta(f(x) - 0.5 delta), otherwise.
    The Huber loss function is quadratic for f(x) <= delta and linear
    otherwise, with equal value and slopes of the different sections at the
    points where f(x) = delta (https://en.wikipedia.org/wiki/Huber_loss). In
    our implementation, we scaled this function with a parameter b that
    determines the smootheness of the transition between the quadratic and
    linear parts. Note that this approximation is piecewise but still
    continuous.

    The metabolic energy model includes components for activation heat rate,
    maintenance heat rate, shortening heat rate, and mechanical work rate.

    The shortening heat rate model differs between concentric contractions and
    eccentric contractions. We smoothed the transition between both contraction
    types using our smoothing functions. Note that when using the force
    dependent shortening proportional constant, we only provide the tanh
    smoothing option for approximating the shortening heat rate. This is
    motivated by the fact that the shortening heat rate is defined by linear
    functions but with different non-zero constants of proportionality for
    concentric and eccentric contractions. It is therefore easier to smooth the
    transition between both contraction types with a tanh function than with a
    Huber loss function. The difference between the original (non-smooth) and the
    smooth implementations is illustrated in the following figure:

     <style>div.image img[src="SmoothShorteningHeatRate.png"]{width:750px;}</style>
    Image: SmoothShorteningHeatRate.png("Curves produced using isometricTotalActiveForce=350, fiberForceTotal=250, velocity_smoothing=10")

    The mechanical work rate model includes negative mechanical work rate
    (i.e., work rate resulting from eccentric contraction) by default. However,
    if specified by the user, the model only takes positive mechanical work
    rate (i.e., work rate resulting from concentric contraction) into account.
    In such case, we smoothed the transition between positive rate and zero
    using our smoothing functions. The difference between the original
    (non-smooth) and the smooth implementations is illustrated in the following
    figure:

     <style>div.image img[src="SmoothMechanicalWorkRate.png"]{width:750px;}</style>
    Image: SmoothMechanicalWorkRate.png("Curves produced using fiber_force_active=250, velocity_smoothing=10")

    The metabolic energy model implementation includes an optional clamping
    that prevents the total metabolic rate (i.e., total metabolic power) to be
    negative. This clamping is done by increasing the shortening heat rate. We
    smoothed the transition between positive and negative total metabolic rate
    using our smoothing functions. The difference between the original
    (non-smooth) and the smooth implementations is illustrated in the following
    figure:

     <style>div.image img[src="ClampingTotalMetabolicRate.png"]{width:750px;}</style>
    Image: ClampingTotalMetabolicRate.png("Curves produced using shorteningHeatRate=totalRate/4, power_smoothing=10")

    The metabolic energy model implementation includes an optional clamping
    (see Umberger et al (2003), page 104) that prevents the total heat rate
    (i.e., activation heat rate + maintenance heat rate + shortening heat rate)
    for a given muscle to fall below 1.0 W/kg. Note that, if active, this
    clamping will cause the sum of the reported individual heat rates and work
    rate to differ from the reported metabolic rate. We smoothed the transition
    between total heat rate higher and lower than 1.0 W/kg using our smoothing
    functions. The difference between the original (non-smooth) and the smooth
    implementations is illustrated in the following figure:

     <style>div.image img[src="ClampingTotalHeatRate.png"]{width:750px;}</style>
    Image: ClampingTotalHeatRate.png("Curves produced using muscle_mass=0.4, heat_rate_smoothing=10")

    Note that the maintenance heat rate implementation relies on a
    PiecewiseLinearFunction. The first and second order derivatives of this
    function can be evaluated but they are discontinuous. This might cause
    issues with gradient-based optimization algorithms. Problems using this
    discontinuous function have successfully converged; therefore, we have
    included it in this implementation of the model.

    You can enable smoothing via the `use_smoothing` property. The smoothing type
    ('tanh' or 'huber') can be chosen via the `smoothing_type` property, and the
    level of smoothing can be controlled by the `velocity_smoothing`,
    `power_smoothing`, and `heat_rate_smoothing` properties.

    Muscles to be included when computing the total metabolic rate should be
    specified using one of the three `addMuscle()` function overloads. See the
    properties of `Bhargava2004SmoothedMuscleMetabolics_MuscleParameters()` for the
    default parameter values used when not specified via the second or third
    `addMuscle()` overload.

    .. code-block:: c++

        Bhargava2004SmoothedMuscleMetabolics* metabolics =
            new Bhargava2004SmoothedMuscleMetabolics();
        metabolics->setName("metabolics");
        metabolics->set_use_smoothing(true);

        The simplest way to add the muscle to the metabolics model: just provide the
        name of the muscle and a reference to Muscle component.
        metabolics->addMuscle("soleus_r", model.getComponent<Muscle>("soleus_r"));

        Provide the ratio of slow to fast twitch fibers and the specific tension of
        muscle when adding it to the metabolics model. The values shown are also the
        default values.
        double ratio_slow_twitch_fibers = 0.5;
        double specific_tension = 0.25e6;
        metabolics->addMuscle("gastroc_r", model.getComponent<Muscle>("gastroc_r"),
                ratio_slow_twitch_fibers, specific_tension);

        Provide the slow and fast twitch fiber constants used to compute the
        activation and maintenance heat rates. The values shown are also the default
        values.
        double activation_constant_slow_twitch = 40.0;
        double activation_constant_fast_twitch = 133.0;
        double maintenance_constant_slow_twitch = 74.0;
        double maintenance_constant_fast_twitch = 111.0;
        metabolics->addMuscle("tibant_r", model.getComponent<Muscle>("tibant_r"),
                ratio_slow_twitch_fibers, specific_tension,
                activation_constant_slow_twitch, activation_constant_fast_twitch,
                maintenance_constant_slow_twitch, maintenance_constant_fast_twitch);

        model.addComponent(metabolics);
        model.finalizeConnections();

    The total metabolic rate output can be obtained using `getTotalMetabolicRate()`,
    which takes a SimTK::State as a argument. You can similarly obtain the
    individual heat rate and mechanical work rate components of the total metabolic
    cost via `getTotalActivationRate()`, `getTotalMaintenanceRate()`,
    `getTotalShorteningRate()`, and `getTotalMechanicalWorkRate()`. All outputs
    require realizing the passed SimTK::State to SimTK::Stage::Dynamics.

    .. code-block:: c++

        const auto& metabolics =
            model.getComponent<Bhargava2004SmoothedMuscleMetabolics>("metabolics");
        model.realizeDynamics(state);
        double totalMetabolicRate = metabolics.getTotalMetabolicRate(state);
        double activationHeatRate = metabolics.getTotalActivationRate(state);

    Bhargava et al. 2004: https://doi.org/10.1016/s0021-9290(03)00239-2
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Bhargava2004SmoothedMuscleMetabolics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Bhargava2004SmoothedMuscleMetabolics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getClassName()

    def clone(self):
        r"""clone(Bhargava2004SmoothedMuscleMetabolics self) -> Bhargava2004SmoothedMuscleMetabolics"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Bhargava2004SmoothedMuscleMetabolics self) -> std::string const &"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getConcreteClassName(self)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source):
        r"""
        copyProperty_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value):
        r"""
        append_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue):
        r"""
        constructProperty_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        get_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        upd_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        set_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_use_force_dependent_shortening_prop_constant(self, source):
        r"""
        copyProperty_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_force_dependent_shortening_prop_constant(self, source)

    def append_use_force_dependent_shortening_prop_constant(self, value):
        r"""
        append_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_use_force_dependent_shortening_prop_constant(self, value)

    def constructProperty_use_force_dependent_shortening_prop_constant(self, initValue):
        r"""
        constructProperty_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_force_dependent_shortening_prop_constant(self, initValue)

    def get_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        get_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_use_force_dependent_shortening_prop_constant(self, *args)

    def upd_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        upd_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_use_force_dependent_shortening_prop_constant(self, *args)

    def set_use_force_dependent_shortening_prop_constant(self, *args):
        r"""
        set_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_use_force_dependent_shortening_prop_constant(self, *args)

    def copyProperty_basal_coefficient(self, source):
        r"""
        copyProperty_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value):
        r"""
        append_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue):
        r"""
        constructProperty_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args):
        r"""
        get_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args):
        r"""
        upd_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args):
        r"""
        set_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source):
        r"""
        copyProperty_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value):
        r"""
        append_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue):
        r"""
        constructProperty_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args):
        r"""
        get_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args):
        r"""
        upd_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args):
        r"""
        set_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_exponent(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source):
        r"""
        copyProperty_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value):
        r"""
        append_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue):
        r"""
        constructProperty_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args):
        r"""
        get_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args):
        r"""
        upd_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args):
        r"""
        set_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source):
        r"""
        copyProperty_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value):
        r"""
        append_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue):
        r"""
        constructProperty_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args):
        r"""
        get_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args):
        r"""
        upd_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args):
        r"""
        set_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source):
        r"""
        copyProperty_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value):
        r"""
        append_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue):
        r"""
        constructProperty_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args):
        r"""
        get_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args):
        r"""
        upd_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args):
        r"""
        set_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_forbid_negative_total_power(self, *args)

    def copyProperty_use_smoothing(self, source):
        r"""
        copyProperty_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_smoothing(self, source)

    def append_use_smoothing(self, value):
        r"""
        append_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_use_smoothing(self, value)

    def constructProperty_use_smoothing(self, *args):
        r"""
        constructProperty_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self)
        constructProperty_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_smoothing(self, *args)

    def get_use_smoothing(self, *args):
        r"""
        get_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> bool const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_use_smoothing(self, *args)

    def upd_use_smoothing(self, *args):
        r"""
        upd_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> bool &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_use_smoothing(self, *args)

    def set_use_smoothing(self, *args):
        r"""
        set_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_smoothing(Bhargava2004SmoothedMuscleMetabolics self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_use_smoothing(self, *args)

    def copyProperty_smoothing_type(self, source):
        r"""
        copyProperty_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_smoothing_type(self, source)

    def append_smoothing_type(self, value):
        r"""
        append_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_smoothing_type(self, value)

    def constructProperty_smoothing_type(self, *args):
        r"""
        constructProperty_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self)
        constructProperty_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_smoothing_type(self, *args)

    def get_smoothing_type(self, *args):
        r"""
        get_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self) -> std::string const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_smoothing_type(self, *args)

    def upd_smoothing_type(self, *args):
        r"""
        upd_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self) -> std::string &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_smoothing_type(self, *args)

    def set_smoothing_type(self, *args):
        r"""
        set_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_smoothing_type(Bhargava2004SmoothedMuscleMetabolics self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_smoothing_type(self, *args)

    def copyProperty_velocity_smoothing(self, source):
        r"""
        copyProperty_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_velocity_smoothing(self, source)

    def append_velocity_smoothing(self, value):
        r"""
        append_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_velocity_smoothing(self, value)

    def constructProperty_velocity_smoothing(self, *args):
        r"""
        constructProperty_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self)
        constructProperty_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_velocity_smoothing(self, *args)

    def get_velocity_smoothing(self, *args):
        r"""
        get_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_velocity_smoothing(self, *args)

    def upd_velocity_smoothing(self, *args):
        r"""
        upd_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_velocity_smoothing(self, *args)

    def set_velocity_smoothing(self, *args):
        r"""
        set_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_velocity_smoothing(self, *args)

    def copyProperty_power_smoothing(self, source):
        r"""
        copyProperty_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_power_smoothing(self, source)

    def append_power_smoothing(self, value):
        r"""
        append_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_power_smoothing(self, value)

    def constructProperty_power_smoothing(self, *args):
        r"""
        constructProperty_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self)
        constructProperty_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_power_smoothing(self, *args)

    def get_power_smoothing(self, *args):
        r"""
        get_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_power_smoothing(self, *args)

    def upd_power_smoothing(self, *args):
        r"""
        upd_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_power_smoothing(self, *args)

    def set_power_smoothing(self, *args):
        r"""
        set_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_power_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_power_smoothing(self, *args)

    def copyProperty_heat_rate_smoothing(self, source):
        r"""
        copyProperty_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_heat_rate_smoothing(self, source)

    def append_heat_rate_smoothing(self, value):
        r"""
        append_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_heat_rate_smoothing(self, value)

    def constructProperty_heat_rate_smoothing(self, *args):
        r"""
        constructProperty_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self)
        constructProperty_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_heat_rate_smoothing(self, *args)

    def get_heat_rate_smoothing(self, *args):
        r"""
        get_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double const

        Parameters
        ----------
        i: int

        get_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double const &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_heat_rate_smoothing(self, *args)

    def upd_heat_rate_smoothing(self, *args):
        r"""
        upd_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i) -> double

        Parameters
        ----------
        i: int

        upd_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self) -> double &
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_heat_rate_smoothing(self, *args)

    def set_heat_rate_smoothing(self, *args):
        r"""
        set_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_heat_rate_smoothing(self, *args)

    def copyProperty_muscle_parameters(self, source):
        r"""
        copyProperty_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics source)

        Parameters
        ----------
        source: OpenSim::Bhargava2004SmoothedMuscleMetabolics::Self const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_parameters(self, source)

    def get_muscle_parameters(self, i):
        r"""
        get_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self, int i) -> Bhargava2004SmoothedMuscleMetabolics_MuscleParameters

        Parameters
        ----------
        i: int

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_muscle_parameters(self, i)

    def upd_muscle_parameters(self, i):
        r"""
        upd_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self, int i) -> Bhargava2004SmoothedMuscleMetabolics_MuscleParameters

        Parameters
        ----------
        i: int

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_parameters(self, i)

    def set_muscle_parameters(self, i, value):
        r"""
        set_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self, int i, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters value)

        Parameters
        ----------
        i: int
        value: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_muscle_parameters(self, i, value)

    def append_muscle_parameters(self, value):
        r"""
        append_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters value) -> int

        Parameters
        ----------
        value: OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_muscle_parameters(self, value)

    def constructProperty_muscle_parameters(self):
        r"""constructProperty_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics self)"""
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_parameters(self)
    _has_output_total_metabolic_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_set, doc=r"""_has_output_total_metabolic_rate : bool""")
    _has_output_total_activation_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_set, doc=r"""_has_output_total_activation_rate : bool""")
    _has_output_total_maintenance_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_set, doc=r"""_has_output_total_maintenance_rate : bool""")
    _has_output_total_shortening_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_set, doc=r"""_has_output_total_shortening_rate : bool""")
    _has_output_total_mechanical_work_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_set, doc=r"""_has_output_total_mechanical_work_rate : bool""")
    _has_output_muscle_metabolic_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_set, doc=r"""_has_output_muscle_metabolic_rate : bool""")

    def __init__(self):
        r"""__init__(Bhargava2004SmoothedMuscleMetabolics self) -> Bhargava2004SmoothedMuscleMetabolics"""
        _simulation.Bhargava2004SmoothedMuscleMetabolics_swiginit(self, _simulation.new_Bhargava2004SmoothedMuscleMetabolics())

    def getNumMetabolicMuscles(self):
        r"""
        Get the number of muscles added to the metabolics model by one of the
           `addMuscle()` overloads.
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getNumMetabolicMuscles(self)

    def addMuscle(self, *args):
        r"""
        *Overload 1:*
        Specify a muscle that should be included when computing the total
           metabolic rate. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 2:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 3:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 4:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. This overload also allows you to specify the slow and fast
           twitch fiber constants used to compute the activation and maintenance heat
           rates. If the `muscle_mass` argument is not provided, it is estimated based
           on the max isometric force, specific tension, muscle density, and optimal
           fiber length.

        |

        *Overload 5:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. This overload also allows you to specify the slow and fast
           twitch fiber constants used to compute the activation and maintenance heat
           rates. If the `muscle_mass` argument is not provided, it is estimated based
           on the max isometric force, specific tension, muscle density, and optimal
           fiber length.
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_addMuscle(self, *args)

    def getTotalMetabolicRate(self, s):
        r"""
        getTotalMetabolicRate(Bhargava2004SmoothedMuscleMetabolics self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMetabolicRate(self, s)

    def getTotalActivationRate(self, s):
        r"""
        getTotalActivationRate(Bhargava2004SmoothedMuscleMetabolics self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalActivationRate(self, s)

    def getTotalMaintenanceRate(self, s):
        r"""
        getTotalMaintenanceRate(Bhargava2004SmoothedMuscleMetabolics self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMaintenanceRate(self, s)

    def getTotalShorteningRate(self, s):
        r"""
        getTotalShorteningRate(Bhargava2004SmoothedMuscleMetabolics self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalShorteningRate(self, s)

    def getTotalMechanicalWorkRate(self, s):
        r"""
        getTotalMechanicalWorkRate(Bhargava2004SmoothedMuscleMetabolics self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMechanicalWorkRate(self, s)

    def getMuscleMetabolicRate(self, s, channel):
        r"""
        getMuscleMetabolicRate(Bhargava2004SmoothedMuscleMetabolics self, State s, std::string const & channel) -> double

        Parameters
        ----------
        s: SimTK::State const &
        channel: std::string const &

        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getMuscleMetabolicRate(self, s, channel)
    __swig_destroy__ = _simulation.delete_Bhargava2004SmoothedMuscleMetabolics

# Register Bhargava2004SmoothedMuscleMetabolics in _simulation:
_simulation.Bhargava2004SmoothedMuscleMetabolics_swigregister(Bhargava2004SmoothedMuscleMetabolics)
class Umberger2010MuscleMetabolicsProbe(Probe):
    r"""
    %Umberger2010MuscleMetabolicsProbe is a Probe ModelComponent for computing
    the net metabolic energy rate of a set of Muscles in the model during a
    simulation.

    # %Umberger2010MuscleMetabolicsProbe Theory

    The discussion here is based on the following papers:


    Uchida, T. K., Hicks, J. L., Dembia, C. L., Delp, S. L. (2016). Stretching
    your energetic budget: how tendon compliance affects the metabolic cost of
    running. PLOS ONE 11(3), e0150378. ("http://dx.doi.org/10.1371/journal.pone.0150378")


    Umberger, B. R. (2010). Stance and swing phase costs in human walking.
    J R Soc Interface 7, 1329-40. ("http://www.ncbi.nlm.nih.gov/pubmed/20356877")


    Umberger, B. R., Gerritsen, K. G. and Martin, P. E. (2003).
    A model of human muscle energy expenditure.
    Comput Methods Biomech Biomed Engin 6, 99-111. ("http://www.ncbi.nlm.nih.gov/pubmed/12745424")

    *Note that the equations below that describe the particular implementation
    of %Umberger2010MuscleMetabolicsProbe may slightly differ from the equations
    described in the representative publications above. Note also that we define
    positive muscle velocity to indicate lengthening (eccentric contraction) and
    negative muscle velocity to indicate shortening (concentric contraction).*


    %Muscle metabolic power (or rate of metabolic energy consumption) is equal to
    the rate at which heat is liberated plus the rate at which work is done:

    **Edot = Bdot + sumOfAllMuscles(Adot + Mdot + Sdot + Wdot).**

    - Bdot is the basal heat rate (W).
    - Adot is the activation heat rate (W).
    - Mdot is the maintenance heat rate (W).
    - Sdot is the shortening heat rate (W).
    - Wdot is the mechanical work rate (W).


    This probe also uses muscle parameters stored in the MetabolicMuscle object for each muscle.
    The full set of all MetabolicMuscles (MetabolicMuscleSet) is a property of this probe:

    - m = The mass of the muscle (kg).
    - r = Ratio of slow-twitch fibers in the muscle (between 0 and 1).

    The recruitment model described by Bhargava et al. (2004) is used to set the
    slow-twitch fiber ratio used in the calculations below. The ratio specified
    by the user indicates the composition of the muscle; this value is used only
    at full excitation (i.e., when all fibers are recruited). As excitation
    decreases from 1 to 0, the proportion of recruited fibers that are
    slow-twitch fibers increases from r to 1. See
    Bhargava, L.J., Pandy,
    M.G., Anderson, F.C. (2004) A phenomenological model for estimating metabolic
    energy consumption in muscle contraction. J Biomech 37:81-88 ("http://www.ncbi.nlm.nih.gov/pubmed/14672571") and Uchida
    et al. (2016). To assume a constant ratio of slow- and fast-twitch fiber
    recruitment, set the 'use_Bhargava_recruitment_model' property to false.



    ## ** BASAL HEAT RATE (W) **
    If *basal_rate_on* is set to true, then Bdot is calculated as follows:

    **Bdot = basal_coefficient * (m_body^basal_exponent) **
        - m_body = mass of the entire model
        - basal_coefficient and basal_exponent are defined by their respective properties.

    *Note that this quantity is muscle independent. Rather it is calculated on a whole body level.*


    ## ** ACTIVATION & MAINTENANCE HEAT RATE (W) **
    If *activation_maintenance_rate_on* is set to true, then Adot+Mdot is calculated as follows:

    **Adot+Mdot = m * [128*(1-r) + 25] * A^0.6 * S                                         **,  * l_CE <= l_CE_opt *

    **Adot+Mdot = m * (0.4*[128*(1-r) + 25] + 0.6*[128*(1-r) + 25]*F_CE_iso) * A^0.6 * S   **,  * l_CE >  l_CE_opt *
        - **A = u          **,    u >  a
        - **A = (u+a)/2    **,    u <= a

        - m = The mass of the muscle (kg).
        - l_CE = muscle fiber length at the current time.
        - l_CE_opt = optimal fiber length of the muscle.
        - F_CE_iso = normalized contractile element force-length curve.
        - u = muscle excitation at the current time.
        - a = muscle activation at the current time.
        - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).


    ## ** SHORTENING HEAT RATE (W) **
    If *shortening_rate_on* is set to true, then Sdot is calculated as follows:

    **Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S)           **,   *l_CE <= l_CE_opt   &   v_CE >= 0 (concentric / isometric contraction)*

    **Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S * F_iso)   **,   *l_CE >  l_CE_opt   &   v_CE >= 0 (concentric / isometric contraction)*

    **Sdot = m * (alphaL * v_CE_norm * A * S)              **,   *l_CE <= l_CE_opt   &   v_CE <  0 (eccentric contraction)*

    **Sdot = m * (alphaL * v_CE_norm * A * S * F_CE_iso)   **,   *l_CE >  l_CE_opt   &   v_CE <  0 (eccentric contraction)*
        - **A = u          **,    *u >  a *
        - **A = (u+a)/2    **,    *u <= a *

        - **alphaS_fast = 153 / v_CE_max          **
        - **alphaS_slow = 100 / (v_CE_max / 2.5)  **
        - **alphaL = 4.0 * alphaS_slow **

        - m = The mass of the muscle (kg).
        - l_CE = muscle fiber length at the current time.
        - l_CE_opt = optimal fiber length of the muscle.
        - F_CE_iso = force that would be developed by the contractile element of muscle under isometric conditions with the current activation and fiber length.
        - v_CE = muscle fiber velocity at the current time.
        - v_CE_max = maximum shortening velocity of the muscle.
        - v_CE_norm = normalized muscle fiber velocity (defined for this model as v_CE/l_CE_opt).
                  Note that this is a different metric to the typical normalized_muscle_fiber_velocity of v_CE/v_CE_max.
        - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).


    ## ** MECHANICAL WORK RATE (W) **
    If *mechanical_work_rate_on* is set to true, then Wdot is calculated as follows:

    **Wdot = -(F_CE * v_CE)           **
        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile element of muscle at the current time.


    If we draw a control volume around the fiber, the first law of thermodynamics
    suggests that negative mechanical work should be included in Wdot. As such,
    we revert back to the model described in Umberger et al. (2003) by default.
    To exclude negative mechanical work from Wdot and use a coefficient of 0.3
    (rather than 4.0) to calculate alpha_L, set the
    'include_negative_mechanical_work' property to false.

    During eccentric contraction, the magnitude of the (negative) mechanical work
    rate can exceed that of the total (positive) heat rate, resulting in a flow
    of energy into the fiber. Experiments indicate that the chemical processes
    involved in fiber contraction cannot be reversed, and most of the energy that
    is absorbed during eccentric contraction (in increased cross-bridge
    potentials, for example) is eventually converted into heat. Thus, we increase
    Sdot (if necessary) to ensure Edot > 0 for each muscle. See
    Constable, J.K.,
    Barclay, C.J., Gibbs, C.L. (1997) Energetics of lengthening in mouse and toad
    skeletal muscles. J Physiol 505:205-215 ("http://www.ncbi.nlm.nih.gov/pubmed/9409483") and Uchida et al. (2016). To
    allow muscles to have negative total power, set the
    'forbid_negative_total_power' property to false.


    Note that if enforce_minimum_heat_rate_per_muscle == true AND
    activation_maintenance_rate_on == shortening_rate_on == true, then the total heat
    rate (AMdot + Sdot) will be capped to a minimum value of 1.0 W/kg (Umberger(2003), page 104).




    # Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

    Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter is an Object class that
    holds the metabolic parameters required to calculate metabolic power for a single muscle.

    ## ** Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter Properties **

    REQUIRED PROPERTIES
    - **specific_tension** = The specific tension of the muscle (Pascals (N/m^2)).
    - **density** = The density of the muscle (kg/m^3).
    - **ratio_slow_twitch_fibers** = Ratio of slow twitch fibers in the muscle (must be between 0 and 1).

    OPTIONAL PROPERTIES
    - **use_provided_muscle_mass** = An optional flag that allows the user to
         explicitly specify a muscle mass. If set to true, the 'provided_muscle_mass'
         property must be specified. The default setting is false, in which case, the
         muscle mass is calculated from the following formula:
             m = (Fmax/specific_tension)*density*Lm_opt, where
                 specific_tension and density are properties defined above
                     (note that their default values are set based on mammalian muscle,
                     0.25e6 N/m^2 and 1059.7 kg/m^3, respectively);
                 Fmax and Lm_opt are the maximum isometric force and optimal
                     fiber length, respectively, of the muscle.

    - **provided_muscle_mass** = The user specified muscle mass (kg).


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Umberger2010MuscleMetabolicsProbe

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Umberger2010MuscleMetabolicsProbe self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getClassName()

    def clone(self):
        r"""clone(Umberger2010MuscleMetabolicsProbe self) -> Umberger2010MuscleMetabolicsProbe"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Umberger2010MuscleMetabolicsProbe self) -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getConcreteClassName(self)

    def copyProperty_activation_maintenance_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_activation_maintenance_rate_on(self, source)

    def append_activation_maintenance_rate_on(self, value):
        r"""
        append_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_activation_maintenance_rate_on(self, value)

    def constructProperty_activation_maintenance_rate_on(self, initValue):
        r"""
        constructProperty_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_activation_maintenance_rate_on(self, initValue)

    def get_activation_maintenance_rate_on(self, *args):
        r"""
        get_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_activation_maintenance_rate_on(self, *args)

    def upd_activation_maintenance_rate_on(self, *args):
        r"""
        upd_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_activation_maintenance_rate_on(self, *args)

    def set_activation_maintenance_rate_on(self, *args):
        r"""
        set_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_activation_maintenance_rate_on(self, *args)

    def copyProperty_shortening_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_shortening_rate_on(self, source)

    def append_shortening_rate_on(self, value):
        r"""
        append_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_shortening_rate_on(self, value)

    def constructProperty_shortening_rate_on(self, initValue):
        r"""
        constructProperty_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_shortening_rate_on(self, initValue)

    def get_shortening_rate_on(self, *args):
        r"""
        get_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_shortening_rate_on(self, *args)

    def upd_shortening_rate_on(self, *args):
        r"""
        upd_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_shortening_rate_on(self, *args)

    def set_shortening_rate_on(self, *args):
        r"""
        set_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_shortening_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_shortening_rate_on(self, *args)

    def copyProperty_basal_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_rate_on(self, source)

    def append_basal_rate_on(self, value):
        r"""
        append_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_rate_on(self, value)

    def constructProperty_basal_rate_on(self, initValue):
        r"""
        constructProperty_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_rate_on(self, initValue)

    def get_basal_rate_on(self, *args):
        r"""
        get_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_basal_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_rate_on(self, *args)

    def upd_basal_rate_on(self, *args):
        r"""
        upd_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_basal_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_rate_on(self, *args)

    def set_basal_rate_on(self, *args):
        r"""
        set_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_basal_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_rate_on(self, *args)

    def copyProperty_mechanical_work_rate_on(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_mechanical_work_rate_on(self, source)

    def append_mechanical_work_rate_on(self, value):
        r"""
        append_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_mechanical_work_rate_on(self, value)

    def constructProperty_mechanical_work_rate_on(self, initValue):
        r"""
        constructProperty_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_mechanical_work_rate_on(self, initValue)

    def get_mechanical_work_rate_on(self, *args):
        r"""
        get_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_mechanical_work_rate_on(self, *args)

    def upd_mechanical_work_rate_on(self, *args):
        r"""
        upd_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_mechanical_work_rate_on(self, *args)

    def set_mechanical_work_rate_on(self, *args):
        r"""
        set_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_mechanical_work_rate_on(self, *args)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value):
        r"""
        append_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue):
        r"""
        constructProperty_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        get_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        upd_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args):
        r"""
        set_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_aerobic_factor(self, source):
        r""" Default value = 1.5. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_aerobic_factor(self, source)

    def append_aerobic_factor(self, value):
        r"""
        append_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_aerobic_factor(self, value)

    def constructProperty_aerobic_factor(self, initValue):
        r"""
        constructProperty_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_aerobic_factor(self, initValue)

    def get_aerobic_factor(self, *args):
        r"""
        get_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_aerobic_factor(Umberger2010MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_aerobic_factor(self, *args)

    def upd_aerobic_factor(self, *args):
        r"""
        upd_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_aerobic_factor(Umberger2010MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_aerobic_factor(self, *args)

    def set_aerobic_factor(self, *args):
        r"""
        set_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_aerobic_factor(Umberger2010MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_aerobic_factor(self, *args)

    def copyProperty_basal_coefficient(self, source):
        r""" Default value = 1.2. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value):
        r"""
        append_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue):
        r"""
        constructProperty_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args):
        r"""
        get_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_coefficient(Umberger2010MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args):
        r"""
        upd_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_coefficient(Umberger2010MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args):
        r"""
        set_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_coefficient(Umberger2010MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source):
        r""" Default value = 1.0. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value):
        r"""
        append_basal_exponent(Umberger2010MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue):
        r"""
        constructProperty_basal_exponent(Umberger2010MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args):
        r"""
        get_basal_exponent(Umberger2010MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_basal_exponent(Umberger2010MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args):
        r"""
        upd_basal_exponent(Umberger2010MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_basal_exponent(Umberger2010MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args):
        r"""
        set_basal_exponent(Umberger2010MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_basal_exponent(Umberger2010MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source):
        r""" Default value = 1.0. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value):
        r"""
        append_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue):
        r"""
        constructProperty_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args):
        r"""
        get_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, int i) -> double const

        Parameters
        ----------
        i: int

        get_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args):
        r"""
        upd_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, int i) -> double

        Parameters
        ----------
        i: int

        upd_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args):
        r"""
        set_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_use_Bhargava_recruitment_model(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_use_Bhargava_recruitment_model(self, source)

    def append_use_Bhargava_recruitment_model(self, value):
        r"""
        append_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_use_Bhargava_recruitment_model(self, value)

    def constructProperty_use_Bhargava_recruitment_model(self, initValue):
        r"""
        constructProperty_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_use_Bhargava_recruitment_model(self, initValue)

    def get_use_Bhargava_recruitment_model(self, *args):
        r"""
        get_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_use_Bhargava_recruitment_model(self, *args)

    def upd_use_Bhargava_recruitment_model(self, *args):
        r"""
        upd_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_use_Bhargava_recruitment_model(self, *args)

    def set_use_Bhargava_recruitment_model(self, *args):
        r"""
        set_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_use_Bhargava_recruitment_model(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value):
        r"""
        append_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue):
        r"""
        constructProperty_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args):
        r"""
        get_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args):
        r"""
        upd_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args):
        r"""
        set_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source):
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value):
        r"""
        append_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue):
        r"""
        constructProperty_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args):
        r"""
        get_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args):
        r"""
        upd_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args):
        r"""
        set_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_forbid_negative_total_power(self, *args)

    def copyProperty_report_total_metabolics_only(self, source):
        r""" Default value = true *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_report_total_metabolics_only(self, source)

    def append_report_total_metabolics_only(self, value):
        r"""
        append_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_report_total_metabolics_only(self, value)

    def constructProperty_report_total_metabolics_only(self, initValue):
        r"""
        constructProperty_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_report_total_metabolics_only(self, initValue)

    def get_report_total_metabolics_only(self, *args):
        r"""
        get_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_report_total_metabolics_only(self, *args)

    def upd_report_total_metabolics_only(self, *args):
        r"""
        upd_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_report_total_metabolics_only(self, *args)

    def set_report_total_metabolics_only(self, *args):
        r"""
        set_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_report_total_metabolics_only(self, *args)

    def copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source):
        r"""
        copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, Umberger2010MuscleMetabolicsProbe source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source)

    def append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value):
        r"""
        append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value) -> int

        Parameters
        ----------
        value: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value)

    def constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue):
        r"""
        constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet initValue)

        Parameters
        ----------
        initValue: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue)

    def get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, int i) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        i: int

        get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, int i) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        i: int

        upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args):
        r"""
        set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, int i, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value)

        Parameters
        ----------
        value: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Umberger2010MuscleMetabolicsProbe_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe(*args))

    def computeProbeInputs(self, state):
        r""" Compute muscle metabolic power."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self):
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self):
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_getProbeOutputLabels(self)

    def getNumMetabolicMuscles(self):
        r""" Get the number of muscles being analyzed in the metabolic analysis."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getNumMetabolicMuscles(self)

    def addMuscle(self, *args):
        r"""
        *Overload 1:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.

        |

        *Overload 2:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_addMuscle(self, *args)

    def removeMuscle(self, muscleName):
        r""" Remove a muscle from the metabolic analysis."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_removeMuscle(self, muscleName)

    def useProvidedMass(self, muscleName, providedMass):
        r""" %Set an existing muscle to use a provided muscle mass."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_useProvidedMass(self, muscleName, providedMass)

    def useCalculatedMass(self, muscleName):
        r""" %Set an existing muscle to calculate its own mass."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_useCalculatedMass(self, muscleName)

    def isUsingProvidedMass(self, muscleName):
        r"""
        Get whether the muscle mass is being explicitly provided.
               True means that it is using the property 'provided_muscle_mass'
               False means that the muscle mass is being calculated from muscle properties.
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_isUsingProvidedMass(self, muscleName)

    def getMuscleMass(self, muscleName):
        r"""
        Get the muscle mass used in the metabolic analysis. The value
               returned will depend on if the muscle mass is explicitly provided
               (i.e. isUsingProvidedMass = true), or if it is being automatically
               calculated from muscle data already present in the model
               (i.e. isUsingProvidedMass = true).
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_getMuscleMass(self, muscleName)

    def getRatioSlowTwitchFibers(self, muscleName):
        r""" Get the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getRatioSlowTwitchFibers(self, muscleName)

    def setRatioSlowTwitchFibers(self, muscleName, ratio):
        r""" %Set the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setRatioSlowTwitchFibers(self, muscleName, ratio)

    def getDensity(self, muscleName):
        r""" Get the density for an existing muscle (kg/m^3)."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getDensity(self, muscleName)

    def setDensity(self, muscleName, density):
        r""" %Set the density for an existing muscle (kg/m^3)."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setDensity(self, muscleName, density)

    def getSpecificTension(self, muscleName):
        r""" Get the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getSpecificTension(self, muscleName)

    def setSpecificTension(self, muscleName, specificTension):
        r""" %Set the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setSpecificTension(self, muscleName, specificTension)
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe

# Register Umberger2010MuscleMetabolicsProbe in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_swigregister(Umberger2010MuscleMetabolicsProbe)
class Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter(opensim.common.OpenSimObject):
    r"""
    Documentation for this class has been provided with the documentation for the
    Umberger2010MuscleMetabolicsProbe class.

    See also: Umberger2010MuscleMetabolicsProbe
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

    def clone(self):
        r"""clone(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source):
        r"""
        copyProperty_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value):
        r"""
        append_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue):
        r"""
        constructProperty_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args):
        r"""
        get_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args):
        r"""
        upd_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args):
        r"""
        set_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_specific_tension(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_specific_tension(self, *args)

    def copyProperty_density(self, source):
        r"""
        copyProperty_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_density(self, source)

    def append_density(self, value):
        r"""
        append_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_density(self, value)

    def constructProperty_density(self, initValue):
        r"""
        constructProperty_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_density(self, initValue)

    def get_density(self, *args):
        r"""
        get_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_density(self, *args)

    def upd_density(self, *args):
        r"""
        upd_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_density(self, *args)

    def set_density(self, *args):
        r"""
        set_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_density(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source):
        r"""
        copyProperty_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value):
        r"""
        append_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue):
        r"""
        constructProperty_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args):
        r"""
        get_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args):
        r"""
        upd_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args):
        r"""
        set_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_ratio_slow_twitch_fibers(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source):
        r"""
        copyProperty_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value):
        r"""
        append_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, initValue):
        r"""
        constructProperty_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_use_provided_muscle_mass(self, initValue)

    def get_use_provided_muscle_mass(self, *args):
        r"""
        get_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> bool const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args):
        r"""
        upd_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> bool &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args):
        r"""
        set_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_use_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source):
        r"""
        copyProperty_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter source)

        Parameters
        ----------
        source: OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter::Self const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value):
        r"""
        append_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, initValue):
        r"""
        constructProperty_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_provided_muscle_mass(self, initValue)

    def get_provided_muscle_mass(self, *args):
        r"""
        get_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args):
        r"""
        upd_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double &
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args):
        r"""
        set_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_provided_muscle_mass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_provided_muscle_mass(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter
        __init__(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, std::string const & muscleName, double ratio_slow_twitch_fibers, double muscle_mass=SimTK::NaN) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

        Parameters
        ----------
        muscleName: std::string const &
        ratio_slow_twitch_fibers: double
        muscle_mass: double

        """
        _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter(*args))

    def getMuscleMass(self):
        r"""getMuscleMass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> double const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscleMass(self)

    def setMuscleMass(self):
        r"""setMuscleMass(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self)"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscleMass(self)

    def getMuscle(self):
        r"""getMuscle(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self) -> Muscle"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscle(self)

    def setMuscle(self, m):
        r"""
        setMuscle(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter self, Muscle m)

        Parameters
        ----------
        m: OpenSim::Muscle *

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscle(self, m)
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

# Register Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_swigregister(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter)
class Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(object):
    r"""
    MetabolicMuscleParameterSet is an internal container class containing the set
    of MetabolicMuscleParameters for each muscle that is probed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

    def clone(self):
        r"""clone(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> std::string const &"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet self) -> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet"""
        _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet())
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet

# Register Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swigregister(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet)
class ModelVisualPreferences(opensim.common.OpenSimObject):
    r"""
     A class that holds the Visual Preferences of a full OpenSim Model
     displayed in Visualizer. Initially these are serializable ModelDisplayHints
     but in the future can be expanded to include search paths for Mesh files,
     Texture, Renderer preferences, lights, cameras etc. attached to Model.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelVisualPreferences

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ModelVisualPreferences_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelVisualPreferences self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ModelVisualPreferences_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ModelVisualPreferences_getClassName()

    def clone(self):
        r"""clone(ModelVisualPreferences self) -> ModelVisualPreferences"""
        return _simulation.ModelVisualPreferences_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelVisualPreferences self) -> std::string const &"""
        return _simulation.ModelVisualPreferences_getConcreteClassName(self)

    def copyProperty_ModelDisplayHints(self, source):
        r"""
        copyProperty_ModelDisplayHints(ModelVisualPreferences self, ModelVisualPreferences source)

        Parameters
        ----------
        source: OpenSim::ModelVisualPreferences::Self const &

        """
        return _simulation.ModelVisualPreferences_copyProperty_ModelDisplayHints(self, source)

    def append_ModelDisplayHints(self, value):
        r"""
        append_ModelDisplayHints(ModelVisualPreferences self, ModelDisplayHints value) -> int

        Parameters
        ----------
        value: OpenSim::ModelDisplayHints const &

        """
        return _simulation.ModelVisualPreferences_append_ModelDisplayHints(self, value)

    def constructProperty_ModelDisplayHints(self, initValue):
        r"""
        constructProperty_ModelDisplayHints(ModelVisualPreferences self, ModelDisplayHints initValue)

        Parameters
        ----------
        initValue: OpenSim::ModelDisplayHints const &

        """
        return _simulation.ModelVisualPreferences_constructProperty_ModelDisplayHints(self, initValue)

    def get_ModelDisplayHints(self, *args):
        r"""
        get_ModelDisplayHints(ModelVisualPreferences self, int i) -> ModelDisplayHints

        Parameters
        ----------
        i: int

        get_ModelDisplayHints(ModelVisualPreferences self) -> ModelDisplayHints
        """
        return _simulation.ModelVisualPreferences_get_ModelDisplayHints(self, *args)

    def upd_ModelDisplayHints(self, *args):
        r"""
        upd_ModelDisplayHints(ModelVisualPreferences self, int i) -> ModelDisplayHints

        Parameters
        ----------
        i: int

        upd_ModelDisplayHints(ModelVisualPreferences self) -> ModelDisplayHints
        """
        return _simulation.ModelVisualPreferences_upd_ModelDisplayHints(self, *args)

    def set_ModelDisplayHints(self, *args):
        r"""
        set_ModelDisplayHints(ModelVisualPreferences self, int i, ModelDisplayHints value)

        Parameters
        ----------
        i: int
        value: OpenSim::ModelDisplayHints const &

        set_ModelDisplayHints(ModelVisualPreferences self, ModelDisplayHints value)

        Parameters
        ----------
        value: OpenSim::ModelDisplayHints const &

        """
        return _simulation.ModelVisualPreferences_set_ModelDisplayHints(self, *args)

    def __init__(self):
        r"""__init__(ModelVisualPreferences self) -> ModelVisualPreferences"""
        _simulation.ModelVisualPreferences_swiginit(self, _simulation.new_ModelVisualPreferences())
    __swig_destroy__ = _simulation.delete_ModelVisualPreferences

# Register ModelVisualPreferences in _simulation:
_simulation.ModelVisualPreferences_swigregister(ModelVisualPreferences)
class ModelVisualizer(object):
    r"""
     This class manages runtime visualization of a Model that is being
    manipulated through the OpenSim API. You should not allocate one of these
    yourself; instead, call the Model's setUseVisualizer() method and let the
    Model allocate one for itself. You may find the defaults to be adequate, but
    you can also get access to the %ModelVisualizer if you need it by calling
    the Model's getVisualizer() method.

    The %ModelVisualizer consults the Model's ModelDisplayHints object for
    instructions on what to display.

    The Simbody visualizer binary needs to be found at runtime to create a
    visualizer. The search proceeds in the following order:
    Directory of the currently running executable/binary.
    Directories referred to by the environment variable PATH.
    Possible locations for simbody installations:
      -- SIMBODY_HOME/bin if the environment variable SIMBODY_HOME exists.
      -- SimTK_INSTALL_DIR/bin if the environment variable SIMBODY_HOME exists.
      -- Platform specific default locations of binaries. For Linux/MacOS, this may
         be /usr/bin, /usr/local/bin etc. For Windows, this set is empty.

    Author: Michael Sherman

    See also: ModelDisplayHints, Model *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ModelVisualizer

    def show(self, state):
        r"""
        * Evaluate the geometry needed to visualize the given *state* and
            use it to generate a new image in the Visualizer window. *
        """
        return _simulation.ModelVisualizer_show(self, state)

    def getInputSilo(self):
        r"""
        ** If you want to poll for user input, you'll need access to the
            SimTK::Visualizer::InputSilo maintained here. Writable access is required
            to remove user input from the queues. *
        """
        return _simulation.ModelVisualizer_getInputSilo(self)

    def updInputSilo(self):
        r"""
        Get writable access to the InputSilo so you can remove user input
           from the queues. *
        """
        return _simulation.ModelVisualizer_updInputSilo(self)

    def getSimbodyVisualizer(self):
        r"""
        If you want access to the underlying Simbody SimTK::Visualizer, you
           can get a const reference here. *
        """
        return _simulation.ModelVisualizer_getSimbodyVisualizer(self)

    def updSimbodyVisualizer(self):
        r"""
        If you want writable access to the underlying Simbody SimTK::Visualizer,
           you can get a non-const reference here, provided that you have non-const
           access to the %ModelVisualizer. *
        """
        return _simulation.ModelVisualizer_updSimbodyVisualizer(self)

    def getGeometryDecorationGenerator(self):
        r"""
        ** Return a pointer to the DefaultGeometry decoration generator used by
            this %ModelVisualizer. *
        """
        return _simulation.ModelVisualizer_getGeometryDecorationGenerator(self)

    def getModel(self):
        r"""
        Return a const reference to the Model for which this %ModelVisualizer
           was constructed. *
        """
        return _simulation.ModelVisualizer_getModel(self)

    def updModel(self):
        r"""
        Return a writable reference to the Model for which this %ModelVisualizer
           was constructed. *
        """
        return _simulation.ModelVisualizer_updModel(self)

    @staticmethod
    def findGeometryFile(model, geoFile, isAbsolute, attempts):
        r"""
        Given the name of a geometry file, this method will attempt to
           find it in a series of locations using the same algorithm as is done
           internally by the %ModelVisualizer.

           :type model: :py:class:`Model`, in
           :param model:
                   Used to obtain the name of the file from which the model was loaded.
           :type geoFile: string, in
           :param geoFile:
                   Name of file to look for; can be absolute or relative path name or just
                   a file name and the extension must be supplied.
           :type isAbsolute: boolean, out
           :param isAbsolute:
                   This output parameter is set to true on return if the supplied
                   *geoFile* was an absolute path name; in that case no searching was
                   done.
           :type attempts: SimTK::Array_< std::string,unsigned int >, out
           :param attempts:
                   On return, this is a list of the absolute path names that were tried.
                   If *geoFile* was found, attempts.back() (the last entry) is the
                   absolute path name of *geoFile*. The last entry of this array will be
                   the path that succeeded in finding the geometry file.
           :rtype: boolean
           :return: ``true`` if *geoFile* was located and is readable.

           The search rule is as follows:
             - If *geoFile* is an absolute pathname no search is done.
             - Otherwise, define modelDir as the directory from which the current
               Model file was read in, if any, otherwise the current directory.
             - Try modelDir/geoFile, then modelDir/Geometry/geoFile.
             - Otherwise, try the search paths added through
               addDirToGeometrySearchPaths(). The paths are searched in
               reverse-chronological order -- the latest path added is searched first.
             - Otherwise a default installation directory.

           No attempt is made to validate the contents of the file or whether it
           has a supported extension; we're just looking for a file of the given
           name that exists and is readable. *
        """
        return _simulation.ModelVisualizer_findGeometryFile(model, geoFile, isAbsolute, attempts)

    @staticmethod
    def addDirToGeometrySearchPaths(dir):
        r"""
        Add a directory to the search path to be used by the function
           findGeometryFile. The added paths are searched in the
           reverse-chronological order -- the latest path added is searched first.
        """
        return _simulation.ModelVisualizer_addDirToGeometrySearchPaths(dir)

# Register ModelVisualizer in _simulation:
_simulation.ModelVisualizer_swigregister(ModelVisualizer)
class ModelHasNoSystem(opensim.common.OpenSimException):
    r""" Model  Exceptions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, modelName):
        r"""
        __init__(ModelHasNoSystem self, std::string const & file, size_t line, std::string const & func, std::string const & modelName) -> ModelHasNoSystem

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        modelName: std::string const &

        """
        _simulation.ModelHasNoSystem_swiginit(self, _simulation.new_ModelHasNoSystem(file, line, func, modelName))
    __swig_destroy__ = _simulation.delete_ModelHasNoSystem

# Register ModelHasNoSystem in _simulation:
_simulation.ModelHasNoSystem_swigregister(ModelHasNoSystem)
class PhysicalOffsetFramesFormLoop(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::PhysicalOffsetFramesFormLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, obj, frameName):
        r"""
        __init__(PhysicalOffsetFramesFormLoop self, std::string const & file, size_t line, std::string const & func, OpenSimObject obj, std::string const & frameName) -> PhysicalOffsetFramesFormLoop

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        obj: OpenSim::Object const &
        frameName: std::string const &

        """
        _simulation.PhysicalOffsetFramesFormLoop_swiginit(self, _simulation.new_PhysicalOffsetFramesFormLoop(file, line, func, obj, frameName))
    __swig_destroy__ = _simulation.delete_PhysicalOffsetFramesFormLoop

# Register PhysicalOffsetFramesFormLoop in _simulation:
_simulation.PhysicalOffsetFramesFormLoop_swigregister(PhysicalOffsetFramesFormLoop)
class JointFramesHaveSameBaseFrame(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::JointFramesHaveSameBaseFrame class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, thisName, parentName, childName, baseName):
        r"""
        __init__(JointFramesHaveSameBaseFrame self, std::string const & file, size_t line, std::string const & func, std::string const & thisName, std::string const & parentName, std::string const & childName, std::string const & baseName) -> JointFramesHaveSameBaseFrame

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        thisName: std::string const &
        parentName: std::string const &
        childName: std::string const &
        baseName: std::string const &

        """
        _simulation.JointFramesHaveSameBaseFrame_swiginit(self, _simulation.new_JointFramesHaveSameBaseFrame(file, line, func, thisName, parentName, childName, baseName))
    __swig_destroy__ = _simulation.delete_JointFramesHaveSameBaseFrame

# Register JointFramesHaveSameBaseFrame in _simulation:
_simulation.JointFramesHaveSameBaseFrame_swigregister(JointFramesHaveSameBaseFrame)
class Model(ModelComponent):
    r"""
     A concrete class that specifies the interface to a musculoskeletal model.
    You can read this in from an XML file or create it programmatically, and
    modify it via the API.

    A Model contains ModelComponents, and is itself a ModelComponent so must
    satisfy the ModelComponent interface, as well as the Object interface from
    which ModelComponent derives. This allows a Model to allocate "global"
    resources using ModelComponent resource-allocation facilities.

    Computation using a Model is done by creating a computational representation
    of the Model, called a System (SimTK::System), using Simbody. Creation of the
    System is initiated by a call to the Model's initSystem() method. The System and
    related objects are maintained in a runtime section of the Model object. You
    can also ask a Model to provide visualization using the setUseVisualizer()
    method, in which case it will allocate and maintain a ModelVisualizer.

    Authors: Frank Anderson, Peter Loan, Ayman Habib, Ajay Seth, Michael Sherman
    See also: ModelComponent, ModelVisualizer, SimTK::System
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Model

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Model_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Model self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Model_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Model_getClassName()

    def copyProperty_credits(self, source):
        r"""
        copyProperty_credits(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_credits(self, source)

    def append_credits(self, value):
        r"""
        append_credits(Model self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_append_credits(self, value)

    def constructProperty_credits(self, initValue):
        r"""
        constructProperty_credits(Model self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Model_constructProperty_credits(self, initValue)

    def get_credits(self, *args):
        r"""
        get_credits(Model self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_credits(Model self) -> std::string const &
        """
        return _simulation.Model_get_credits(self, *args)

    def upd_credits(self, *args):
        r"""
        upd_credits(Model self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_credits(Model self) -> std::string &
        """
        return _simulation.Model_upd_credits(self, *args)

    def set_credits(self, *args):
        r"""
        set_credits(Model self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_credits(Model self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_set_credits(self, *args)

    def copyProperty_publications(self, source):
        r"""
        copyProperty_publications(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_publications(self, source)

    def append_publications(self, value):
        r"""
        append_publications(Model self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_append_publications(self, value)

    def constructProperty_publications(self, initValue):
        r"""
        constructProperty_publications(Model self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Model_constructProperty_publications(self, initValue)

    def get_publications(self, *args):
        r"""
        get_publications(Model self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_publications(Model self) -> std::string const &
        """
        return _simulation.Model_get_publications(self, *args)

    def upd_publications(self, *args):
        r"""
        upd_publications(Model self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_publications(Model self) -> std::string &
        """
        return _simulation.Model_upd_publications(self, *args)

    def set_publications(self, *args):
        r"""
        set_publications(Model self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_publications(Model self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_set_publications(self, *args)

    def copyProperty_length_units(self, source):
        r"""
        copyProperty_length_units(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_length_units(self, source)

    def append_length_units(self, value):
        r"""
        append_length_units(Model self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_append_length_units(self, value)

    def constructProperty_length_units(self, initValue):
        r"""
        constructProperty_length_units(Model self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Model_constructProperty_length_units(self, initValue)

    def get_length_units(self, *args):
        r"""
        get_length_units(Model self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_length_units(Model self) -> std::string const &
        """
        return _simulation.Model_get_length_units(self, *args)

    def upd_length_units(self, *args):
        r"""
        upd_length_units(Model self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_length_units(Model self) -> std::string &
        """
        return _simulation.Model_upd_length_units(self, *args)

    def set_length_units(self, *args):
        r"""
        set_length_units(Model self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_length_units(Model self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_set_length_units(self, *args)

    def copyProperty_force_units(self, source):
        r"""
        copyProperty_force_units(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_force_units(self, source)

    def append_force_units(self, value):
        r"""
        append_force_units(Model self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_append_force_units(self, value)

    def constructProperty_force_units(self, initValue):
        r"""
        constructProperty_force_units(Model self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.Model_constructProperty_force_units(self, initValue)

    def get_force_units(self, *args):
        r"""
        get_force_units(Model self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_force_units(Model self) -> std::string const &
        """
        return _simulation.Model_get_force_units(self, *args)

    def upd_force_units(self, *args):
        r"""
        upd_force_units(Model self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_force_units(Model self) -> std::string &
        """
        return _simulation.Model_upd_force_units(self, *args)

    def set_force_units(self, *args):
        r"""
        set_force_units(Model self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_force_units(Model self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.Model_set_force_units(self, *args)

    def copyProperty_assembly_accuracy(self, source):
        r"""
        copyProperty_assembly_accuracy(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_assembly_accuracy(self, source)

    def append_assembly_accuracy(self, value):
        r"""
        append_assembly_accuracy(Model self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Model_append_assembly_accuracy(self, value)

    def constructProperty_assembly_accuracy(self, initValue):
        r"""
        constructProperty_assembly_accuracy(Model self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Model_constructProperty_assembly_accuracy(self, initValue)

    def get_assembly_accuracy(self, *args):
        r"""
        get_assembly_accuracy(Model self, int i) -> double const

        Parameters
        ----------
        i: int

        get_assembly_accuracy(Model self) -> double const &
        """
        return _simulation.Model_get_assembly_accuracy(self, *args)

    def upd_assembly_accuracy(self, *args):
        r"""
        upd_assembly_accuracy(Model self, int i) -> double

        Parameters
        ----------
        i: int

        upd_assembly_accuracy(Model self) -> double &
        """
        return _simulation.Model_upd_assembly_accuracy(self, *args)

    def set_assembly_accuracy(self, *args):
        r"""
        set_assembly_accuracy(Model self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_assembly_accuracy(Model self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Model_set_assembly_accuracy(self, *args)

    def copyProperty_gravity(self, source):
        r"""
        copyProperty_gravity(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_gravity(self, source)

    def append_gravity(self, value):
        r"""
        append_gravity(Model self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Model_append_gravity(self, value)

    def constructProperty_gravity(self, initValue):
        r"""
        constructProperty_gravity(Model self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.Model_constructProperty_gravity(self, initValue)

    def get_gravity(self, *args):
        r"""
        get_gravity(Model self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_gravity(Model self) -> Vec3
        """
        return _simulation.Model_get_gravity(self, *args)

    def upd_gravity(self, *args):
        r"""
        upd_gravity(Model self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_gravity(Model self) -> Vec3
        """
        return _simulation.Model_upd_gravity(self, *args)

    def set_gravity(self, *args):
        r"""
        set_gravity(Model self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_gravity(Model self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.Model_set_gravity(self, *args)

    def copyProperty_ground(self, source):
        r"""
        copyProperty_ground(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ground(self, source)

    def append_ground(self, value):
        r"""
        append_ground(Model self, Ground value) -> int

        Parameters
        ----------
        value: OpenSim::Ground const &

        """
        return _simulation.Model_append_ground(self, value)

    def constructProperty_ground(self, initValue):
        r"""
        constructProperty_ground(Model self, Ground initValue)

        Parameters
        ----------
        initValue: OpenSim::Ground const &

        """
        return _simulation.Model_constructProperty_ground(self, initValue)

    def get_ground(self, *args):
        r"""
        get_ground(Model self, int i) -> Ground

        Parameters
        ----------
        i: int

        get_ground(Model self) -> Ground
        """
        return _simulation.Model_get_ground(self, *args)

    def upd_ground(self, *args):
        r"""
        upd_ground(Model self, int i) -> Ground

        Parameters
        ----------
        i: int

        upd_ground(Model self) -> Ground
        """
        return _simulation.Model_upd_ground(self, *args)

    def set_ground(self, *args):
        r"""
        set_ground(Model self, int i, Ground value)

        Parameters
        ----------
        i: int
        value: OpenSim::Ground const &

        set_ground(Model self, Ground value)

        Parameters
        ----------
        value: OpenSim::Ground const &

        """
        return _simulation.Model_set_ground(self, *args)

    def copyProperty_BodySet(self, source):
        r"""
        copyProperty_BodySet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_BodySet(self, source)

    def append_BodySet(self, value):
        r"""
        append_BodySet(Model self, BodySet value) -> int

        Parameters
        ----------
        value: OpenSim::BodySet const &

        """
        return _simulation.Model_append_BodySet(self, value)

    def constructProperty_BodySet(self, initValue):
        r"""
        constructProperty_BodySet(Model self, BodySet initValue)

        Parameters
        ----------
        initValue: OpenSim::BodySet const &

        """
        return _simulation.Model_constructProperty_BodySet(self, initValue)

    def get_BodySet(self, *args):
        r"""
        get_BodySet(Model self, int i) -> BodySet

        Parameters
        ----------
        i: int

        get_BodySet(Model self) -> BodySet
        """
        return _simulation.Model_get_BodySet(self, *args)

    def upd_BodySet(self, *args):
        r"""
        upd_BodySet(Model self, int i) -> BodySet

        Parameters
        ----------
        i: int

        upd_BodySet(Model self) -> BodySet
        """
        return _simulation.Model_upd_BodySet(self, *args)

    def set_BodySet(self, *args):
        r"""
        set_BodySet(Model self, int i, BodySet value)

        Parameters
        ----------
        i: int
        value: OpenSim::BodySet const &

        set_BodySet(Model self, BodySet value)

        Parameters
        ----------
        value: OpenSim::BodySet const &

        """
        return _simulation.Model_set_BodySet(self, *args)

    def copyProperty_JointSet(self, source):
        r"""
        copyProperty_JointSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_JointSet(self, source)

    def append_JointSet(self, value):
        r"""
        append_JointSet(Model self, JointSet value) -> int

        Parameters
        ----------
        value: OpenSim::JointSet const &

        """
        return _simulation.Model_append_JointSet(self, value)

    def constructProperty_JointSet(self, initValue):
        r"""
        constructProperty_JointSet(Model self, JointSet initValue)

        Parameters
        ----------
        initValue: OpenSim::JointSet const &

        """
        return _simulation.Model_constructProperty_JointSet(self, initValue)

    def get_JointSet(self, *args):
        r"""
        get_JointSet(Model self, int i) -> JointSet

        Parameters
        ----------
        i: int

        get_JointSet(Model self) -> JointSet
        """
        return _simulation.Model_get_JointSet(self, *args)

    def upd_JointSet(self, *args):
        r"""
        upd_JointSet(Model self, int i) -> JointSet

        Parameters
        ----------
        i: int

        upd_JointSet(Model self) -> JointSet
        """
        return _simulation.Model_upd_JointSet(self, *args)

    def set_JointSet(self, *args):
        r"""
        set_JointSet(Model self, int i, JointSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::JointSet const &

        set_JointSet(Model self, JointSet value)

        Parameters
        ----------
        value: OpenSim::JointSet const &

        """
        return _simulation.Model_set_JointSet(self, *args)

    def copyProperty_ConstraintSet(self, source):
        r"""
        copyProperty_ConstraintSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ConstraintSet(self, source)

    def append_ConstraintSet(self, value):
        r"""
        append_ConstraintSet(Model self, ConstraintSet value) -> int

        Parameters
        ----------
        value: OpenSim::ConstraintSet const &

        """
        return _simulation.Model_append_ConstraintSet(self, value)

    def constructProperty_ConstraintSet(self, initValue):
        r"""
        constructProperty_ConstraintSet(Model self, ConstraintSet initValue)

        Parameters
        ----------
        initValue: OpenSim::ConstraintSet const &

        """
        return _simulation.Model_constructProperty_ConstraintSet(self, initValue)

    def get_ConstraintSet(self, *args):
        r"""
        get_ConstraintSet(Model self, int i) -> ConstraintSet

        Parameters
        ----------
        i: int

        get_ConstraintSet(Model self) -> ConstraintSet
        """
        return _simulation.Model_get_ConstraintSet(self, *args)

    def upd_ConstraintSet(self, *args):
        r"""
        upd_ConstraintSet(Model self, int i) -> ConstraintSet

        Parameters
        ----------
        i: int

        upd_ConstraintSet(Model self) -> ConstraintSet
        """
        return _simulation.Model_upd_ConstraintSet(self, *args)

    def set_ConstraintSet(self, *args):
        r"""
        set_ConstraintSet(Model self, int i, ConstraintSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ConstraintSet const &

        set_ConstraintSet(Model self, ConstraintSet value)

        Parameters
        ----------
        value: OpenSim::ConstraintSet const &

        """
        return _simulation.Model_set_ConstraintSet(self, *args)

    def copyProperty_MarkerSet(self, source):
        r"""
        copyProperty_MarkerSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_MarkerSet(self, source)

    def append_MarkerSet(self, value):
        r"""
        append_MarkerSet(Model self, MarkerSet value) -> int

        Parameters
        ----------
        value: OpenSim::MarkerSet const &

        """
        return _simulation.Model_append_MarkerSet(self, value)

    def constructProperty_MarkerSet(self, initValue):
        r"""
        constructProperty_MarkerSet(Model self, MarkerSet initValue)

        Parameters
        ----------
        initValue: OpenSim::MarkerSet const &

        """
        return _simulation.Model_constructProperty_MarkerSet(self, initValue)

    def get_MarkerSet(self, *args):
        r"""
        get_MarkerSet(Model self, int i) -> MarkerSet

        Parameters
        ----------
        i: int

        get_MarkerSet(Model self) -> MarkerSet
        """
        return _simulation.Model_get_MarkerSet(self, *args)

    def upd_MarkerSet(self, *args):
        r"""
        upd_MarkerSet(Model self, int i) -> MarkerSet

        Parameters
        ----------
        i: int

        upd_MarkerSet(Model self) -> MarkerSet
        """
        return _simulation.Model_upd_MarkerSet(self, *args)

    def set_MarkerSet(self, *args):
        r"""
        set_MarkerSet(Model self, int i, MarkerSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::MarkerSet const &

        set_MarkerSet(Model self, MarkerSet value)

        Parameters
        ----------
        value: OpenSim::MarkerSet const &

        """
        return _simulation.Model_set_MarkerSet(self, *args)

    def copyProperty_ForceSet(self, source):
        r"""
        copyProperty_ForceSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ForceSet(self, source)

    def append_ForceSet(self, value):
        r"""
        append_ForceSet(Model self, ForceSet value) -> int

        Parameters
        ----------
        value: OpenSim::ForceSet const &

        """
        return _simulation.Model_append_ForceSet(self, value)

    def constructProperty_ForceSet(self, initValue):
        r"""
        constructProperty_ForceSet(Model self, ForceSet initValue)

        Parameters
        ----------
        initValue: OpenSim::ForceSet const &

        """
        return _simulation.Model_constructProperty_ForceSet(self, initValue)

    def get_ForceSet(self, *args):
        r"""
        get_ForceSet(Model self, int i) -> ForceSet

        Parameters
        ----------
        i: int

        get_ForceSet(Model self) -> ForceSet
        """
        return _simulation.Model_get_ForceSet(self, *args)

    def upd_ForceSet(self, *args):
        r"""
        upd_ForceSet(Model self, int i) -> ForceSet

        Parameters
        ----------
        i: int

        upd_ForceSet(Model self) -> ForceSet
        """
        return _simulation.Model_upd_ForceSet(self, *args)

    def set_ForceSet(self, *args):
        r"""
        set_ForceSet(Model self, int i, ForceSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ForceSet const &

        set_ForceSet(Model self, ForceSet value)

        Parameters
        ----------
        value: OpenSim::ForceSet const &

        """
        return _simulation.Model_set_ForceSet(self, *args)

    def copyProperty_ControllerSet(self, source):
        r"""
        copyProperty_ControllerSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ControllerSet(self, source)

    def append_ControllerSet(self, value):
        r"""
        append_ControllerSet(Model self, ControllerSet value) -> int

        Parameters
        ----------
        value: OpenSim::ControllerSet const &

        """
        return _simulation.Model_append_ControllerSet(self, value)

    def constructProperty_ControllerSet(self, initValue):
        r"""
        constructProperty_ControllerSet(Model self, ControllerSet initValue)

        Parameters
        ----------
        initValue: OpenSim::ControllerSet const &

        """
        return _simulation.Model_constructProperty_ControllerSet(self, initValue)

    def get_ControllerSet(self, *args):
        r"""
        get_ControllerSet(Model self, int i) -> ControllerSet

        Parameters
        ----------
        i: int

        get_ControllerSet(Model self) -> ControllerSet
        """
        return _simulation.Model_get_ControllerSet(self, *args)

    def upd_ControllerSet(self, *args):
        r"""
        upd_ControllerSet(Model self, int i) -> ControllerSet

        Parameters
        ----------
        i: int

        upd_ControllerSet(Model self) -> ControllerSet
        """
        return _simulation.Model_upd_ControllerSet(self, *args)

    def set_ControllerSet(self, *args):
        r"""
        set_ControllerSet(Model self, int i, ControllerSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ControllerSet const &

        set_ControllerSet(Model self, ControllerSet value)

        Parameters
        ----------
        value: OpenSim::ControllerSet const &

        """
        return _simulation.Model_set_ControllerSet(self, *args)

    def copyProperty_ContactGeometrySet(self, source):
        r"""
        copyProperty_ContactGeometrySet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ContactGeometrySet(self, source)

    def append_ContactGeometrySet(self, value):
        r"""
        append_ContactGeometrySet(Model self, ContactGeometrySet value) -> int

        Parameters
        ----------
        value: OpenSim::ContactGeometrySet const &

        """
        return _simulation.Model_append_ContactGeometrySet(self, value)

    def constructProperty_ContactGeometrySet(self, initValue):
        r"""
        constructProperty_ContactGeometrySet(Model self, ContactGeometrySet initValue)

        Parameters
        ----------
        initValue: OpenSim::ContactGeometrySet const &

        """
        return _simulation.Model_constructProperty_ContactGeometrySet(self, initValue)

    def get_ContactGeometrySet(self, *args):
        r"""
        get_ContactGeometrySet(Model self, int i) -> ContactGeometrySet

        Parameters
        ----------
        i: int

        get_ContactGeometrySet(Model self) -> ContactGeometrySet
        """
        return _simulation.Model_get_ContactGeometrySet(self, *args)

    def upd_ContactGeometrySet(self, *args):
        r"""
        upd_ContactGeometrySet(Model self, int i) -> ContactGeometrySet

        Parameters
        ----------
        i: int

        upd_ContactGeometrySet(Model self) -> ContactGeometrySet
        """
        return _simulation.Model_upd_ContactGeometrySet(self, *args)

    def set_ContactGeometrySet(self, *args):
        r"""
        set_ContactGeometrySet(Model self, int i, ContactGeometrySet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ContactGeometrySet const &

        set_ContactGeometrySet(Model self, ContactGeometrySet value)

        Parameters
        ----------
        value: OpenSim::ContactGeometrySet const &

        """
        return _simulation.Model_set_ContactGeometrySet(self, *args)

    def copyProperty_ProbeSet(self, source):
        r"""
        copyProperty_ProbeSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ProbeSet(self, source)

    def append_ProbeSet(self, value):
        r"""
        append_ProbeSet(Model self, ProbeSet value) -> int

        Parameters
        ----------
        value: OpenSim::ProbeSet const &

        """
        return _simulation.Model_append_ProbeSet(self, value)

    def constructProperty_ProbeSet(self, initValue):
        r"""
        constructProperty_ProbeSet(Model self, ProbeSet initValue)

        Parameters
        ----------
        initValue: OpenSim::ProbeSet const &

        """
        return _simulation.Model_constructProperty_ProbeSet(self, initValue)

    def get_ProbeSet(self, *args):
        r"""
        get_ProbeSet(Model self, int i) -> ProbeSet

        Parameters
        ----------
        i: int

        get_ProbeSet(Model self) -> ProbeSet
        """
        return _simulation.Model_get_ProbeSet(self, *args)

    def upd_ProbeSet(self, *args):
        r"""
        upd_ProbeSet(Model self, int i) -> ProbeSet

        Parameters
        ----------
        i: int

        upd_ProbeSet(Model self) -> ProbeSet
        """
        return _simulation.Model_upd_ProbeSet(self, *args)

    def set_ProbeSet(self, *args):
        r"""
        set_ProbeSet(Model self, int i, ProbeSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ProbeSet const &

        set_ProbeSet(Model self, ProbeSet value)

        Parameters
        ----------
        value: OpenSim::ProbeSet const &

        """
        return _simulation.Model_set_ProbeSet(self, *args)

    def copyProperty_ComponentSet(self, source):
        r"""
        copyProperty_ComponentSet(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ComponentSet(self, source)

    def append_ComponentSet(self, value):
        r"""
        append_ComponentSet(Model self, ComponentSet value) -> int

        Parameters
        ----------
        value: OpenSim::ComponentSet const &

        """
        return _simulation.Model_append_ComponentSet(self, value)

    def constructProperty_ComponentSet(self, initValue):
        r"""
        constructProperty_ComponentSet(Model self, ComponentSet initValue)

        Parameters
        ----------
        initValue: OpenSim::ComponentSet const &

        """
        return _simulation.Model_constructProperty_ComponentSet(self, initValue)

    def get_ComponentSet(self, *args):
        r"""
        get_ComponentSet(Model self, int i) -> ComponentSet

        Parameters
        ----------
        i: int

        get_ComponentSet(Model self) -> ComponentSet
        """
        return _simulation.Model_get_ComponentSet(self, *args)

    def upd_ComponentSet(self, *args):
        r"""
        upd_ComponentSet(Model self, int i) -> ComponentSet

        Parameters
        ----------
        i: int

        upd_ComponentSet(Model self) -> ComponentSet
        """
        return _simulation.Model_upd_ComponentSet(self, *args)

    def set_ComponentSet(self, *args):
        r"""
        set_ComponentSet(Model self, int i, ComponentSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::ComponentSet const &

        set_ComponentSet(Model self, ComponentSet value)

        Parameters
        ----------
        value: OpenSim::ComponentSet const &

        """
        return _simulation.Model_set_ComponentSet(self, *args)

    def copyProperty_ModelVisualPreferences(self, source):
        r"""
        copyProperty_ModelVisualPreferences(Model self, Model source)

        Parameters
        ----------
        source: OpenSim::Model::Self const &

        """
        return _simulation.Model_copyProperty_ModelVisualPreferences(self, source)

    def append_ModelVisualPreferences(self, value):
        r"""
        append_ModelVisualPreferences(Model self, ModelVisualPreferences value) -> int

        Parameters
        ----------
        value: OpenSim::ModelVisualPreferences const &

        """
        return _simulation.Model_append_ModelVisualPreferences(self, value)

    def constructProperty_ModelVisualPreferences(self, initValue):
        r"""
        constructProperty_ModelVisualPreferences(Model self, ModelVisualPreferences initValue)

        Parameters
        ----------
        initValue: OpenSim::ModelVisualPreferences const &

        """
        return _simulation.Model_constructProperty_ModelVisualPreferences(self, initValue)

    def get_ModelVisualPreferences(self, *args):
        r"""
        get_ModelVisualPreferences(Model self, int i) -> ModelVisualPreferences

        Parameters
        ----------
        i: int

        get_ModelVisualPreferences(Model self) -> ModelVisualPreferences
        """
        return _simulation.Model_get_ModelVisualPreferences(self, *args)

    def upd_ModelVisualPreferences(self, *args):
        r"""
        upd_ModelVisualPreferences(Model self, int i) -> ModelVisualPreferences

        Parameters
        ----------
        i: int

        upd_ModelVisualPreferences(Model self) -> ModelVisualPreferences
        """
        return _simulation.Model_upd_ModelVisualPreferences(self, *args)

    def set_ModelVisualPreferences(self, *args):
        r"""
        set_ModelVisualPreferences(Model self, int i, ModelVisualPreferences value)

        Parameters
        ----------
        i: int
        value: OpenSim::ModelVisualPreferences const &

        set_ModelVisualPreferences(Model self, ModelVisualPreferences value)

        Parameters
        ----------
        value: OpenSim::ModelVisualPreferences const &

        """
        return _simulation.Model_set_ModelVisualPreferences(self, *args)
    _has_output_com_position = property(_simulation.Model__has_output_com_position_get, _simulation.Model__has_output_com_position_set, doc=r"""_has_output_com_position : bool""")
    _has_output_com_velocity = property(_simulation.Model__has_output_com_velocity_get, _simulation.Model__has_output_com_velocity_set, doc=r"""_has_output_com_velocity : bool""")
    _has_output_com_acceleration = property(_simulation.Model__has_output_com_acceleration_get, _simulation.Model__has_output_com_acceleration_set, doc=r"""_has_output_com_acceleration : bool""")
    _has_output_kinetic_energy = property(_simulation.Model__has_output_kinetic_energy_get, _simulation.Model__has_output_kinetic_energy_set, doc=r"""_has_output_kinetic_energy : bool""")
    _has_output_potential_energy = property(_simulation.Model__has_output_potential_energy_get, _simulation.Model__has_output_potential_energy_set, doc=r"""_has_output_potential_energy : bool""")
    _has_output_momentum = property(_simulation.Model__has_output_momentum_get, _simulation.Model__has_output_momentum_set, doc=r"""_has_output_momentum : bool""")
    _has_output_angular_momentum = property(_simulation.Model__has_output_angular_momentum_get, _simulation.Model__has_output_angular_momentum_set, doc=r"""_has_output_angular_momentum : bool""")
    _has_output_linear_momentum = property(_simulation.Model__has_output_linear_momentum_get, _simulation.Model__has_output_linear_momentum_set, doc=r"""_has_output_linear_momentum : bool""")

    def finalizeConnections(self, *args):
        r"""
        *Overload 1:*
         Satisfy all connections (Sockets and Inputs) in the model, using this
        model as the root Component. This is a convenience form of
        Component::finalizeConnections() that uses this model as root.

        |

        *Overload 2:*
         Satisfy the Component's connections specified by its Sockets and Inputs.
                Locate Components and their Outputs to satisfy the connections in an
                aggregate Component (e.g. Model), which is the root of a tree of
                Components.
        """
        return _simulation.Model_finalizeConnections(self, *args)

    def setup(self):
        r"""
        Perform some set up functions that happen after the
        object has been deserialized. TODO: this method is
        not yet designed to be called after a model has been
        copied.
        """
        return _simulation.Model_setup(self)

    def cleanup(self):
        r"""
        Perform some clean up functions that are normally done
        from the destructor however this gives the GUI a way to
        proactively do the cleaning without waiting for garbage
        collection to do the actual cleanup.
        """
        return _simulation.Model_cleanup(self)

    def clone(self):
        r"""
        Model clone() override that invokes finalizeFromProperties()
               on a default copy constructed Model, prior to returning the Model.
        """
        return _simulation.Model_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Model self) -> std::string const &"""
        return _simulation.Model_getConcreteClassName(self)

    def getDisplayHints(self):
        r"""
        * Get read only access to the ModelDisplayHints object stored with this
            %Model. These should be checked whenever display geometry is being
            generated. *
        """
        return _simulation.Model_getDisplayHints(self)

    def updDisplayHints(self):
        r"""
        Get writable access to the ModelDisplayHints object stored with this
           %Model. The GUI or ModelVisualizer can update these as a result of user
           requests, or an OpenSim API program can set them programmatically. *
        """
        return _simulation.Model_updDisplayHints(self)

    def setUseVisualizer(self, visualize):
        r"""
        Request or suppress visualization of this %Model. This flag is checked
           during initSystem() and if set causes the %Model to allocate a
           ModelVisualizer that provides visualization and interaction with the %Model
           as it is executing. The default is no visualization.
           See also: getModelVisualizer() *
        """
        return _simulation.Model_setUseVisualizer(self, visualize)

    def getUseVisualizer(self):
        r"""
        Return the current setting of the "use visualizer" flag, which will
           take effect at the next call to initSystem() on this %Model. *
        """
        return _simulation.Model_getUseVisualizer(self)

    def hasVisualizer(self):
        r"""
        Test whether a ModelVisualizer has been created for this Model. Even
           if visualization has been requested there will be no visualizer present
           until initSystem() has been successfully invoked. Use this method prior
           to calling getVisualizer() or updVisualizer() to avoid an
           unpleasant exception. *
        """
        return _simulation.Model_hasVisualizer(self)

    def getVisualizer(self):
        r"""
        Obtain read-only access to the ModelVisualizer. This will throw an
           exception if visualization was not requested or initSystem() not yet
           called.
           :rtype: :py:class:`ModelVisualizer`
           :return: A const reference to the allocated ModelVisualizer. *
        """
        return _simulation.Model_getVisualizer(self)

    def updVisualizer(self):
        r"""
        Obtain writable access to the ModelVisualizer. This will throw an
           exception if visualization was not requested or initSystem() not yet
           called. Writable access to the ModelVisualizer requires that you have
           writable access to this containing Model.
           :rtype: :py:class:`ModelVisualizer`
           :return: A non-const reference to the allocated ModelVisualizer. *
        """
        return _simulation.Model_updVisualizer(self)

    def buildSystem(self):
        r"""
        * After the %Model and its components have been constructed, call this to
            interconnect the components and then create the Simbody
            MultibodySystem needed to represent the %Model computationally. The
            extendConnectToModel() method of each contained ModelComponent will be invoked,
            and then their addToSystem() methods are invoked.
            The resulting MultibodySystem is maintained internally by the %Model. After
            this call, you may obtain a writable reference to the System using
            updMultibodySystem() which you can use to make any additions you want. Then
            when the System is complete, call initializeState() to finalize it and
            obtain an initial State. *
        """
        return _simulation.Model_buildSystem(self)

    def initializeState(self):
        r"""
        After buildSystem() has been called, and any additional modifications
           to the Simbody MultibodySystem have been made, call this method to finalize
           the MultibodySystem (by calling its realizeTopology() method), obtain an
           initial state, and assemble it so that position constraints are
           satisfied. The initStateFromProperties() method of each contained
           ModelComponent will be invoked. A reference to the writable internally-
           maintained model State is returned (note that this does not affect the
           system's default state (which is part of the model and hence read only).
           The model's state can be reset to the system's default state at any time
           by re-executing initializeState(). *
        """
        return _simulation.Model_initializeState(self)

    def initSystem(self):
        r"""
        Convenience method that invokes buildSystem() and then
           initializeState(). This returns a reference to the writable internally-
           maintained model State. Note that this does not affect the
           system's default state (which is part of the model and hence read-only). *
        """
        return _simulation.Model_initSystem(self)

    def getWorkingState(self):
        r"""
        Convenience method that returns a reference to the model's 'working'
           state. This is just returning the reference that was returned by
           initSystem() and initializeState() -- note that either of these methods
           must be called prior to getWorkingState(), otherwise an empty state will
           be returned. *
        """
        return _simulation.Model_getWorkingState(self)

    def updWorkingState(self):
        r"""updWorkingState(Model self) -> State"""
        return _simulation.Model_updWorkingState(self)

    def initStateWithoutRecreatingSystem(self, state):
        r"""
        This is called after the Model is fully created but before starting a simulation.
        It ONLY initializes the computational system used to simulate the model and
        addToSystem() has been called already. This method should only be used if
        if additional SimTK::System components are being added using the SimTK API
        and the programmer is certain that the model's system has been created.
        """
        return _simulation.Model_initStateWithoutRecreatingSystem(self, state)

    def invalidateSystem(self):
        r"""
        Mark the computational system as invalid.  This should be called whenever a property
        of the model is modified.  Once this has been called, no calculations can be done until
        initSystem() is called again.
        """
        return _simulation.Model_invalidateSystem(self)

    def isValidSystem(self):
        r"""
        Check that the underlying computational system representing the model is valid.
               That is, is the system ready for performing calculations.
        """
        return _simulation.Model_isValidSystem(self)

    def formStateStorage(self, originalStorage, statesStorage, warnUnspecifiedStates=True):
        r"""
        Create a storage (statesStorage) that has same label order as model's states
        with values populated from originalStorage. Use the default state value if
        a state is unspecified in the originalStorage. If warnUnspecifiedStates is
        true then a warning is printed that includes the default value used for
        the state value unspecified in originalStorage. The input originalStorage
        must be in meters or radians for Coordinate values and their speeds
        (m/s, rad/s) otherwise an Exception is thrown.
        """
        return _simulation.Model_formStateStorage(self, originalStorage, statesStorage, warnUnspecifiedStates)

    def formQStorage(self, originalStorage, qStorage):
        r"""
        formQStorage(Model self, Storage originalStorage, Storage qStorage)

        Parameters
        ----------
        originalStorage: OpenSim::Storage const &
        qStorage: OpenSim::Storage &

        """
        return _simulation.Model_formQStorage(self, originalStorage, qStorage)

    def updateAssemblyConditions(self, s):
        r"""Update the AssemblySolver to the latest coordinate locking/constraints"""
        return _simulation.Model_updateAssemblyConditions(self, s)

    def assemble(self, state, coord=None, weight=10):
        r"""
        Find the kinematic state of the model that satisfies constraints and coordinate goals
        If assemble is being called due to a coordinate set value, provide the option
        to weight that coordinate value more heavily if specified.
        """
        return _simulation.Model_assemble(self, state, coord, weight)

    def equilibrateMuscles(self, state):
        r"""Update the state of all Muscles so they are in equilibrium."""
        return _simulation.Model_equilibrateMuscles(self, state)

    def getMultibodySystem(self):
        r"""
        * Get read-only access to the internal Simbody MultibodySystem that was
            created by this %Model at the last initSystem() call. *
        """
        return _simulation.Model_getMultibodySystem(self)

    def updMultibodySystem(self):
        r"""
        (Advanced) Get writable access to the internal Simbody MultibodySystem
           that was created by this %Model at the last initSystem() call. Be careful
           if you make modifications to the System because that will invalidate
           initialization already performed by the Model.
           See also: initStateWithoutRecreatingSystem() *
        """
        return _simulation.Model_updMultibodySystem(self)

    def getDefaultSubsystem(self):
        r"""
        Get read-only access to the internal DefaultSystemSubsystem allocated
           by this %Model's Simbody MultibodySystem. *
        """
        return _simulation.Model_getDefaultSubsystem(self)

    def updDefaultSubsystem(self):
        r"""
        (Advanced) Get writable access to the internal DefaultSystemSubsystem
           allocated by this %Model's Simbody MultibodySystem. *
        """
        return _simulation.Model_updDefaultSubsystem(self)

    def getMatterSubsystem(self):
        r"""
        Get read-only access to the internal SimbodyMatterSubsystem allocated
           by this %Model. *
        """
        return _simulation.Model_getMatterSubsystem(self)

    def updMatterSubsystem(self):
        r"""
        (Advanced) Get writable access to the internal SimbodyMatterSubsystem
           allocated by this %Model. *
        """
        return _simulation.Model_updMatterSubsystem(self)

    def getGravityForce(self):
        r"""
        Get read-only access to the Simbody Force::Gravity element that was
           allocated by this %Model. *
        """
        return _simulation.Model_getGravityForce(self)

    def updGravityForce(self):
        r"""
        (Advanced) Get writable access to the Simbody Force::Gravity element
           that was allocated by this %Model. *
        """
        return _simulation.Model_updGravityForce(self)

    def getForceSubsystem(self):
        r"""
        Get read-only access to the internal Simbody GeneralForceSubsystem
           allocated by this %Model. *
        """
        return _simulation.Model_getForceSubsystem(self)

    def updForceSubsystem(self):
        r"""
        (Advanced) Get writable access to the internal Simbody
           GeneralForceSubsystem allocated by this %Model. *
        """
        return _simulation.Model_updForceSubsystem(self)

    def getRigidBodyForces(self, state):
        r""" (Advanced) Get read only access to internal Simbody RigidBodyForces at Dynamics stage *"""
        return _simulation.Model_getRigidBodyForces(self, state)

    def getMobilityForces(self, state):
        r""" (Advanced) Get read only access to internal Simbody Mobility Forces at Dynamics stage *"""
        return _simulation.Model_getMobilityForces(self, state)

    def getGravityBodyForces(self, state):
        r""" (Advanced) Get read only access to internal Simbody Body Forces due to Gravity *"""
        return _simulation.Model_getGravityBodyForces(self, state)

    def realizeTime(self, state):
        r"""** Perform computations that depend only on time and earlier stages. *"""
        return _simulation.Model_realizeTime(self, state)

    def realizePosition(self, state):
        r"""
        Perform computations that depend only on position-level state
           variables and computations performed in earlier stages (including time). *
        """
        return _simulation.Model_realizePosition(self, state)

    def realizeVelocity(self, state):
        r"""
        Perform computations that depend only on velocity-level state
           variables and computations performed in earlier stages (including position,
           and time). *
        """
        return _simulation.Model_realizeVelocity(self, state)

    def realizeDynamics(self, state):
        r"""
        Perform computations (typically forces) that may depend on
           dynamics-stage state variables, and on computations performed in earlier
           stages (including velocity, position, and time), but not on other forces,
           accelerations, constraint multipliers, or reaction forces. *
        """
        return _simulation.Model_realizeDynamics(self, state)

    def realizeAcceleration(self, state):
        r""" Perform computations that may depend on applied forces. *"""
        return _simulation.Model_realizeAcceleration(self, state)

    def realizeReport(self, state):
        r"""
        Perform computations that may depend on anything but are only used
           for reporting and cannot affect subsequent simulation behavior. *
        """
        return _simulation.Model_realizeReport(self, state)

    def addModelComponent(self, adoptee):
        r"""*"""
        val = _simulation.Model_addModelComponent(self, adoptee)

        adoptee._markAdopted()


        return val


    def addBody(self, adoptee):
        r"""
        addBody(Model self, Body adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Body *

        """
        val = _simulation.Model_addBody(self, adoptee)

        adoptee._markAdopted()


        return val


    def addJoint(self, adoptee):
        r"""
        addJoint(Model self, Joint adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Joint *

        """
        val = _simulation.Model_addJoint(self, adoptee)

        adoptee._markAdopted()


        return val


    def addConstraint(self, adoptee):
        r"""
        addConstraint(Model self, Constraint adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Constraint *

        """
        val = _simulation.Model_addConstraint(self, adoptee)

        adoptee._markAdopted()


        return val


    def addForce(self, adoptee):
        r"""
        addForce(Model self, Force adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Force *

        """
        val = _simulation.Model_addForce(self, adoptee)

        adoptee._markAdopted()


        return val


    def addProbe(self, adoptee):
        r"""
        addProbe(Model self, Probe adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Probe *

        """
        val = _simulation.Model_addProbe(self, adoptee)

        adoptee._markAdopted()


        return val


    def addContactGeometry(self, adoptee):
        r"""
        addContactGeometry(Model self, ContactGeometry adoptee)

        Parameters
        ----------
        adoptee: OpenSim::ContactGeometry *

        """
        val = _simulation.Model_addContactGeometry(self, adoptee)

        adoptee._markAdopted()


        return val


    def addMarker(self, adoptee):
        r"""
        addMarker(Model self, Marker adoptee)

        Parameters
        ----------
        adoptee: OpenSim::Marker *

        """
        val = _simulation.Model_addMarker(self, adoptee)

        adoptee._markAdopted()


        return val


    def removeProbe(self, probe):
        r""" remove passed in Probe from model *"""
        return _simulation.Model_removeProbe(self, probe)

    def getInputFileName(self):
        r"""
        Get the XML file name used to construct the model.

        :rtype: string
        :return: XML file name string.
        """
        return _simulation.Model_getInputFileName(self)

    def setInputFileName(self, fileName):
        r"""
        %Set the XML file name used to construct the model.

        :type fileName: string
        :param fileName: The XML file name.
        """
        return _simulation.Model_setInputFileName(self, fileName)

    def getCredits(self):
        r"""
        Get the credits (e.g., model author names) associated with the model.

        :rtype: string
        :return: Credits string.
        """
        return _simulation.Model_getCredits(self)

    def setAuthors(self, aCredits):
        r"""
        %Set the credits (e.g., model author names) associated with the model.

        :type aCredits: string
        :param aCredits: The string of credits.
        """
        return _simulation.Model_setAuthors(self, aCredits)

    def getPublications(self):
        r"""
        Get the publications associated with the model.

        :rtype: string
        :return: Publications string.
        """
        return _simulation.Model_getPublications(self)

    def setPublications(self, aPublications):
        r"""
        %Set the publications associated with the model.

        :type aPublications: string
        :param aPublications: The string of publications.
        """
        return _simulation.Model_setPublications(self, aPublications)

    def getLengthUnits(self):
        r"""
        Get the length units associated with the model.

        :rtype: :py:class:`Units`
        :return: Length units.
        """
        return _simulation.Model_getLengthUnits(self)

    def getForceUnits(self):
        r"""
        Get the force units associated with the model.

        :rtype: :py:class:`Units`
        :return: Force units
        """
        return _simulation.Model_getForceUnits(self)

    def getGravity(self):
        r"""
        Get the gravity vector in the global frame.

        :rtype: :py:class:`Vec3`
        :return: The XYZ gravity vector in the global frame.
        """
        return _simulation.Model_getGravity(self)

    def setGravity(self, aGrav):
        r"""
        %Set the gravity vector in the global frame.

        :type aGrav: :py:class:`Vec3`
        :param aGrav: The XYZ gravity vector
        :rtype: boolean
        :return: Whether or not the gravity vector was successfully set.
        """
        return _simulation.Model_setGravity(self, aGrav)

    def getNumMarkers(self):
        r"""
        Get the number of markers in the model.
        :rtype: int
        :return: Number of markers.
        """
        return _simulation.Model_getNumMarkers(self)

    def getNumContactGeometries(self):
        r"""
        Get the number of ContactGeometries in the model.
        :rtype: int
        :return: Number of ContactGeometries.
        """
        return _simulation.Model_getNumContactGeometries(self)

    def getNumBodies(self):
        r"""
        Get the total number of bodies in the model.
        :rtype: int
        :return: Number of bodies.
        """
        return _simulation.Model_getNumBodies(self)

    def getNumJoints(self):
        r"""
        Get the total number of joints in the model.
        :rtype: int
        :return: Number of joints.
        """
        return _simulation.Model_getNumJoints(self)

    def getNumCoordinates(self):
        r"""
        Get the total number of coordinates in the model.
        :rtype: int
        :return: Number of coordinates.
        """
        return _simulation.Model_getNumCoordinates(self)

    def getNumSpeeds(self):
        r"""
        Get the total number of speeds in the model.
        :rtype: int
        :return: Number of speeds.
        """
        return _simulation.Model_getNumSpeeds(self)

    def getNumConstraints(self):
        r"""
        Get the total number of constraints in the model.
        :rtype: int
        :return: Number of constraints.
        """
        return _simulation.Model_getNumConstraints(self)

    def getNumProbes(self):
        r"""
        Get the total number of probes in the model.
        :rtype: int
        :return: Number of probes.
        """
        return _simulation.Model_getNumProbes(self)

    def getActuators(self):
        r"""
        Get the subset of Forces in the model which are actuators
        :rtype: OpenSim::Set< OpenSim::Actuator >
        :return: The set of Actuators
        """
        return _simulation.Model_getActuators(self)

    def updActuators(self):
        r"""updActuators(Model self) -> SetActuators"""
        return _simulation.Model_updActuators(self)

    def getMuscles(self):
        r"""
        Get the subset of Forces in the model which are muscles
        :rtype: OpenSim::Set< OpenSim::Muscle >
        :return: The set of Muscles
        """
        return _simulation.Model_getMuscles(self)

    def updMuscles(self):
        r"""updMuscles(Model self) -> SetMuscles"""
        return _simulation.Model_updMuscles(self)

    def getForceSet(self):
        r"""getForceSet(Model self) -> ForceSet"""
        return _simulation.Model_getForceSet(self)

    def updForceSet(self):
        r"""updForceSet(Model self) -> ForceSet"""
        return _simulation.Model_updForceSet(self)

    def getProbeSet(self):
        r"""
        Get the subset of Probes in the model
        :rtype: :py:class:`ProbeSet`
        :return: The set of Probes
        """
        return _simulation.Model_getProbeSet(self)

    def updProbeSet(self):
        r"""updProbeSet(Model self) -> ProbeSet"""
        return _simulation.Model_updProbeSet(self)

    def getMiscModelComponentSet(self):
        r"""
        Get the subst of misc ModelComponents in the model
        :rtype: :py:class:`ComponentSet`
        :return: The set of misc ModelComponents
        """
        return _simulation.Model_getMiscModelComponentSet(self)

    def updMiscModelComponentSet(self):
        r"""updMiscModelComponentSet(Model self) -> ComponentSet"""
        return _simulation.Model_updMiscModelComponentSet(self)

    def getNumAnalyses(self):
        r"""
        Get the number of analyses in the model.
        :rtype: int
        :return: The number of analyses.
        """
        return _simulation.Model_getNumAnalyses(self)

    def getNumControls(self):
        r"""
        Get the number of controls for this the model.
        Only valid once underlying system for the model has been created.
        Throws an exception if called before Model::initSystem()
        :rtype: int
        :return: number of controls corresponding to all the actuators in the model
        """
        return _simulation.Model_getNumControls(self)

    def updDefaultControls(self):
        r"""
        Writable access to the default values for controls. These values are used for
               control value during a simulation unless updated, for example, by a Controller
        """
        return _simulation.Model_updDefaultControls(self)

    def setDefaultControls(self, controls):
        r"""
        setDefaultControls(Model self, Vector controls)

        Parameters
        ----------
        controls: SimTK::Vector const &

        """
        return _simulation.Model_setDefaultControls(self, controls)

    def getDefaultControls(self):
        r"""getDefaultControls(Model self) -> Vector"""
        return _simulation.Model_getDefaultControls(self)

    def updControls(self, s):
        r"""
        Update the controls for this the model at a given state.
        Only callable once underlying system for the model has been created.
        Throws an exception if called before Model::initSystem()
        This call invalidates the dynamics of the model and invalidates the
        value of the controls until they are marked as valid when the update
        is completed (See also: markControlsAsValid)
        :type s: :py:class:`State`, in
        :param s:         System state at which to apply the controls
        :rtype: :py:class:`Vector`
        :return: writable controls Vector
        """
        return _simulation.Model_updControls(self, s)

    def markControlsAsValid(self, s):
        r"""
        Mark controls as valid after an update at a given state.
        Indicates that controls are valid for use at the dynamics stage.
        If the stage is Velocity or lower the controls will remain invalid.
        :type s: :py:class:`State`, in
        :param s:         System state in which the controls are updated
        """
        return _simulation.Model_markControlsAsValid(self, s)

    def markControlsAsInvalid(self, s):
        r"""
        Mark controls as invalid after an update at a given state.
        Indicates that controls are not valid for use at the dynamics stage.
        :type s: :py:class:`State`, in
        :param s:         System state in which the controls are updated
        """
        return _simulation.Model_markControlsAsInvalid(self, s)

    def setControls(self, s, controls):
        r"""
        Alternatively, set the controls on the model at a given state.
        Note, this method will invalidate the dynamics of the model,
        but will mark the controls as valid. (E.g. controllers will not be invoked)
        :type s: :py:class:`State`, in
        :param s:         System state at which to apply the controls
        :type controls: :py:class:`Vector`, in
        :param controls:  The complete Vector of controls to be applied
        """
        return _simulation.Model_setControls(self, s, controls)

    def getControls(self, s):
        r""" Const access to controls does not invalidate dynamics"""
        return _simulation.Model_getControls(self, s)

    def computeControls(self, state, controls):
        r"""
        Compute the controls for the model.
           Calls down to the Controllers to make their contributions to the controls.

           :type state: :py:class:`State`, in
           :param state:       System state from which Controllers should draw
                                        when computing their control outputs.
           :type controls: :py:class:`Vector`, out
           :param controls:    The complete vector of controls into which
                                        individual controller contributions should be
                                        added. *
        """
        return _simulation.Model_computeControls(self, state, controls)

    def isControlled(self):
        r"""Get a flag indicating if the model needs controls to operate its actuators"""
        return _simulation.Model_isControlled(self)

    def storeControls(self, s, step):
        r"""
        storeControls(Model self, State s, int step)

        Parameters
        ----------
        s: SimTK::State const &
        step: int

        """
        return _simulation.Model_storeControls(self, s, step)

    def printControlStorage(self, fileName):
        r"""
        printControlStorage(Model self, std::string const & fileName)

        Parameters
        ----------
        fileName: std::string const &

        """
        return _simulation.Model_printControlStorage(self, fileName)

    def getControlsTable(self):
        r"""getControlsTable(Model self) -> TimeSeriesTable"""
        return _simulation.Model_getControlsTable(self)

    def getControllerSet(self):
        r"""getControllerSet(Model self) -> ControllerSet"""
        return _simulation.Model_getControllerSet(self)

    def updControllerSet(self):
        r"""updControllerSet(Model self) -> ControllerSet"""
        return _simulation.Model_updControllerSet(self)

    def getAllControllersEnabled(self):
        r"""getAllControllersEnabled(Model self) -> bool"""
        return _simulation.Model_getAllControllersEnabled(self)

    def setAllControllersEnabled(self, enabled):
        r"""
        setAllControllersEnabled(Model self, bool enabled)

        Parameters
        ----------
        enabled: bool

        """
        return _simulation.Model_setAllControllersEnabled(self, enabled)

    def applyDefaultConfiguration(self, s):
        r"""
        applyDefaultConfiguration(Model self, State s)

        Parameters
        ----------
        s: SimTK::State &

        """
        return _simulation.Model_applyDefaultConfiguration(self, s)

    def getSimbodyEngine(self):
        r"""
        Get the model's dynamics engine

        :rtype: :py:class:`SimbodyEngine`
        :return: Reference to the Simbody dynamics engine
        """
        return _simulation.Model_getSimbodyEngine(self)

    def updSimbodyEngine(self):
        r"""updSimbodyEngine(Model self) -> SimbodyEngine"""
        return _simulation.Model_updSimbodyEngine(self)

    def computeStateVariableDerivatives(self, s):
        r"""Compute the derivatives of the generalized coordinates and speeds."""
        return _simulation.Model_computeStateVariableDerivatives(self, s)

    def getTotalMass(self, s):
        r"""
        Get the total mass of the model.

        :rtype: float
        :return: the mass of the model.
        """
        return _simulation.Model_getTotalMass(self, s)

    def getInertiaAboutMassCenter(self, s):
        r"""
        Get the whole-body inertia of the model about the center of mass,
        expressed in the Ground frame.
        """
        return _simulation.Model_getInertiaAboutMassCenter(self, s)

    def calcMassCenterPosition(self, s):
        r"""
        Return the position vector of the system mass center, measured from the
        Ground origin, and expressed in Ground.
        """
        return _simulation.Model_calcMassCenterPosition(self, s)

    def calcMassCenterVelocity(self, s):
        r"""
        Return the velocity vector of the system mass center, measured from the
        Ground origin, and expressed in Ground.
        """
        return _simulation.Model_calcMassCenterVelocity(self, s)

    def calcMassCenterAcceleration(self, s):
        r"""
        Return the acceleration vector of the system mass center, measured from
        the Ground origin, and expressed in Ground.
        """
        return _simulation.Model_calcMassCenterAcceleration(self, s)

    def calcMomentum(self, s):
        r"""
        Return the spatial momentum about the system mass center expressed in
        Ground.
        """
        return _simulation.Model_calcMomentum(self, s)

    def calcAngularMomentum(self, s):
        r"""
        Return the angular momentum about the system mass center expressed in
        Ground.
        """
        return _simulation.Model_calcAngularMomentum(self, s)

    def calcLinearMomentum(self, s):
        r"""Return the linear momentum expressed in Ground."""
        return _simulation.Model_calcLinearMomentum(self, s)

    def calcKineticEnergy(self, s):
        r""" Return the total Kinetic Energy for the underlying system."""
        return _simulation.Model_calcKineticEnergy(self, s)

    def calcPotentialEnergy(self, s):
        r""" Return the total Potential Energy for the underlying system."""
        return _simulation.Model_calcPotentialEnergy(self, s)

    def calcForceContributionsSum(self, state, forceIndexes, bodyForces, mobilityForces):
        r"""
         Calulate the sum of body and mobility forces in the system applied by
        the Force%s at the supplied indexes.

        :type state: :py:class:`State`, in
        :param state:            The system SimTK::State at which to
                                          calculate forces.
        :type forceIndexes: SimTK::Array_< SimTK::ForceIndex,unsigned int >, in
        :param forceIndexes:     The indexes (SimTK::ForceIndex) of the
                                          forces in the system for which to calculate
                                          forces.
        :type bodyForces: SimTK::Vector_< SimTK::SpatialVec >, out
        :param bodyForces:       The sum of the body forces applied by the
                                          forces at the supplied indexes.
        :type mobilityForces: :py:class:`Vector`, out
        :param mobilityForces:   The sum of the mobility forces applied by
                                          the forces at the supplied indexes.
        """
        return _simulation.Model_calcForceContributionsSum(self, state, forceIndexes, bodyForces, mobilityForces)

    def getNumMuscleStates(self):
        r"""getNumMuscleStates(Model self) -> int"""
        return _simulation.Model_getNumMuscleStates(self)

    def getNumProbeStates(self):
        r"""getNumProbeStates(Model self) -> int"""
        return _simulation.Model_getNumProbeStates(self)

    def updCoordinateSet(self):
        r"""updCoordinateSet(Model self) -> CoordinateSet"""
        return _simulation.Model_updCoordinateSet(self)

    def getCoordinateSet(self):
        r"""getCoordinateSet(Model self) -> CoordinateSet"""
        return _simulation.Model_getCoordinateSet(self)

    def getCoordinatesInMultibodyTreeOrder(self):
        r"""
        Obtain a list of Model's Coordinates in the order they appear in the
               MultibodySystem after Model::initSystem() has been called.
               Coordinates in the CoordinateSet do not have a predefined order. In
               some instances it is helpful to get the coordinates in order of
               generalized coordinates in the Multibody Tree as defined in the
               underlying MultibodySystem. For example, computing the generalized
               forces from the System, yields a vector of generalized forces
               in order of the Multibody Tree and now that can be attributed to
               corresponding generalized Coordinates of the Model.
               Throws if the MultibodySystem is not valid.
        """
        return _simulation.Model_getCoordinatesInMultibodyTreeOrder(self)

    def getCoordinateNamesInMultibodyTreeOrder(self):
        r""" A variant of getCoordinatesInMultibodyTreeOrder that returns names for Scripting users"""
        return _simulation.Model_getCoordinateNamesInMultibodyTreeOrder(self)

    def getWarningMesssageForMotionTypeInconsistency(self):
        r"""
        Get a warning message if any Coordinates have a MotionType that is NOT
               consistent with its previous user-specified value that existed in
               Model files prior to OpenSim 4.0
        """
        return _simulation.Model_getWarningMesssageForMotionTypeInconsistency(self)

    def updBodySet(self):
        r"""updBodySet(Model self) -> BodySet"""
        return _simulation.Model_updBodySet(self)

    def getBodySet(self):
        r"""getBodySet(Model self) -> BodySet"""
        return _simulation.Model_getBodySet(self)

    def updJointSet(self):
        r"""updJointSet(Model self) -> JointSet"""
        return _simulation.Model_updJointSet(self)

    def getJointSet(self):
        r"""getJointSet(Model self) -> JointSet"""
        return _simulation.Model_getJointSet(self)

    def updAnalysisSet(self):
        r"""updAnalysisSet(Model self) -> AnalysisSet"""
        return _simulation.Model_updAnalysisSet(self)

    def getAnalysisSet(self):
        r"""getAnalysisSet(Model self) -> AnalysisSet"""
        return _simulation.Model_getAnalysisSet(self)

    def updContactGeometrySet(self):
        r"""updContactGeometrySet(Model self) -> ContactGeometrySet"""
        return _simulation.Model_updContactGeometrySet(self)

    def getContactGeometrySet(self):
        r"""getContactGeometrySet(Model self) -> ContactGeometrySet"""
        return _simulation.Model_getContactGeometrySet(self)

    def getGround(self):
        r""" Get a const reference to the Ground reference frame"""
        return _simulation.Model_getGround(self)

    def updGround(self):
        r""" Get a writable reference to the Ground reference frame"""
        return _simulation.Model_updGround(self)

    def updConstraintSet(self):
        r"""updConstraintSet(Model self) -> ConstraintSet"""
        return _simulation.Model_updConstraintSet(self)

    def getConstraintSet(self):
        r"""getConstraintSet(Model self) -> ConstraintSet"""
        return _simulation.Model_getConstraintSet(self)

    def updMarkerSet(self):
        r"""updMarkerSet(Model self) -> MarkerSet"""
        return _simulation.Model_updMarkerSet(self)

    def getMarkerSet(self):
        r"""getMarkerSet(Model self) -> MarkerSet"""
        return _simulation.Model_getMarkerSet(self)

    def writeMarkerFile(self, aFileName):
        r"""
        writeMarkerFile(Model self, std::string const & aFileName)

        Parameters
        ----------
        aFileName: std::string const &

        """
        return _simulation.Model_writeMarkerFile(self, aFileName)

    def updateMarkerSet(self, newMarkerSet):
        r"""
        Update the markers in the model by appending the ones in the
        passed-in marker set. If the marker of the same name exists
        in the model, then replace it.

        :type newMarkerSet: :py:class:`MarkerSet`
        :param newMarkerSet: the set of markers used to update the model's set.
        """
        return _simulation.Model_updateMarkerSet(self, newMarkerSet)

    def deleteUnusedMarkers(self, aMarkerNames):
        r"""
        deleteUnusedMarkers(Model self, ArrayStr aMarkerNames) -> int

        Parameters
        ----------
        aMarkerNames: OpenSim::Array< std::string > const &

        """
        return _simulation.Model_deleteUnusedMarkers(self, aMarkerNames)

    def addAnalysis(self, adoptee):
        r"""
        Add an Analysis to the %Model.

        :type adoptee: :py:class:`Analysis`
        :param adoptee: pointer to the Analysis to add
        """
        val = _simulation.Model_addAnalysis(self, adoptee)

        adoptee._markAdopted()


        return val


    def addController(self, adoptee):
        r""" Add a Controller to the %Model. *"""
        val = _simulation.Model_addController(self, adoptee)

        adoptee._markAdopted()


        return val


    def removeAnalysis(self, analysis, deleteIt=True):
        r"""
        Remove an Analysis from the %Model.

        :type analysis: :py:class:`Analysis`
        :param analysis:  Pointer to the analysis to remove.
        :type deleteIt: boolean, optional
        :param deleteIt:  Whether the removed object should be deleted.
        """
        return _simulation.Model_removeAnalysis(self, analysis, deleteIt)

    def removeController(self, aController):
        r""" Remove a Controller from the %Model. *"""
        return _simulation.Model_removeController(self, aController)

    def scale(self, state, scaleSet, preserveMassDist, finalMass=-1.0):
        r"""
        Scale the model.

        :type state: :py:class:`State`
        :param state:      State containing parameter values that might be
                              modified here.
        :type scaleSet: :py:class:`ScaleSet`
        :param scaleSet:   The set of XYZ scale factors for the bodies.
        :type preserveMassDist: boolean
        :param preserveMassDist:
                              Whether the masses of the bodies should be scaled by
                              the scale factors. If `false`, body masses will be
                              adjusted only if `finalMass` has been specified; if
                              `true`, body masses will be scaled by the product of
                              the body's scale factors (and then a second time if
                              `finalMass` has been specified). Inertias are always
                              updated to reflect changes in body dimensions.
        :type finalMass: float, optional
        :param finalMass:  The total mass that the scaled model should have.
        :rtype: boolean
        :return: Whether or not scaling was successful.
        """
        return _simulation.Model_scale(self, state, scaleSet, preserveMassDist, finalMass)

    def printBasicInfo(self, *args):
        r"""
        Print some basic information about the model.

        :type aOStream: std::ostream, optional
        :param aOStream: Output stream. If this is std::cout, then the info is
            logged using OpenSim's Logger so that the info is printed to all log
            sinks.
        """
        return _simulation.Model_printBasicInfo(self, *args)

    def printDetailedInfo(self, *args):
        r"""
        Print detailed information about the model.

        :type s: :py:class:`State`
        :param s:        the system State.
        :type aOStream: std::ostream, optional
        :param aOStream: Output stream. If this is std::cout, then the info is
            logged using OpenSim's Logger so that the info is printed to all log
            sinks.
        """
        return _simulation.Model_printDetailedInfo(self, *args)

    def disownAllComponents(self):
        r"""
        Model relinquishes ownership of all components such as: Bodies, Constraints, Forces,
        ContactGeometry and so on. That means the freeing of the memory of these objects is up
        to the caller. This only affects components stored in the Model's Sets,
        and does not affect those added via Component::addComponent().
        """
        return _simulation.Model_disownAllComponents(self)

    def overrideAllActuators(self, s, flag):
        r"""Convenience function to turn on/off overriding the force for all actuators"""
        return _simulation.Model_overrideAllActuators(self, s, flag)

    def getValidationLog(self):
        r"""Get a log of errors/warnings encountered when loading/constructing the model"""
        return _simulation.Model_getValidationLog(self)

    def appendToValidationLog(self, note):
        r""" Append to the Model's validation log without affecting is current contents"""
        return _simulation.Model_appendToValidationLog(self, note)

    def clearValidationLog(self):
        r"""clearValidationLog(Model self)"""
        return _simulation.Model_clearValidationLog(self)

    def getObjectByTypeAndName(self, typeString, nameString):
        r"""
        Utility to get a reference to an Object based on its name and type
        throws an exception if the object was not found.
        names are case sensitive
        :type typeString: string
        :param typeString: the type of object being looked up (Body, Force, Constraint, Coordinate, Joint, Marker, Controller, Frame)
        :type nameString: string
        :param nameString: the name of the object being looked up
        :rtype: :py:class:`Object`
        :return: reference to the object if found or throws an exception.
        """
        return _simulation.Model_getObjectByTypeAndName(self, typeString, nameString)
    __swig_destroy__ = _simulation.delete_Model

    def updateFromXMLNode(self, aNode, versionNumber=-1):
        r""" Override of the default implementation to account for versioning."""
        return _simulation.Model_updateFromXMLNode(self, aNode, versionNumber)

    def extendFinalizeFromProperties(self):
        r"""**"""
        return _simulation.Model_extendFinalizeFromProperties(self)

    def extendConnectToModel(self, model):
        r"""
        extendConnectToModel(Model self, Model model)

        Parameters
        ----------
        model: OpenSim::Model &

        """
        return _simulation.Model_extendConnectToModel(self, model)

    def extendAddToSystem(self, system):
        r"""
        extendAddToSystem(Model self, SimTK::MultibodySystem & system)

        Parameters
        ----------
        system: SimTK::MultibodySystem &

        """
        return _simulation.Model_extendAddToSystem(self, system)

    def extendInitStateFromProperties(self, state):
        r"""
        extendInitStateFromProperties(Model self, State state)

        Parameters
        ----------
        state: SimTK::State &

        """
        return _simulation.Model_extendInitStateFromProperties(self, state)

    def extendSetPropertiesFromState(self, state):
        r"""
        *
        Given a State, set all default values for this Model to match those
        found in the State.
        """
        return _simulation.Model_extendSetPropertiesFromState(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""*"""
        return _simulation.Model_generateDecorations(self, fixed, hints, state, appendToThis)

    def getFrameList(self):
        r"""getFrameList(Model self) -> FrameList"""
        return _simulation.Model_getFrameList(self)

    def getBodyList(self):
        r"""getBodyList(Model self) -> BodyList"""
        return _simulation.Model_getBodyList(self)

    def getMuscleList(self):
        r"""getMuscleList(Model self) -> MuscleList"""
        return _simulation.Model_getMuscleList(self)

    def getJointList(self):
        r"""getJointList(Model self) -> JointList"""
        return _simulation.Model_getJointList(self)

    def getActuatorList(self):
        r"""getActuatorList(Model self) -> ActuatorList"""
        return _simulation.Model_getActuatorList(self)

    def getModelComponentList(self):
        r"""getModelComponentList(Model self) -> ModelComponentList"""
        return _simulation.Model_getModelComponentList(self)

    def getThelen2003MuscleList(self):
        r"""getThelen2003MuscleList(Model self) -> Thelen2003MuscleList"""
        return _simulation.Model_getThelen2003MuscleList(self)

    def getMillard2012EquilibriumMuscleList(self):
        r"""getMillard2012EquilibriumMuscleList(Model self) -> Millard2012EquilibriumMuscleList"""
        return _simulation.Model_getMillard2012EquilibriumMuscleList(self)

    def __init__(self, *args):
        r"""
        __init__(Model self) -> Model
        __init__(Model self, std::string const & filename) -> Model

        Parameters
        ----------
        filename: std::string const &

        __init__(Model self, Model other) -> Model

        Parameters
        ----------
        other: OpenSim::Model const &

        """
        _simulation.Model_swiginit(self, _simulation.new_Model(*args))

# Register Model in _simulation:
_simulation.Model_swigregister(Model)
class AbstractPathPoint(Point):
    r"""An abstract class implementing a path point interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AbstractPathPoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AbstractPathPoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AbstractPathPoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AbstractPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AbstractPathPoint_getClassName()

    def clone(self):
        r"""clone(AbstractPathPoint self) -> AbstractPathPoint"""
        return _simulation.AbstractPathPoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AbstractPathPoint self) -> std::string const &"""
        return _simulation.AbstractPathPoint_getConcreteClassName(self)
    PropertyIndex_socket_parent_frame = property(_simulation.AbstractPathPoint_PropertyIndex_socket_parent_frame_get, _simulation.AbstractPathPoint_PropertyIndex_socket_parent_frame_set, doc=r"""PropertyIndex_socket_parent_frame : OpenSim::PropertyIndex""")

    def connectSocket_parent_frame(self, object):
        r"""
        connectSocket_parent_frame(AbstractPathPoint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.AbstractPathPoint_connectSocket_parent_frame(self, object)
    __swig_destroy__ = _simulation.delete_AbstractPathPoint

    def getLocation(self, s):
        r"""
        get the relative location of the path point with respect to the body
           it is connected to.
        """
        return _simulation.AbstractPathPoint_getLocation(self, s)

    def getParentFrame(self):
        r""" get the parent PhysicalFrame in which the PathPoint is defined"""
        return _simulation.AbstractPathPoint_getParentFrame(self)

    def setParentFrame(self, aFrame):
        r""" set the parent PhysicalFrame in which the PathPoint is defined"""
        return _simulation.AbstractPathPoint_setParentFrame(self, aFrame)

    def getBody(self):
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use getParentFrame() instead to get the PhysicalFrame in which
               this PathPoint is defined.
        """
        return _simulation.AbstractPathPoint_getBody(self)

    def setBody(self, body):
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use setParentFrame() instead.
        """
        return _simulation.AbstractPathPoint_setBody(self, body)

    def getBodyName(self):
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use getParentFrame().getName() instead.
        """
        return _simulation.AbstractPathPoint_getBodyName(self)

    def getWrapObject(self):
        r"""getWrapObject(AbstractPathPoint self) -> WrapObject"""
        return _simulation.AbstractPathPoint_getWrapObject(self)

    def isActive(self, s):
        r"""
        isActive(AbstractPathPoint self, State s) -> bool

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.AbstractPathPoint_isActive(self, s)

    def getdPointdQ(self, s):
        r"""
        get the partial derivative of the point location in the parent frame
               w.r.t. to the coordinates(Q) and expressed in the parent frame.
        """
        return _simulation.AbstractPathPoint_getdPointdQ(self, s)

    @staticmethod
    def deletePathPoint(aPoint):
        r"""
        deletePathPoint(AbstractPathPoint aPoint)

        Parameters
        ----------
        aPoint: OpenSim::AbstractPathPoint *

        """
        return _simulation.AbstractPathPoint_deletePathPoint(aPoint)

    def updateFromXMLNode(self, aNode, versionNumber):
        r"""
        Update the use of *body* property in previous revisions to the
               parent_frame (Socket) for the path point's dependency on a
               PhysicalFrame.
               Notes: If overriding updateFromXMLNode of derived classes, do not
               forget to invoke Super::updateFromXMLNode to include this update.
        """
        return _simulation.AbstractPathPoint_updateFromXMLNode(self, aNode, versionNumber)

# Register AbstractPathPoint in _simulation:
_simulation.AbstractPathPoint_swigregister(AbstractPathPoint)
class PathPoint(AbstractPathPoint):
    r"""A path point that is stationary with respect to parent's PhysicalFrame"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathPoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathPoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathPoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathPoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathPoint_getClassName()

    def clone(self):
        r"""clone(PathPoint self) -> PathPoint"""
        return _simulation.PathPoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathPoint self) -> std::string const &"""
        return _simulation.PathPoint_getConcreteClassName(self)

    def copyProperty_location(self, source):
        r"""
        copyProperty_location(PathPoint self, PathPoint source)

        Parameters
        ----------
        source: OpenSim::PathPoint::Self const &

        """
        return _simulation.PathPoint_copyProperty_location(self, source)

    def append_location(self, value):
        r"""
        append_location(PathPoint self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PathPoint_append_location(self, value)

    def constructProperty_location(self, initValue):
        r"""
        constructProperty_location(PathPoint self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PathPoint_constructProperty_location(self, initValue)

    def get_location(self, *args):
        r"""
        get_location(PathPoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_location(PathPoint self) -> Vec3
        """
        return _simulation.PathPoint_get_location(self, *args)

    def upd_location(self, *args):
        r"""
        upd_location(PathPoint self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_location(PathPoint self) -> Vec3
        """
        return _simulation.PathPoint_upd_location(self, *args)

    def set_location(self, *args):
        r"""
        set_location(PathPoint self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_location(PathPoint self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PathPoint_set_location(self, *args)

    def __init__(self):
        r"""__init__(PathPoint self) -> PathPoint"""
        _simulation.PathPoint_swiginit(self, _simulation.new_PathPoint())

    def setLocationCoord(self, s, aXYZ, aValue):
        r""" **(Deprecated)** Old PathPoint interface"""
        return _simulation.PathPoint_setLocationCoord(self, s, aXYZ, aValue)

    def getLocation(self, s):
        r"""
        getLocation(PathPoint self, State s) -> Vec3

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathPoint_getLocation(self, s)

    def setLocation(self, location):
        r"""
        setLocation(PathPoint self, Vec3 location)

        Parameters
        ----------
        location: SimTK::Vec3 const &

        """
        return _simulation.PathPoint_setLocation(self, location)

    def changeBodyPreserveLocation(self, s, body):
        r"""
        changeBodyPreserveLocation(PathPoint self, State s, PhysicalFrame body)

        Parameters
        ----------
        s: SimTK::State const &
        body: OpenSim::PhysicalFrame const &

        """
        return _simulation.PathPoint_changeBodyPreserveLocation(self, s, body)

    def extendScale(self, s, scaleSet):
        r"""
        extendScale(PathPoint self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.PathPoint_extendScale(self, s, scaleSet)

    def getdPointdQ(self, s):
        r"""
        getdPointdQ(PathPoint self, State s) -> Vec3

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathPoint_getdPointdQ(self, s)
    __swig_destroy__ = _simulation.delete_PathPoint

# Register PathPoint in _simulation:
_simulation.PathPoint_swigregister(PathPoint)
class PathWrapPoint(AbstractPathPoint):
    r"""
    A class implementing a path wrapping point, which is a path point that
    is produced by a PathWrap.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathWrapPoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathWrapPoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathWrapPoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathWrapPoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathWrapPoint_getClassName()

    def clone(self):
        r"""clone(PathWrapPoint self) -> PathWrapPoint"""
        return _simulation.PathWrapPoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathWrapPoint self) -> std::string const &"""
        return _simulation.PathWrapPoint_getConcreteClassName(self)

    def extendAddToSystem(self, arg2):
        r"""
        extendAddToSystem(PathWrapPoint self, SimTK::MultibodySystem & arg2)

        Parameters
        ----------
        arg2: SimTK::MultibodySystem &

        """
        return _simulation.PathWrapPoint_extendAddToSystem(self, arg2)

    def getWrapObject(self):
        r"""getWrapObject(PathWrapPoint self) -> WrapObject"""
        return _simulation.PathWrapPoint_getWrapObject(self)

    def setWrapObject(self, arg2):
        r"""
        setWrapObject(PathWrapPoint self, WrapObject arg2)

        Parameters
        ----------
        arg2: OpenSim::WrapObject const *

        """
        return _simulation.PathWrapPoint_setWrapObject(self, arg2)

    def getWrapPath(self, arg2):
        r"""
        getWrapPath(PathWrapPoint self, State arg2) -> ArrayVec3

        Parameters
        ----------
        arg2: SimTK::State const &

        """
        return _simulation.PathWrapPoint_getWrapPath(self, arg2)

    def setWrapPath(self, arg2, arg3):
        r"""
        setWrapPath(PathWrapPoint self, State arg2, ArrayVec3 arg3)

        Parameters
        ----------
        arg2: SimTK::State const &
        arg3: OpenSim::Array< SimTK::Vec3 > const &

        """
        return _simulation.PathWrapPoint_setWrapPath(self, arg2, arg3)

    def clearWrapPath(self, arg2):
        r"""
        clearWrapPath(PathWrapPoint self, State arg2)

        Parameters
        ----------
        arg2: SimTK::State const &

        """
        return _simulation.PathWrapPoint_clearWrapPath(self, arg2)

    def getWrapLength(self, arg2):
        r"""
        getWrapLength(PathWrapPoint self, State arg2) -> double

        Parameters
        ----------
        arg2: SimTK::State const &

        """
        return _simulation.PathWrapPoint_getWrapLength(self, arg2)

    def setWrapLength(self, arg2, newLength):
        r"""
        setWrapLength(PathWrapPoint self, State arg2, double newLength)

        Parameters
        ----------
        arg2: SimTK::State const &
        newLength: double

        """
        return _simulation.PathWrapPoint_setWrapLength(self, arg2, newLength)

    def getLocation(self, arg2):
        r"""
        getLocation(PathWrapPoint self, State arg2) -> Vec3

        Parameters
        ----------
        arg2: SimTK::State const &

        """
        return _simulation.PathWrapPoint_getLocation(self, arg2)

    def setLocation(self, arg2, arg3):
        r"""
        setLocation(PathWrapPoint self, State arg2, Vec3 arg3)

        Parameters
        ----------
        arg2: SimTK::State const &
        arg3: SimTK::Vec3 const &

        """
        return _simulation.PathWrapPoint_setLocation(self, arg2, arg3)

    def getdPointdQ(self, arg2):
        r"""
        getdPointdQ(PathWrapPoint self, State arg2) -> Vec3

        Parameters
        ----------
        arg2: SimTK::State const &

        """
        return _simulation.PathWrapPoint_getdPointdQ(self, arg2)

    def __init__(self):
        r"""__init__(PathWrapPoint self) -> PathWrapPoint"""
        _simulation.PathWrapPoint_swiginit(self, _simulation.new_PathWrapPoint())
    __swig_destroy__ = _simulation.delete_PathWrapPoint

# Register PathWrapPoint in _simulation:
_simulation.PathWrapPoint_swigregister(PathWrapPoint)
class ConditionalPathPoint(PathPoint):
    r"""
    A class implementing a conditional path point, which is a point that
    is active only for a specified range of a coordinate.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ConditionalPathPoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ConditionalPathPoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ConditionalPathPoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ConditionalPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ConditionalPathPoint_getClassName()

    def clone(self):
        r"""clone(ConditionalPathPoint self) -> ConditionalPathPoint"""
        return _simulation.ConditionalPathPoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ConditionalPathPoint self) -> std::string const &"""
        return _simulation.ConditionalPathPoint_getConcreteClassName(self)

    def copyProperty_range(self, source):
        r"""
        copyProperty_range(ConditionalPathPoint self, ConditionalPathPoint source)

        Parameters
        ----------
        source: OpenSim::ConditionalPathPoint::Self const &

        """
        return _simulation.ConditionalPathPoint_copyProperty_range(self, source)

    def get_range(self, i):
        r"""
        get_range(ConditionalPathPoint self, int i) -> double const &

        Parameters
        ----------
        i: int

        """
        return _simulation.ConditionalPathPoint_get_range(self, i)

    def upd_range(self, i):
        r"""
        upd_range(ConditionalPathPoint self, int i) -> double &

        Parameters
        ----------
        i: int

        """
        return _simulation.ConditionalPathPoint_upd_range(self, i)

    def set_range(self, i, value):
        r"""
        set_range(ConditionalPathPoint self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        """
        return _simulation.ConditionalPathPoint_set_range(self, i, value)

    def append_range(self, value):
        r"""
        append_range(ConditionalPathPoint self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ConditionalPathPoint_append_range(self, value)
    PropertyIndex_socket_coordinate = property(_simulation.ConditionalPathPoint_PropertyIndex_socket_coordinate_get, _simulation.ConditionalPathPoint_PropertyIndex_socket_coordinate_set, doc=r"""PropertyIndex_socket_coordinate : OpenSim::PropertyIndex""")

    def connectSocket_coordinate(self, object):
        r"""
        connectSocket_coordinate(ConditionalPathPoint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.ConditionalPathPoint_connectSocket_coordinate(self, object)

    def __init__(self):
        r"""__init__(ConditionalPathPoint self) -> ConditionalPathPoint"""
        _simulation.ConditionalPathPoint_swiginit(self, _simulation.new_ConditionalPathPoint())
    __swig_destroy__ = _simulation.delete_ConditionalPathPoint

    def setRangeMin(self, minVal):
        r"""
        setRangeMin(ConditionalPathPoint self, double minVal)

        Parameters
        ----------
        minVal: double

        """
        return _simulation.ConditionalPathPoint_setRangeMin(self, minVal)

    def setRangeMax(self, maxVal):
        r"""
        setRangeMax(ConditionalPathPoint self, double maxVal)

        Parameters
        ----------
        maxVal: double

        """
        return _simulation.ConditionalPathPoint_setRangeMax(self, maxVal)

    def setCoordinate(self, coordinate):
        r"""
        setCoordinate(ConditionalPathPoint self, Coordinate coordinate)

        Parameters
        ----------
        coordinate: OpenSim::Coordinate const &

        """
        return _simulation.ConditionalPathPoint_setCoordinate(self, coordinate)

    def hasCoordinate(self):
        r"""hasCoordinate(ConditionalPathPoint self) -> bool"""
        return _simulation.ConditionalPathPoint_hasCoordinate(self)

    def getCoordinate(self):
        r"""getCoordinate(ConditionalPathPoint self) -> Coordinate"""
        return _simulation.ConditionalPathPoint_getCoordinate(self)

    def isActive(self, s):
        r"""
        isActive(ConditionalPathPoint self, State s) -> bool

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ConditionalPathPoint_isActive(self, s)

# Register ConditionalPathPoint in _simulation:
_simulation.ConditionalPathPoint_swigregister(ConditionalPathPoint)
class MovingPathPoint(AbstractPathPoint):
    r"""
    A class implementing a moving muscle point, which is a muscle point that
    moves in a body's reference frame as a function of a coordinate.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MovingPathPoint

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MovingPathPoint_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MovingPathPoint self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MovingPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MovingPathPoint_getClassName()

    def clone(self):
        r"""clone(MovingPathPoint self) -> MovingPathPoint"""
        return _simulation.MovingPathPoint_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MovingPathPoint self) -> std::string const &"""
        return _simulation.MovingPathPoint_getConcreteClassName(self)

    def copyProperty_x_location(self, source):
        r"""
        copyProperty_x_location(MovingPathPoint self, MovingPathPoint source)

        Parameters
        ----------
        source: OpenSim::MovingPathPoint::Self const &

        """
        return _simulation.MovingPathPoint_copyProperty_x_location(self, source)

    def append_x_location(self, value):
        r"""
        append_x_location(MovingPathPoint self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_append_x_location(self, value)

    def constructProperty_x_location(self, *args):
        r"""
        constructProperty_x_location(MovingPathPoint self)
        constructProperty_x_location(MovingPathPoint self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_constructProperty_x_location(self, *args)

    def get_x_location(self, *args):
        r"""
        get_x_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        get_x_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_get_x_location(self, *args)

    def upd_x_location(self, *args):
        r"""
        upd_x_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_x_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_upd_x_location(self, *args)

    def set_x_location(self, *args):
        r"""
        set_x_location(MovingPathPoint self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_x_location(MovingPathPoint self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_set_x_location(self, *args)

    def copyProperty_y_location(self, source):
        r"""
        copyProperty_y_location(MovingPathPoint self, MovingPathPoint source)

        Parameters
        ----------
        source: OpenSim::MovingPathPoint::Self const &

        """
        return _simulation.MovingPathPoint_copyProperty_y_location(self, source)

    def append_y_location(self, value):
        r"""
        append_y_location(MovingPathPoint self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_append_y_location(self, value)

    def constructProperty_y_location(self, *args):
        r"""
        constructProperty_y_location(MovingPathPoint self)
        constructProperty_y_location(MovingPathPoint self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_constructProperty_y_location(self, *args)

    def get_y_location(self, *args):
        r"""
        get_y_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        get_y_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_get_y_location(self, *args)

    def upd_y_location(self, *args):
        r"""
        upd_y_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_y_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_upd_y_location(self, *args)

    def set_y_location(self, *args):
        r"""
        set_y_location(MovingPathPoint self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_y_location(MovingPathPoint self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_set_y_location(self, *args)

    def copyProperty_z_location(self, source):
        r"""
        copyProperty_z_location(MovingPathPoint self, MovingPathPoint source)

        Parameters
        ----------
        source: OpenSim::MovingPathPoint::Self const &

        """
        return _simulation.MovingPathPoint_copyProperty_z_location(self, source)

    def append_z_location(self, value):
        r"""
        append_z_location(MovingPathPoint self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_append_z_location(self, value)

    def constructProperty_z_location(self, *args):
        r"""
        constructProperty_z_location(MovingPathPoint self)
        constructProperty_z_location(MovingPathPoint self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_constructProperty_z_location(self, *args)

    def get_z_location(self, *args):
        r"""
        get_z_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        get_z_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_get_z_location(self, *args)

    def upd_z_location(self, *args):
        r"""
        upd_z_location(MovingPathPoint self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_z_location(MovingPathPoint self) -> Function
        """
        return _simulation.MovingPathPoint_upd_z_location(self, *args)

    def set_z_location(self, *args):
        r"""
        set_z_location(MovingPathPoint self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_z_location(MovingPathPoint self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.MovingPathPoint_set_z_location(self, *args)
    PropertyIndex_socket_x_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_x_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_x_coordinate_set, doc=r"""PropertyIndex_socket_x_coordinate : OpenSim::PropertyIndex""")

    def connectSocket_x_coordinate(self, object):
        r"""
        connectSocket_x_coordinate(MovingPathPoint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.MovingPathPoint_connectSocket_x_coordinate(self, object)
    PropertyIndex_socket_y_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_y_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_y_coordinate_set, doc=r"""PropertyIndex_socket_y_coordinate : OpenSim::PropertyIndex""")

    def connectSocket_y_coordinate(self, object):
        r"""
        connectSocket_y_coordinate(MovingPathPoint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.MovingPathPoint_connectSocket_y_coordinate(self, object)
    PropertyIndex_socket_z_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_z_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_z_coordinate_set, doc=r"""PropertyIndex_socket_z_coordinate : OpenSim::PropertyIndex""")

    def connectSocket_z_coordinate(self, object):
        r"""
        connectSocket_z_coordinate(MovingPathPoint self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.MovingPathPoint_connectSocket_z_coordinate(self, object)

    def __init__(self):
        r"""__init__(MovingPathPoint self) -> MovingPathPoint"""
        _simulation.MovingPathPoint_swiginit(self, _simulation.new_MovingPathPoint())
    __swig_destroy__ = _simulation.delete_MovingPathPoint

    def updateFromXMLNode(self, aNode, versionNumber):
        r"""
        updateFromXMLNode(MovingPathPoint self, SimTK::Xml::Element & aNode, int versionNumber)

        Parameters
        ----------
        aNode: SimTK::Xml::Element &
        versionNumber: int

        """
        return _simulation.MovingPathPoint_updateFromXMLNode(self, aNode, versionNumber)

    def hasXCoordinate(self):
        r"""hasXCoordinate(MovingPathPoint self) -> bool"""
        return _simulation.MovingPathPoint_hasXCoordinate(self)

    def hasYCoordinate(self):
        r"""hasYCoordinate(MovingPathPoint self) -> bool"""
        return _simulation.MovingPathPoint_hasYCoordinate(self)

    def hasZCoordinate(self):
        r"""hasZCoordinate(MovingPathPoint self) -> bool"""
        return _simulation.MovingPathPoint_hasZCoordinate(self)

    def getXCoordinate(self):
        r"""getXCoordinate(MovingPathPoint self) -> Coordinate"""
        return _simulation.MovingPathPoint_getXCoordinate(self)

    def getYCoordinate(self):
        r"""getYCoordinate(MovingPathPoint self) -> Coordinate"""
        return _simulation.MovingPathPoint_getYCoordinate(self)

    def getZCoordinate(self):
        r"""getZCoordinate(MovingPathPoint self) -> Coordinate"""
        return _simulation.MovingPathPoint_getZCoordinate(self)

    def setXCoordinate(self, coordinate):
        r"""
        setXCoordinate(MovingPathPoint self, Coordinate coordinate)

        Parameters
        ----------
        coordinate: OpenSim::Coordinate const &

        """
        return _simulation.MovingPathPoint_setXCoordinate(self, coordinate)

    def setYCoordinate(self, coordinate):
        r"""
        setYCoordinate(MovingPathPoint self, Coordinate coordinate)

        Parameters
        ----------
        coordinate: OpenSim::Coordinate const &

        """
        return _simulation.MovingPathPoint_setYCoordinate(self, coordinate)

    def setZCoordinate(self, coordinate):
        r"""
        setZCoordinate(MovingPathPoint self, Coordinate coordinate)

        Parameters
        ----------
        coordinate: OpenSim::Coordinate const &

        """
        return _simulation.MovingPathPoint_setZCoordinate(self, coordinate)

    def isActive(self, s):
        r"""
        isActive(MovingPathPoint self, State s) -> bool

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MovingPathPoint_isActive(self, s)

    def getLocation(self, s):
        r""" Get the local location of the MovingPathPoint in its Frame"""
        return _simulation.MovingPathPoint_getLocation(self, s)

    def getVelocity(self, s):
        r"""
        Get the local velocity of the MovingPathPoint w.r.t to and
               expressed in its Frame. To get the velocity of the point w.r.t.
               and expressed in Ground, call getVelocityInGround().
        """
        return _simulation.MovingPathPoint_getVelocity(self, s)

    def getdPointdQ(self, s):
        r"""
        getdPointdQ(MovingPathPoint self, State s) -> Vec3

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MovingPathPoint_getdPointdQ(self, s)

    def extendScale(self, s, scaleSet):
        r"""
        Scale the underlying MultiplierFunctions associated with the
               MovingPathPoint.
        """
        return _simulation.MovingPathPoint_extendScale(self, s, scaleSet)

# Register MovingPathPoint in _simulation:
_simulation.MovingPathPoint_swigregister(MovingPathPoint)
class SetOfPathPoints(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetOfPathPoints

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetOfPathPoints_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetOfPathPoints self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetOfPathPoints_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetOfPathPoints_getClassName()

    def clone(self):
        r"""clone(SetOfPathPoints self) -> SetOfPathPoints"""
        return _simulation.SetOfPathPoints_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetOfPathPoints self) -> std::string const &"""
        return _simulation.SetOfPathPoints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetOfPathPoints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::AbstractPathPoint,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetOfPathPoints_swiginit(self, _simulation.new_SetOfPathPoints(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetOfPathPoints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetOfPathPoints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetOfPathPoints_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetOfPathPoints_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetOfPathPoints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetOfPathPoints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetOfPathPoints self)"""
        return _simulation.SetOfPathPoints_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`AbstractPathPoint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`AbstractPathPoint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetOfPathPoints_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetOfPathPoints_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetOfPathPoints_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetOfPathPoints_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetOfPathPoints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetOfPathPoints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetOfPathPoints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetOfPathPoints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetOfPathPoints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetOfPathPoints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetOfPathPoints in _simulation:
_simulation.SetOfPathPoints_swigregister(SetOfPathPoints)
class ArrayPathPoint(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ArrayPathPoint

    def __init__(self, *args):
        r"""
        __init__(ArrayPathPoint self, ArrayPathPoint arg2) -> ArrayPathPoint

        Parameters
        ----------
        arg2: OpenSim::Array< OpenSim::AbstractPathPoint * > const &

        __init__(ArrayPathPoint self, ArrayPathPoint arg2) -> ArrayPathPoint

        Parameters
        ----------
        arg2: OpenSim::Array< OpenSim::AbstractPathPoint * > &&

        __init__(ArrayPathPoint self, std::initializer_list< OpenSim::AbstractPathPoint * > initList) -> ArrayPathPoint

        Parameters
        ----------
        initList: std::initializer_list< OpenSim::AbstractPathPoint * >

        __init__(ArrayPathPoint self, AbstractPathPoint aDefaultValue=OpenSim::AbstractPathPoint *(), int aSize=0, int aCapacity=1) -> ArrayPathPoint

        Parameters
        ----------
        aDefaultValue: OpenSim::AbstractPathPoint *
        aSize: int
        aCapacity: int

        """
        _simulation.ArrayPathPoint_swiginit(self, _simulation.new_ArrayPathPoint(*args))

    def arrayEquals(self, aArray):
        r"""
        arrayEquals(ArrayPathPoint self, ArrayPathPoint aArray) -> bool

        Parameters
        ----------
        aArray: OpenSim::Array< OpenSim::AbstractPathPoint * > const &

        """
        return _simulation.ArrayPathPoint_arrayEquals(self, aArray)

    def trim(self):
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _simulation.ArrayPathPoint_trim(self)

    def setSize(self, aSize):
        r"""
        Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _simulation.ArrayPathPoint_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.ArrayPathPoint_getSize(self)

    def size(self):
        r""" Alternate name for getSize(). *"""
        return _simulation.ArrayPathPoint_size(self)

    def append(self, *args):
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::AbstractPathPoint * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _simulation.ArrayPathPoint_append(self, *args)

    def insert(self, aIndex, aValue):
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _simulation.ArrayPathPoint_insert(self, aIndex, aValue)

    def remove(self, aIndex):
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _simulation.ArrayPathPoint_remove(self, aIndex)

    def set(self, aIndex, aValue):
        r"""
        Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value.
        """
        return _simulation.ArrayPathPoint_set(self, aIndex, aValue)

    def get(self, aIndex):
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`AbstractPathPoint`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _simulation.ArrayPathPoint_get(self, aIndex)

    def getitem(self, index):
        r"""
        getitem(ArrayPathPoint self, int index) -> AbstractPathPoint

        Parameters
        ----------
        index: int

        """
        return _simulation.ArrayPathPoint_getitem(self, index)

    def setitem(self, index, val):
        r"""
        setitem(ArrayPathPoint self, int index, AbstractPathPoint val)

        Parameters
        ----------
        index: int
        val: OpenSim::AbstractPathPoint *

        """
        return _simulation.ArrayPathPoint_setitem(self, index, val)

    def getLast(self):
        r"""
        Get the last value in the array.

        :rtype: :py:class:`AbstractPathPoint`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.ArrayPathPoint_getLast(self)

    def findIndex(self, aValue):
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPathPoint_findIndex(self, aValue)

    def rfindIndex(self, aValue):
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPathPoint_rfindIndex(self, aValue)

    def searchBinary(self, aValue, aFindFirst=False, aLo=-1, aHi=-1):
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: DEPRECATED: this is now ALWAYS `true` - regardless of
            what you are calling it with. This makes the behavior predictable on all
            platforms.

        OLD BEHAVIOR: If true, find the first element that satisfies the search.
        OLD BEHAVIOR: If false, the index of any element that satisfies the
        search can be returned. Which index will be returned depends on the
        length of the array and is therefore somewhat arbitrary.
        OLD BEHAVIOR: By default, this flag is false (now: it is always true)
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue. If an error is encountered (e.g., the array
            is empty), or if the array contains no element that is less than or
            equal to aValue, -1 is returned.
        """
        return _simulation.ArrayPathPoint_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayPathPoint in _simulation:
_simulation.ArrayPathPoint_swigregister(ArrayPathPoint)
class PathPointSet(SetOfPathPoints):
    r"""
    A class for holding a set of path points.
    Notes: the Set contains any path point that derives from AbstractPathPoint

    Authors: Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathPointSet

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathPointSet_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathPointSet self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathPointSet_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathPointSet_getClassName()

    def clone(self):
        r"""clone(PathPointSet self) -> PathPointSet"""
        return _simulation.PathPointSet_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathPointSet self) -> std::string const &"""
        return _simulation.PathPointSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(PathPointSet self) -> PathPointSet
        __init__(PathPointSet self, std::string const & file, bool updateFromXML=True) -> PathPointSet

        Parameters
        ----------
        file: std::string const &
        updateFromXML: bool

        """
        _simulation.PathPointSet_swiginit(self, _simulation.new_PathPointSet(*args))

    def adoptAndAppend(self, aPathPoint):
        aPathPoint._markAdopted()
        return super(PathPointSet, self).adoptAndAppend(aPathPoint)

    __swig_destroy__ = _simulation.delete_PathPointSet

# Register PathPointSet in _simulation:
_simulation.PathPointSet_swigregister(PathPointSet)
class PointForceDirection(object):
    r"""
    Convenience class for a generic representation of geometry of a complex
    Force (or any other object) with multiple points of contact through
    which forces are applied to bodies. This represents one such point and an
    array of these objects defines a complete Force distribution (i.e., path).

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PointForceDirection self, Vec3 point, PhysicalFrame frame, Vec3 direction) -> PointForceDirection

        Parameters
        ----------
        point: SimTK::Vec3
        frame: OpenSim::PhysicalFrame const &
        direction: SimTK::Vec3

        __init__(PointForceDirection self, Vec3 point, PhysicalFrame frame, Vec3 direction, double scale) -> PointForceDirection

        Parameters
        ----------
        point: SimTK::Vec3
        frame: OpenSim::PhysicalFrame const &
        direction: SimTK::Vec3
        scale: double

        """
        _simulation.PointForceDirection_swiginit(self, _simulation.new_PointForceDirection(*args))

    def point(self):
        r""" Returns the point of "contact", defined in `frame()`"""
        return _simulation.PointForceDirection_point(self)

    def frame(self):
        r""" Returns the frame in which `point()` is defined"""
        return _simulation.PointForceDirection_frame(self)

    def direction(self):
        r""" Returns the (potentially, non-unit-length) direction, defined in ground, of the force at `point()`"""
        return _simulation.PointForceDirection_direction(self)

    def scale(self):
        r""" Returns the scale factor of the force"""
        return _simulation.PointForceDirection_scale(self)

    def addToDirection(self, newDirection):
        r""" Replaces the current direction with `direction + newDirection`"""
        return _simulation.PointForceDirection_addToDirection(self, newDirection)
    __swig_destroy__ = _simulation.delete_PointForceDirection

# Register PointForceDirection in _simulation:
_simulation.PointForceDirection_swigregister(PointForceDirection)
class ArrayPointForceDirection(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ArrayPointForceDirection

    def __init__(self, *args):
        r"""
        __init__(ArrayPointForceDirection self, ArrayPointForceDirection arg2) -> ArrayPointForceDirection

        Parameters
        ----------
        arg2: OpenSim::Array< OpenSim::PointForceDirection * > const &

        __init__(ArrayPointForceDirection self, ArrayPointForceDirection arg2) -> ArrayPointForceDirection

        Parameters
        ----------
        arg2: OpenSim::Array< OpenSim::PointForceDirection * > &&

        __init__(ArrayPointForceDirection self, std::initializer_list< OpenSim::PointForceDirection * > initList) -> ArrayPointForceDirection

        Parameters
        ----------
        initList: std::initializer_list< OpenSim::PointForceDirection * >

        __init__(ArrayPointForceDirection self, PointForceDirection aDefaultValue=OpenSim::PointForceDirection *(), int aSize=0, int aCapacity=1) -> ArrayPointForceDirection

        Parameters
        ----------
        aDefaultValue: OpenSim::PointForceDirection *
        aSize: int
        aCapacity: int

        """
        _simulation.ArrayPointForceDirection_swiginit(self, _simulation.new_ArrayPointForceDirection(*args))

    def arrayEquals(self, aArray):
        r"""
        arrayEquals(ArrayPointForceDirection self, ArrayPointForceDirection aArray) -> bool

        Parameters
        ----------
        aArray: OpenSim::Array< OpenSim::PointForceDirection * > const &

        """
        return _simulation.ArrayPointForceDirection_arrayEquals(self, aArray)

    def trim(self):
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _simulation.ArrayPointForceDirection_trim(self)

    def setSize(self, aSize):
        r"""
        Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _simulation.ArrayPointForceDirection_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.ArrayPointForceDirection_getSize(self)

    def size(self):
        r""" Alternate name for getSize(). *"""
        return _simulation.ArrayPointForceDirection_size(self)

    def append(self, *args):
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::PointForceDirection * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _simulation.ArrayPointForceDirection_append(self, *args)

    def insert(self, aIndex, aValue):
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _simulation.ArrayPointForceDirection_insert(self, aIndex, aValue)

    def remove(self, aIndex):
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _simulation.ArrayPointForceDirection_remove(self, aIndex)

    def set(self, aIndex, aValue):
        r"""
        Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value.
        """
        return _simulation.ArrayPointForceDirection_set(self, aIndex, aValue)

    def get(self, aIndex):
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`PointForceDirection`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _simulation.ArrayPointForceDirection_get(self, aIndex)

    def getitem(self, index):
        r"""
        getitem(ArrayPointForceDirection self, int index) -> PointForceDirection

        Parameters
        ----------
        index: int

        """
        return _simulation.ArrayPointForceDirection_getitem(self, index)

    def setitem(self, index, val):
        r"""
        setitem(ArrayPointForceDirection self, int index, PointForceDirection val)

        Parameters
        ----------
        index: int
        val: OpenSim::PointForceDirection *

        """
        return _simulation.ArrayPointForceDirection_setitem(self, index, val)

    def getLast(self):
        r"""
        Get the last value in the array.

        :rtype: :py:class:`PointForceDirection`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.ArrayPointForceDirection_getLast(self)

    def findIndex(self, aValue):
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_findIndex(self, aValue)

    def rfindIndex(self, aValue):
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_rfindIndex(self, aValue)

    def searchBinary(self, aValue, aFindFirst=False, aLo=-1, aHi=-1):
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: DEPRECATED: this is now ALWAYS `true` - regardless of
            what you are calling it with. This makes the behavior predictable on all
            platforms.

        OLD BEHAVIOR: If true, find the first element that satisfies the search.
        OLD BEHAVIOR: If false, the index of any element that satisfies the
        search can be returned. Which index will be returned depends on the
        length of the array and is therefore somewhat arbitrary.
        OLD BEHAVIOR: By default, this flag is false (now: it is always true)
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue. If an error is encountered (e.g., the array
            is empty), or if the array contains no element that is less than or
            equal to aValue, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayPointForceDirection in _simulation:
_simulation.ArrayPointForceDirection_swigregister(ArrayPointForceDirection)
class AbstractGeometryPath(ModelComponent):
    r"""
    A base class that represents a path that has a computable length and
    lengthening speed.

    This class is typically used in places where the model needs to simulate
    the changes in a path over time. For example, in `OpenSim::Muscle`s,
    `OpenSim::Ligament`s, etc.

    This class *only* defines a length and lengthening speed. We do not assume
    that an `OpenSim::AbstractGeometryPath` is a straight line between two points
    or assume that it is many straight lines between `n` points. The derived
    implementation may define a path using points, or it may define a path using
    a curve fit. It may also define a path based on analytical functions for the
    length and lengthening speed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AbstractGeometryPath

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AbstractGeometryPath_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AbstractGeometryPath self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AbstractGeometryPath_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AbstractGeometryPath_getClassName()

    def clone(self):
        r"""clone(AbstractGeometryPath self) -> AbstractGeometryPath"""
        return _simulation.AbstractGeometryPath_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AbstractGeometryPath self) -> std::string const &"""
        return _simulation.AbstractGeometryPath_getConcreteClassName(self)
    _has_output_length = property(_simulation.AbstractGeometryPath__has_output_length_get, _simulation.AbstractGeometryPath__has_output_length_set, doc=r"""_has_output_length : bool""")
    _has_output_lengthening_speed = property(_simulation.AbstractGeometryPath__has_output_lengthening_speed_get, _simulation.AbstractGeometryPath__has_output_lengthening_speed_set, doc=r"""_has_output_lengthening_speed : bool""")

    def copyProperty_Appearance(self, source):
        r"""
        copyProperty_Appearance(AbstractGeometryPath self, AbstractGeometryPath source)

        Parameters
        ----------
        source: OpenSim::AbstractGeometryPath::Self const &

        """
        return _simulation.AbstractGeometryPath_copyProperty_Appearance(self, source)

    def append_Appearance(self, value):
        r"""
        append_Appearance(AbstractGeometryPath self, Appearance value) -> int

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.AbstractGeometryPath_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue):
        r"""
        constructProperty_Appearance(AbstractGeometryPath self, Appearance initValue)

        Parameters
        ----------
        initValue: OpenSim::Appearance const &

        """
        return _simulation.AbstractGeometryPath_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args):
        r"""
        get_Appearance(AbstractGeometryPath self, int i) -> Appearance

        Parameters
        ----------
        i: int

        get_Appearance(AbstractGeometryPath self) -> Appearance
        """
        return _simulation.AbstractGeometryPath_get_Appearance(self, *args)

    def upd_Appearance(self, *args):
        r"""
        upd_Appearance(AbstractGeometryPath self, int i) -> Appearance

        Parameters
        ----------
        i: int

        upd_Appearance(AbstractGeometryPath self) -> Appearance
        """
        return _simulation.AbstractGeometryPath_upd_Appearance(self, *args)

    def set_Appearance(self, *args):
        r"""
        set_Appearance(AbstractGeometryPath self, int i, Appearance value)

        Parameters
        ----------
        i: int
        value: OpenSim::Appearance const &

        set_Appearance(AbstractGeometryPath self, Appearance value)

        Parameters
        ----------
        value: OpenSim::Appearance const &

        """
        return _simulation.AbstractGeometryPath_set_Appearance(self, *args)
    __swig_destroy__ = _simulation.delete_AbstractGeometryPath

    def getLength(self, s):
        r"""
        Get the current length of the path.

        Internally, this may use a variety of methods to figure out how long the
        path is, such as using spline-fits, or computing the distance between
        points in space. It is up to concrete implementations (e.g.,
        `GeometryPath`) to provide a relevant implementation.
        """
        return _simulation.AbstractGeometryPath_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        Get the lengthening speed of the path.

        Internally, this may use a variety of methods to figure out the
        lengthening speed. It might use the finite difference between two
        lengths, or an analytic solution, or always return `0.0`. It is up to
        concrete implementations (e.g., `GeometryPath`) to provide a relevant
        implementation.
        """
        return _simulation.AbstractGeometryPath_getLengtheningSpeed(self, s)

    def produceForces(self, state, tension, forceConsumer):
        r"""
        Requests that the concrete implementation produces forces resulting from
        applying a tension along its path, emitting them into the supplied
        `ForceConsumer`.

        :type state: :py:class:`State`
        :param state:         the state used to evaluate forces
        :type tension: float
        :param tension:       scalar of the applied (+ve) tensile force
        :type forceConsumer: OpenSim::ForceConsumer
        :param forceConsumer: a `ForceConsumer` shall receive each produced force
        """
        return _simulation.AbstractGeometryPath_produceForces(self, state, tension, forceConsumer)

    def addInEquivalentForces(self, state, tension, bodyForces, mobilityForces):
        r"""
         Add in the equivalent body and generalized forces to be applied to the
         multibody system resulting from a tension along the AbstractGeometryPath.

        Note: this internally uses `produceForces`

         :type state: :py:class:`State`
         :param state:           state used to evaluate forces
         :type tension: float, in
         :param tension:         scalar of the applied (+ve) tensile force
         :type bodyForces: SimTK::Vector_< SimTK::SpatialVec >, in/out
         :param bodyForces:      Vector of forces (SpatialVec's) on bodies
         :type mobilityForces: :py:class:`Vector`, in/out
         :param mobilityForces:  Vector of generalized forces
        """
        return _simulation.AbstractGeometryPath_addInEquivalentForces(self, state, tension, bodyForces, mobilityForces)

    def computeMomentArm(self, s, aCoord):
        r"""
        Returns the moment arm of the path in the given state with respect to
        the specified coordinate.
        """
        return _simulation.AbstractGeometryPath_computeMomentArm(self, s, aCoord)

    def isVisualPath(self):
        r"""
        Return whether or not a path can be visualized.

        Concrete implementations may be visualizable (e.g., `GeometryPath`) or
        they may not be and therefore must provide a relevant implementation.
        """
        return _simulation.AbstractGeometryPath_isVisualPath(self)

    def getDefaultColor(self):
        r"""
        Get the default color of the path.

        Returns the color that will be used to initialize the color cache
        at the next extendAddToSystem() call. Use `getColor` to retrieve the
        (potentially different) color that will be used to draw the path.
        """
        return _simulation.AbstractGeometryPath_getDefaultColor(self)

    def setDefaultColor(self, color):
        r"""
        Set the default color of the path.

        Sets the internal, default, color value for the path. This is the color
        that's used when the simulation is initialized (specifically, during the
        `extendAddToSystem` call).

        This color is not necessarily the *current* color of the path. Other code
        in the system (e.g. muscle implementations) may change the runtime color
        with `setColor`. Use `getColor`, with a particular simulation state, to
        get the color of the path in that state.
        """
        return _simulation.AbstractGeometryPath_setDefaultColor(self, color)

    def getColor(self, s):
        r"""
        Get the current color of the path.

        This is the runtime, potentially state-dependent, color of the path. It
        is the color used to display the path in that state (e.g., for UI
        rendering).

        This color value is typically initialized with the default color (see:
        `getDefaultColor`), but the color can change between simulation states
        because downstream code (e.g. muscles) might call `setColor` to implement
        state-dependent path coloring.

        If not overridden in concrete implementations, this method returns the
        default color.
        """
        return _simulation.AbstractGeometryPath_getColor(self, s)

    def setColor(self, s, color):
        r"""
        Set the current color of the path.

        Internally, sets the current color value of the path for the provided
        state (e.g. using cache variables).

        The value of this variable is used as the color when the path is drawn,
        which occurs with the state realized to Stage::Dynamics. Therefore, you
        must call this method during realizeDynamics() or earlier in order for it
        to have any effect.

        If not overridden in concrete implementations, this method does nothing.
        """
        return _simulation.AbstractGeometryPath_setColor(self, s, color)

    def getPreScaleLength(self, s):
        r"""
        Get the current length of the path, *before* the last set of scaling
        operations were applied to it.

        Internally, the path stores the original length in a `double` during
        `extendPreScale`. Therefore, be *very* careful with this method, because
        the recorded length is dependent on the length as computed during
        `extendPreScale`, which may have been called with a different state.
        """
        return _simulation.AbstractGeometryPath_getPreScaleLength(self, s)

    def setPreScaleLength(self, s, preScaleLength):
        r"""
        setPreScaleLength(AbstractGeometryPath self, State s, double preScaleLength)

        Parameters
        ----------
        s: SimTK::State const &
        preScaleLength: double

        """
        return _simulation.AbstractGeometryPath_setPreScaleLength(self, s, preScaleLength)

# Register AbstractGeometryPath in _simulation:
_simulation.AbstractGeometryPath_swigregister(AbstractGeometryPath)
class GeometryPath(AbstractGeometryPath):
    r"""
    A concrete class representing a path (muscle, ligament, etc.) based on
    geometry objects in the model (e.g., PathPoints and PathWraps).

    Author: Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> GeometryPath

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.GeometryPath_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(GeometryPath self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.GeometryPath_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.GeometryPath_getClassName()

    def clone(self):
        r"""clone(GeometryPath self) -> GeometryPath"""
        return _simulation.GeometryPath_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(GeometryPath self) -> std::string const &"""
        return _simulation.GeometryPath_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(GeometryPath self) -> GeometryPath"""
        _simulation.GeometryPath_swiginit(self, _simulation.new_GeometryPath())
    __swig_destroy__ = _simulation.delete_GeometryPath

    def getPathPointSet(self):
        r"""getPathPointSet(GeometryPath self) -> PathPointSet"""
        return _simulation.GeometryPath_getPathPointSet(self)

    def updPathPointSet(self):
        r"""updPathPointSet(GeometryPath self) -> PathPointSet"""
        return _simulation.GeometryPath_updPathPointSet(self)

    def getWrapSet(self):
        r"""getWrapSet(GeometryPath self) -> PathWrapSet"""
        return _simulation.GeometryPath_getWrapSet(self)

    def updWrapSet(self):
        r"""updWrapSet(GeometryPath self) -> PathWrapSet"""
        return _simulation.GeometryPath_updWrapSet(self)

    def addPathWrap(self, aWrapObject):
        r"""
        addPathWrap(GeometryPath self, WrapObject aWrapObject)

        Parameters
        ----------
        aWrapObject: OpenSim::WrapObject &

        """
        return _simulation.GeometryPath_addPathWrap(self, aWrapObject)

    def addPathPoint(self, s, index, frame):
        r"""
        addPathPoint(GeometryPath self, State s, int index, PhysicalFrame frame) -> AbstractPathPoint

        Parameters
        ----------
        s: SimTK::State const &
        index: int
        frame: OpenSim::PhysicalFrame const &

        """
        return _simulation.GeometryPath_addPathPoint(self, s, index, frame)

    def appendNewPathPoint(self, proposedName, frame, locationOnFrame):
        r"""
        appendNewPathPoint(GeometryPath self, std::string const & proposedName, PhysicalFrame frame, Vec3 locationOnFrame) -> AbstractPathPoint

        Parameters
        ----------
        proposedName: std::string const &
        frame: OpenSim::PhysicalFrame const &
        locationOnFrame: SimTK::Vec3 const &

        """
        return _simulation.GeometryPath_appendNewPathPoint(self, proposedName, frame, locationOnFrame)

    def canDeletePathPoint(self, index):
        r"""
        canDeletePathPoint(GeometryPath self, int index) -> bool

        Parameters
        ----------
        index: int

        """
        return _simulation.GeometryPath_canDeletePathPoint(self, index)

    def deletePathPoint(self, s, index):
        r"""
        deletePathPoint(GeometryPath self, State s, int index) -> bool

        Parameters
        ----------
        s: SimTK::State const &
        index: int

        """
        return _simulation.GeometryPath_deletePathPoint(self, s, index)

    def moveUpPathWrap(self, s, index):
        r"""
        moveUpPathWrap(GeometryPath self, State s, int index)

        Parameters
        ----------
        s: SimTK::State const &
        index: int

        """
        return _simulation.GeometryPath_moveUpPathWrap(self, s, index)

    def moveDownPathWrap(self, s, index):
        r"""
        moveDownPathWrap(GeometryPath self, State s, int index)

        Parameters
        ----------
        s: SimTK::State const &
        index: int

        """
        return _simulation.GeometryPath_moveDownPathWrap(self, s, index)

    def deletePathWrap(self, s, index):
        r"""
        deletePathWrap(GeometryPath self, State s, int index)

        Parameters
        ----------
        s: SimTK::State const &
        index: int

        """
        return _simulation.GeometryPath_deletePathWrap(self, s, index)

    def replacePathPoint(self, s, oldPathPoint, newPathPoint):
        r"""
        replacePathPoint(GeometryPath self, State s, AbstractPathPoint oldPathPoint, AbstractPathPoint newPathPoint) -> bool

        Parameters
        ----------
        s: SimTK::State const &
        oldPathPoint: OpenSim::AbstractPathPoint *
        newPathPoint: OpenSim::AbstractPathPoint *

        """
        return _simulation.GeometryPath_replacePathPoint(self, s, oldPathPoint, newPathPoint)

    def setColor(self, s, color):
        r"""
        %Set the value of the color cache variable owned by this %GeometryPath
           object, in the cache of the given state. The value of this variable is used
           as the color when the path is drawn, which occurs with the state realized
           to Stage::Dynamics. So you must call this method during realizeDynamics() or
           earlier in order for it to have any effect. *
        """
        return _simulation.GeometryPath_setColor(self, s, color)

    def getColor(self, s):
        r"""
        Get the current value of the color cache entry owned by this
           %GeometryPath object in the given state. You can access this value any time
           after the state is initialized, at which point it will have been set to
           the default color value specified in a call to setDefaultColor() earlier,
           or it will have the default color value chosen by %GeometryPath.
           See also: setDefaultColor() *
        """
        return _simulation.GeometryPath_getColor(self, s)

    def getLength(self, s):
        r"""
        getLength(GeometryPath self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.GeometryPath_getLength(self, s)

    def setLength(self, s, length):
        r"""
        setLength(GeometryPath self, State s, double length)

        Parameters
        ----------
        s: SimTK::State const &
        length: double

        """
        return _simulation.GeometryPath_setLength(self, s, length)

    def getCurrentPath(self, s):
        r"""
        getCurrentPath(GeometryPath self, State s) -> ArrayPathPoint

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.GeometryPath_getCurrentPath(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(GeometryPath self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.GeometryPath_getLengtheningSpeed(self, s)

    def setLengtheningSpeed(self, s, speed):
        r"""
        setLengtheningSpeed(GeometryPath self, State s, double speed)

        Parameters
        ----------
        s: SimTK::State const &
        speed: double

        """
        return _simulation.GeometryPath_setLengtheningSpeed(self, s, speed)

    def getPointForceDirections(self, s, rPFDs):
        r"""
        get the path as PointForceDirections directions, which can be used
               to apply tension to bodies the points are connected to.
        """
        return _simulation.GeometryPath_getPointForceDirections(self, s, rPFDs)

    def produceForces(self, state, tension, forceConsumer):
        r"""
        Requests forces resulting from applying a tension along its path and
        emits them into the supplied `ForceConsumer`.

        :type state: :py:class:`State`
        :param state:         the state used to evaluate forces
        :type tension: float
        :param tension:       scalar of the applied (+ve) tensile force
        :type forceConsumer: OpenSim::ForceConsumer
        :param forceConsumer: a `ForceConsumer` shall receive each produced force
        """
        return _simulation.GeometryPath_produceForces(self, state, tension, forceConsumer)

    def isVisualPath(self):
        r"""isVisualPath(GeometryPath self) -> bool"""
        return _simulation.GeometryPath_isVisualPath(self)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(GeometryPath self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate const &

        """
        return _simulation.GeometryPath_computeMomentArm(self, s, aCoord)

    def extendPreScale(self, s, scaleSet):
        r"""
        Calculate the path length in the current body position and store it for
               use after the Model has been scaled.
        """
        return _simulation.GeometryPath_extendPreScale(self, s, scaleSet)

    def extendPostScale(self, s, scaleSet):
        r""" Recalculate the path after the Model has been scaled."""
        return _simulation.GeometryPath_extendPostScale(self, s, scaleSet)

    def updateGeometry(self, s):
        r"""
        updateGeometry(GeometryPath self, State s)

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.GeometryPath_updateGeometry(self, s)

# Register GeometryPath in _simulation:
_simulation.GeometryPath_swigregister(GeometryPath)
class FunctionBasedPath(AbstractGeometryPath):
    r"""
    A concrete class representing a path for muscles, ligaments, etc., based on
    `Function` objects. This class can be used when efficient computations of
    path length, lengthening speed, and moment arms are a priority (e.g., a
    direct collocation problem).

    Each instance of this class requires both a list of model coordinates that
    the path is dependent on and a function, :math:`l(q)`, that computes the
    length of the path as a function of the coordinate values, :math:`q`.
    Optionally, functions can be provided to compute the moment arms of the path
    as a function of the coordinate values and a function that computes the speed
    of the path as a function of the coordinate values and speeds.

    If the moment arm and/or speed functions are not provided, they will be
    computed from the length function based on van den Bogert et al. (2013) and
    Meyer et al. (2017):

    .. math::

        r_i = -\frac{\partial l}{\partial q_i} \quad \forall q_i \in Q

    .. math::

        \dot{l} = \frac{dl}{dt}
                = \sum_i \frac{\partial l}{\partial q_i} \frac{dq_i}{dt}
                = \sum_i -r_i \dot{q}_i

    Where,
    - :math:`r_i`: the moment arm of the path with respect to coordinate
    _i:math:`.-` l :math:`: the length of the path.-` :math:`: the lengthening speed of the path.-` q_i :math:`: the i-th coordinate value.-` _i :math:`: the i-th coordinate value derivative.-` Q :math:`: the set of all coordinates.@note The moment arm expression above assumes that all constraints in themodel are workless (i.e., no `MovingPathPoint`s). Other path types (e.g.,`GeometryPath`) compute moment arms based on the generalized force applied tojoint given a unit force along the path, which does not rely on thisassumption (see `MomentArmSolver`). Please keep this in mind when providingthe path functions. See Sherman et al. (2013) for more details.@note` _i :math:`is usually, but not necessarily, the same as thegeneralized speed of the coordinate,` u_i :math:`(e.g., see `BallJoint`).Please keep this in mind when providing a speed function. See Sherman et al.(2013) for more details.The length function and (if provided) the moment arm functions must have thesame number of arguments as the number of coordinates, where the order of thearguments matches the order in the `coordinates` property. Each moment armfunction corresponds to a single coordinate, and the order of the functionsin the `moment_arm_functions` property must match the order in `coordinates`.The speed function (if provided) must have twice as many arguments as thenumber of coordinates, where the first half of the arguments are thecoordinate values and the second half are the coordinate speeds. Again, theorder of the value and speed arguments must match the order in the`coordinates` property.@note The forces applied to the model by the path are computed by multiplyingthe tension in the path by the moment arms. Therefore, this class onlyapplies mobility (i.e., generalized) forces to the model.# References- [1] Meyer AJ, Patten C, Fregly BJ (2017) "Lower extremity EMG-driven      modeling of walking with automated adjustment of musculoskeletal      geometry." PLoS ONE 12(7): e0179698.      https://doi.org/10.1371/journal.pone.0179698- [2] van den Bogert, A.J., Geijtenbeek, T., Even-Zohar, O. et al. (2013) "A      real-time system for biomechanical analysis of human movement and      muscle function." Med Biol Eng Comput 51, 1069–1077 (2013).      https://doi.org/10.1007/s11517-013-1076-z- [3] Sherman MA, Seth A, Delp SL. (2013) "What is a Moment Arm? Calculating      Muscle Effectiveness in Biomechanical Models Using Generalized      Coordinates." ASME. International Design Engineering Technical      Conferences and Computers and Information in Engineering Conference,      Volume 7B: 9th International Conference on Multibody Systems,      Nonlinear Dynamics, and Control.`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FunctionBasedPath

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FunctionBasedPath_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FunctionBasedPath self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FunctionBasedPath_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FunctionBasedPath_getClassName()

    def clone(self):
        r"""clone(FunctionBasedPath self) -> FunctionBasedPath"""
        return _simulation.FunctionBasedPath_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FunctionBasedPath self) -> std::string const &"""
        return _simulation.FunctionBasedPath_getConcreteClassName(self)

    def copyProperty_coordinate_paths(self, source):
        r"""
        copyProperty_coordinate_paths(FunctionBasedPath self, FunctionBasedPath source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedPath::Self const &

        """
        return _simulation.FunctionBasedPath_copyProperty_coordinate_paths(self, source)

    def get_coordinate_paths(self, i):
        r"""
        get_coordinate_paths(FunctionBasedPath self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _simulation.FunctionBasedPath_get_coordinate_paths(self, i)

    def upd_coordinate_paths(self, i):
        r"""
        upd_coordinate_paths(FunctionBasedPath self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _simulation.FunctionBasedPath_upd_coordinate_paths(self, i)

    def set_coordinate_paths(self, i, value):
        r"""
        set_coordinate_paths(FunctionBasedPath self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _simulation.FunctionBasedPath_set_coordinate_paths(self, i, value)

    def append_coordinate_paths(self, value):
        r"""
        append_coordinate_paths(FunctionBasedPath self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.FunctionBasedPath_append_coordinate_paths(self, value)

    def constructProperty_coordinate_paths(self):
        r"""constructProperty_coordinate_paths(FunctionBasedPath self)"""
        return _simulation.FunctionBasedPath_constructProperty_coordinate_paths(self)

    def copyProperty_length_function(self, source):
        r"""
        copyProperty_length_function(FunctionBasedPath self, FunctionBasedPath source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedPath::Self const &

        """
        return _simulation.FunctionBasedPath_copyProperty_length_function(self, source)

    def append_length_function(self, value):
        r"""
        append_length_function(FunctionBasedPath self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_append_length_function(self, value)

    def constructProperty_length_function(self, *args):
        r"""
        constructProperty_length_function(FunctionBasedPath self)
        constructProperty_length_function(FunctionBasedPath self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_constructProperty_length_function(self, *args)

    def get_length_function(self, *args):
        r"""
        get_length_function(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        get_length_function(FunctionBasedPath self) -> Function
        """
        return _simulation.FunctionBasedPath_get_length_function(self, *args)

    def upd_length_function(self, *args):
        r"""
        upd_length_function(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_length_function(FunctionBasedPath self) -> Function
        """
        return _simulation.FunctionBasedPath_upd_length_function(self, *args)

    def set_length_function(self, *args):
        r"""
        set_length_function(FunctionBasedPath self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_length_function(FunctionBasedPath self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_set_length_function(self, *args)

    def copyProperty_moment_arm_functions(self, source):
        r"""
        copyProperty_moment_arm_functions(FunctionBasedPath self, FunctionBasedPath source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedPath::Self const &

        """
        return _simulation.FunctionBasedPath_copyProperty_moment_arm_functions(self, source)

    def get_moment_arm_functions(self, i):
        r"""
        get_moment_arm_functions(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        """
        return _simulation.FunctionBasedPath_get_moment_arm_functions(self, i)

    def upd_moment_arm_functions(self, i):
        r"""
        upd_moment_arm_functions(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        """
        return _simulation.FunctionBasedPath_upd_moment_arm_functions(self, i)

    def set_moment_arm_functions(self, i, value):
        r"""
        set_moment_arm_functions(FunctionBasedPath self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_set_moment_arm_functions(self, i, value)

    def append_moment_arm_functions(self, value):
        r"""
        append_moment_arm_functions(FunctionBasedPath self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_append_moment_arm_functions(self, value)

    def constructProperty_moment_arm_functions(self):
        r"""constructProperty_moment_arm_functions(FunctionBasedPath self)"""
        return _simulation.FunctionBasedPath_constructProperty_moment_arm_functions(self)

    def copyProperty_lengthening_speed_function(self, source):
        r"""
        copyProperty_lengthening_speed_function(FunctionBasedPath self, FunctionBasedPath source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedPath::Self const &

        """
        return _simulation.FunctionBasedPath_copyProperty_lengthening_speed_function(self, source)

    def append_lengthening_speed_function(self, value):
        r"""
        append_lengthening_speed_function(FunctionBasedPath self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_append_lengthening_speed_function(self, value)

    def constructProperty_lengthening_speed_function(self, *args):
        r"""
        constructProperty_lengthening_speed_function(FunctionBasedPath self)
        constructProperty_lengthening_speed_function(FunctionBasedPath self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_constructProperty_lengthening_speed_function(self, *args)

    def get_lengthening_speed_function(self, *args):
        r"""
        get_lengthening_speed_function(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        get_lengthening_speed_function(FunctionBasedPath self) -> Function
        """
        return _simulation.FunctionBasedPath_get_lengthening_speed_function(self, *args)

    def upd_lengthening_speed_function(self, *args):
        r"""
        upd_lengthening_speed_function(FunctionBasedPath self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_lengthening_speed_function(FunctionBasedPath self) -> Function
        """
        return _simulation.FunctionBasedPath_upd_lengthening_speed_function(self, *args)

    def set_lengthening_speed_function(self, *args):
        r"""
        set_lengthening_speed_function(FunctionBasedPath self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_lengthening_speed_function(FunctionBasedPath self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_set_lengthening_speed_function(self, *args)

    def __init__(self):
        r"""__init__(FunctionBasedPath self) -> FunctionBasedPath"""
        _simulation.FunctionBasedPath_swiginit(self, _simulation.new_FunctionBasedPath())

    def setCoordinatePaths(self, coordinatePaths):
        r"""
        Set the list of paths to the model coordinate that are used as arguments
        to the length and, if provided, lengthening speed and moment functions.
        The order of the coordinates must match the order of the function
        arguments.
        """
        return _simulation.FunctionBasedPath_setCoordinatePaths(self, coordinatePaths)

    def appendCoordinatePath(self, coordinatePath):
        r"""
        appendCoordinatePath(FunctionBasedPath self, std::string const & coordinatePath)

        Parameters
        ----------
        coordinatePath: std::string const &

        """
        return _simulation.FunctionBasedPath_appendCoordinatePath(self, coordinatePath)

    def getCoordinatePaths(self):
        r"""getCoordinatePaths(FunctionBasedPath self) -> StdVectorString"""
        return _simulation.FunctionBasedPath_getCoordinatePaths(self)

    def setLengthFunction(self, lengthFunction):
        r"""
        Set the function that computes the length of the path as a function of
        the coordinate values. The function must have the same number of
        arguments as the number of coordinates.
        """
        return _simulation.FunctionBasedPath_setLengthFunction(self, lengthFunction)

    def getLengthFunction(self):
        r"""getLengthFunction(FunctionBasedPath self) -> Function"""
        return _simulation.FunctionBasedPath_getLengthFunction(self)

    def setMomentArmFunctions(self, momentArmFunctions):
        r"""
        Set the list of functions that compute the moment arms of the path as a
        function of the coordinate values. The order of the functions must match
        the order of the coordinates.
        """
        return _simulation.FunctionBasedPath_setMomentArmFunctions(self, momentArmFunctions)

    def appendMomentArmFunction(self, momentArmFunction):
        r"""
        appendMomentArmFunction(FunctionBasedPath self, Function momentArmFunction)

        Parameters
        ----------
        momentArmFunction: OpenSim::Function const &

        """
        return _simulation.FunctionBasedPath_appendMomentArmFunction(self, momentArmFunction)

    def getMomentArmFunction(self, coordinatePath):
        r"""
        getMomentArmFunction(FunctionBasedPath self, std::string const & coordinatePath) -> Function

        Parameters
        ----------
        coordinatePath: std::string const &

        """
        return _simulation.FunctionBasedPath_getMomentArmFunction(self, coordinatePath)

    def getMomentArms(self, s):
        r"""
        getMomentArms(FunctionBasedPath self, State s) -> Vector

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.FunctionBasedPath_getMomentArms(self, s)

    def setLengtheningSpeedFunction(self, speedFunction):
        r"""
        Set the function that computes the speed of the path as a function of
        the coordinate values and speeds. The function must have the same number
        of arguments as the number of coordinate values and speeds.
        """
        return _simulation.FunctionBasedPath_setLengtheningSpeedFunction(self, speedFunction)

    def getLengtheningSpeedFunction(self):
        r"""getLengtheningSpeedFunction(FunctionBasedPath self) -> Function"""
        return _simulation.FunctionBasedPath_getLengtheningSpeedFunction(self)

    def getLength(self, s):
        r"""
        getLength(FunctionBasedPath self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.FunctionBasedPath_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(FunctionBasedPath self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.FunctionBasedPath_getLengtheningSpeed(self, s)

    def computeMomentArm(self, s, coord):
        r"""
        Notes: This must check if the path is dependent on the provided
        coordinate, which requires a search through the list of coordinates.
        To retrieve the moment arms directly from the cache variable in the
        SimTK::State, use `getMomentArms()` instead.
        """
        return _simulation.FunctionBasedPath_computeMomentArm(self, s, coord)

    def produceForces(self, arg2, tension, arg4):
        r"""
        produceForces(FunctionBasedPath self, State arg2, double tension, OpenSim::ForceConsumer & arg4)

        Parameters
        ----------
        arg2: SimTK::State const &
        tension: double
        arg4: OpenSim::ForceConsumer &

        """
        return _simulation.FunctionBasedPath_produceForces(self, arg2, tension, arg4)

    def isVisualPath(self):
        r"""isVisualPath(FunctionBasedPath self) -> bool"""
        return _simulation.FunctionBasedPath_isVisualPath(self)
    __swig_destroy__ = _simulation.delete_FunctionBasedPath

# Register FunctionBasedPath in _simulation:
_simulation.FunctionBasedPath_swigregister(FunctionBasedPath)
class Ligament(ForceProducer):
    r"""
    A class implementing a ligament. The path of the ligament is
    stored in an object derived from AbstractGeometryPath.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Ligament

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Ligament_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Ligament self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Ligament_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Ligament_getClassName()

    def clone(self):
        r"""clone(Ligament self) -> Ligament"""
        return _simulation.Ligament_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Ligament self) -> std::string const &"""
        return _simulation.Ligament_getConcreteClassName(self)

    def copyProperty_path(self, source):
        r"""
        copyProperty_path(Ligament self, Ligament source)

        Parameters
        ----------
        source: OpenSim::Ligament::Self const &

        """
        return _simulation.Ligament_copyProperty_path(self, source)

    def append_path(self, value):
        r"""
        append_path(Ligament self, AbstractGeometryPath value) -> int

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Ligament_append_path(self, value)

    def constructProperty_path(self, initValue):
        r"""
        constructProperty_path(Ligament self, AbstractGeometryPath initValue)

        Parameters
        ----------
        initValue: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Ligament_constructProperty_path(self, initValue)

    def get_path(self, *args):
        r"""
        get_path(Ligament self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(Ligament self) -> AbstractGeometryPath
        """
        return _simulation.Ligament_get_path(self, *args)

    def upd_path(self, *args):
        r"""
        upd_path(Ligament self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        upd_path(Ligament self) -> AbstractGeometryPath
        """
        return _simulation.Ligament_upd_path(self, *args)

    def set_path(self, *args):
        r"""
        set_path(Ligament self, int i, AbstractGeometryPath value)

        Parameters
        ----------
        i: int
        value: OpenSim::AbstractGeometryPath const &

        set_path(Ligament self, AbstractGeometryPath value)

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Ligament_set_path(self, *args)

    def copyProperty_resting_length(self, source):
        r"""
        copyProperty_resting_length(Ligament self, Ligament source)

        Parameters
        ----------
        source: OpenSim::Ligament::Self const &

        """
        return _simulation.Ligament_copyProperty_resting_length(self, source)

    def append_resting_length(self, value):
        r"""
        append_resting_length(Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Ligament_append_resting_length(self, value)

    def constructProperty_resting_length(self, initValue):
        r"""
        constructProperty_resting_length(Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Ligament_constructProperty_resting_length(self, initValue)

    def get_resting_length(self, *args):
        r"""
        get_resting_length(Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_resting_length(Ligament self) -> double const &
        """
        return _simulation.Ligament_get_resting_length(self, *args)

    def upd_resting_length(self, *args):
        r"""
        upd_resting_length(Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_resting_length(Ligament self) -> double &
        """
        return _simulation.Ligament_upd_resting_length(self, *args)

    def set_resting_length(self, *args):
        r"""
        set_resting_length(Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_resting_length(Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Ligament_set_resting_length(self, *args)

    def copyProperty_pcsa_force(self, source):
        r"""
        copyProperty_pcsa_force(Ligament self, Ligament source)

        Parameters
        ----------
        source: OpenSim::Ligament::Self const &

        """
        return _simulation.Ligament_copyProperty_pcsa_force(self, source)

    def append_pcsa_force(self, value):
        r"""
        append_pcsa_force(Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Ligament_append_pcsa_force(self, value)

    def constructProperty_pcsa_force(self, initValue):
        r"""
        constructProperty_pcsa_force(Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Ligament_constructProperty_pcsa_force(self, initValue)

    def get_pcsa_force(self, *args):
        r"""
        get_pcsa_force(Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pcsa_force(Ligament self) -> double const &
        """
        return _simulation.Ligament_get_pcsa_force(self, *args)

    def upd_pcsa_force(self, *args):
        r"""
        upd_pcsa_force(Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_pcsa_force(Ligament self) -> double &
        """
        return _simulation.Ligament_upd_pcsa_force(self, *args)

    def set_pcsa_force(self, *args):
        r"""
        set_pcsa_force(Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_pcsa_force(Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Ligament_set_pcsa_force(self, *args)

    def copyProperty_force_length_curve(self, source):
        r"""
        copyProperty_force_length_curve(Ligament self, Ligament source)

        Parameters
        ----------
        source: OpenSim::Ligament::Self const &

        """
        return _simulation.Ligament_copyProperty_force_length_curve(self, source)

    def append_force_length_curve(self, value):
        r"""
        append_force_length_curve(Ligament self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.Ligament_append_force_length_curve(self, value)

    def constructProperty_force_length_curve(self, initValue):
        r"""
        constructProperty_force_length_curve(Ligament self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.Ligament_constructProperty_force_length_curve(self, initValue)

    def get_force_length_curve(self, *args):
        r"""
        get_force_length_curve(Ligament self, int i) -> Function

        Parameters
        ----------
        i: int

        get_force_length_curve(Ligament self) -> Function
        """
        return _simulation.Ligament_get_force_length_curve(self, *args)

    def upd_force_length_curve(self, *args):
        r"""
        upd_force_length_curve(Ligament self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_force_length_curve(Ligament self) -> Function
        """
        return _simulation.Ligament_upd_force_length_curve(self, *args)

    def set_force_length_curve(self, *args):
        r"""
        set_force_length_curve(Ligament self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_force_length_curve(Ligament self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.Ligament_set_force_length_curve(self, *args)

    def __init__(self):
        r"""__init__(Ligament self) -> Ligament"""
        _simulation.Ligament_swiginit(self, _simulation.new_Ligament())

    def updPath(self):
        r"""updPath(Ligament self) -> AbstractGeometryPath"""
        return _simulation.Ligament_updPath(self)

    def getPath(self):
        r"""getPath(Ligament self) -> AbstractGeometryPath"""
        return _simulation.Ligament_getPath(self)

    def updGeometryPath(self):
        r"""updGeometryPath(Ligament self) -> GeometryPath"""
        return _simulation.Ligament_updGeometryPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(Ligament self) -> GeometryPath"""
        return _simulation.Ligament_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(Ligament self) -> bool"""
        return _simulation.Ligament_hasVisualPath(self)

    def getLength(self, s):
        r"""
        getLength(Ligament self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Ligament_getLength(self, s)

    def getRestingLength(self):
        r"""getRestingLength(Ligament self) -> double"""
        return _simulation.Ligament_getRestingLength(self)

    def setRestingLength(self, aRestingLength):
        r"""
        setRestingLength(Ligament self, double aRestingLength) -> bool

        Parameters
        ----------
        aRestingLength: double

        """
        return _simulation.Ligament_setRestingLength(self, aRestingLength)

    def getMaxIsometricForce(self):
        r"""getMaxIsometricForce(Ligament self) -> double"""
        return _simulation.Ligament_getMaxIsometricForce(self)

    def setMaxIsometricForce(self, aMaxIsometricForce):
        r"""
        setMaxIsometricForce(Ligament self, double aMaxIsometricForce) -> bool

        Parameters
        ----------
        aMaxIsometricForce: double

        """
        return _simulation.Ligament_setMaxIsometricForce(self, aMaxIsometricForce)

    def getForceLengthCurve(self):
        r"""getForceLengthCurve(Ligament self) -> Function"""
        return _simulation.Ligament_getForceLengthCurve(self)

    def setForceLengthCurve(self, aForceLengthCurve):
        r"""
        setForceLengthCurve(Ligament self, Function aForceLengthCurve) -> bool

        Parameters
        ----------
        aForceLengthCurve: OpenSim::Function const &

        """
        return _simulation.Ligament_setForceLengthCurve(self, aForceLengthCurve)

    def getTension(self, s):
        r"""
        getTension(Ligament self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Ligament_getTension(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(Ligament self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.Ligament_computeMomentArm(self, s, aCoord)

    def extendPostScale(self, s, scaleSet):
        r"""
        Adjust the resting length of the ligament after the model has been
               scaled. The `resting_length` property is multiplied by the quotient of
               the current path length and the path length before scaling.
        """
        return _simulation.Ligament_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_Ligament

# Register Ligament in _simulation:
_simulation.Ligament_swigregister(Ligament)
class Blankevoort1991Ligament(ForceProducer):
    r"""
    This class implements a nonlinear spring ligament model introduced by
    Blankevoort et al.\ (1991) [1] and further described in Smith et al.\ (2016)
    [2]. This model is partially based on the formulation orginally proposed by
    Wismans et al.\ (1980) [3]. The ligament is represented as a passive spring
    with the force-strain relationship described by a quadratic "toe" region at
    low strains and a linear region at high strains. The toe region represents the
    uncrimping and alignment of collagen fibers and the linear region represents
    the subsequent stretching of the aligned fibers. The ligament model also
    includes a damping force that is only applied if the ligament is stretched
    beyond the slack length and if the ligament is lengthening.
    The length of the ligament is :math:`l`.

    Image: fig_Blankevoort1991Ligament.png(width=400px)

    **Governing Equations**

    Spring %Force:

    .. math::

        F_{\mathrm{spring}} =
            \begin{Bmatrix}
            0 & \epsilon < 0 \\
            \frac{1}{2\epsilon_t }k\epsilon^2 & 0 \leq \epsilon \leq \epsilon_t \\
             k(\epsilon - \frac{\epsilon_t}{2})& \epsilon > \epsilon_t
            \end{Bmatrix}

    Damping %Force:

    .. math::

        F_{\mathrm{damping}} = 
            \begin{Bmatrix} 
            c\cdot \dot{\epsilon} & \epsilon > 0 \: and \: \dot{\epsilon} > 0 \\
            0 & otherwise
            \end{Bmatrix}

    Total %Force:

    .. math::

        F_{\mathrm{total}} = F_{\mathrm{spring}} + F_{\mathrm{damping}}

    This Force component has the following properties:

    - linear stiffness (k): The force/strain (e.g. N) stiffness of the linear
    region of the ligament model.

    - slack_length (_0:math:`): The resting length of the ligament (e.g. m).- damping coefficient (c): Damping coefficient used in the dampingforce calculation in units of force*time/strain (e.g. N*s/strain). The default value is 0.003.- transition_strain (`_t:math:`): The strain value where the ligamentmodel transitions from the quadratic toe region to the linear stiffness region.The default value is 0.06 (6%) according to Blankevoort (1991) [1].This value is widely used in the multibody knee modeling literature [2,4,5,6]and also agrees with some experimental studies [7]. However, other literaturesuggests the transition strain of ligaments occurs at around 0.03 (3%) strain[8,9]. In reality, the transition strain is likely dependent on the strainrate [10,11], however this effect is not included in this implementation.The Blankevoort1991Ligament implementation is intended to be compatible with common methods in the literature for parameterizing ligament properties. The zero-load length of the ligament is parameterized by theslack_length property, which can be set directly, in meters, usingset_slack_length(), or using setSlackLengthFromReferenceStrain() andsetSlackLengthFromReferenceForce(). Here, reference strain and referenceforce are the strain or force in the ligament at a reference pose (state). Ifyou want to compute the strain or force of the ligament in a given pose (state), you can use the getStrain() and getForce() methods. Thelinear_stiffness property has units of force/strain (newton) but can be set and obtained in units of force/length (newton/meter) usingsetLinearStiffnessForcePerLength() and getLinearStiffnessForcePerLength().When scaling a model (using the ScaleTool) that contains a Blankevoort1991Ligament, the slack_length property is scaled by the ratio of the entire path length in the default model pose before and afterscaling the bone geometries. This ensures that the strain in the ligament in the default pose is equivilent before and after scaling. Thus, it is important to consider the order of scaling the model and setting the slack_length property for your specific application. The linear_stiffness property is not affected by scaling the model. ### References[1] Blankevoort, L. and Huiskes, R., (1991).    Ligament-bone interaction in a three-dimensional model of the knee.    J Biomech Eng, 113(3), 263-269[2] Smith, C.R., Lenhart, R.L., Kaiser, J., Vignos, M.F. and Thelen, D.G.,    (2016). Influence of ligament properties on tibiofemoral mechanics    in walking. J Knee Surg, 29(02), 99-106.[3] Wismans, J.A.C., Veldpaus, F., Janssen, J., Huson, A. and Struben, P.,    (1980). A three-dimensional mathematical model of the knee-joint.    J Biomech, 13(8), 677-685.[4] Marra, M. A., Vanheule, V., Fluit, R., Koopman, B. H., Rasmussen, J.,    Verdonschot, N., & Andersen, M. S. (2015). A subject-specific    musculoskeletal modeling framework to predict in vivo mechanics of total    knee arthroplasty. Journal of biomechanical engineering, 137(2), 020904.[5] Guess, T. M., Razu, S., & Jahandar, H. (2016). Evaluation of knee ligament    mechanics using computational models. The journal of knee surgery, 29(02),    126-137.[6] Li, G., Gil, J., Kanamori, A., & Woo, S. Y. (1999). A validated    three-dimensional computational model of a human knee joint. Journal of    biomechanical engineering, 121(6), 657-662.[7] Ristaniemi, A., Stenroth, L., Mikkonen, S., & Korhonen, R. K. (2018).    Comparison of elastic, viscoelastic and failure tensile material properties    of knee ligaments and patellar tendon. Journal of biomechanics, 79, 31-38.[8] Weiss, J. A., & Gardiner, J. C. (2001). Computational modeling of ligament    mechanics. Critical Reviews in Biomedical Engineering, 29(3).[9] Martin, R. B., Burr, D. B., Sharkey, N. A., & Fyhrie, D. P. (2015).    Mechanical properties of ligament and tendon. In Skeletal Tissue Mechanics    (pp. 175-225). Springer, New York, NY.[10] Pioletti, D. P., Rakotomanana, L. R., Benvenuti, J. F., & Leyvraz, P. F.    (1998). Viscoelastic constitutive law in large deformations: application to     human knee ligaments and tendons. Journal of biomechanics, 31(8), 753-757.[11] Pioletti, D. P., Rakotomanana, L. R., & Leyvraz, P. F. (1999). Strain    rate effect on the mechanical behavior of the anterior cruciate    ligament-bone complex. Medical Engineering & Physics, 21(2), 95-100.[12] Galbusera, F., Freutel, M., Durselen, L., D'Aiuto, M., Croce, D.,    Villa, T., Sansone, V. & Innocenti, B. (2014). Material models and     properties in the finite element analysis of knee ligaments: a literature     review. Frontiers in bioengineering and biotechnology, 2, 54.@author Colin Smith`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Blankevoort1991Ligament

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Blankevoort1991Ligament_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Blankevoort1991Ligament self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Blankevoort1991Ligament_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Blankevoort1991Ligament_getClassName()

    def clone(self):
        r"""clone(Blankevoort1991Ligament self) -> Blankevoort1991Ligament"""
        return _simulation.Blankevoort1991Ligament_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Blankevoort1991Ligament self) -> std::string const &"""
        return _simulation.Blankevoort1991Ligament_getConcreteClassName(self)

    def copyProperty_path(self, source):
        r"""
        copyProperty_path(Blankevoort1991Ligament self, Blankevoort1991Ligament source)

        Parameters
        ----------
        source: OpenSim::Blankevoort1991Ligament::Self const &

        """
        return _simulation.Blankevoort1991Ligament_copyProperty_path(self, source)

    def append_path(self, value):
        r"""
        append_path(Blankevoort1991Ligament self, AbstractGeometryPath value) -> int

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Blankevoort1991Ligament_append_path(self, value)

    def constructProperty_path(self, initValue):
        r"""
        constructProperty_path(Blankevoort1991Ligament self, AbstractGeometryPath initValue)

        Parameters
        ----------
        initValue: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Blankevoort1991Ligament_constructProperty_path(self, initValue)

    def get_path(self, *args):
        r"""
        get_path(Blankevoort1991Ligament self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(Blankevoort1991Ligament self) -> AbstractGeometryPath
        """
        return _simulation.Blankevoort1991Ligament_get_path(self, *args)

    def upd_path(self, *args):
        r"""
        upd_path(Blankevoort1991Ligament self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        upd_path(Blankevoort1991Ligament self) -> AbstractGeometryPath
        """
        return _simulation.Blankevoort1991Ligament_upd_path(self, *args)

    def set_path(self, *args):
        r"""
        set_path(Blankevoort1991Ligament self, int i, AbstractGeometryPath value)

        Parameters
        ----------
        i: int
        value: OpenSim::AbstractGeometryPath const &

        set_path(Blankevoort1991Ligament self, AbstractGeometryPath value)

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.Blankevoort1991Ligament_set_path(self, *args)

    def copyProperty_linear_stiffness(self, source):
        r"""
        copyProperty_linear_stiffness(Blankevoort1991Ligament self, Blankevoort1991Ligament source)

        Parameters
        ----------
        source: OpenSim::Blankevoort1991Ligament::Self const &

        """
        return _simulation.Blankevoort1991Ligament_copyProperty_linear_stiffness(self, source)

    def append_linear_stiffness(self, value):
        r"""
        append_linear_stiffness(Blankevoort1991Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_append_linear_stiffness(self, value)

    def constructProperty_linear_stiffness(self, initValue):
        r"""
        constructProperty_linear_stiffness(Blankevoort1991Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Blankevoort1991Ligament_constructProperty_linear_stiffness(self, initValue)

    def get_linear_stiffness(self, *args):
        r"""
        get_linear_stiffness(Blankevoort1991Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_linear_stiffness(Blankevoort1991Ligament self) -> double const &
        """
        return _simulation.Blankevoort1991Ligament_get_linear_stiffness(self, *args)

    def upd_linear_stiffness(self, *args):
        r"""
        upd_linear_stiffness(Blankevoort1991Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_linear_stiffness(Blankevoort1991Ligament self) -> double &
        """
        return _simulation.Blankevoort1991Ligament_upd_linear_stiffness(self, *args)

    def set_linear_stiffness(self, *args):
        r"""
        set_linear_stiffness(Blankevoort1991Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_linear_stiffness(Blankevoort1991Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_set_linear_stiffness(self, *args)

    def copyProperty_transition_strain(self, source):
        r"""
        copyProperty_transition_strain(Blankevoort1991Ligament self, Blankevoort1991Ligament source)

        Parameters
        ----------
        source: OpenSim::Blankevoort1991Ligament::Self const &

        """
        return _simulation.Blankevoort1991Ligament_copyProperty_transition_strain(self, source)

    def append_transition_strain(self, value):
        r"""
        append_transition_strain(Blankevoort1991Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_append_transition_strain(self, value)

    def constructProperty_transition_strain(self, initValue):
        r"""
        constructProperty_transition_strain(Blankevoort1991Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Blankevoort1991Ligament_constructProperty_transition_strain(self, initValue)

    def get_transition_strain(self, *args):
        r"""
        get_transition_strain(Blankevoort1991Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition_strain(Blankevoort1991Ligament self) -> double const &
        """
        return _simulation.Blankevoort1991Ligament_get_transition_strain(self, *args)

    def upd_transition_strain(self, *args):
        r"""
        upd_transition_strain(Blankevoort1991Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition_strain(Blankevoort1991Ligament self) -> double &
        """
        return _simulation.Blankevoort1991Ligament_upd_transition_strain(self, *args)

    def set_transition_strain(self, *args):
        r"""
        set_transition_strain(Blankevoort1991Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition_strain(Blankevoort1991Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_set_transition_strain(self, *args)

    def copyProperty_damping_coefficient(self, source):
        r"""
        copyProperty_damping_coefficient(Blankevoort1991Ligament self, Blankevoort1991Ligament source)

        Parameters
        ----------
        source: OpenSim::Blankevoort1991Ligament::Self const &

        """
        return _simulation.Blankevoort1991Ligament_copyProperty_damping_coefficient(self, source)

    def append_damping_coefficient(self, value):
        r"""
        append_damping_coefficient(Blankevoort1991Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_append_damping_coefficient(self, value)

    def constructProperty_damping_coefficient(self, initValue):
        r"""
        constructProperty_damping_coefficient(Blankevoort1991Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Blankevoort1991Ligament_constructProperty_damping_coefficient(self, initValue)

    def get_damping_coefficient(self, *args):
        r"""
        get_damping_coefficient(Blankevoort1991Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_damping_coefficient(Blankevoort1991Ligament self) -> double const &
        """
        return _simulation.Blankevoort1991Ligament_get_damping_coefficient(self, *args)

    def upd_damping_coefficient(self, *args):
        r"""
        upd_damping_coefficient(Blankevoort1991Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_damping_coefficient(Blankevoort1991Ligament self) -> double &
        """
        return _simulation.Blankevoort1991Ligament_upd_damping_coefficient(self, *args)

    def set_damping_coefficient(self, *args):
        r"""
        set_damping_coefficient(Blankevoort1991Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_damping_coefficient(Blankevoort1991Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_set_damping_coefficient(self, *args)

    def copyProperty_slack_length(self, source):
        r"""
        copyProperty_slack_length(Blankevoort1991Ligament self, Blankevoort1991Ligament source)

        Parameters
        ----------
        source: OpenSim::Blankevoort1991Ligament::Self const &

        """
        return _simulation.Blankevoort1991Ligament_copyProperty_slack_length(self, source)

    def append_slack_length(self, value):
        r"""
        append_slack_length(Blankevoort1991Ligament self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_append_slack_length(self, value)

    def constructProperty_slack_length(self, initValue):
        r"""
        constructProperty_slack_length(Blankevoort1991Ligament self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Blankevoort1991Ligament_constructProperty_slack_length(self, initValue)

    def get_slack_length(self, *args):
        r"""
        get_slack_length(Blankevoort1991Ligament self, int i) -> double const

        Parameters
        ----------
        i: int

        get_slack_length(Blankevoort1991Ligament self) -> double const &
        """
        return _simulation.Blankevoort1991Ligament_get_slack_length(self, *args)

    def upd_slack_length(self, *args):
        r"""
        upd_slack_length(Blankevoort1991Ligament self, int i) -> double

        Parameters
        ----------
        i: int

        upd_slack_length(Blankevoort1991Ligament self) -> double &
        """
        return _simulation.Blankevoort1991Ligament_upd_slack_length(self, *args)

    def set_slack_length(self, *args):
        r"""
        set_slack_length(Blankevoort1991Ligament self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_slack_length(Blankevoort1991Ligament self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Blankevoort1991Ligament_set_slack_length(self, *args)
    _has_output_spring_force = property(_simulation.Blankevoort1991Ligament__has_output_spring_force_get, _simulation.Blankevoort1991Ligament__has_output_spring_force_set, doc=r"""_has_output_spring_force : bool""")
    _has_output_damping_force = property(_simulation.Blankevoort1991Ligament__has_output_damping_force_get, _simulation.Blankevoort1991Ligament__has_output_damping_force_set, doc=r"""_has_output_damping_force : bool""")
    _has_output_total_force = property(_simulation.Blankevoort1991Ligament__has_output_total_force_get, _simulation.Blankevoort1991Ligament__has_output_total_force_set, doc=r"""_has_output_total_force : bool""")
    _has_output_strain = property(_simulation.Blankevoort1991Ligament__has_output_strain_get, _simulation.Blankevoort1991Ligament__has_output_strain_set, doc=r"""_has_output_strain : bool""")
    _has_output_strain_rate = property(_simulation.Blankevoort1991Ligament__has_output_strain_rate_get, _simulation.Blankevoort1991Ligament__has_output_strain_rate_set, doc=r"""_has_output_strain_rate : bool""")
    _has_output_length = property(_simulation.Blankevoort1991Ligament__has_output_length_get, _simulation.Blankevoort1991Ligament__has_output_length_set, doc=r"""_has_output_length : bool""")
    _has_output_lengthening_speed = property(_simulation.Blankevoort1991Ligament__has_output_lengthening_speed_get, _simulation.Blankevoort1991Ligament__has_output_lengthening_speed_set, doc=r"""_has_output_lengthening_speed : bool""")

    def __init__(self, *args):
        r"""
        __init__(Blankevoort1991Ligament self) -> Blankevoort1991Ligament
        __init__(Blankevoort1991Ligament self, std::string name, PhysicalFrame frame1, Vec3 point1, PhysicalFrame frame2, Vec3 point2) -> Blankevoort1991Ligament

        Parameters
        ----------
        name: std::string
        frame1: OpenSim::PhysicalFrame const &
        point1: SimTK::Vec3
        frame2: OpenSim::PhysicalFrame const &
        point2: SimTK::Vec3

        __init__(Blankevoort1991Ligament self, std::string name, PhysicalFrame frame1, Vec3 point1, PhysicalFrame frame2, Vec3 point2, double linear_stiffness, double slack_length) -> Blankevoort1991Ligament

        Parameters
        ----------
        name: std::string
        frame1: OpenSim::PhysicalFrame const &
        point1: SimTK::Vec3
        frame2: OpenSim::PhysicalFrame const &
        point2: SimTK::Vec3
        linear_stiffness: double
        slack_length: double

        __init__(Blankevoort1991Ligament self, std::string name, double linear_stiffness, double slack_length) -> Blankevoort1991Ligament

        Parameters
        ----------
        name: std::string
        linear_stiffness: double
        slack_length: double

        """
        _simulation.Blankevoort1991Ligament_swiginit(self, _simulation.new_Blankevoort1991Ligament(*args))

    def updPath(self):
        r"""updPath(Blankevoort1991Ligament self) -> AbstractGeometryPath"""
        return _simulation.Blankevoort1991Ligament_updPath(self)

    def getPath(self):
        r"""getPath(Blankevoort1991Ligament self) -> AbstractGeometryPath"""
        return _simulation.Blankevoort1991Ligament_getPath(self)

    def updGeometryPath(self):
        r"""updGeometryPath(Blankevoort1991Ligament self) -> GeometryPath"""
        return _simulation.Blankevoort1991Ligament_updGeometryPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(Blankevoort1991Ligament self) -> GeometryPath"""
        return _simulation.Blankevoort1991Ligament_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(Blankevoort1991Ligament self) -> bool"""
        return _simulation.Blankevoort1991Ligament_hasVisualPath(self)

    def setSlackLengthFromReferenceStrain(self, strain, reference_state):
        r"""
         %Set the slack_length property using the strain in the ligament at a
        known pose (reference state). Note that scaling the model will adjust
             the slack length property to hold the input reference strain constant
             if the input reference_state is equal to the default model pose
             (generated by initSystem()).
        """
        return _simulation.Blankevoort1991Ligament_setSlackLengthFromReferenceStrain(self, strain, reference_state)

    def setSlackLengthFromReferenceForce(self, force, reference_state):
        r"""
        %Set the slack_length property using the absolute spring force (N) in
           the ligament at a known pose (reference force). Note that scaling the
           model will adjust the slack_length property, thus it is important to
           consider the order of scaling and using this function for your application.
        """
        return _simulation.Blankevoort1991Ligament_setSlackLengthFromReferenceForce(self, force, reference_state)

    def setLinearStiffnessForcePerLength(self, linear_stiffness):
        r"""
        %Set the linear_stiffness property using a value in units of
            force/length (N/m). Note that scaling the model keeps the
            linear_stiffness property (in units of force/strain) constant, thus the
            linear_stiffness in units of force/length input to this function will be
            altered by scaling.
        """
        return _simulation.Blankevoort1991Ligament_setLinearStiffnessForcePerLength(self, linear_stiffness)

    def setDampingCoefficientForceTimePerLength(self, damping_coefficient):
        r"""
        %Set the damping_coefficient property using a value in units of
           force*time/length (N*s/m). Note that scaling the model keeps the
           damping_coefficient property (in units force*time/strain) constant, thus
           the damping_coefficient in units of force*time/length input to this
           function will be altered by scaling.
        """
        return _simulation.Blankevoort1991Ligament_setDampingCoefficientForceTimePerLength(self, damping_coefficient)

    def getStrain(self, state):
        r"""
        getStrain(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getStrain(self, state)

    def getStrainRate(self, state):
        r"""
        getStrainRate(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getStrainRate(self, state)

    def getLength(self, state):
        r"""
        getLength(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getLength(self, state)

    def getLengtheningSpeed(self, state):
        r"""
        getLengtheningSpeed(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getLengtheningSpeed(self, state)

    def getSpringForce(self, state):
        r"""
        getSpringForce(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getSpringForce(self, state)

    def getDampingForce(self, state):
        r"""
        getDampingForce(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getDampingForce(self, state)

    def getTotalForce(self, state):
        r"""
        getTotalForce(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getTotalForce(self, state)

    def getLinearStiffnessForcePerLength(self):
        r""" Get the linear_stiffness property in units of force/length (N/m)"""
        return _simulation.Blankevoort1991Ligament_getLinearStiffnessForcePerLength(self)

    def getTransitionLength(self):
        r"""
        Get the length (m) of the ligament where the model transitions from
           the toe region to the linear region. This corresponds to the length of the
           ligament at the transistion_strain.
        """
        return _simulation.Blankevoort1991Ligament_getTransitionLength(self)

    def getDampingCoefficientForceTimePerLength(self):
        r""" Get the damping_coefficient in units of force*time/length (N*s/m)"""
        return _simulation.Blankevoort1991Ligament_getDampingCoefficientForceTimePerLength(self)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(Blankevoort1991Ligament self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.Blankevoort1991Ligament_computeMomentArm(self, s, aCoord)

    def computePotentialEnergy(self, state):
        r"""
        computePotentialEnergy(Blankevoort1991Ligament self, State state) -> double

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_computePotentialEnergy(self, state)

    def extendPostScale(self, s, scaleSet):
        r"""
        extendPostScale(Blankevoort1991Ligament self, State s, ScaleSet scaleSet)

        Parameters
        ----------
        s: SimTK::State const &
        scaleSet: OpenSim::ScaleSet const &

        """
        return _simulation.Blankevoort1991Ligament_extendPostScale(self, s, scaleSet)

    def getRecordLabels(self):
        r"""getRecordLabels(Blankevoort1991Ligament self) -> ArrayStr"""
        return _simulation.Blankevoort1991Ligament_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        getRecordValues(Blankevoort1991Ligament self, State state) -> ArrayDouble

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.Blankevoort1991Ligament_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_Blankevoort1991Ligament

# Register Blankevoort1991Ligament in _simulation:
_simulation.Blankevoort1991Ligament_swigregister(Blankevoort1991Ligament)
class PathActuator(ScalarActuator):
    r"""
    This is the base class for actuators that apply controllable tension along
    a path. %PathActuator has no states; the control is simply the tension to be
    applied along a path (i.e. tensionable rope).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathActuator_getClassName()

    def clone(self):
        r"""clone(PathActuator self) -> PathActuator"""
        return _simulation.PathActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathActuator self) -> std::string const &"""
        return _simulation.PathActuator_getConcreteClassName(self)

    def copyProperty_path(self, source):
        r"""
        copyProperty_path(PathActuator self, PathActuator source)

        Parameters
        ----------
        source: OpenSim::PathActuator::Self const &

        """
        return _simulation.PathActuator_copyProperty_path(self, source)

    def append_path(self, value):
        r"""
        append_path(PathActuator self, AbstractGeometryPath value) -> int

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathActuator_append_path(self, value)

    def constructProperty_path(self, initValue):
        r"""
        constructProperty_path(PathActuator self, AbstractGeometryPath initValue)

        Parameters
        ----------
        initValue: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathActuator_constructProperty_path(self, initValue)

    def get_path(self, *args):
        r"""
        get_path(PathActuator self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(PathActuator self) -> AbstractGeometryPath
        """
        return _simulation.PathActuator_get_path(self, *args)

    def upd_path(self, *args):
        r"""
        upd_path(PathActuator self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        upd_path(PathActuator self) -> AbstractGeometryPath
        """
        return _simulation.PathActuator_upd_path(self, *args)

    def set_path(self, *args):
        r"""
        set_path(PathActuator self, int i, AbstractGeometryPath value)

        Parameters
        ----------
        i: int
        value: OpenSim::AbstractGeometryPath const &

        set_path(PathActuator self, AbstractGeometryPath value)

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathActuator_set_path(self, *args)

    def copyProperty_optimal_force(self, source):
        r"""
        copyProperty_optimal_force(PathActuator self, PathActuator source)

        Parameters
        ----------
        source: OpenSim::PathActuator::Self const &

        """
        return _simulation.PathActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value):
        r"""
        append_optimal_force(PathActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue):
        r"""
        constructProperty_optimal_force(PathActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PathActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(PathActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(PathActuator self) -> double const &
        """
        return _simulation.PathActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args):
        r"""
        upd_optimal_force(PathActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_force(PathActuator self) -> double &
        """
        return _simulation.PathActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args):
        r"""
        set_optimal_force(PathActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_force(PathActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathActuator_set_optimal_force(self, *args)
    _has_output_tension = property(_simulation.PathActuator__has_output_tension_get, _simulation.PathActuator__has_output_tension_set, doc=r"""_has_output_tension : bool""")

    def __init__(self):
        r"""__init__(PathActuator self) -> PathActuator"""
        _simulation.PathActuator_swiginit(self, _simulation.new_PathActuator())

    def updPath(self):
        r"""updPath(PathActuator self) -> AbstractGeometryPath"""
        return _simulation.PathActuator_updPath(self)

    def getPath(self):
        r"""getPath(PathActuator self) -> AbstractGeometryPath"""
        return _simulation.PathActuator_getPath(self)

    def updGeometryPath(self):
        r"""updGeometryPath(PathActuator self) -> GeometryPath"""
        return _simulation.PathActuator_updGeometryPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(PathActuator self) -> GeometryPath"""
        return _simulation.PathActuator_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(PathActuator self) -> bool"""
        return _simulation.PathActuator_hasVisualPath(self)

    def setOptimalForce(self, aOptimalForce):
        r"""
        setOptimalForce(PathActuator self, double aOptimalForce)

        Parameters
        ----------
        aOptimalForce: double

        """
        return _simulation.PathActuator_setOptimalForce(self, aOptimalForce)

    def getOptimalForce(self):
        r"""getOptimalForce(PathActuator self) -> double"""
        return _simulation.PathActuator_getOptimalForce(self)

    def getLength(self, s):
        r"""
        getLength(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_getLengtheningSpeed(self, s)

    def getSpeed(self, s):
        r"""
        getSpeed(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_getSpeed(self, s)

    def getPower(self, s):
        r"""
        getPower(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_getPower(self, s)

    def getStress(self, s):
        r"""
        getStress(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_getStress(self, s)

    def addNewPathPoint(self, proposedName, aBody, aPositionOnBody):
        r"""
         Notes: This function does not maintain the State and so should be used
        only before a valid State is created.
        Only valid if the `path` owned by this PathActuator supports
        PathPoint%s (e.g., GeometryPath).
        """
        return _simulation.PathActuator_addNewPathPoint(self, proposedName, aBody, aPositionOnBody)

    def computeActuation(self, s):
        r"""
        computeActuation(PathActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.PathActuator_computeActuation(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(PathActuator self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.PathActuator_computeMomentArm(self, s, aCoord)
    __swig_destroy__ = _simulation.delete_PathActuator

# Register PathActuator in _simulation:
_simulation.PathActuator_swigregister(PathActuator)
class MuscleCannotEquilibrate(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::MuscleCannotEquilibrate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, obj, detail):
        r"""
        __init__(MuscleCannotEquilibrate self, std::string const & file, size_t line, std::string const & func, OpenSimObject obj, std::string const & detail) -> MuscleCannotEquilibrate

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        obj: OpenSim::Object const &
        detail: std::string const &

        """
        _simulation.MuscleCannotEquilibrate_swiginit(self, _simulation.new_MuscleCannotEquilibrate(file, line, func, obj, detail))
    __swig_destroy__ = _simulation.delete_MuscleCannotEquilibrate

# Register MuscleCannotEquilibrate in _simulation:
_simulation.MuscleCannotEquilibrate_swigregister(MuscleCannotEquilibrate)
class Muscle(PathActuator):
    r"""
    A base class for modeling a muscle-tendon actuator. It defines muscle parameters
    and methods to PathActuator, but does not implement all of the necessary methods,
    and remains an abstract class. The path information for a muscle is contained
    in PathActuator, and the force-generating behavior should be defined in
    the derived classes.

    This class defines a subset of muscle models that include an active fiber
    (contractile element) in series with a tendon. This class defines common
    data members and handles the geometry of a unipennate fiber in connection
    with a tendon. No states are assumed, but concrete classes are free to
    add whatever states are necessary to describe the specific behavior of a
    muscle.

    Author: Ajay Seth, Matt Millard

    (Based on earlier work by Peter Loan and Frank C. Anderson.)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Muscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Muscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Muscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Muscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Muscle_getClassName()

    def clone(self):
        r"""clone(Muscle self) -> Muscle"""
        return _simulation.Muscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Muscle self) -> std::string const &"""
        return _simulation.Muscle_getConcreteClassName(self)

    def copyProperty_max_isometric_force(self, source):
        r"""
        copyProperty_max_isometric_force(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_max_isometric_force(self, source)

    def append_max_isometric_force(self, value):
        r"""
        append_max_isometric_force(Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_append_max_isometric_force(self, value)

    def constructProperty_max_isometric_force(self, initValue):
        r"""
        constructProperty_max_isometric_force(Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Muscle_constructProperty_max_isometric_force(self, initValue)

    def get_max_isometric_force(self, *args):
        r"""
        get_max_isometric_force(Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_isometric_force(Muscle self) -> double const &
        """
        return _simulation.Muscle_get_max_isometric_force(self, *args)

    def upd_max_isometric_force(self, *args):
        r"""
        upd_max_isometric_force(Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_isometric_force(Muscle self) -> double &
        """
        return _simulation.Muscle_upd_max_isometric_force(self, *args)

    def set_max_isometric_force(self, *args):
        r"""
        set_max_isometric_force(Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_isometric_force(Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_set_max_isometric_force(self, *args)

    def copyProperty_optimal_fiber_length(self, source):
        r"""
        copyProperty_optimal_fiber_length(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_optimal_fiber_length(self, source)

    def append_optimal_fiber_length(self, value):
        r"""
        append_optimal_fiber_length(Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_append_optimal_fiber_length(self, value)

    def constructProperty_optimal_fiber_length(self, initValue):
        r"""
        constructProperty_optimal_fiber_length(Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Muscle_constructProperty_optimal_fiber_length(self, initValue)

    def get_optimal_fiber_length(self, *args):
        r"""
        get_optimal_fiber_length(Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_fiber_length(Muscle self) -> double const &
        """
        return _simulation.Muscle_get_optimal_fiber_length(self, *args)

    def upd_optimal_fiber_length(self, *args):
        r"""
        upd_optimal_fiber_length(Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_fiber_length(Muscle self) -> double &
        """
        return _simulation.Muscle_upd_optimal_fiber_length(self, *args)

    def set_optimal_fiber_length(self, *args):
        r"""
        set_optimal_fiber_length(Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_fiber_length(Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_set_optimal_fiber_length(self, *args)

    def copyProperty_tendon_slack_length(self, source):
        r"""
        copyProperty_tendon_slack_length(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_tendon_slack_length(self, source)

    def append_tendon_slack_length(self, value):
        r"""
        append_tendon_slack_length(Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_append_tendon_slack_length(self, value)

    def constructProperty_tendon_slack_length(self, initValue):
        r"""
        constructProperty_tendon_slack_length(Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Muscle_constructProperty_tendon_slack_length(self, initValue)

    def get_tendon_slack_length(self, *args):
        r"""
        get_tendon_slack_length(Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_slack_length(Muscle self) -> double const &
        """
        return _simulation.Muscle_get_tendon_slack_length(self, *args)

    def upd_tendon_slack_length(self, *args):
        r"""
        upd_tendon_slack_length(Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_tendon_slack_length(Muscle self) -> double &
        """
        return _simulation.Muscle_upd_tendon_slack_length(self, *args)

    def set_tendon_slack_length(self, *args):
        r"""
        set_tendon_slack_length(Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_tendon_slack_length(Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_set_tendon_slack_length(self, *args)

    def copyProperty_pennation_angle_at_optimal(self, source):
        r"""
        copyProperty_pennation_angle_at_optimal(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_pennation_angle_at_optimal(self, source)

    def append_pennation_angle_at_optimal(self, value):
        r"""
        append_pennation_angle_at_optimal(Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_append_pennation_angle_at_optimal(self, value)

    def constructProperty_pennation_angle_at_optimal(self, initValue):
        r"""
        constructProperty_pennation_angle_at_optimal(Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Muscle_constructProperty_pennation_angle_at_optimal(self, initValue)

    def get_pennation_angle_at_optimal(self, *args):
        r"""
        get_pennation_angle_at_optimal(Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pennation_angle_at_optimal(Muscle self) -> double const &
        """
        return _simulation.Muscle_get_pennation_angle_at_optimal(self, *args)

    def upd_pennation_angle_at_optimal(self, *args):
        r"""
        upd_pennation_angle_at_optimal(Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_pennation_angle_at_optimal(Muscle self) -> double &
        """
        return _simulation.Muscle_upd_pennation_angle_at_optimal(self, *args)

    def set_pennation_angle_at_optimal(self, *args):
        r"""
        set_pennation_angle_at_optimal(Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_pennation_angle_at_optimal(Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_set_pennation_angle_at_optimal(self, *args)

    def copyProperty_max_contraction_velocity(self, source):
        r"""
        copyProperty_max_contraction_velocity(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_max_contraction_velocity(self, source)

    def append_max_contraction_velocity(self, value):
        r"""
        append_max_contraction_velocity(Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_append_max_contraction_velocity(self, value)

    def constructProperty_max_contraction_velocity(self, initValue):
        r"""
        constructProperty_max_contraction_velocity(Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Muscle_constructProperty_max_contraction_velocity(self, initValue)

    def get_max_contraction_velocity(self, *args):
        r"""
        get_max_contraction_velocity(Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_contraction_velocity(Muscle self) -> double const &
        """
        return _simulation.Muscle_get_max_contraction_velocity(self, *args)

    def upd_max_contraction_velocity(self, *args):
        r"""
        upd_max_contraction_velocity(Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_contraction_velocity(Muscle self) -> double &
        """
        return _simulation.Muscle_upd_max_contraction_velocity(self, *args)

    def set_max_contraction_velocity(self, *args):
        r"""
        set_max_contraction_velocity(Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_contraction_velocity(Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Muscle_set_max_contraction_velocity(self, *args)

    def copyProperty_ignore_tendon_compliance(self, source):
        r"""
        copyProperty_ignore_tendon_compliance(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_ignore_tendon_compliance(self, source)

    def append_ignore_tendon_compliance(self, value):
        r"""
        append_ignore_tendon_compliance(Muscle self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Muscle_append_ignore_tendon_compliance(self, value)

    def constructProperty_ignore_tendon_compliance(self, initValue):
        r"""
        constructProperty_ignore_tendon_compliance(Muscle self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Muscle_constructProperty_ignore_tendon_compliance(self, initValue)

    def get_ignore_tendon_compliance(self, *args):
        r"""
        get_ignore_tendon_compliance(Muscle self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_tendon_compliance(Muscle self) -> bool const &
        """
        return _simulation.Muscle_get_ignore_tendon_compliance(self, *args)

    def upd_ignore_tendon_compliance(self, *args):
        r"""
        upd_ignore_tendon_compliance(Muscle self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_ignore_tendon_compliance(Muscle self) -> bool &
        """
        return _simulation.Muscle_upd_ignore_tendon_compliance(self, *args)

    def set_ignore_tendon_compliance(self, *args):
        r"""
        set_ignore_tendon_compliance(Muscle self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_ignore_tendon_compliance(Muscle self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Muscle_set_ignore_tendon_compliance(self, *args)

    def copyProperty_ignore_activation_dynamics(self, source):
        r"""
        copyProperty_ignore_activation_dynamics(Muscle self, Muscle source)

        Parameters
        ----------
        source: OpenSim::Muscle::Self const &

        """
        return _simulation.Muscle_copyProperty_ignore_activation_dynamics(self, source)

    def append_ignore_activation_dynamics(self, value):
        r"""
        append_ignore_activation_dynamics(Muscle self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Muscle_append_ignore_activation_dynamics(self, value)

    def constructProperty_ignore_activation_dynamics(self, initValue):
        r"""
        constructProperty_ignore_activation_dynamics(Muscle self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.Muscle_constructProperty_ignore_activation_dynamics(self, initValue)

    def get_ignore_activation_dynamics(self, *args):
        r"""
        get_ignore_activation_dynamics(Muscle self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_activation_dynamics(Muscle self) -> bool const &
        """
        return _simulation.Muscle_get_ignore_activation_dynamics(self, *args)

    def upd_ignore_activation_dynamics(self, *args):
        r"""
        upd_ignore_activation_dynamics(Muscle self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_ignore_activation_dynamics(Muscle self) -> bool &
        """
        return _simulation.Muscle_upd_ignore_activation_dynamics(self, *args)

    def set_ignore_activation_dynamics(self, *args):
        r"""
        set_ignore_activation_dynamics(Muscle self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_ignore_activation_dynamics(Muscle self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.Muscle_set_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Muscle__has_output_excitation_get, _simulation.Muscle__has_output_excitation_set, doc=r"""_has_output_excitation : bool""")
    _has_output_activation = property(_simulation.Muscle__has_output_activation_get, _simulation.Muscle__has_output_activation_set, doc=r"""_has_output_activation : bool""")
    _has_output_fiber_length = property(_simulation.Muscle__has_output_fiber_length_get, _simulation.Muscle__has_output_fiber_length_set, doc=r"""_has_output_fiber_length : bool""")
    _has_output_pennation_angle = property(_simulation.Muscle__has_output_pennation_angle_get, _simulation.Muscle__has_output_pennation_angle_set, doc=r"""_has_output_pennation_angle : bool""")
    _has_output_cos_pennation_angle = property(_simulation.Muscle__has_output_cos_pennation_angle_get, _simulation.Muscle__has_output_cos_pennation_angle_set, doc=r"""_has_output_cos_pennation_angle : bool""")
    _has_output_tendon_length = property(_simulation.Muscle__has_output_tendon_length_get, _simulation.Muscle__has_output_tendon_length_set, doc=r"""_has_output_tendon_length : bool""")
    _has_output_normalized_fiber_length = property(_simulation.Muscle__has_output_normalized_fiber_length_get, _simulation.Muscle__has_output_normalized_fiber_length_set, doc=r"""_has_output_normalized_fiber_length : bool""")
    _has_output_fiber_length_along_tendon = property(_simulation.Muscle__has_output_fiber_length_along_tendon_get, _simulation.Muscle__has_output_fiber_length_along_tendon_set, doc=r"""_has_output_fiber_length_along_tendon : bool""")
    _has_output_tendon_strain = property(_simulation.Muscle__has_output_tendon_strain_get, _simulation.Muscle__has_output_tendon_strain_set, doc=r"""_has_output_tendon_strain : bool""")
    _has_output_passive_force_multiplier = property(_simulation.Muscle__has_output_passive_force_multiplier_get, _simulation.Muscle__has_output_passive_force_multiplier_set, doc=r"""_has_output_passive_force_multiplier : bool""")
    _has_output_active_force_length_multiplier = property(_simulation.Muscle__has_output_active_force_length_multiplier_get, _simulation.Muscle__has_output_active_force_length_multiplier_set, doc=r"""_has_output_active_force_length_multiplier : bool""")
    _has_output_fiber_velocity = property(_simulation.Muscle__has_output_fiber_velocity_get, _simulation.Muscle__has_output_fiber_velocity_set, doc=r"""_has_output_fiber_velocity : bool""")
    _has_output_normalized_fiber_velocity = property(_simulation.Muscle__has_output_normalized_fiber_velocity_get, _simulation.Muscle__has_output_normalized_fiber_velocity_set, doc=r"""_has_output_normalized_fiber_velocity : bool""")
    _has_output_fiber_velocity_along_tendon = property(_simulation.Muscle__has_output_fiber_velocity_along_tendon_get, _simulation.Muscle__has_output_fiber_velocity_along_tendon_set, doc=r"""_has_output_fiber_velocity_along_tendon : bool""")
    _has_output_tendon_velocity = property(_simulation.Muscle__has_output_tendon_velocity_get, _simulation.Muscle__has_output_tendon_velocity_set, doc=r"""_has_output_tendon_velocity : bool""")
    _has_output_force_velocity_multiplier = property(_simulation.Muscle__has_output_force_velocity_multiplier_get, _simulation.Muscle__has_output_force_velocity_multiplier_set, doc=r"""_has_output_force_velocity_multiplier : bool""")
    _has_output_pennation_angular_velocity = property(_simulation.Muscle__has_output_pennation_angular_velocity_get, _simulation.Muscle__has_output_pennation_angular_velocity_set, doc=r"""_has_output_pennation_angular_velocity : bool""")
    _has_output_fiber_force = property(_simulation.Muscle__has_output_fiber_force_get, _simulation.Muscle__has_output_fiber_force_set, doc=r"""_has_output_fiber_force : bool""")
    _has_output_fiber_force_along_tendon = property(_simulation.Muscle__has_output_fiber_force_along_tendon_get, _simulation.Muscle__has_output_fiber_force_along_tendon_set, doc=r"""_has_output_fiber_force_along_tendon : bool""")
    _has_output_active_fiber_force = property(_simulation.Muscle__has_output_active_fiber_force_get, _simulation.Muscle__has_output_active_fiber_force_set, doc=r"""_has_output_active_fiber_force : bool""")
    _has_output_passive_fiber_force = property(_simulation.Muscle__has_output_passive_fiber_force_get, _simulation.Muscle__has_output_passive_fiber_force_set, doc=r"""_has_output_passive_fiber_force : bool""")
    _has_output_active_fiber_force_along_tendon = property(_simulation.Muscle__has_output_active_fiber_force_along_tendon_get, _simulation.Muscle__has_output_active_fiber_force_along_tendon_set, doc=r"""_has_output_active_fiber_force_along_tendon : bool""")
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Muscle__has_output_passive_fiber_force_along_tendon_get, _simulation.Muscle__has_output_passive_fiber_force_along_tendon_set, doc=r"""_has_output_passive_fiber_force_along_tendon : bool""")
    _has_output_tendon_force = property(_simulation.Muscle__has_output_tendon_force_get, _simulation.Muscle__has_output_tendon_force_set, doc=r"""_has_output_tendon_force : bool""")
    _has_output_fiber_stiffness = property(_simulation.Muscle__has_output_fiber_stiffness_get, _simulation.Muscle__has_output_fiber_stiffness_set, doc=r"""_has_output_fiber_stiffness : bool""")
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Muscle__has_output_fiber_stiffness_along_tendon_get, _simulation.Muscle__has_output_fiber_stiffness_along_tendon_set, doc=r"""_has_output_fiber_stiffness_along_tendon : bool""")
    _has_output_tendon_stiffness = property(_simulation.Muscle__has_output_tendon_stiffness_get, _simulation.Muscle__has_output_tendon_stiffness_set, doc=r"""_has_output_tendon_stiffness : bool""")
    _has_output_muscle_stiffness = property(_simulation.Muscle__has_output_muscle_stiffness_get, _simulation.Muscle__has_output_muscle_stiffness_set, doc=r"""_has_output_muscle_stiffness : bool""")
    _has_output_fiber_active_power = property(_simulation.Muscle__has_output_fiber_active_power_get, _simulation.Muscle__has_output_fiber_active_power_set, doc=r"""_has_output_fiber_active_power : bool""")
    _has_output_fiber_passive_power = property(_simulation.Muscle__has_output_fiber_passive_power_get, _simulation.Muscle__has_output_fiber_passive_power_set, doc=r"""_has_output_fiber_passive_power : bool""")
    _has_output_tendon_power = property(_simulation.Muscle__has_output_tendon_power_get, _simulation.Muscle__has_output_tendon_power_set, doc=r"""_has_output_tendon_power : bool""")
    _has_output_muscle_power = property(_simulation.Muscle__has_output_muscle_power_get, _simulation.Muscle__has_output_muscle_power_set, doc=r"""_has_output_muscle_power : bool""")

    def getMaxIsometricForce(self):
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Muscle_getMaxIsometricForce(self)

    def setMaxIsometricForce(self, maxIsometricForce):
        r"""
        setMaxIsometricForce(Muscle self, double maxIsometricForce)

        Parameters
        ----------
        maxIsometricForce: double

        """
        return _simulation.Muscle_setMaxIsometricForce(self, maxIsometricForce)

    def getOptimalFiberLength(self):
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Muscle_getOptimalFiberLength(self)

    def setOptimalFiberLength(self, optimalFiberLength):
        r"""
        setOptimalFiberLength(Muscle self, double optimalFiberLength)

        Parameters
        ----------
        optimalFiberLength: double

        """
        return _simulation.Muscle_setOptimalFiberLength(self, optimalFiberLength)

    def getTendonSlackLength(self):
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Muscle_getTendonSlackLength(self)

    def setTendonSlackLength(self, tendonSlackLength):
        r"""
        setTendonSlackLength(Muscle self, double tendonSlackLength)

        Parameters
        ----------
        tendonSlackLength: double

        """
        return _simulation.Muscle_setTendonSlackLength(self, tendonSlackLength)

    def getPennationAngleAtOptimalFiberLength(self):
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Muscle_getPennationAngleAtOptimalFiberLength(self)

    def setPennationAngleAtOptimalFiberLength(self, pennationAngle):
        r"""
        setPennationAngleAtOptimalFiberLength(Muscle self, double pennationAngle)

        Parameters
        ----------
        pennationAngle: double

        """
        return _simulation.Muscle_setPennationAngleAtOptimalFiberLength(self, pennationAngle)

    def getMaxContractionVelocity(self):
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Muscle_getMaxContractionVelocity(self)

    def setMaxContractionVelocity(self, maxContractionVelocity):
        r"""
        setMaxContractionVelocity(Muscle self, double maxContractionVelocity)

        Parameters
        ----------
        maxContractionVelocity: double

        """
        return _simulation.Muscle_setMaxContractionVelocity(self, maxContractionVelocity)

    def getIgnoreTendonCompliance(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Muscle_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s, ignore):
        r"""
        setIgnoreTendonCompliance(Muscle self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Muscle_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Muscle_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s, ignore):
        r"""
        setIgnoreActivationDynamics(Muscle self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Muscle_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s):
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Muscle_getActivation(self, s)

    def getFiberLength(self, s):
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Muscle_getFiberLength(self, s)

    def getPennationAngle(self, s):
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Muscle_getPennationAngle(self, s)

    def getCosPennationAngle(self, s):
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Muscle_getCosPennationAngle(self, s)

    def getTendonLength(self, s):
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Muscle_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s):
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Muscle_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s):
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Muscle_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s):
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Muscle_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Muscle_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Muscle_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s):
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Muscle_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s):
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Muscle_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s):
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Muscle_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s):
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.Muscle_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s):
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Muscle_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s):
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Muscle_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s):
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Muscle_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s):
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Muscle_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s):
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Muscle_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s):
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Muscle_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s):
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Muscle_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s):
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Muscle_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s):
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Muscle_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s):
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Muscle_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s):
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Muscle_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s):
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Muscle_getTendonForce(self, s)

    def getFiberStiffness(self, s):
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Muscle_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.Muscle_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s):
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Muscle_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s):
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Muscle_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s):
        r""" get the current active fiber power (W)"""
        return _simulation.Muscle_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s):
        r""" get the current passive fiber power (W)"""
        return _simulation.Muscle_getFiberPassivePower(self, s)

    def getTendonPower(self, s):
        r""" get the current tendon power (W)"""
        return _simulation.Muscle_getTendonPower(self, s)

    def getMusclePower(self, s):
        r""" get the current muscle power (W)"""
        return _simulation.Muscle_getMusclePower(self, s)

    def getStress(self, s):
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Muscle_getStress(self, s)

    def setExcitation(self, s, excitation):
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Muscle_setExcitation(self, s, excitation)

    def getExcitation(self, s):
        r"""
        getExcitation(Muscle self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Muscle_getExcitation(self, s)

    def setActivation(self, s, activation):
        r""" DEPRECATED: only for backward compatibility"""
        return _simulation.Muscle_setActivation(self, s, activation)

    def computeActuation(self, s):
        r"""
        Actuator interface for a muscle computes the tension in the muscle
               and applied by the tendon to bones (i.e. not the fiber force)
        """
        return _simulation.Muscle_computeActuation(self, s)

    def computeEquilibrium(self, s):
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Muscle_computeEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""Conditional comment:"""
        return _simulation.Muscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)
    __swig_destroy__ = _simulation.delete_Muscle

# Register Muscle in _simulation:
_simulation.Muscle_swigregister(Muscle)
class ActivationFiberLengthMuscle(Muscle):
    r"""
    A base class representing a two-state muscle-tendon actuator.
    It adds activation and fiber-length states and dynamics to the
    Muscle class, but does not implement all of the necessary methods,
    so it is abstract as well. The path information for a muscle is contained
    in the Muscle class, and the force-generating behavior should be defined in
    the derived classes.

    Author: Ajay Seth

    (Based on earlier work by Peter Loan and Frank C. Anderson.)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ActivationFiberLengthMuscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ActivationFiberLengthMuscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ActivationFiberLengthMuscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ActivationFiberLengthMuscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ActivationFiberLengthMuscle_getClassName()

    def clone(self):
        r"""clone(ActivationFiberLengthMuscle self) -> ActivationFiberLengthMuscle"""
        return _simulation.ActivationFiberLengthMuscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActivationFiberLengthMuscle self) -> std::string const &"""
        return _simulation.ActivationFiberLengthMuscle_getConcreteClassName(self)

    def copyProperty_default_activation(self, source):
        r"""
        copyProperty_default_activation(ActivationFiberLengthMuscle self, ActivationFiberLengthMuscle source)

        Parameters
        ----------
        source: OpenSim::ActivationFiberLengthMuscle::Self const &

        """
        return _simulation.ActivationFiberLengthMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value):
        r"""
        append_default_activation(ActivationFiberLengthMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue):
        r"""
        constructProperty_default_activation(ActivationFiberLengthMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(ActivationFiberLengthMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(ActivationFiberLengthMuscle self) -> double const &
        """
        return _simulation.ActivationFiberLengthMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args):
        r"""
        upd_default_activation(ActivationFiberLengthMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_activation(ActivationFiberLengthMuscle self) -> double &
        """
        return _simulation.ActivationFiberLengthMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args):
        r"""
        set_default_activation(ActivationFiberLengthMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_activation(ActivationFiberLengthMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source):
        r"""
        copyProperty_default_fiber_length(ActivationFiberLengthMuscle self, ActivationFiberLengthMuscle source)

        Parameters
        ----------
        source: OpenSim::ActivationFiberLengthMuscle::Self const &

        """
        return _simulation.ActivationFiberLengthMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value):
        r"""
        append_default_fiber_length(ActivationFiberLengthMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue):
        r"""
        constructProperty_default_fiber_length(ActivationFiberLengthMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args):
        r"""
        get_default_fiber_length(ActivationFiberLengthMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_length(ActivationFiberLengthMuscle self) -> double const &
        """
        return _simulation.ActivationFiberLengthMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args):
        r"""
        upd_default_fiber_length(ActivationFiberLengthMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_fiber_length(ActivationFiberLengthMuscle self) -> double &
        """
        return _simulation.ActivationFiberLengthMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args):
        r"""
        set_default_fiber_length(ActivationFiberLengthMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_fiber_length(ActivationFiberLengthMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActivationFiberLengthMuscle_set_default_fiber_length(self, *args)

    def getDefaultActivation(self):
        r"""getDefaultActivation(ActivationFiberLengthMuscle self) -> double"""
        return _simulation.ActivationFiberLengthMuscle_getDefaultActivation(self)

    def setDefaultActivation(self, activation):
        r"""
        setDefaultActivation(ActivationFiberLengthMuscle self, double activation)

        Parameters
        ----------
        activation: double

        """
        return _simulation.ActivationFiberLengthMuscle_setDefaultActivation(self, activation)

    def getDefaultFiberLength(self):
        r"""getDefaultFiberLength(ActivationFiberLengthMuscle self) -> double"""
        return _simulation.ActivationFiberLengthMuscle_getDefaultFiberLength(self)

    def setDefaultFiberLength(self, length):
        r"""
        setDefaultFiberLength(ActivationFiberLengthMuscle self, double length)

        Parameters
        ----------
        length: double

        """
        return _simulation.ActivationFiberLengthMuscle_setDefaultFiberLength(self, length)

    def setActivation(self, s, activation):
        r"""
        setActivation(ActivationFiberLengthMuscle self, State s, double activation)

        Parameters
        ----------
        s: SimTK::State &
        activation: double

        """
        return _simulation.ActivationFiberLengthMuscle_setActivation(self, s, activation)

    def setFiberLength(self, s, fiberLength):
        r"""
        setFiberLength(ActivationFiberLengthMuscle self, State s, double fiberLength)

        Parameters
        ----------
        s: SimTK::State &
        fiberLength: double

        """
        return _simulation.ActivationFiberLengthMuscle_setFiberLength(self, s, fiberLength)

    def getActivationRate(self, s):
        r"""
        getActivationRate(ActivationFiberLengthMuscle self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ActivationFiberLengthMuscle_getActivationRate(self, s)

    def extendPostScale(self, s, scaleSet):
        r"""
        Adjust the properties of the muscle after the model has been scaled. The
               optimal fiber length and tendon slack length are each multiplied by the
               ratio of the current path length and the path length before scaling.
        """
        return _simulation.ActivationFiberLengthMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_ActivationFiberLengthMuscle

# Register ActivationFiberLengthMuscle in _simulation:
_simulation.ActivationFiberLengthMuscle_swigregister(ActivationFiberLengthMuscle)
class PointToPointSpring(Force):
    r"""
    A simple point to point spring with a resting length and stiffness.
    Points are connected to bodies and are defined in the body frame.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointToPointSpring

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PointToPointSpring_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointToPointSpring self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PointToPointSpring_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PointToPointSpring_getClassName()

    def clone(self):
        r"""clone(PointToPointSpring self) -> PointToPointSpring"""
        return _simulation.PointToPointSpring_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointToPointSpring self) -> std::string const &"""
        return _simulation.PointToPointSpring_getConcreteClassName(self)

    def copyProperty_point1(self, source):
        r"""
        copyProperty_point1(PointToPointSpring self, PointToPointSpring source)

        Parameters
        ----------
        source: OpenSim::PointToPointSpring::Self const &

        """
        return _simulation.PointToPointSpring_copyProperty_point1(self, source)

    def append_point1(self, value):
        r"""
        append_point1(PointToPointSpring self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_append_point1(self, value)

    def constructProperty_point1(self, initValue):
        r"""
        constructProperty_point1(PointToPointSpring self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_constructProperty_point1(self, initValue)

    def get_point1(self, *args):
        r"""
        get_point1(PointToPointSpring self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point1(PointToPointSpring self) -> Vec3
        """
        return _simulation.PointToPointSpring_get_point1(self, *args)

    def upd_point1(self, *args):
        r"""
        upd_point1(PointToPointSpring self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point1(PointToPointSpring self) -> Vec3
        """
        return _simulation.PointToPointSpring_upd_point1(self, *args)

    def set_point1(self, *args):
        r"""
        set_point1(PointToPointSpring self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point1(PointToPointSpring self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_set_point1(self, *args)

    def copyProperty_point2(self, source):
        r"""
        copyProperty_point2(PointToPointSpring self, PointToPointSpring source)

        Parameters
        ----------
        source: OpenSim::PointToPointSpring::Self const &

        """
        return _simulation.PointToPointSpring_copyProperty_point2(self, source)

    def append_point2(self, value):
        r"""
        append_point2(PointToPointSpring self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_append_point2(self, value)

    def constructProperty_point2(self, initValue):
        r"""
        constructProperty_point2(PointToPointSpring self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_constructProperty_point2(self, initValue)

    def get_point2(self, *args):
        r"""
        get_point2(PointToPointSpring self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point2(PointToPointSpring self) -> Vec3
        """
        return _simulation.PointToPointSpring_get_point2(self, *args)

    def upd_point2(self, *args):
        r"""
        upd_point2(PointToPointSpring self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point2(PointToPointSpring self) -> Vec3
        """
        return _simulation.PointToPointSpring_upd_point2(self, *args)

    def set_point2(self, *args):
        r"""
        set_point2(PointToPointSpring self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point2(PointToPointSpring self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.PointToPointSpring_set_point2(self, *args)

    def copyProperty_stiffness(self, source):
        r"""
        copyProperty_stiffness(PointToPointSpring self, PointToPointSpring source)

        Parameters
        ----------
        source: OpenSim::PointToPointSpring::Self const &

        """
        return _simulation.PointToPointSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value):
        r"""
        append_stiffness(PointToPointSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PointToPointSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue):
        r"""
        constructProperty_stiffness(PointToPointSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PointToPointSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args):
        r"""
        get_stiffness(PointToPointSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness(PointToPointSpring self) -> double const &
        """
        return _simulation.PointToPointSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args):
        r"""
        upd_stiffness(PointToPointSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness(PointToPointSpring self) -> double &
        """
        return _simulation.PointToPointSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args):
        r"""
        set_stiffness(PointToPointSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness(PointToPointSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PointToPointSpring_set_stiffness(self, *args)

    def copyProperty_rest_length(self, source):
        r"""
        copyProperty_rest_length(PointToPointSpring self, PointToPointSpring source)

        Parameters
        ----------
        source: OpenSim::PointToPointSpring::Self const &

        """
        return _simulation.PointToPointSpring_copyProperty_rest_length(self, source)

    def append_rest_length(self, value):
        r"""
        append_rest_length(PointToPointSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PointToPointSpring_append_rest_length(self, value)

    def constructProperty_rest_length(self, initValue):
        r"""
        constructProperty_rest_length(PointToPointSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PointToPointSpring_constructProperty_rest_length(self, initValue)

    def get_rest_length(self, *args):
        r"""
        get_rest_length(PointToPointSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_rest_length(PointToPointSpring self) -> double const &
        """
        return _simulation.PointToPointSpring_get_rest_length(self, *args)

    def upd_rest_length(self, *args):
        r"""
        upd_rest_length(PointToPointSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_rest_length(PointToPointSpring self) -> double &
        """
        return _simulation.PointToPointSpring_upd_rest_length(self, *args)

    def set_rest_length(self, *args):
        r"""
        set_rest_length(PointToPointSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_rest_length(PointToPointSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PointToPointSpring_set_rest_length(self, *args)
    PropertyIndex_socket_body1 = property(_simulation.PointToPointSpring_PropertyIndex_socket_body1_get, _simulation.PointToPointSpring_PropertyIndex_socket_body1_set, doc=r"""PropertyIndex_socket_body1 : OpenSim::PropertyIndex""")

    def connectSocket_body1(self, object):
        r"""
        connectSocket_body1(PointToPointSpring self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointToPointSpring_connectSocket_body1(self, object)
    PropertyIndex_socket_body2 = property(_simulation.PointToPointSpring_PropertyIndex_socket_body2_get, _simulation.PointToPointSpring_PropertyIndex_socket_body2_set, doc=r"""PropertyIndex_socket_body2 : OpenSim::PropertyIndex""")

    def connectSocket_body2(self, object):
        r"""
        connectSocket_body2(PointToPointSpring self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.PointToPointSpring_connectSocket_body2(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type body1: :py:class:`PhysicalFrame`
           :param body1:        the first body to which the spring is attached
           :type point1: :py:class:`Vec3`
           :param point1:       location where spring is attached on body1
           :type body2: :py:class:`PhysicalFrame`
           :param body2:        the second body to which the spring is attached
           :type point2: :py:class:`Vec3`
           :param point2:       location where spring is attached on body2
           :type stiffness: float
           :param stiffness:    spring stiffness
           :type restlength: float
           :param restlength:   the resting (zero force) length of the spring
        """
        _simulation.PointToPointSpring_swiginit(self, _simulation.new_PointToPointSpring(*args))

    def setBody1(self, body):
        r"""Spring end point bodies"""
        return _simulation.PointToPointSpring_setBody1(self, body)

    def setBody2(self, body):
        r"""
        setBody2(PointToPointSpring self, PhysicalFrame body)

        Parameters
        ----------
        body: OpenSim::PhysicalFrame const &

        """
        return _simulation.PointToPointSpring_setBody2(self, body)

    def getBody1(self):
        r"""getBody1(PointToPointSpring self) -> PhysicalFrame"""
        return _simulation.PointToPointSpring_getBody1(self)

    def getBody2(self):
        r"""getBody2(PointToPointSpring self) -> PhysicalFrame"""
        return _simulation.PointToPointSpring_getBody2(self)

    def setPoint1(self, aPosition):
        r"""Spring end points"""
        return _simulation.PointToPointSpring_setPoint1(self, aPosition)

    def getPoint1(self):
        r"""getPoint1(PointToPointSpring self) -> Vec3"""
        return _simulation.PointToPointSpring_getPoint1(self)

    def setPoint2(self, aPosition):
        r"""
        setPoint2(PointToPointSpring self, Vec3 aPosition)

        Parameters
        ----------
        aPosition: SimTK::Vec3

        """
        return _simulation.PointToPointSpring_setPoint2(self, aPosition)

    def getPoint2(self):
        r"""getPoint2(PointToPointSpring self) -> Vec3"""
        return _simulation.PointToPointSpring_getPoint2(self)

    def setStiffness(self, stiffness):
        r"""
        Spring stiffness
        :type stiffness: float
        :param stiffness:
        """
        return _simulation.PointToPointSpring_setStiffness(self, stiffness)

    def getStiffness(self):
        r"""getStiffness(PointToPointSpring self) -> double"""
        return _simulation.PointToPointSpring_getStiffness(self)

    def setRestlength(self, restLength):
        r"""
        Spring resting length
        :type restLength: float
        :param restLength:
        """
        return _simulation.PointToPointSpring_setRestlength(self, restLength)

    def getRestlength(self):
        r"""getRestlength(PointToPointSpring self) -> double"""
        return _simulation.PointToPointSpring_getRestlength(self)

    def getRecordLabels(self):
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.PointToPointSpring_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.PointToPointSpring_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_PointToPointSpring

# Register PointToPointSpring in _simulation:
_simulation.PointToPointSpring_swigregister(PointToPointSpring)
class ExpressionBasedPointToPointForce(ForceProducer):
    r"""
    A point-to-point Force whose force magnitude is determined by a user-defined
    expression, with the distance (d) and its time derivative (ddot) as variables.
    The direction of the force is directed along the line connecting the two
    points.

    "d" and "ddot" are the variables names expected by the expression parser.
    Common C math library functions such as: exp(), pow(), sqrt(), sin(), ...
    are permitted. See Lepton/Operation.h for a complete list.

    For example: string expression = "-1.5*exp(10*(d-0.25)^2)*(1 + 2.0*ddot)"
                 provides a model of a nonlinear point-to point spring, while
                 expression = "1.25/(rd^2)" is an electric field force between
                 charged particles at points separated by the distance, d.
                 i.e. K*q1*q2 = 1.25

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExpressionBasedPointToPointForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExpressionBasedPointToPointForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExpressionBasedPointToPointForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExpressionBasedPointToPointForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExpressionBasedPointToPointForce_getClassName()

    def clone(self):
        r"""clone(ExpressionBasedPointToPointForce self) -> ExpressionBasedPointToPointForce"""
        return _simulation.ExpressionBasedPointToPointForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExpressionBasedPointToPointForce self) -> std::string const &"""
        return _simulation.ExpressionBasedPointToPointForce_getConcreteClassName(self)

    def copyProperty_body1(self, source):
        r"""
        copyProperty_body1(ExpressionBasedPointToPointForce self, ExpressionBasedPointToPointForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPointToPointForce::Self const &

        """
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_body1(self, source)

    def append_body1(self, value):
        r"""
        append_body1(ExpressionBasedPointToPointForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_append_body1(self, value)

    def constructProperty_body1(self, *args):
        r"""
        constructProperty_body1(ExpressionBasedPointToPointForce self)
        constructProperty_body1(ExpressionBasedPointToPointForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_body1(self, *args)

    def get_body1(self, *args):
        r"""
        get_body1(ExpressionBasedPointToPointForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_body1(ExpressionBasedPointToPointForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedPointToPointForce_get_body1(self, *args)

    def upd_body1(self, *args):
        r"""
        upd_body1(ExpressionBasedPointToPointForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_body1(ExpressionBasedPointToPointForce self) -> std::string &
        """
        return _simulation.ExpressionBasedPointToPointForce_upd_body1(self, *args)

    def set_body1(self, *args):
        r"""
        set_body1(ExpressionBasedPointToPointForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_body1(ExpressionBasedPointToPointForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_set_body1(self, *args)

    def copyProperty_body2(self, source):
        r"""
        copyProperty_body2(ExpressionBasedPointToPointForce self, ExpressionBasedPointToPointForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPointToPointForce::Self const &

        """
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_body2(self, source)

    def append_body2(self, value):
        r"""
        append_body2(ExpressionBasedPointToPointForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_append_body2(self, value)

    def constructProperty_body2(self, *args):
        r"""
        constructProperty_body2(ExpressionBasedPointToPointForce self)
        constructProperty_body2(ExpressionBasedPointToPointForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_body2(self, *args)

    def get_body2(self, *args):
        r"""
        get_body2(ExpressionBasedPointToPointForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_body2(ExpressionBasedPointToPointForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedPointToPointForce_get_body2(self, *args)

    def upd_body2(self, *args):
        r"""
        upd_body2(ExpressionBasedPointToPointForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_body2(ExpressionBasedPointToPointForce self) -> std::string &
        """
        return _simulation.ExpressionBasedPointToPointForce_upd_body2(self, *args)

    def set_body2(self, *args):
        r"""
        set_body2(ExpressionBasedPointToPointForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_body2(ExpressionBasedPointToPointForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_set_body2(self, *args)

    def copyProperty_point1(self, source):
        r"""
        copyProperty_point1(ExpressionBasedPointToPointForce self, ExpressionBasedPointToPointForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPointToPointForce::Self const &

        """
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_point1(self, source)

    def append_point1(self, value):
        r"""
        append_point1(ExpressionBasedPointToPointForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_append_point1(self, value)

    def constructProperty_point1(self, initValue):
        r"""
        constructProperty_point1(ExpressionBasedPointToPointForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_point1(self, initValue)

    def get_point1(self, *args):
        r"""
        get_point1(ExpressionBasedPointToPointForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point1(ExpressionBasedPointToPointForce self) -> Vec3
        """
        return _simulation.ExpressionBasedPointToPointForce_get_point1(self, *args)

    def upd_point1(self, *args):
        r"""
        upd_point1(ExpressionBasedPointToPointForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point1(ExpressionBasedPointToPointForce self) -> Vec3
        """
        return _simulation.ExpressionBasedPointToPointForce_upd_point1(self, *args)

    def set_point1(self, *args):
        r"""
        set_point1(ExpressionBasedPointToPointForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point1(ExpressionBasedPointToPointForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_set_point1(self, *args)

    def copyProperty_point2(self, source):
        r"""
        copyProperty_point2(ExpressionBasedPointToPointForce self, ExpressionBasedPointToPointForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPointToPointForce::Self const &

        """
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_point2(self, source)

    def append_point2(self, value):
        r"""
        append_point2(ExpressionBasedPointToPointForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_append_point2(self, value)

    def constructProperty_point2(self, initValue):
        r"""
        constructProperty_point2(ExpressionBasedPointToPointForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_point2(self, initValue)

    def get_point2(self, *args):
        r"""
        get_point2(ExpressionBasedPointToPointForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point2(ExpressionBasedPointToPointForce self) -> Vec3
        """
        return _simulation.ExpressionBasedPointToPointForce_get_point2(self, *args)

    def upd_point2(self, *args):
        r"""
        upd_point2(ExpressionBasedPointToPointForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point2(ExpressionBasedPointToPointForce self) -> Vec3
        """
        return _simulation.ExpressionBasedPointToPointForce_upd_point2(self, *args)

    def set_point2(self, *args):
        r"""
        set_point2(ExpressionBasedPointToPointForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point2(ExpressionBasedPointToPointForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedPointToPointForce_set_point2(self, *args)

    def copyProperty_expression(self, source):
        r"""
        copyProperty_expression(ExpressionBasedPointToPointForce self, ExpressionBasedPointToPointForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPointToPointForce::Self const &

        """
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_expression(self, source)

    def append_expression(self, value):
        r"""
        append_expression(ExpressionBasedPointToPointForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_append_expression(self, value)

    def constructProperty_expression(self, initValue):
        r"""
        constructProperty_expression(ExpressionBasedPointToPointForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_expression(self, initValue)

    def get_expression(self, *args):
        r"""
        get_expression(ExpressionBasedPointToPointForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_expression(ExpressionBasedPointToPointForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedPointToPointForce_get_expression(self, *args)

    def upd_expression(self, *args):
        r"""
        upd_expression(ExpressionBasedPointToPointForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_expression(ExpressionBasedPointToPointForce self) -> std::string &
        """
        return _simulation.ExpressionBasedPointToPointForce_upd_expression(self, *args)

    def set_expression(self, *args):
        r"""
        set_expression(ExpressionBasedPointToPointForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_expression(ExpressionBasedPointToPointForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_set_expression(self, *args)
    _has_output_force_magnitude = property(_simulation.ExpressionBasedPointToPointForce__has_output_force_magnitude_get, _simulation.ExpressionBasedPointToPointForce__has_output_force_magnitude_set, doc=r"""_has_output_force_magnitude : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type body1Name: string
           :param body1Name:    name of the first body to which the p2p force is attached
           :type point1: :py:class:`Vec3`
           :param point1:       first point location attached to body1
           :type body2Name: string
           :param body2Name:    name of the second body to which the p2p force is attached
           :type point2: :py:class:`Vec3`
           :param point2:       second  point location attached to body2
           :type expression: string
           :param expression:   the expression used to compute the force action at points
        """
        _simulation.ExpressionBasedPointToPointForce_swiginit(self, _simulation.new_ExpressionBasedPointToPointForce(*args))

    def setBody1Name(self, body1Name):
        r"""Force end point bodies"""
        return _simulation.ExpressionBasedPointToPointForce_setBody1Name(self, body1Name)

    def setBody2Name(self, body2Name):
        r"""
        setBody2Name(ExpressionBasedPointToPointForce self, std::string const & body2Name)

        Parameters
        ----------
        body2Name: std::string const &

        """
        return _simulation.ExpressionBasedPointToPointForce_setBody2Name(self, body2Name)

    def getBody1Name(self):
        r"""getBody1Name(ExpressionBasedPointToPointForce self) -> std::string const &"""
        return _simulation.ExpressionBasedPointToPointForce_getBody1Name(self)

    def getBody2Name(self):
        r"""getBody2Name(ExpressionBasedPointToPointForce self) -> std::string const &"""
        return _simulation.ExpressionBasedPointToPointForce_getBody2Name(self)

    def setPoint1(self, aPosition):
        r"""Force end points"""
        return _simulation.ExpressionBasedPointToPointForce_setPoint1(self, aPosition)

    def getPoint1(self):
        r"""getPoint1(ExpressionBasedPointToPointForce self) -> Vec3"""
        return _simulation.ExpressionBasedPointToPointForce_getPoint1(self)

    def setPoint2(self, aPosition):
        r"""
        setPoint2(ExpressionBasedPointToPointForce self, Vec3 aPosition)

        Parameters
        ----------
        aPosition: SimTK::Vec3

        """
        return _simulation.ExpressionBasedPointToPointForce_setPoint2(self, aPosition)

    def getPoint2(self):
        r"""getPoint2(ExpressionBasedPointToPointForce self) -> Vec3"""
        return _simulation.ExpressionBasedPointToPointForce_getPoint2(self)

    def setExpression(self, expression):
        r"""
        %Set the mathematical expression that defines the force magnitude of this
        point-to-point force in terms of the point-to-point distance (d) and its
        time derivative (ddot). Expressions with C-mathematical operations
        such as +,-,*,/ and common functions: exp, pow, sqrt, sin, cos, tan,
        and so on are acceptable.
        NOTE: a limitation is that the expression may not contain whitespace
        :type expression: string
        :param expression:    string containing the mathematical expression that
                                 defines the point-to-point force
        """
        return _simulation.ExpressionBasedPointToPointForce_setExpression(self, expression)

    def getForceMagnitude(self, state):
        r"""
        Get the computed Force magnitude determined by evaluating the
        expression above. Note, computeForce must be evaluated first,
        and this is done automatically if the system is realized to Dynamics
        :type state: :py:class:`State`
        :param state:    const state (reference) for the model
        :rtype: float
        :return: const double ref to the force magnitude
        """
        return _simulation.ExpressionBasedPointToPointForce_getForceMagnitude(self, state)

    def getRecordLabels(self):
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ExpressionBasedPointToPointForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedPointToPointForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedPointToPointForce

# Register ExpressionBasedPointToPointForce in _simulation:
_simulation.ExpressionBasedPointToPointForce_swigregister(ExpressionBasedPointToPointForce)
class ExpressionBasedCoordinateForce(ForceProducer):
    r"""Proxy of C++ OpenSim::ExpressionBasedCoordinateForce class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExpressionBasedCoordinateForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExpressionBasedCoordinateForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExpressionBasedCoordinateForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExpressionBasedCoordinateForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExpressionBasedCoordinateForce_getClassName()

    def clone(self):
        r"""clone(ExpressionBasedCoordinateForce self) -> ExpressionBasedCoordinateForce"""
        return _simulation.ExpressionBasedCoordinateForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExpressionBasedCoordinateForce self) -> std::string const &"""
        return _simulation.ExpressionBasedCoordinateForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source):
        r"""
        copyProperty_coordinate(ExpressionBasedCoordinateForce self, ExpressionBasedCoordinateForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedCoordinateForce::Self const &

        """
        return _simulation.ExpressionBasedCoordinateForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value):
        r"""
        append_coordinate(ExpressionBasedCoordinateForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, initValue):
        r"""
        constructProperty_coordinate(ExpressionBasedCoordinateForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_constructProperty_coordinate(self, initValue)

    def get_coordinate(self, *args):
        r"""
        get_coordinate(ExpressionBasedCoordinateForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_coordinate(ExpressionBasedCoordinateForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedCoordinateForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args):
        r"""
        upd_coordinate(ExpressionBasedCoordinateForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_coordinate(ExpressionBasedCoordinateForce self) -> std::string &
        """
        return _simulation.ExpressionBasedCoordinateForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args):
        r"""
        set_coordinate(ExpressionBasedCoordinateForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_coordinate(ExpressionBasedCoordinateForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_set_coordinate(self, *args)

    def copyProperty_expression(self, source):
        r"""
        copyProperty_expression(ExpressionBasedCoordinateForce self, ExpressionBasedCoordinateForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedCoordinateForce::Self const &

        """
        return _simulation.ExpressionBasedCoordinateForce_copyProperty_expression(self, source)

    def append_expression(self, value):
        r"""
        append_expression(ExpressionBasedCoordinateForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_append_expression(self, value)

    def constructProperty_expression(self, initValue):
        r"""
        constructProperty_expression(ExpressionBasedCoordinateForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_constructProperty_expression(self, initValue)

    def get_expression(self, *args):
        r"""
        get_expression(ExpressionBasedCoordinateForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_expression(ExpressionBasedCoordinateForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedCoordinateForce_get_expression(self, *args)

    def upd_expression(self, *args):
        r"""
        upd_expression(ExpressionBasedCoordinateForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_expression(ExpressionBasedCoordinateForce self) -> std::string &
        """
        return _simulation.ExpressionBasedCoordinateForce_upd_expression(self, *args)

    def set_expression(self, *args):
        r"""
        set_expression(ExpressionBasedCoordinateForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_expression(ExpressionBasedCoordinateForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedCoordinateForce_set_expression(self, *args)
    _has_output_force_magnitude = property(_simulation.ExpressionBasedCoordinateForce__has_output_force_magnitude_get, _simulation.ExpressionBasedCoordinateForce__has_output_force_magnitude_set, doc=r"""_has_output_force_magnitude : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type coordinate: string
           :param coordinate:   name of the coordinate to apply the force to
           :type expression: string
           :param expression:   the expression used to compute the force magnitude
        """
        _simulation.ExpressionBasedCoordinateForce_swiginit(self, _simulation.new_ExpressionBasedCoordinateForce(*args))

    def setCoordinateName(self, coord):
        r"""Coordinate"""
        return _simulation.ExpressionBasedCoordinateForce_setCoordinateName(self, coord)

    def getCoordinateName(self):
        r"""getCoordinateName(ExpressionBasedCoordinateForce self) -> std::string const &"""
        return _simulation.ExpressionBasedCoordinateForce_getCoordinateName(self)

    def setExpression(self, expression):
        r"""
        %Set the mathematical expression that defines the force magnitude of this
        coordinate force in terms of the coordinate value (q) and its
        time derivative (qdot). Expressions with C-mathematical operations
        such as +,-,*,/ and common functions: exp, pow, sqrt, sin, cos, tan,
        and so on are acceptable.
        NOTE: a limitation is that the expression may not contain whitespace
        :type expression: string
        :param expression:    string containing the mathematical expression that
                                 defines the coordinate force
        """
        return _simulation.ExpressionBasedCoordinateForce_setExpression(self, expression)

    def getForceMagnitude(self, state):
        r"""
        Get the computed Force magnitude determined by evaluating the
        expression above. Note, computeForce must be evaluated first,
        and this is done automatically if the system is realized to Dynamics
        :type state: :py:class:`State`
        :param state:    const state (reference) for the model
        :rtype: float
        :return: const double ref to the force magnitude
        """
        return _simulation.ExpressionBasedCoordinateForce_getForceMagnitude(self, state)

    def calcExpressionForce(self, s):
        r""" Force calculation operator. *"""
        return _simulation.ExpressionBasedCoordinateForce_calcExpressionForce(self, s)

    def getRecordLabels(self):
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ExpressionBasedCoordinateForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedCoordinateForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedCoordinateForce

# Register ExpressionBasedCoordinateForce in _simulation:
_simulation.ExpressionBasedCoordinateForce_swigregister(ExpressionBasedCoordinateForce)
class PathSpring(ForceProducer):
    r"""
    A class implementing a PathSpring. The path of the PathSpring is
    determined by an object derived from AbstractGeometryPath. A PathSpring is a
    massless Force element which applies tension along a path connected to bodies
    and can wrap over surfaces.  The tension is proportional to its stretch
    beyond its resting length and the amount of dissipation scales with amount of
    stretch, such that tension = (K*s)*(1+D*ldot) where stretch, s = l-lo for
    l > lo, and 0 otherwise. l is the path length of the spring and lo is its
    rest length. K is the linear stiffness and D is the dissipation factor.
    When l < lo the spring applies no tension to the bodies and considered
    to be slack.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PathSpring

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PathSpring_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PathSpring self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PathSpring_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PathSpring_getClassName()

    def clone(self):
        r"""clone(PathSpring self) -> PathSpring"""
        return _simulation.PathSpring_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PathSpring self) -> std::string const &"""
        return _simulation.PathSpring_getConcreteClassName(self)

    def copyProperty_resting_length(self, source):
        r"""
        copyProperty_resting_length(PathSpring self, PathSpring source)

        Parameters
        ----------
        source: OpenSim::PathSpring::Self const &

        """
        return _simulation.PathSpring_copyProperty_resting_length(self, source)

    def append_resting_length(self, value):
        r"""
        append_resting_length(PathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_append_resting_length(self, value)

    def constructProperty_resting_length(self, initValue):
        r"""
        constructProperty_resting_length(PathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PathSpring_constructProperty_resting_length(self, initValue)

    def get_resting_length(self, *args):
        r"""
        get_resting_length(PathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_resting_length(PathSpring self) -> double const &
        """
        return _simulation.PathSpring_get_resting_length(self, *args)

    def upd_resting_length(self, *args):
        r"""
        upd_resting_length(PathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_resting_length(PathSpring self) -> double &
        """
        return _simulation.PathSpring_upd_resting_length(self, *args)

    def set_resting_length(self, *args):
        r"""
        set_resting_length(PathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_resting_length(PathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_set_resting_length(self, *args)

    def copyProperty_stiffness(self, source):
        r"""
        copyProperty_stiffness(PathSpring self, PathSpring source)

        Parameters
        ----------
        source: OpenSim::PathSpring::Self const &

        """
        return _simulation.PathSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value):
        r"""
        append_stiffness(PathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue):
        r"""
        constructProperty_stiffness(PathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PathSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args):
        r"""
        get_stiffness(PathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness(PathSpring self) -> double const &
        """
        return _simulation.PathSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args):
        r"""
        upd_stiffness(PathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness(PathSpring self) -> double &
        """
        return _simulation.PathSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args):
        r"""
        set_stiffness(PathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness(PathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source):
        r"""
        copyProperty_dissipation(PathSpring self, PathSpring source)

        Parameters
        ----------
        source: OpenSim::PathSpring::Self const &

        """
        return _simulation.PathSpring_copyProperty_dissipation(self, source)

    def append_dissipation(self, value):
        r"""
        append_dissipation(PathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue):
        r"""
        constructProperty_dissipation(PathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.PathSpring_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args):
        r"""
        get_dissipation(PathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_dissipation(PathSpring self) -> double const &
        """
        return _simulation.PathSpring_get_dissipation(self, *args)

    def upd_dissipation(self, *args):
        r"""
        upd_dissipation(PathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_dissipation(PathSpring self) -> double &
        """
        return _simulation.PathSpring_upd_dissipation(self, *args)

    def set_dissipation(self, *args):
        r"""
        set_dissipation(PathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_dissipation(PathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.PathSpring_set_dissipation(self, *args)

    def copyProperty_path(self, source):
        r"""
        copyProperty_path(PathSpring self, PathSpring source)

        Parameters
        ----------
        source: OpenSim::PathSpring::Self const &

        """
        return _simulation.PathSpring_copyProperty_path(self, source)

    def append_path(self, value):
        r"""
        append_path(PathSpring self, AbstractGeometryPath value) -> int

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathSpring_append_path(self, value)

    def constructProperty_path(self, initValue):
        r"""
        constructProperty_path(PathSpring self, AbstractGeometryPath initValue)

        Parameters
        ----------
        initValue: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathSpring_constructProperty_path(self, initValue)

    def get_path(self, *args):
        r"""
        get_path(PathSpring self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(PathSpring self) -> AbstractGeometryPath
        """
        return _simulation.PathSpring_get_path(self, *args)

    def upd_path(self, *args):
        r"""
        upd_path(PathSpring self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        upd_path(PathSpring self) -> AbstractGeometryPath
        """
        return _simulation.PathSpring_upd_path(self, *args)

    def set_path(self, *args):
        r"""
        set_path(PathSpring self, int i, AbstractGeometryPath value)

        Parameters
        ----------
        i: int
        value: OpenSim::AbstractGeometryPath const &

        set_path(PathSpring self, AbstractGeometryPath value)

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.PathSpring_set_path(self, *args)
    _has_output_length = property(_simulation.PathSpring__has_output_length_get, _simulation.PathSpring__has_output_length_set, doc=r"""_has_output_length : bool""")
    _has_output_stretch = property(_simulation.PathSpring__has_output_stretch_get, _simulation.PathSpring__has_output_stretch_set, doc=r"""_has_output_stretch : bool""")
    _has_output_lengthening_speed = property(_simulation.PathSpring__has_output_lengthening_speed_get, _simulation.PathSpring__has_output_lengthening_speed_set, doc=r"""_has_output_lengthening_speed : bool""")
    _has_output_tension = property(_simulation.PathSpring__has_output_tension_get, _simulation.PathSpring__has_output_tension_set, doc=r"""_has_output_tension : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a PathSpring with default parameters. Users should note
            that the default values for resting_length, stiffness, and dissipation
            are `NaN` so they must be set before simulating.

        |

        *Overload 2:*
         Convenience constructor with PathSpring parameters
        :type name: string
        :param name:          name of this %PathSpring Object
        :type restLength: float
        :param restLength:    the spring's resting length
        :type stiffness: float
        :param stiffness:     the spring stiffness
        :type dissipation: float
        :param dissipation:   the dissipation factor
        """
        _simulation.PathSpring_swiginit(self, _simulation.new_PathSpring(*args))

    def getRestingLength(self):
        r""" get/set the resting length"""
        return _simulation.PathSpring_getRestingLength(self)

    def setRestingLength(self, restingLength):
        r"""
        setRestingLength(PathSpring self, double restingLength)

        Parameters
        ----------
        restingLength: double

        """
        return _simulation.PathSpring_setRestingLength(self, restingLength)

    def getStiffness(self):
        r""" get/set the stiffness"""
        return _simulation.PathSpring_getStiffness(self)

    def setStiffness(self, stiffness):
        r"""
        setStiffness(PathSpring self, double stiffness)

        Parameters
        ----------
        stiffness: double

        """
        return _simulation.PathSpring_setStiffness(self, stiffness)

    def getDissipation(self):
        r""" get/set the dissipation factor"""
        return _simulation.PathSpring_getDissipation(self)

    def setDissipation(self, dissipation):
        r"""
        setDissipation(PathSpring self, double dissipation)

        Parameters
        ----------
        dissipation: double

        """
        return _simulation.PathSpring_setDissipation(self, dissipation)

    def updPath(self):
        r""" get/set the path object"""
        return _simulation.PathSpring_updPath(self)

    def getPath(self):
        r"""getPath(PathSpring self) -> AbstractGeometryPath"""
        return _simulation.PathSpring_getPath(self)

    def updGeometryPath(self):
        r"""updGeometryPath(PathSpring self) -> GeometryPath"""
        return _simulation.PathSpring_updGeometryPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(PathSpring self) -> GeometryPath"""
        return _simulation.PathSpring_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(PathSpring self) -> bool"""
        return _simulation.PathSpring_hasVisualPath(self)

    def getLength(self, s):
        r""" get the length of the PathSpring. Accessible at Stage::Position"""
        return _simulation.PathSpring_getLength(self, s)

    def getStretch(self, s):
        r"""
        get the stretch in the PathSpring. The value of the stretch
               can only be obtained after the system as be realized to Stage::Position
        """
        return _simulation.PathSpring_getStretch(self, s)

    def getLengtheningSpeed(self, s):
        r""" get the length of the PathSpring. Accessible at Stage::Velocity"""
        return _simulation.PathSpring_getLengtheningSpeed(self, s)

    def getTension(self, s):
        r"""
        get the tension generated by the PathSpring. The value of the tension
               can only be obtained after the system as be realized to Stage::Dynamics
        """
        return _simulation.PathSpring_getTension(self, s)

    def computeMomentArm(self, s, aCoord):
        r""" compute the moment-arm of the PathSpring about a coordinate of interest."""
        return _simulation.PathSpring_computeMomentArm(self, s, aCoord)

    def extendPostScale(self, s, scaleSet):
        r"""
        Adjust the resting length of the path spring after the model has been
               scaled. The `resting_length` property is multiplied by the quotient of
               the current path length and the path length before scaling.
        """
        return _simulation.PathSpring_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_PathSpring

# Register PathSpring in _simulation:
_simulation.PathSpring_swigregister(PathSpring)
class ExpressionBasedPathForce(ForceProducer):
    r"""
    A massless, path-based Force whose force magnitude is determined by a
    user-defined expression, with the path stretch (`s = l-l0`) and the path
    speed (`ldot`) as variables, where `l` is the path length and `l0` is the
    rest length. The path of the ExpressionBasedPathForce is determined by an
    object derived from AbstractGeometryPath.

    "s" and "ldot" are the variables names expected by the expression parser.
    Common C math library functions such as: exp(), pow(), sqrt(), sin(), ...
    are permitted. See Lepton/Operation.h for a complete list.

    By default, the ExpressionBasedPathForce will not apply tension when the
    path stretch is negative (i.e., when the path is shorter than its resting
    length). This behavior can be modified by setting the `clamp_stretch`
    property via `setClampStretch()`. Clamping the path stretch creates a
    discontinuity in the force profile, which may not be desired during gradient
    based optimization.

    For example: string expression = "-1.5*exp(10*(d-0.25)^2)*(1 + 2.0*ddot)"
                 provides a model of a path force with non-linear stiffness
                 and damping.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExpressionBasedPathForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExpressionBasedPathForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExpressionBasedPathForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExpressionBasedPathForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExpressionBasedPathForce_getClassName()

    def clone(self):
        r"""clone(ExpressionBasedPathForce self) -> ExpressionBasedPathForce"""
        return _simulation.ExpressionBasedPathForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExpressionBasedPathForce self) -> std::string const &"""
        return _simulation.ExpressionBasedPathForce_getConcreteClassName(self)

    def copyProperty_resting_length(self, source):
        r"""
        copyProperty_resting_length(ExpressionBasedPathForce self, ExpressionBasedPathForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPathForce::Self const &

        """
        return _simulation.ExpressionBasedPathForce_copyProperty_resting_length(self, source)

    def append_resting_length(self, value):
        r"""
        append_resting_length(ExpressionBasedPathForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedPathForce_append_resting_length(self, value)

    def constructProperty_resting_length(self, initValue):
        r"""
        constructProperty_resting_length(ExpressionBasedPathForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ExpressionBasedPathForce_constructProperty_resting_length(self, initValue)

    def get_resting_length(self, *args):
        r"""
        get_resting_length(ExpressionBasedPathForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_resting_length(ExpressionBasedPathForce self) -> double const &
        """
        return _simulation.ExpressionBasedPathForce_get_resting_length(self, *args)

    def upd_resting_length(self, *args):
        r"""
        upd_resting_length(ExpressionBasedPathForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_resting_length(ExpressionBasedPathForce self) -> double &
        """
        return _simulation.ExpressionBasedPathForce_upd_resting_length(self, *args)

    def set_resting_length(self, *args):
        r"""
        set_resting_length(ExpressionBasedPathForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_resting_length(ExpressionBasedPathForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedPathForce_set_resting_length(self, *args)

    def copyProperty_expression(self, source):
        r"""
        copyProperty_expression(ExpressionBasedPathForce self, ExpressionBasedPathForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPathForce::Self const &

        """
        return _simulation.ExpressionBasedPathForce_copyProperty_expression(self, source)

    def append_expression(self, value):
        r"""
        append_expression(ExpressionBasedPathForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPathForce_append_expression(self, value)

    def constructProperty_expression(self, initValue):
        r"""
        constructProperty_expression(ExpressionBasedPathForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedPathForce_constructProperty_expression(self, initValue)

    def get_expression(self, *args):
        r"""
        get_expression(ExpressionBasedPathForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_expression(ExpressionBasedPathForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedPathForce_get_expression(self, *args)

    def upd_expression(self, *args):
        r"""
        upd_expression(ExpressionBasedPathForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_expression(ExpressionBasedPathForce self) -> std::string &
        """
        return _simulation.ExpressionBasedPathForce_upd_expression(self, *args)

    def set_expression(self, *args):
        r"""
        set_expression(ExpressionBasedPathForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_expression(ExpressionBasedPathForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedPathForce_set_expression(self, *args)

    def copyProperty_path(self, source):
        r"""
        copyProperty_path(ExpressionBasedPathForce self, ExpressionBasedPathForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPathForce::Self const &

        """
        return _simulation.ExpressionBasedPathForce_copyProperty_path(self, source)

    def append_path(self, value):
        r"""
        append_path(ExpressionBasedPathForce self, AbstractGeometryPath value) -> int

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.ExpressionBasedPathForce_append_path(self, value)

    def constructProperty_path(self, initValue):
        r"""
        constructProperty_path(ExpressionBasedPathForce self, AbstractGeometryPath initValue)

        Parameters
        ----------
        initValue: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.ExpressionBasedPathForce_constructProperty_path(self, initValue)

    def get_path(self, *args):
        r"""
        get_path(ExpressionBasedPathForce self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(ExpressionBasedPathForce self) -> AbstractGeometryPath
        """
        return _simulation.ExpressionBasedPathForce_get_path(self, *args)

    def upd_path(self, *args):
        r"""
        upd_path(ExpressionBasedPathForce self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        upd_path(ExpressionBasedPathForce self) -> AbstractGeometryPath
        """
        return _simulation.ExpressionBasedPathForce_upd_path(self, *args)

    def set_path(self, *args):
        r"""
        set_path(ExpressionBasedPathForce self, int i, AbstractGeometryPath value)

        Parameters
        ----------
        i: int
        value: OpenSim::AbstractGeometryPath const &

        set_path(ExpressionBasedPathForce self, AbstractGeometryPath value)

        Parameters
        ----------
        value: OpenSim::AbstractGeometryPath const &

        """
        return _simulation.ExpressionBasedPathForce_set_path(self, *args)

    def copyProperty_clamp_stretch(self, source):
        r"""
        copyProperty_clamp_stretch(ExpressionBasedPathForce self, ExpressionBasedPathForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedPathForce::Self const &

        """
        return _simulation.ExpressionBasedPathForce_copyProperty_clamp_stretch(self, source)

    def append_clamp_stretch(self, value):
        r"""
        append_clamp_stretch(ExpressionBasedPathForce self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ExpressionBasedPathForce_append_clamp_stretch(self, value)

    def constructProperty_clamp_stretch(self, initValue):
        r"""
        constructProperty_clamp_stretch(ExpressionBasedPathForce self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.ExpressionBasedPathForce_constructProperty_clamp_stretch(self, initValue)

    def get_clamp_stretch(self, *args):
        r"""
        get_clamp_stretch(ExpressionBasedPathForce self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_clamp_stretch(ExpressionBasedPathForce self) -> bool const &
        """
        return _simulation.ExpressionBasedPathForce_get_clamp_stretch(self, *args)

    def upd_clamp_stretch(self, *args):
        r"""
        upd_clamp_stretch(ExpressionBasedPathForce self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_clamp_stretch(ExpressionBasedPathForce self) -> bool &
        """
        return _simulation.ExpressionBasedPathForce_upd_clamp_stretch(self, *args)

    def set_clamp_stretch(self, *args):
        r"""
        set_clamp_stretch(ExpressionBasedPathForce self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_clamp_stretch(ExpressionBasedPathForce self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.ExpressionBasedPathForce_set_clamp_stretch(self, *args)
    _has_output_length = property(_simulation.ExpressionBasedPathForce__has_output_length_get, _simulation.ExpressionBasedPathForce__has_output_length_set, doc=r"""_has_output_length : bool""")
    _has_output_stretch = property(_simulation.ExpressionBasedPathForce__has_output_stretch_get, _simulation.ExpressionBasedPathForce__has_output_stretch_set, doc=r"""_has_output_stretch : bool""")
    _has_output_lengthening_speed = property(_simulation.ExpressionBasedPathForce__has_output_lengthening_speed_get, _simulation.ExpressionBasedPathForce__has_output_lengthening_speed_set, doc=r"""_has_output_lengthening_speed : bool""")
    _has_output_tension = property(_simulation.ExpressionBasedPathForce__has_output_tension_get, _simulation.ExpressionBasedPathForce__has_output_tension_set, doc=r"""_has_output_tension : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor.

        |

        *Overload 2:*
         Convenience constructor.
        :type name: string
        :param name:          name of this %ExpressionBasedPathForce Object
        :type restLength: float
        :param restLength:    the force's resting length
        :type expression: string
        :param expression:    the expression used to compute force tension
        :type clampStretch: boolean, optional
        :param clampStretch:  if true, the force will not apply tension when the
                                 path is shorter than its resting length

        |

        *Overload 3:*
         Convenience constructor.
        :type name: string
        :param name:          name of this %ExpressionBasedPathForce Object
        :type restLength: float
        :param restLength:    the force's resting length
        :type expression: string
        :param expression:    the expression used to compute force tension
        :param clampStretch:  if true, the force will not apply tension when the
                                 path is shorter than its resting length
        """
        _simulation.ExpressionBasedPathForce_swiginit(self, _simulation.new_ExpressionBasedPathForce(*args))

    def getRestingLength(self):
        r"""The resting length of the path force. The default value is 0."""
        return _simulation.ExpressionBasedPathForce_getRestingLength(self)

    def setRestingLength(self, restingLength):
        
        return _simulation.ExpressionBasedPathForce_setRestingLength(self, restingLength)

    def setExpression(self, expression):
        r"""
        The expression that defines the path force tension.
        Notes: The expression must not contain any whitespace separating
              characters.
        """
        return _simulation.ExpressionBasedPathForce_setExpression(self, expression)

    def getExpression(self):
        
        return _simulation.ExpressionBasedPathForce_getExpression(self)

    def getClampStretch(self):
        r"""
        If true, the force will not apply tension when the path is shorter than
        its resting length. Default: true.
        """
        return _simulation.ExpressionBasedPathForce_getClampStretch(self)

    def setClampStretch(self, clampStretch):
        
        return _simulation.ExpressionBasedPathForce_setClampStretch(self, clampStretch)

    def updPath(self):
        r"""The path object."""
        return _simulation.ExpressionBasedPathForce_updPath(self)

    def getPath(self):
        r"""getPath(ExpressionBasedPathForce self) -> AbstractGeometryPath"""
        return _simulation.ExpressionBasedPathForce_getPath(self)

    def updGeometryPath(self):
        r"""updGeometryPath(ExpressionBasedPathForce self) -> GeometryPath"""
        return _simulation.ExpressionBasedPathForce_updGeometryPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(ExpressionBasedPathForce self) -> GeometryPath"""
        return _simulation.ExpressionBasedPathForce_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(ExpressionBasedPathForce self) -> bool"""
        return _simulation.ExpressionBasedPathForce_hasVisualPath(self)

    def getLength(self, s):
        r"""
        Get the length of the ExpressionBasedPathForce.

        Notes: Accessible at SimTK::Stage::Position.
        """
        return _simulation.ExpressionBasedPathForce_getLength(self, s)

    def getStretch(self, s):
        r"""
        Get the stretch in the ExpressionBasedPathForce.

        Notes: Accessible at SimTK::Stage::Position.
        """
        return _simulation.ExpressionBasedPathForce_getStretch(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        Get the lengthening speed of the ExpressionBasedPathForce.

        Notes: Accessible at SimTK::Stage::Velocity.
        """
        return _simulation.ExpressionBasedPathForce_getLengtheningSpeed(self, s)

    def getTension(self, s):
        r"""
        Get the tension generated by the ExpressionBasedPathForce.

        Notes: Accessible at SimTK::Stage::Dynamics.
        """
        return _simulation.ExpressionBasedPathForce_getTension(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""Compute the moment arm of the path with respect to a given coordinate."""
        return _simulation.ExpressionBasedPathForce_computeMomentArm(self, s, aCoord)

    def extendPostScale(self, s, scaleSet):
        r"""
         Adjust the resting length of the path force after the model has been
        scaled. The `resting_length` property is multiplied by the quotient of
        the current path length and the path length before scaling.
        """
        return _simulation.ExpressionBasedPathForce_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_ExpressionBasedPathForce

# Register ExpressionBasedPathForce in _simulation:
_simulation.ExpressionBasedPathForce_swigregister(ExpressionBasedPathForce)
class BushingForce(TwoFrameLinkerForce):
    r"""
    A class implementing a Bushing Force.

    A Bushing Force is the force proportional to the deviation of two frames.
    One can think of the Bushing as being composed of 3 linear and 3 torsional
    spring-dampers, which act along or about the bushing frames. Orientations
    are measured as x-y-z body-fixed Euler rotations, which are treated as
    though they were uncoupled. Damping is proportional to the deflection rate of
    change (e.g. Euler angle derivatives) which is NOT the angular velocity
    between the two frames. That makes this bushing model suitable only for
    relatively small relative orientation deviations between the frames.

    The underlying Force in Simbody is a SimtK::Force::LinearBushing. This
    implementation exposes the state variable for the dissipated energy of the
    bushing force allocated internally by Simbody.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BushingForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BushingForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BushingForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BushingForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BushingForce_getClassName()

    def clone(self):
        r"""clone(BushingForce self) -> BushingForce"""
        return _simulation.BushingForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BushingForce self) -> std::string const &"""
        return _simulation.BushingForce_getConcreteClassName(self)

    def copyProperty_rotational_stiffness(self, source):
        r"""
        copyProperty_rotational_stiffness(BushingForce self, BushingForce source)

        Parameters
        ----------
        source: OpenSim::BushingForce::Self const &

        """
        return _simulation.BushingForce_copyProperty_rotational_stiffness(self, source)

    def append_rotational_stiffness(self, value):
        r"""
        append_rotational_stiffness(BushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_append_rotational_stiffness(self, value)

    def constructProperty_rotational_stiffness(self, initValue):
        r"""
        constructProperty_rotational_stiffness(BushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_constructProperty_rotational_stiffness(self, initValue)

    def get_rotational_stiffness(self, *args):
        r"""
        get_rotational_stiffness(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_rotational_stiffness(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_get_rotational_stiffness(self, *args)

    def upd_rotational_stiffness(self, *args):
        r"""
        upd_rotational_stiffness(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_rotational_stiffness(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_upd_rotational_stiffness(self, *args)

    def set_rotational_stiffness(self, *args):
        r"""
        set_rotational_stiffness(BushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_rotational_stiffness(BushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_set_rotational_stiffness(self, *args)

    def copyProperty_translational_stiffness(self, source):
        r"""
        copyProperty_translational_stiffness(BushingForce self, BushingForce source)

        Parameters
        ----------
        source: OpenSim::BushingForce::Self const &

        """
        return _simulation.BushingForce_copyProperty_translational_stiffness(self, source)

    def append_translational_stiffness(self, value):
        r"""
        append_translational_stiffness(BushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_append_translational_stiffness(self, value)

    def constructProperty_translational_stiffness(self, initValue):
        r"""
        constructProperty_translational_stiffness(BushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_constructProperty_translational_stiffness(self, initValue)

    def get_translational_stiffness(self, *args):
        r"""
        get_translational_stiffness(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translational_stiffness(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_get_translational_stiffness(self, *args)

    def upd_translational_stiffness(self, *args):
        r"""
        upd_translational_stiffness(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translational_stiffness(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_upd_translational_stiffness(self, *args)

    def set_translational_stiffness(self, *args):
        r"""
        set_translational_stiffness(BushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translational_stiffness(BushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_set_translational_stiffness(self, *args)

    def copyProperty_rotational_damping(self, source):
        r"""
        copyProperty_rotational_damping(BushingForce self, BushingForce source)

        Parameters
        ----------
        source: OpenSim::BushingForce::Self const &

        """
        return _simulation.BushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value):
        r"""
        append_rotational_damping(BushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue):
        r"""
        constructProperty_rotational_damping(BushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args):
        r"""
        get_rotational_damping(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_rotational_damping(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args):
        r"""
        upd_rotational_damping(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_rotational_damping(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args):
        r"""
        set_rotational_damping(BushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_rotational_damping(BushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source):
        r"""
        copyProperty_translational_damping(BushingForce self, BushingForce source)

        Parameters
        ----------
        source: OpenSim::BushingForce::Self const &

        """
        return _simulation.BushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value):
        r"""
        append_translational_damping(BushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue):
        r"""
        constructProperty_translational_damping(BushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args):
        r"""
        get_translational_damping(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translational_damping(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args):
        r"""
        upd_translational_damping(BushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translational_damping(BushingForce self) -> Vec3
        """
        return _simulation.BushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args):
        r"""
        set_translational_damping(BushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translational_damping(BushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.BushingForce_set_translational_damping(self, *args)
    _has_output_statebounds_dissipated_energy = property(_simulation.BushingForce__has_output_statebounds_dissipated_energy_get, _simulation.BushingForce__has_output_statebounds_dissipated_energy_set, doc=r"""_has_output_statebounds_dissipated_energy : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves frames unspecified and sets all bushing
                stiffness and damping properties to zero. *

        |

        *Overload 2:*
         Convenience Constructor.
            Create a BushingForce between two PhysicalFrames, frame1 and frame2.
            :type name: string, in
            :param name:         the name of this BushingForce
            :type frame1: :py:class:`PhysicalFrame`, in
            :param frame1:       the bushing's first PhysicalFrame
            :type frame2: :py:class:`PhysicalFrame`, in
            :param frame2:       the bushing's second PhysicalFrame

        |

        *Overload 3:*
         Convenience Constructor.
            Create a BushingForce between two PhysicalFrames, frame1 and frame2.
            :type name: string, in
            :param name:         the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:   the name of the bushing's first PhysicalFrame
            :type frame2Name: string, in
            :param frame2Name:   the name of the bushing's second PhysicalFrame

        |

        *Overload 4:*
         Construct a BushingForce given physical frames that it
        tries to keep aligned by generating a passive force according to the
        physical properties of the bushing. See property declarations for more
        information.

        |

        *Overload 5:*
         Construct a BushingForce given the names of physical frames that it
        tries to keep aligned by generating a passive force according to the
        physical properties of the bushing. See property declarations for more
        information.

        |

        *Overload 6:*
         Convenience Constructor
            Construct a BushingForce between two frames with offset transforms on the
            respective frames.

            :type name: string, in
            :param name:              the name of this BushingForce
            :type frame1: :py:class:`PhysicalFrame`, in
            :param frame1:            first PhysicalFrame that the bushing connects
            :type transformInFrame1: :py:class:`Transform`, in
            :param transformInFrame1: offset Transform on the first frame
            :type frame2: :py:class:`PhysicalFrame`, in
            :param frame2:            second PhysicalFrame that the bushing connects
            :type transformInFrame2: :py:class:`Transform`, in
            :param transformInFrame2: offset Transform on the second frame
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:    translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:      rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:      translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:        rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping

        |

        *Overload 7:*
         Convenience Constructor
            Construct a BushingForce where the two frames are specified by the name
            and offset transforms on the respective frames.

            :type name: string, in
            :param name:              the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:        first PhysicalFrame that the bushing connects
            :type transformInFrame1: :py:class:`Transform`, in
            :param transformInFrame1: offset Transform on the first frame
            :type frame2Name: string, in
            :param frame2Name:        second PhysicalFrame that the bushing connects
            :type transformInFrame2: :py:class:`Transform`, in
            :param transformInFrame2: offset Transform on the second frame
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:    translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:      rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:      translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:        rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping

        |

        *Overload 8:*
         Backwards compatible Convenience Constructor
            Construct a BushingForce where the bushing frames are specified in terms of their
            location and orientation in their respective PhysicalFrames and passive force
            defined by the physical properties of the bushing. See property declarations
            for more information.
            :type name: string, in
            :param name:                the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:          name of the first PhysicalFrame of the bushing
            :type locationInFrame1: :py:class:`Vec3`, in
            :param locationInFrame1:    Vec3 location of the bushing in the first frame
            :type orientationInFrame1: :py:class:`Vec3`, in
            :param orientationInFrame1: Vec3 of the XYZ body-fixed Euler angles of the
                                               bushing frame orientation in frame 1.
            :type frame2Name: string, in
            :param frame2Name:          name of the second PhysicalFrame of the bushing
            :type locationInFrame2: :py:class:`Vec3`, in
            :param locationInFrame2:    Vec3 location of the weld in the second frame
            :type orientationInFrame2: :py:class:`Vec3`, in
            :param orientationInFrame2: Vec3 of the XYZ body-fixed Euler angles of the
                                               bushing frame orientation in frame2.
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:      translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:        rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:        translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:          rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping
        """
        _simulation.BushingForce_swiginit(self, _simulation.new_BushingForce(*args))

    def computePotentialEnergy(self, s):
        r""" Potential energy is the elastic energy stored in the bushing."""
        return _simulation.BushingForce_computePotentialEnergy(self, s)

    def getDissipatedEnergy(self, state):
        r"""
        Obtain the total amount of energy dissipated by this BushingForce since
        some arbitrary starting point, in joules.

        This is the time integral of the power dissipation. For a system whose
        only non-conservative forces are Bushings, the sum of potential, kinetic,
        and dissipated energies should be conserved.
        """
        return _simulation.BushingForce_getDissipatedEnergy(self, state)

    def setDissipatedEnergy(self, state, value):
        r"""
        Set the accumulated dissipated energy to an arbitrary value, in joules.

        Typically this is used only to reset the dissipated energy to zero, but
        non-zero values can be useful if you are trying to match some existing
        data or continuing a simulation.
        """
        return _simulation.BushingForce_setDissipatedEnergy(self, state, value)

    def getPowerDissipation(self, state):
        r"""
        Obtain the rate at which energy is being dissipated by this BushingForce,
        that is, the power being lost, in watts.
        """
        return _simulation.BushingForce_getPowerDissipation(self, state)

    def getBoundsDissipatedEnergy(self, arg2):
        r"""
        The first element of the Vec2 is the lower bound, and the second is the
        upper bound.

        This function is intended primarily for the model Output
        'statebounds_dissipated_energy'. We don't need the state, but the state
        parameter is a requirement of Output functions.
        """
        return _simulation.BushingForce_getBoundsDissipatedEnergy(self, arg2)

    def getRecordLabels(self):
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.BushingForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.BushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_BushingForce

# Register BushingForce in _simulation:
_simulation.BushingForce_swigregister(BushingForce)
class FunctionBasedBushingForce(TwoFrameLinkerForceProducer):
    r"""
    A class implementing a bushing force specified by functions of the frame
    deflections. These functions are user specified and can be used to capture
    the nonlinearities of biologic structures.  This FunctionBasedBushing
    does not capture coupling between the deflections (e.g. force in x due to
    rotation about z).

    A bushing force is the resistive force due to deviation between two frames.
    One can think of the Bushing as being composed of 3 translational and 3
    torsional spring-dampers, which act along or about the bushing frame axes.
    Orientations are measured as x-y-z body-fixed Euler rotations.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FunctionBasedBushingForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FunctionBasedBushingForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FunctionBasedBushingForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FunctionBasedBushingForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FunctionBasedBushingForce_getClassName()

    def clone(self):
        r"""clone(FunctionBasedBushingForce self) -> FunctionBasedBushingForce"""
        return _simulation.FunctionBasedBushingForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FunctionBasedBushingForce self) -> std::string const &"""
        return _simulation.FunctionBasedBushingForce_getConcreteClassName(self)

    def copyProperty_m_x_theta_x_function(self, source):
        r"""
        copyProperty_m_x_theta_x_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_m_x_theta_x_function(self, source)

    def append_m_x_theta_x_function(self, value):
        r"""
        append_m_x_theta_x_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_m_x_theta_x_function(self, value)

    def constructProperty_m_x_theta_x_function(self, *args):
        r"""
        constructProperty_m_x_theta_x_function(FunctionBasedBushingForce self)
        constructProperty_m_x_theta_x_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_m_x_theta_x_function(self, *args)

    def get_m_x_theta_x_function(self, *args):
        r"""
        get_m_x_theta_x_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_m_x_theta_x_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_m_x_theta_x_function(self, *args)

    def upd_m_x_theta_x_function(self, *args):
        r"""
        upd_m_x_theta_x_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_m_x_theta_x_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_m_x_theta_x_function(self, *args)

    def set_m_x_theta_x_function(self, *args):
        r"""
        set_m_x_theta_x_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_m_x_theta_x_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_m_x_theta_x_function(self, *args)

    def copyProperty_m_y_theta_y_function(self, source):
        r"""
        copyProperty_m_y_theta_y_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_m_y_theta_y_function(self, source)

    def append_m_y_theta_y_function(self, value):
        r"""
        append_m_y_theta_y_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_m_y_theta_y_function(self, value)

    def constructProperty_m_y_theta_y_function(self, *args):
        r"""
        constructProperty_m_y_theta_y_function(FunctionBasedBushingForce self)
        constructProperty_m_y_theta_y_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_m_y_theta_y_function(self, *args)

    def get_m_y_theta_y_function(self, *args):
        r"""
        get_m_y_theta_y_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_m_y_theta_y_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_m_y_theta_y_function(self, *args)

    def upd_m_y_theta_y_function(self, *args):
        r"""
        upd_m_y_theta_y_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_m_y_theta_y_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_m_y_theta_y_function(self, *args)

    def set_m_y_theta_y_function(self, *args):
        r"""
        set_m_y_theta_y_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_m_y_theta_y_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_m_y_theta_y_function(self, *args)

    def copyProperty_m_z_theta_z_function(self, source):
        r"""
        copyProperty_m_z_theta_z_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_m_z_theta_z_function(self, source)

    def append_m_z_theta_z_function(self, value):
        r"""
        append_m_z_theta_z_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_m_z_theta_z_function(self, value)

    def constructProperty_m_z_theta_z_function(self, *args):
        r"""
        constructProperty_m_z_theta_z_function(FunctionBasedBushingForce self)
        constructProperty_m_z_theta_z_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_m_z_theta_z_function(self, *args)

    def get_m_z_theta_z_function(self, *args):
        r"""
        get_m_z_theta_z_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_m_z_theta_z_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_m_z_theta_z_function(self, *args)

    def upd_m_z_theta_z_function(self, *args):
        r"""
        upd_m_z_theta_z_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_m_z_theta_z_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_m_z_theta_z_function(self, *args)

    def set_m_z_theta_z_function(self, *args):
        r"""
        set_m_z_theta_z_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_m_z_theta_z_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_m_z_theta_z_function(self, *args)

    def copyProperty_f_x_delta_x_function(self, source):
        r"""
        copyProperty_f_x_delta_x_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_f_x_delta_x_function(self, source)

    def append_f_x_delta_x_function(self, value):
        r"""
        append_f_x_delta_x_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_f_x_delta_x_function(self, value)

    def constructProperty_f_x_delta_x_function(self, *args):
        r"""
        constructProperty_f_x_delta_x_function(FunctionBasedBushingForce self)
        constructProperty_f_x_delta_x_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_f_x_delta_x_function(self, *args)

    def get_f_x_delta_x_function(self, *args):
        r"""
        get_f_x_delta_x_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_f_x_delta_x_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_f_x_delta_x_function(self, *args)

    def upd_f_x_delta_x_function(self, *args):
        r"""
        upd_f_x_delta_x_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_f_x_delta_x_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_f_x_delta_x_function(self, *args)

    def set_f_x_delta_x_function(self, *args):
        r"""
        set_f_x_delta_x_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_f_x_delta_x_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_f_x_delta_x_function(self, *args)

    def copyProperty_f_y_delta_y_function(self, source):
        r"""
        copyProperty_f_y_delta_y_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_f_y_delta_y_function(self, source)

    def append_f_y_delta_y_function(self, value):
        r"""
        append_f_y_delta_y_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_f_y_delta_y_function(self, value)

    def constructProperty_f_y_delta_y_function(self, *args):
        r"""
        constructProperty_f_y_delta_y_function(FunctionBasedBushingForce self)
        constructProperty_f_y_delta_y_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_f_y_delta_y_function(self, *args)

    def get_f_y_delta_y_function(self, *args):
        r"""
        get_f_y_delta_y_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_f_y_delta_y_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_f_y_delta_y_function(self, *args)

    def upd_f_y_delta_y_function(self, *args):
        r"""
        upd_f_y_delta_y_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_f_y_delta_y_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_f_y_delta_y_function(self, *args)

    def set_f_y_delta_y_function(self, *args):
        r"""
        set_f_y_delta_y_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_f_y_delta_y_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_f_y_delta_y_function(self, *args)

    def copyProperty_f_z_delta_z_function(self, source):
        r"""
        copyProperty_f_z_delta_z_function(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_f_z_delta_z_function(self, source)

    def append_f_z_delta_z_function(self, value):
        r"""
        append_f_z_delta_z_function(FunctionBasedBushingForce self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_append_f_z_delta_z_function(self, value)

    def constructProperty_f_z_delta_z_function(self, *args):
        r"""
        constructProperty_f_z_delta_z_function(FunctionBasedBushingForce self)
        constructProperty_f_z_delta_z_function(FunctionBasedBushingForce self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_f_z_delta_z_function(self, *args)

    def get_f_z_delta_z_function(self, *args):
        r"""
        get_f_z_delta_z_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        get_f_z_delta_z_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_get_f_z_delta_z_function(self, *args)

    def upd_f_z_delta_z_function(self, *args):
        r"""
        upd_f_z_delta_z_function(FunctionBasedBushingForce self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_f_z_delta_z_function(FunctionBasedBushingForce self) -> Function
        """
        return _simulation.FunctionBasedBushingForce_upd_f_z_delta_z_function(self, *args)

    def set_f_z_delta_z_function(self, *args):
        r"""
        set_f_z_delta_z_function(FunctionBasedBushingForce self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_f_z_delta_z_function(FunctionBasedBushingForce self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _simulation.FunctionBasedBushingForce_set_f_z_delta_z_function(self, *args)

    def copyProperty_visual_aspect_ratio(self, source):
        r"""
        copyProperty_visual_aspect_ratio(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_visual_aspect_ratio(self, source)

    def append_visual_aspect_ratio(self, value):
        r"""
        append_visual_aspect_ratio(FunctionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_append_visual_aspect_ratio(self, value)

    def constructProperty_visual_aspect_ratio(self, *args):
        r"""
        constructProperty_visual_aspect_ratio(FunctionBasedBushingForce self)
        constructProperty_visual_aspect_ratio(FunctionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_visual_aspect_ratio(self, *args)

    def get_visual_aspect_ratio(self, *args):
        r"""
        get_visual_aspect_ratio(FunctionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_visual_aspect_ratio(FunctionBasedBushingForce self) -> double const &
        """
        return _simulation.FunctionBasedBushingForce_get_visual_aspect_ratio(self, *args)

    def upd_visual_aspect_ratio(self, *args):
        r"""
        upd_visual_aspect_ratio(FunctionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_visual_aspect_ratio(FunctionBasedBushingForce self) -> double &
        """
        return _simulation.FunctionBasedBushingForce_upd_visual_aspect_ratio(self, *args)

    def set_visual_aspect_ratio(self, *args):
        r"""
        set_visual_aspect_ratio(FunctionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_visual_aspect_ratio(FunctionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_set_visual_aspect_ratio(self, *args)

    def copyProperty_moment_visual_scale(self, source):
        r"""
        copyProperty_moment_visual_scale(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_moment_visual_scale(self, source)

    def append_moment_visual_scale(self, value):
        r"""
        append_moment_visual_scale(FunctionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_append_moment_visual_scale(self, value)

    def constructProperty_moment_visual_scale(self, *args):
        r"""
        constructProperty_moment_visual_scale(FunctionBasedBushingForce self)
        constructProperty_moment_visual_scale(FunctionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_moment_visual_scale(self, *args)

    def get_moment_visual_scale(self, *args):
        r"""
        get_moment_visual_scale(FunctionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_moment_visual_scale(FunctionBasedBushingForce self) -> double const &
        """
        return _simulation.FunctionBasedBushingForce_get_moment_visual_scale(self, *args)

    def upd_moment_visual_scale(self, *args):
        r"""
        upd_moment_visual_scale(FunctionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_moment_visual_scale(FunctionBasedBushingForce self) -> double &
        """
        return _simulation.FunctionBasedBushingForce_upd_moment_visual_scale(self, *args)

    def set_moment_visual_scale(self, *args):
        r"""
        set_moment_visual_scale(FunctionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_moment_visual_scale(FunctionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_set_moment_visual_scale(self, *args)

    def copyProperty_force_visual_scale(self, source):
        r"""
        copyProperty_force_visual_scale(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_force_visual_scale(self, source)

    def append_force_visual_scale(self, value):
        r"""
        append_force_visual_scale(FunctionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_append_force_visual_scale(self, value)

    def constructProperty_force_visual_scale(self, *args):
        r"""
        constructProperty_force_visual_scale(FunctionBasedBushingForce self)
        constructProperty_force_visual_scale(FunctionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_force_visual_scale(self, *args)

    def get_force_visual_scale(self, *args):
        r"""
        get_force_visual_scale(FunctionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_force_visual_scale(FunctionBasedBushingForce self) -> double const &
        """
        return _simulation.FunctionBasedBushingForce_get_force_visual_scale(self, *args)

    def upd_force_visual_scale(self, *args):
        r"""
        upd_force_visual_scale(FunctionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_force_visual_scale(FunctionBasedBushingForce self) -> double &
        """
        return _simulation.FunctionBasedBushingForce_upd_force_visual_scale(self, *args)

    def set_force_visual_scale(self, *args):
        r"""
        set_force_visual_scale(FunctionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_force_visual_scale(FunctionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FunctionBasedBushingForce_set_force_visual_scale(self, *args)

    def copyProperty_rotational_damping(self, source):
        r"""
        copyProperty_rotational_damping(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value):
        r"""
        append_rotational_damping(FunctionBasedBushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue):
        r"""
        constructProperty_rotational_damping(FunctionBasedBushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args):
        r"""
        get_rotational_damping(FunctionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_rotational_damping(FunctionBasedBushingForce self) -> Vec3
        """
        return _simulation.FunctionBasedBushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args):
        r"""
        upd_rotational_damping(FunctionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_rotational_damping(FunctionBasedBushingForce self) -> Vec3
        """
        return _simulation.FunctionBasedBushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args):
        r"""
        set_rotational_damping(FunctionBasedBushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_rotational_damping(FunctionBasedBushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source):
        r"""
        copyProperty_translational_damping(FunctionBasedBushingForce self, FunctionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::FunctionBasedBushingForce::Self const &

        """
        return _simulation.FunctionBasedBushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value):
        r"""
        append_translational_damping(FunctionBasedBushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue):
        r"""
        constructProperty_translational_damping(FunctionBasedBushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args):
        r"""
        get_translational_damping(FunctionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translational_damping(FunctionBasedBushingForce self) -> Vec3
        """
        return _simulation.FunctionBasedBushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args):
        r"""
        upd_translational_damping(FunctionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translational_damping(FunctionBasedBushingForce self) -> Vec3
        """
        return _simulation.FunctionBasedBushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args):
        r"""
        set_translational_damping(FunctionBasedBushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translational_damping(FunctionBasedBushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.FunctionBasedBushingForce_set_translational_damping(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves bodies unspecified, sets the bushing frames
        to be at their body origins, and sets all bushing parameters to zero. *

        |

        *Overload 2:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 3:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero. The frames are
        specified by name (path). *

        |

        *Overload 4:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*

        |

        *Overload 5:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles. The frames are specified by name (path). *
        """
        _simulation.FunctionBasedBushingForce_swiginit(self, _simulation.new_FunctionBasedBushingForce(*args))

    def setMomentVisualScale(self, scale):
        r"""
         Set the value used to scale the bushing moment on body2 when drawing it to screen.
        A moment of magnitude |M| will be drawn on screen with a length of (|M|*scale).  *
        """
        return _simulation.FunctionBasedBushingForce_setMomentVisualScale(self, scale)

    def setForceVisualScale(self, scale):
        r"""
         Set the value used to scale the bushing force on body2 when drawing it to screen.
        A force of magnitude |F| will be drawn on screen with a length of (|F|*scale).  *
        """
        return _simulation.FunctionBasedBushingForce_setForceVisualScale(self, scale)

    def setVisualAspectRatio(self, ratio):
        r"""
        Set the aspect ratio used to control the thickness of the bushing force and moment
               in drawn in the visualizer.  ratio = length/diameter.
        """
        return _simulation.FunctionBasedBushingForce_setVisualAspectRatio(self, ratio)

    def extendFinalizeFromProperties(self):
        r""" Component interface."""
        return _simulation.FunctionBasedBushingForce_extendFinalizeFromProperties(self)

    def calcStiffnessForce(self, state):
        r"""
        Calculate the bushing force contribution due to its stiffness. This is
           a function of the deflection between the bushing frames. It is the force
           on frame2 from frame1 in the basis of the deflection (dq).
        """
        return _simulation.FunctionBasedBushingForce_calcStiffnessForce(self, state)

    def calcDampingForce(self, state):
        r"""
        Calculate the bushing force contribution due to its damping. This is a
           function of the deflection rate between the bushing frames. It is the
           force on frame2 from frame1 in the basis of the deflection rate (dqdot).
        """
        return _simulation.FunctionBasedBushingForce_calcDampingForce(self, state)

    def getRecordLabels(self):
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.FunctionBasedBushingForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.FunctionBasedBushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_FunctionBasedBushingForce

# Register FunctionBasedBushingForce in _simulation:
_simulation.FunctionBasedBushingForce_swigregister(FunctionBasedBushingForce)
class ExpressionBasedBushingForce(TwoFrameLinkerForceProducer):
    r"""
    A class implementing a bushing force specified by expressions of the
    deflection between two bushing frames. These expressions are user specified
    as strings that are interpreted during a simulation.
    Each expression is a function of the bushing's rotational deflections
    (theta_x, theta_y, theta_z) and translational deflections, (delta_x, delta_y,
    delta_z). These user defined expressions can capture nonlinearities and
    coupling common in biologic structures.

    A bushing force is the resistive force due to defection between two frames.
    One can think of the Bushing as being composed of 3 translational and 3
    torsional spring-dampers, which act along or about the bushing frame axes.
    Orientations are measured as x-y-z body-fixed Euler rotations.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ExpressionBasedBushingForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ExpressionBasedBushingForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ExpressionBasedBushingForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ExpressionBasedBushingForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ExpressionBasedBushingForce_getClassName()

    def clone(self):
        r"""clone(ExpressionBasedBushingForce self) -> ExpressionBasedBushingForce"""
        return _simulation.ExpressionBasedBushingForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ExpressionBasedBushingForce self) -> std::string const &"""
        return _simulation.ExpressionBasedBushingForce_getConcreteClassName(self)

    def copyProperty_Mx_expression(self, source):
        r"""
        copyProperty_Mx_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_Mx_expression(self, source)

    def append_Mx_expression(self, value):
        r"""
        append_Mx_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_Mx_expression(self, value)

    def constructProperty_Mx_expression(self, initValue):
        r"""
        constructProperty_Mx_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_Mx_expression(self, initValue)

    def get_Mx_expression(self, *args):
        r"""
        get_Mx_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_Mx_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_Mx_expression(self, *args)

    def upd_Mx_expression(self, *args):
        r"""
        upd_Mx_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_Mx_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_Mx_expression(self, *args)

    def set_Mx_expression(self, *args):
        r"""
        set_Mx_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_Mx_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_Mx_expression(self, *args)

    def copyProperty_My_expression(self, source):
        r"""
        copyProperty_My_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_My_expression(self, source)

    def append_My_expression(self, value):
        r"""
        append_My_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_My_expression(self, value)

    def constructProperty_My_expression(self, initValue):
        r"""
        constructProperty_My_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_My_expression(self, initValue)

    def get_My_expression(self, *args):
        r"""
        get_My_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_My_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_My_expression(self, *args)

    def upd_My_expression(self, *args):
        r"""
        upd_My_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_My_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_My_expression(self, *args)

    def set_My_expression(self, *args):
        r"""
        set_My_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_My_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_My_expression(self, *args)

    def copyProperty_Mz_expression(self, source):
        r"""
        copyProperty_Mz_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_Mz_expression(self, source)

    def append_Mz_expression(self, value):
        r"""
        append_Mz_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_Mz_expression(self, value)

    def constructProperty_Mz_expression(self, initValue):
        r"""
        constructProperty_Mz_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_Mz_expression(self, initValue)

    def get_Mz_expression(self, *args):
        r"""
        get_Mz_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_Mz_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_Mz_expression(self, *args)

    def upd_Mz_expression(self, *args):
        r"""
        upd_Mz_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_Mz_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_Mz_expression(self, *args)

    def set_Mz_expression(self, *args):
        r"""
        set_Mz_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_Mz_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_Mz_expression(self, *args)

    def copyProperty_Fx_expression(self, source):
        r"""
        copyProperty_Fx_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fx_expression(self, source)

    def append_Fx_expression(self, value):
        r"""
        append_Fx_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_Fx_expression(self, value)

    def constructProperty_Fx_expression(self, initValue):
        r"""
        constructProperty_Fx_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fx_expression(self, initValue)

    def get_Fx_expression(self, *args):
        r"""
        get_Fx_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_Fx_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_Fx_expression(self, *args)

    def upd_Fx_expression(self, *args):
        r"""
        upd_Fx_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_Fx_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_Fx_expression(self, *args)

    def set_Fx_expression(self, *args):
        r"""
        set_Fx_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_Fx_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_Fx_expression(self, *args)

    def copyProperty_Fy_expression(self, source):
        r"""
        copyProperty_Fy_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fy_expression(self, source)

    def append_Fy_expression(self, value):
        r"""
        append_Fy_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_Fy_expression(self, value)

    def constructProperty_Fy_expression(self, initValue):
        r"""
        constructProperty_Fy_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fy_expression(self, initValue)

    def get_Fy_expression(self, *args):
        r"""
        get_Fy_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_Fy_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_Fy_expression(self, *args)

    def upd_Fy_expression(self, *args):
        r"""
        upd_Fy_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_Fy_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_Fy_expression(self, *args)

    def set_Fy_expression(self, *args):
        r"""
        set_Fy_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_Fy_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_Fy_expression(self, *args)

    def copyProperty_Fz_expression(self, source):
        r"""
        copyProperty_Fz_expression(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fz_expression(self, source)

    def append_Fz_expression(self, value):
        r"""
        append_Fz_expression(ExpressionBasedBushingForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_append_Fz_expression(self, value)

    def constructProperty_Fz_expression(self, initValue):
        r"""
        constructProperty_Fz_expression(ExpressionBasedBushingForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fz_expression(self, initValue)

    def get_Fz_expression(self, *args):
        r"""
        get_Fz_expression(ExpressionBasedBushingForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_Fz_expression(ExpressionBasedBushingForce self) -> std::string const &
        """
        return _simulation.ExpressionBasedBushingForce_get_Fz_expression(self, *args)

    def upd_Fz_expression(self, *args):
        r"""
        upd_Fz_expression(ExpressionBasedBushingForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_Fz_expression(ExpressionBasedBushingForce self) -> std::string &
        """
        return _simulation.ExpressionBasedBushingForce_upd_Fz_expression(self, *args)

    def set_Fz_expression(self, *args):
        r"""
        set_Fz_expression(ExpressionBasedBushingForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_Fz_expression(ExpressionBasedBushingForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.ExpressionBasedBushingForce_set_Fz_expression(self, *args)

    def copyProperty_visual_aspect_ratio(self, source):
        r"""
        copyProperty_visual_aspect_ratio(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_visual_aspect_ratio(self, source)

    def append_visual_aspect_ratio(self, value):
        r"""
        append_visual_aspect_ratio(ExpressionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_append_visual_aspect_ratio(self, value)

    def constructProperty_visual_aspect_ratio(self, *args):
        r"""
        constructProperty_visual_aspect_ratio(ExpressionBasedBushingForce self)
        constructProperty_visual_aspect_ratio(ExpressionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_visual_aspect_ratio(self, *args)

    def get_visual_aspect_ratio(self, *args):
        r"""
        get_visual_aspect_ratio(ExpressionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_visual_aspect_ratio(ExpressionBasedBushingForce self) -> double const &
        """
        return _simulation.ExpressionBasedBushingForce_get_visual_aspect_ratio(self, *args)

    def upd_visual_aspect_ratio(self, *args):
        r"""
        upd_visual_aspect_ratio(ExpressionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_visual_aspect_ratio(ExpressionBasedBushingForce self) -> double &
        """
        return _simulation.ExpressionBasedBushingForce_upd_visual_aspect_ratio(self, *args)

    def set_visual_aspect_ratio(self, *args):
        r"""
        set_visual_aspect_ratio(ExpressionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_visual_aspect_ratio(ExpressionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_set_visual_aspect_ratio(self, *args)

    def copyProperty_moment_visual_scale(self, source):
        r"""
        copyProperty_moment_visual_scale(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_moment_visual_scale(self, source)

    def append_moment_visual_scale(self, value):
        r"""
        append_moment_visual_scale(ExpressionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_append_moment_visual_scale(self, value)

    def constructProperty_moment_visual_scale(self, *args):
        r"""
        constructProperty_moment_visual_scale(ExpressionBasedBushingForce self)
        constructProperty_moment_visual_scale(ExpressionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_moment_visual_scale(self, *args)

    def get_moment_visual_scale(self, *args):
        r"""
        get_moment_visual_scale(ExpressionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_moment_visual_scale(ExpressionBasedBushingForce self) -> double const &
        """
        return _simulation.ExpressionBasedBushingForce_get_moment_visual_scale(self, *args)

    def upd_moment_visual_scale(self, *args):
        r"""
        upd_moment_visual_scale(ExpressionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_moment_visual_scale(ExpressionBasedBushingForce self) -> double &
        """
        return _simulation.ExpressionBasedBushingForce_upd_moment_visual_scale(self, *args)

    def set_moment_visual_scale(self, *args):
        r"""
        set_moment_visual_scale(ExpressionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_moment_visual_scale(ExpressionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_set_moment_visual_scale(self, *args)

    def copyProperty_force_visual_scale(self, source):
        r"""
        copyProperty_force_visual_scale(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_force_visual_scale(self, source)

    def append_force_visual_scale(self, value):
        r"""
        append_force_visual_scale(ExpressionBasedBushingForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_append_force_visual_scale(self, value)

    def constructProperty_force_visual_scale(self, *args):
        r"""
        constructProperty_force_visual_scale(ExpressionBasedBushingForce self)
        constructProperty_force_visual_scale(ExpressionBasedBushingForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_force_visual_scale(self, *args)

    def get_force_visual_scale(self, *args):
        r"""
        get_force_visual_scale(ExpressionBasedBushingForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_force_visual_scale(ExpressionBasedBushingForce self) -> double const &
        """
        return _simulation.ExpressionBasedBushingForce_get_force_visual_scale(self, *args)

    def upd_force_visual_scale(self, *args):
        r"""
        upd_force_visual_scale(ExpressionBasedBushingForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_force_visual_scale(ExpressionBasedBushingForce self) -> double &
        """
        return _simulation.ExpressionBasedBushingForce_upd_force_visual_scale(self, *args)

    def set_force_visual_scale(self, *args):
        r"""
        set_force_visual_scale(ExpressionBasedBushingForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_force_visual_scale(ExpressionBasedBushingForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ExpressionBasedBushingForce_set_force_visual_scale(self, *args)

    def copyProperty_rotational_damping(self, source):
        r"""
        copyProperty_rotational_damping(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value):
        r"""
        append_rotational_damping(ExpressionBasedBushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue):
        r"""
        constructProperty_rotational_damping(ExpressionBasedBushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args):
        r"""
        get_rotational_damping(ExpressionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_rotational_damping(ExpressionBasedBushingForce self) -> Vec3
        """
        return _simulation.ExpressionBasedBushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args):
        r"""
        upd_rotational_damping(ExpressionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_rotational_damping(ExpressionBasedBushingForce self) -> Vec3
        """
        return _simulation.ExpressionBasedBushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args):
        r"""
        set_rotational_damping(ExpressionBasedBushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_rotational_damping(ExpressionBasedBushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source):
        r"""
        copyProperty_translational_damping(ExpressionBasedBushingForce self, ExpressionBasedBushingForce source)

        Parameters
        ----------
        source: OpenSim::ExpressionBasedBushingForce::Self const &

        """
        return _simulation.ExpressionBasedBushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value):
        r"""
        append_translational_damping(ExpressionBasedBushingForce self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue):
        r"""
        constructProperty_translational_damping(ExpressionBasedBushingForce self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args):
        r"""
        get_translational_damping(ExpressionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_translational_damping(ExpressionBasedBushingForce self) -> Vec3
        """
        return _simulation.ExpressionBasedBushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args):
        r"""
        upd_translational_damping(ExpressionBasedBushingForce self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_translational_damping(ExpressionBasedBushingForce self) -> Vec3
        """
        return _simulation.ExpressionBasedBushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args):
        r"""
        set_translational_damping(ExpressionBasedBushingForce self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_translational_damping(ExpressionBasedBushingForce self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.ExpressionBasedBushingForce_set_translational_damping(self, *args)
    _has_output_bushing_force = property(_simulation.ExpressionBasedBushingForce__has_output_bushing_force_get, _simulation.ExpressionBasedBushingForce__has_output_bushing_force_set, doc=r"""_has_output_bushing_force : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves bodies unspecified, sets the bushing frames
        to be at their body origins, and sets all bushing parameters to zero. *

        |

        *Overload 2:*
         This convenience constructor sets the bushing frames and sets all
        bushing functions to zero.  *

        |

        *Overload 3:*
         This convenience constructor defines and sets the bushing frames by name
        and sets all bushing functions to zero.  *

        |

        *Overload 4:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 5:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 6:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*

        |

        *Overload 7:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*
        """
        _simulation.ExpressionBasedBushingForce_swiginit(self, _simulation.new_ExpressionBasedBushingForce(*args))

    def setMomentVisualScale(self, scale):
        r"""
        Set the value used to scale the bushing moment on body2 when drawing it to
               screen. A moment of magnitude |M| will be drawn on screen with a length of
               (|M|*scale).  *
        """
        return _simulation.ExpressionBasedBushingForce_setMomentVisualScale(self, scale)

    def setForceVisualScale(self, scale):
        r"""
        Set the value used to scale the bushing force on body2 when drawing it to
               screen. A force of magnitude |F| will be drawn on screen with a length of
               (|F|*scale).  *
        """
        return _simulation.ExpressionBasedBushingForce_setForceVisualScale(self, scale)

    def setVisualAspectRatio(self, ratio):
        r"""
        Set the aspect ratio used to control the thickness of the bushing force
               and moment in drawn in the visualizer.  ratio = length/diameter.*
        """
        return _simulation.ExpressionBasedBushingForce_setVisualAspectRatio(self, ratio)

    def setMxExpression(self, expression):
        r"""
        Set the expression defining Mx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMxExpression(self, expression)

    def setMyExpression(self, expression):
        r"""
        Set the expression defining My as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMyExpression(self, expression)

    def setMzExpression(self, expression):
        r"""
        Set the expression defining Mz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMzExpression(self, expression)

    def setFxExpression(self, expression):
        r"""
        Set the expression defining Fx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFxExpression(self, expression)

    def setFyExpression(self, expression):
        r"""
        Set the expression defining Fy as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFyExpression(self, expression)

    def setFzExpression(self, expression):
        r"""
        Set the expression defining Fz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFzExpression(self, expression)

    def getMxExpression(self):
        r"""
        Get the expression defining Mx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMxExpression(self)

    def getMyExpression(self):
        r"""
        Get the expression defining My as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMyExpression(self)

    def getMzExpression(self):
        r"""
        Get the expression defining Mz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMzExpression(self)

    def getFxExpression(self):
        r"""
        Get the expression defining Fx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFxExpression(self)

    def getFyExpression(self):
        r"""
        Get the expression defining Fy as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFyExpression(self)

    def getFzExpression(self):
        r"""
        Get the expression defining Fz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFzExpression(self)

    def calcStiffnessForce(self, state):
        r"""
        Calculate the bushing force contribution due to its stiffness. This is
               a function of the deflection between the bushing frames. It is the force
               on frame2 from frame1 in the basis of the deflection (dq).
        """
        return _simulation.ExpressionBasedBushingForce_calcStiffnessForce(self, state)

    def calcDampingForce(self, state):
        r"""
        Calculate the bushing force contribution due to its damping. This is a
               function of the deflection rate between the bushing frames. It is the
               force on frame2 from frame1 in the basis of the deflection rate (dqdot).
        """
        return _simulation.ExpressionBasedBushingForce_calcDampingForce(self, state)

    def calcBushingForce(self, state):
        r"""
        Calculate the total bushing force. This is the sum of the stiffness and
               damping force contributions.
        """
        return _simulation.ExpressionBasedBushingForce_calcBushingForce(self, state)

    def getRecordLabels(self):
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.ExpressionBasedBushingForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedBushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedBushingForce

# Register ExpressionBasedBushingForce in _simulation:
_simulation.ExpressionBasedBushingForce_swigregister(ExpressionBasedBushingForce)
class ReferenceVec3(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ReferenceVec3

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ReferenceVec3_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ReferenceVec3 self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ReferenceVec3_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ReferenceVec3_getClassName()

    def clone(self):
        r"""clone(ReferenceVec3 self) -> ReferenceVec3"""
        return _simulation.ReferenceVec3_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ReferenceVec3 self) -> std::string const &"""
        return _simulation.ReferenceVec3_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceVec3

    def getNumRefs(self):
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceVec3_getNumRefs(self)

    def getValidTimeRange(self):
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceVec3_getValidTimeRange(self)

    def getNames(self):
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceVec3_getNames(self)

    def hasNext(self):
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceVec3_hasNext(self)

    def getWeights(self, *args):
        r"""
        getWeights(ReferenceVec3 self, State s, SimTKArrayDouble weights)

        Parameters
        ----------
        s: SimTK::State const &
        weights: SimTK::Array_< double,unsigned int > &

        getWeights(ReferenceVec3 self, State s) -> SimTKArrayDouble

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ReferenceVec3_getWeights(self, *args)

    def getValuesAtTime(self, time, values):
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceVec3_getValuesAtTime(self, time, values)

    def getValues(self, time):
        r"""
        getValues(ReferenceVec3 self, double time) -> SimTKArrayVec3

        Parameters
        ----------
        time: double

        """
        return _simulation.ReferenceVec3_getValues(self, time)

# Register ReferenceVec3 in _simulation:
_simulation.ReferenceVec3_swigregister(ReferenceVec3)
class ReferenceDouble(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ReferenceDouble

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ReferenceDouble_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ReferenceDouble self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ReferenceDouble_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ReferenceDouble_getClassName()

    def clone(self):
        r"""clone(ReferenceDouble self) -> ReferenceDouble"""
        return _simulation.ReferenceDouble_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ReferenceDouble self) -> std::string const &"""
        return _simulation.ReferenceDouble_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceDouble

    def getNumRefs(self):
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceDouble_getNumRefs(self)

    def getValidTimeRange(self):
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceDouble_getValidTimeRange(self)

    def getNames(self):
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceDouble_getNames(self)

    def hasNext(self):
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceDouble_hasNext(self)

    def getWeights(self, *args):
        r"""
        getWeights(ReferenceDouble self, State s, SimTKArrayDouble weights)

        Parameters
        ----------
        s: SimTK::State const &
        weights: SimTK::Array_< double,unsigned int > &

        getWeights(ReferenceDouble self, State s) -> SimTKArrayDouble

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ReferenceDouble_getWeights(self, *args)

    def getValuesAtTime(self, time, values):
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceDouble_getValuesAtTime(self, time, values)

    def getValues(self, time):
        r"""
        getValues(ReferenceDouble self, double time) -> SimTKArrayDouble

        Parameters
        ----------
        time: double

        """
        return _simulation.ReferenceDouble_getValues(self, time)

# Register ReferenceDouble in _simulation:
_simulation.ReferenceDouble_swigregister(ReferenceDouble)
class ReferenceRotation(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ReferenceRotation

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ReferenceRotation_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ReferenceRotation self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ReferenceRotation_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ReferenceRotation_getClassName()

    def clone(self):
        r"""clone(ReferenceRotation self) -> ReferenceRotation"""
        return _simulation.ReferenceRotation_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ReferenceRotation self) -> std::string const &"""
        return _simulation.ReferenceRotation_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceRotation

    def getNumRefs(self):
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceRotation_getNumRefs(self)

    def getValidTimeRange(self):
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceRotation_getValidTimeRange(self)

    def getNames(self):
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceRotation_getNames(self)

    def hasNext(self):
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceRotation_hasNext(self)

    def getWeights(self, *args):
        r"""
        getWeights(ReferenceRotation self, State s, SimTKArrayDouble weights)

        Parameters
        ----------
        s: SimTK::State const &
        weights: SimTK::Array_< double,unsigned int > &

        getWeights(ReferenceRotation self, State s) -> SimTKArrayDouble

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ReferenceRotation_getWeights(self, *args)

    def getValuesAtTime(self, time, values):
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceRotation_getValuesAtTime(self, time, values)

    def getValues(self, time):
        r"""
        getValues(ReferenceRotation self, double time) -> SimTKArrayRotation

        Parameters
        ----------
        time: double

        """
        return _simulation.ReferenceRotation_getValues(self, time)

# Register ReferenceRotation in _simulation:
_simulation.ReferenceRotation_swigregister(ReferenceRotation)
class StreamableReferenceRotation(ReferenceRotation):
    r"""Proxy of C++ OpenSim::StreamableReference_< SimTK::Rotation_< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> StreamableReferenceRotation

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.StreamableReferenceRotation_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(StreamableReferenceRotation self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.StreamableReferenceRotation_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.StreamableReferenceRotation_getClassName()

    def clone(self):
        r"""clone(StreamableReferenceRotation self) -> StreamableReferenceRotation"""
        return _simulation.StreamableReferenceRotation_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(StreamableReferenceRotation self) -> std::string const &"""
        return _simulation.StreamableReferenceRotation_getConcreteClassName(self)

    def getNextValuesAndTime(self, values):
        r"""
        getNextValuesAndTime(StreamableReferenceRotation self, SimTKArrayRotation values) -> double

        Parameters
        ----------
        values: SimTK::Array_< SimTK::Rotation_< double >,unsigned int > &

        """
        return _simulation.StreamableReferenceRotation_getNextValuesAndTime(self, values)

    def hasNext(self):
        r"""hasNext(StreamableReferenceRotation self) -> bool"""
        return _simulation.StreamableReferenceRotation_hasNext(self)
    __swig_destroy__ = _simulation.delete_StreamableReferenceRotation

# Register StreamableReferenceRotation in _simulation:
_simulation.StreamableReferenceRotation_swigregister(StreamableReferenceRotation)
class SimTKArrayCoordinateReference(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simulation.SimTKArrayCoordinateReference_swiginit(self, _simulation.new_SimTKArrayCoordinateReference(*args))
    __swig_destroy__ = _simulation.delete_SimTKArrayCoordinateReference

    def deallocate(self):
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< OpenSim::CoordinateReference >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simulation.SimTKArrayCoordinateReference_deallocate(self)

    def assign(self, n, fillValue):
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: :py:class:`CoordinateReference`, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simulation.SimTKArrayCoordinateReference_assign(self, n, fillValue)

    def fill(self, fillValue):
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: :py:class:`CoordinateReference`, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simulation.SimTKArrayCoordinateReference_fill(self, fillValue)

    def swap(self, other):
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simulation.SimTKArrayCoordinateReference_swap(self, other)

    def adoptData(self, *args):
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simulation.SimTKArrayCoordinateReference_adoptData(self, *args)

    def shareData(self, *args):
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simulation.SimTKArrayCoordinateReference_shareData(self, *args)

    def size(self):
        r""" Return the current number of elements stored in this array. *"""
        return _simulation.SimTKArrayCoordinateReference_size(self)

    def max_size(self):
        r""" Return the maximum allowable size for this array. *"""
        return _simulation.SimTKArrayCoordinateReference_max_size(self)

    def empty(self):
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simulation.SimTKArrayCoordinateReference_empty(self)

    def capacity(self):
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simulation.SimTKArrayCoordinateReference_capacity(self)

    def resize(self, *args):
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simulation.SimTKArrayCoordinateReference_resize(self, *args)

    def reserve(self, n):
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simulation.SimTKArrayCoordinateReference_reserve(self, n)

    def shrink_to_fit(self):
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simulation.SimTKArrayCoordinateReference_shrink_to_fit(self)

    def allocated(self):
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_allocated(self)

    def isOwner(self):
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_isOwner(self)

    def cbegin(self):
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simulation.SimTKArrayCoordinateReference_cbegin(self)

    def begin(self, *args):
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simulation.SimTKArrayCoordinateReference_begin(self, *args)

    def cend(self):
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simulation.SimTKArrayCoordinateReference_cend(self)

    def end(self, *args):
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simulation.SimTKArrayCoordinateReference_end(self, *args)

    def crbegin(self):
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simulation.SimTKArrayCoordinateReference_crbegin(self)

    def rbegin(self, *args):
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simulation.SimTKArrayCoordinateReference_rbegin(self, *args)

    def crend(self):
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simulation.SimTKArrayCoordinateReference_crend(self)

    def rend(self, *args):
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simulation.SimTKArrayCoordinateReference_rend(self, *args)

    def cdata(self):
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simulation.SimTKArrayCoordinateReference_cdata(self)

    def data(self, *args):
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_data(self, *args)

    def at(self, *args):
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_at(self, *args)

    def getElt(self, i):
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simulation.SimTKArrayCoordinateReference_getElt(self, i)

    def updElt(self, i):
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simulation.SimTKArrayCoordinateReference_updElt(self, i)

    def front(self, *args):
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_front(self, *args)

    def back(self, *args):
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_back(self, *args)

    def push_back(self, *args):
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: :py:class:`CoordinateReference`, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simulation.SimTKArrayCoordinateReference_push_back(self, *args)

    def raw_push_back(self):
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simulation.SimTKArrayCoordinateReference_raw_push_back(self)

    def pop_back(self):
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simulation.SimTKArrayCoordinateReference_pop_back(self)

    def erase(self, *args):
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: :py:class:`CoordinateReference`
        :param first:
                Points to the first element that will be erased.
        :type last1: :py:class:`CoordinateReference`
        :param last1:
                Points one element past the last element to be erased.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: :py:class:`CoordinateReference`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simulation.SimTKArrayCoordinateReference_erase(self, *args)

    def eraseFast(self, p):
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: :py:class:`CoordinateReference`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simulation.SimTKArrayCoordinateReference_eraseFast(self, p)

    def clear(self):
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simulation.SimTKArrayCoordinateReference_clear(self)

    def insert(self, *args):
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: :py:class:`CoordinateReference`, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: :py:class:`CoordinateReference`, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simulation.SimTKArrayCoordinateReference_insert(self, *args)

# Register SimTKArrayCoordinateReference in _simulation:
_simulation.SimTKArrayCoordinateReference_swigregister(SimTKArrayCoordinateReference)
class UnsupportedFileType(opensim.common.OpenSimException):
    r"""Proxy of C++ OpenSim::UnsupportedFileType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file, line, func, filename, msg):
        r"""
        __init__(UnsupportedFileType self, std::string const & file, size_t line, std::string const & func, std::string const & filename, std::string const & msg) -> UnsupportedFileType

        Parameters
        ----------
        file: std::string const &
        line: size_t
        func: std::string const &
        filename: std::string const &
        msg: std::string const &

        """
        _simulation.UnsupportedFileType_swiginit(self, _simulation.new_UnsupportedFileType(file, line, func, filename, msg))
    __swig_destroy__ = _simulation.delete_UnsupportedFileType

# Register UnsupportedFileType in _simulation:
_simulation.UnsupportedFileType_swigregister(UnsupportedFileType)
class MarkerWeight(opensim.common.OpenSimObject):
    r"""Proxy of C++ OpenSim::MarkerWeight class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MarkerWeight

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MarkerWeight_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MarkerWeight self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MarkerWeight_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MarkerWeight_getClassName()

    def clone(self):
        r"""clone(MarkerWeight self) -> MarkerWeight"""
        return _simulation.MarkerWeight_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MarkerWeight self) -> std::string const &"""
        return _simulation.MarkerWeight_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(MarkerWeight self) -> MarkerWeight
        __init__(MarkerWeight self, std::string name, double weight) -> MarkerWeight

        Parameters
        ----------
        name: std::string
        weight: double

        """
        _simulation.MarkerWeight_swiginit(self, _simulation.new_MarkerWeight(*args))

    def setWeight(self, weight):
        r"""
        setWeight(MarkerWeight self, double weight)

        Parameters
        ----------
        weight: double

        """
        return _simulation.MarkerWeight_setWeight(self, weight)

    def getWeight(self):
        r"""getWeight(MarkerWeight self) -> double"""
        return _simulation.MarkerWeight_getWeight(self)
    __swig_destroy__ = _simulation.delete_MarkerWeight

# Register MarkerWeight in _simulation:
_simulation.MarkerWeight_swigregister(MarkerWeight)
class MarkersReference(ReferenceVec3):
    r"""
    Reference values to be achieved for specified Markers that will be used
    via optimization and/or tracking. Also contains a weighting that identifies
    the relative importance of achieving one marker's reference relative to
    another.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MarkersReference

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MarkersReference_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MarkersReference self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MarkersReference_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MarkersReference_getClassName()

    def clone(self):
        r"""clone(MarkersReference self) -> MarkersReference"""
        return _simulation.MarkersReference_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MarkersReference self) -> std::string const &"""
        return _simulation.MarkersReference_getConcreteClassName(self)

    def copyProperty_marker_file(self, source):
        r"""
        copyProperty_marker_file(MarkersReference self, MarkersReference source)

        Parameters
        ----------
        source: OpenSim::MarkersReference::Self const &

        """
        return _simulation.MarkersReference_copyProperty_marker_file(self, source)

    def append_marker_file(self, value):
        r"""
        append_marker_file(MarkersReference self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.MarkersReference_append_marker_file(self, value)

    def constructProperty_marker_file(self, initValue):
        r"""
        constructProperty_marker_file(MarkersReference self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.MarkersReference_constructProperty_marker_file(self, initValue)

    def get_marker_file(self, *args):
        r"""
        get_marker_file(MarkersReference self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_marker_file(MarkersReference self) -> std::string const &
        """
        return _simulation.MarkersReference_get_marker_file(self, *args)

    def upd_marker_file(self, *args):
        r"""
        upd_marker_file(MarkersReference self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_marker_file(MarkersReference self) -> std::string &
        """
        return _simulation.MarkersReference_upd_marker_file(self, *args)

    def set_marker_file(self, *args):
        r"""
        set_marker_file(MarkersReference self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_marker_file(MarkersReference self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.MarkersReference_set_marker_file(self, *args)

    def copyProperty_marker_weights(self, source):
        r"""
        copyProperty_marker_weights(MarkersReference self, MarkersReference source)

        Parameters
        ----------
        source: OpenSim::MarkersReference::Self const &

        """
        return _simulation.MarkersReference_copyProperty_marker_weights(self, source)

    def append_marker_weights(self, value):
        r"""
        append_marker_weights(MarkersReference self, SetMarkerWeights value) -> int

        Parameters
        ----------
        value: OpenSim::Set< OpenSim::MarkerWeight > const &

        """
        return _simulation.MarkersReference_append_marker_weights(self, value)

    def constructProperty_marker_weights(self, initValue):
        r"""
        constructProperty_marker_weights(MarkersReference self, SetMarkerWeights initValue)

        Parameters
        ----------
        initValue: OpenSim::Set< OpenSim::MarkerWeight > const &

        """
        return _simulation.MarkersReference_constructProperty_marker_weights(self, initValue)

    def get_marker_weights(self, *args):
        r"""
        get_marker_weights(MarkersReference self, int i) -> SetMarkerWeights

        Parameters
        ----------
        i: int

        get_marker_weights(MarkersReference self) -> SetMarkerWeights
        """
        return _simulation.MarkersReference_get_marker_weights(self, *args)

    def upd_marker_weights(self, *args):
        r"""
        upd_marker_weights(MarkersReference self, int i) -> SetMarkerWeights

        Parameters
        ----------
        i: int

        upd_marker_weights(MarkersReference self) -> SetMarkerWeights
        """
        return _simulation.MarkersReference_upd_marker_weights(self, *args)

    def set_marker_weights(self, *args):
        r"""
        set_marker_weights(MarkersReference self, int i, SetMarkerWeights value)

        Parameters
        ----------
        i: int
        value: OpenSim::Set< OpenSim::MarkerWeight > const &

        set_marker_weights(MarkersReference self, SetMarkerWeights value)

        Parameters
        ----------
        value: OpenSim::Set< OpenSim::MarkerWeight > const &

        """
        return _simulation.MarkersReference_set_marker_weights(self, *args)

    def copyProperty_default_weight(self, source):
        r"""
        copyProperty_default_weight(MarkersReference self, MarkersReference source)

        Parameters
        ----------
        source: OpenSim::MarkersReference::Self const &

        """
        return _simulation.MarkersReference_copyProperty_default_weight(self, source)

    def append_default_weight(self, value):
        r"""
        append_default_weight(MarkersReference self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MarkersReference_append_default_weight(self, value)

    def constructProperty_default_weight(self, initValue):
        r"""
        constructProperty_default_weight(MarkersReference self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MarkersReference_constructProperty_default_weight(self, initValue)

    def get_default_weight(self, *args):
        r"""
        get_default_weight(MarkersReference self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_weight(MarkersReference self) -> double const &
        """
        return _simulation.MarkersReference_get_default_weight(self, *args)

    def upd_default_weight(self, *args):
        r"""
        upd_default_weight(MarkersReference self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_weight(MarkersReference self) -> double &
        """
        return _simulation.MarkersReference_upd_default_weight(self, *args)

    def set_default_weight(self, *args):
        r"""
        set_default_weight(MarkersReference self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_weight(MarkersReference self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MarkersReference_set_default_weight(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience load markers from a file. See below.

        |

        *Overload 2:*
        Convenience load markers from a file. See below.

        |

        *Overload 3:*
        Form a Reference from TimeSeriesTable and corresponding marker weights.
           The marker weights are used to initialize the weightings of the markers
           provided by the Reference. Marker weights are associated to markers by
           name. If a markerWeightSet is provided, then only those markers listed in
           the set are tracked, otherwise all the markerData table that correspond
           with model markers are tracked with the default weighting.
           The TimeSeriesTable should contain the key 'Units', representing
           units of the columns, as table metadata. In absence of 'Units' metadata,
           columns are assumed to be of units 'meters'.

        |

        *Overload 4:*
        Form a Reference from TimeSeriesTable and corresponding marker weights.
           The marker weights are used to initialize the weightings of the markers
           provided by the Reference. Marker weights are associated to markers by
           name. If a markerWeightSet is provided, then only those markers listed in
           the set are tracked, otherwise all the markerData table that correspond
           with model markers are tracked with the default weighting.
           The TimeSeriesTable should contain the key 'Units', representing
           units of the columns, as table metadata. In absence of 'Units' metadata,
           columns are assumed to be of units 'meters'.
        """
        _simulation.MarkersReference_swiginit(self, _simulation.new_MarkersReference(*args))
    __swig_destroy__ = _simulation.delete_MarkersReference

    def initializeFromMarkersFile(self, *args):
        r"""
        Initialize this MarkersReference from data in a markerFile such that it
               corresponds to the markers that have weights. If weights is empty Set,
               all corresponding markers are tracked at default reference weight.
               See setDefaultWeight()
        """
        return _simulation.MarkersReference_initializeFromMarkersFile(self, *args)

    def getNumRefs(self):
        r"""getNumRefs(MarkersReference self) -> int"""
        return _simulation.MarkersReference_getNumRefs(self)

    def getValidTimeRange(self):
        r"""
        get the time range for which the MarkersReference values are valid,
               based on the loaded marker data.
        """
        return _simulation.MarkersReference_getValidTimeRange(self)

    def getNames(self):
        r""" get the names of the markers serving as references"""
        return _simulation.MarkersReference_getNames(self)

    def getValuesAtTime(self, time, values):
        r""" get the value of the MarkersReference"""
        return _simulation.MarkersReference_getValuesAtTime(self, time, values)

    def getWeights(self, s, weights):
        r"""
        get the weighting (importance) of meeting this MarkersReference in the
               same order as names
        """
        return _simulation.MarkersReference_getWeights(self, s, weights)

    def getMarkerTable(self):
        r""" get the marker trajectories in a table"""
        return _simulation.MarkersReference_getMarkerTable(self)

    def getSamplingFrequency(self):
        r"""getSamplingFrequency(MarkersReference self) -> double"""
        return _simulation.MarkersReference_getSamplingFrequency(self)

    def getMarkerWeightSet(self):
        r"""getMarkerWeightSet(MarkersReference self) -> SetMarkerWeights"""
        return _simulation.MarkersReference_getMarkerWeightSet(self)

    def updMarkerWeightSet(self):
        r"""updMarkerWeightSet(MarkersReference self) -> SetMarkerWeights"""
        return _simulation.MarkersReference_updMarkerWeightSet(self)

    def setMarkerWeightSet(self, markerWeights):
        r"""
        %Set the marker weights from a set of MarkerWeights. As of OpenSim 4.0
               the input set is const and a copy of the Set is used internally.
               Therefore, subsequent changes to the Set of MarkerWeights will have
               no effect on the marker weights associated with this Reference.
        """
        return _simulation.MarkersReference_setMarkerWeightSet(self, markerWeights)

    def setDefaultWeight(self, weight):
        r"""
        setDefaultWeight(MarkersReference self, double weight)

        Parameters
        ----------
        weight: double

        """
        return _simulation.MarkersReference_setDefaultWeight(self, weight)

    def getNumFrames(self):
        r"""getNumFrames(MarkersReference self) -> size_t"""
        return _simulation.MarkersReference_getNumFrames(self)

# Register MarkersReference in _simulation:
_simulation.MarkersReference_swigregister(MarkersReference)
class SharedMarkersReference(object):
    r"""Proxy of C++ std::shared_ptr< OpenSim::MarkersReference > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SharedMarkersReference self) -> SharedMarkersReference"""
        _simulation.SharedMarkersReference_swiginit(self, _simulation.new_SharedMarkersReference())
    __swig_destroy__ = _simulation.delete_SharedMarkersReference

# Register SharedMarkersReference in _simulation:
_simulation.SharedMarkersReference_swigregister(SharedMarkersReference)
class SetMarkerWeights(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetMarkerWeights

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetMarkerWeights_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetMarkerWeights self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetMarkerWeights_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetMarkerWeights_getClassName()

    def clone(self):
        r"""clone(SetMarkerWeights self) -> SetMarkerWeights"""
        return _simulation.SetMarkerWeights_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetMarkerWeights self) -> std::string const &"""
        return _simulation.SetMarkerWeights_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMarkerWeights

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::MarkerWeight,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetMarkerWeights_swiginit(self, _simulation.new_SetMarkerWeights(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMarkerWeights_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMarkerWeights_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMarkerWeights_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMarkerWeights_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMarkerWeights_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetMarkerWeights_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetMarkerWeights self)"""
        return _simulation.SetMarkerWeights_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`MarkerWeight`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`MarkerWeight`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMarkerWeights_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMarkerWeights_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMarkerWeights_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetMarkerWeights_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetMarkerWeights_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMarkerWeights_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetMarkerWeights_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetMarkerWeights_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetMarkerWeights_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMarkerWeights_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMarkerWeights in _simulation:
_simulation.SetMarkerWeights_swigregister(SetMarkerWeights)
class CoordinateReference(ReferenceDouble):
    r"""
    Reference value to be achieved for a specified coordinate that will be used
    via optimization and/or tracking. Also contains a weighting that identifies
    the relative importance of achieving one CoordinateReference relative to
    other coordinates.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CoordinateReference

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.CoordinateReference_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CoordinateReference self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.CoordinateReference_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.CoordinateReference_getClassName()

    def clone(self):
        r"""clone(CoordinateReference self) -> CoordinateReference"""
        return _simulation.CoordinateReference_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CoordinateReference self) -> std::string const &"""
        return _simulation.CoordinateReference_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(CoordinateReference self) -> CoordinateReference
        __init__(CoordinateReference self, std::string const name, Function ReferenceFunction) -> CoordinateReference

        Parameters
        ----------
        name: std::string const
        ReferenceFunction: OpenSim::Function const &

        __init__(CoordinateReference self, CoordinateReference source) -> CoordinateReference

        Parameters
        ----------
        source: OpenSim::CoordinateReference const &

        """
        _simulation.CoordinateReference_swiginit(self, _simulation.new_CoordinateReference(*args))
    __swig_destroy__ = _simulation.delete_CoordinateReference

    def getNumRefs(self):
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.CoordinateReference_getNumRefs(self)

    def getNames(self):
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.CoordinateReference_getNames(self)

    def getValuesAtTime(self, time, values):
        r""" get the value of the Reference as a function of the state"""
        return _simulation.CoordinateReference_getValuesAtTime(self, time, values)

    def getWeights(self, s, weights):
        r""" get the weighting (importance) of meeting this Reference"""
        return _simulation.CoordinateReference_getWeights(self, s, weights)

    def getValue(self, s):
        r""" get the value of the CoordinateReference"""
        return _simulation.CoordinateReference_getValue(self, s)

    def getSpeedValue(self, s):
        r""" get the speed value of the CoordinateReference"""
        return _simulation.CoordinateReference_getSpeedValue(self, s)

    def getAccelerationValue(self, s):
        r""" get the speed value of the CoordinateReference"""
        return _simulation.CoordinateReference_getAccelerationValue(self, s)

    def getWeight(self, s):
        r""" get the weighting (importance) of meeting this CoordinateReference"""
        return _simulation.CoordinateReference_getWeight(self, s)

    def setWeight(self, weight):
        r""" set the weighting (importance) of meeting this CoordinateReference"""
        return _simulation.CoordinateReference_setWeight(self, weight)

    def setValueFunction(self, function):
        r""" %Set the coordinate value as a function of time."""
        return _simulation.CoordinateReference_setValueFunction(self, function)

# Register CoordinateReference in _simulation:
_simulation.CoordinateReference_swigregister(CoordinateReference)
class OrientationWeight(opensim.common.OpenSimObject):
    r"""Proxy of C++ OpenSim::OrientationWeight class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> OrientationWeight

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.OrientationWeight_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(OrientationWeight self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.OrientationWeight_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.OrientationWeight_getClassName()

    def clone(self):
        r"""clone(OrientationWeight self) -> OrientationWeight"""
        return _simulation.OrientationWeight_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(OrientationWeight self) -> std::string const &"""
        return _simulation.OrientationWeight_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(OrientationWeight self) -> OrientationWeight
        __init__(OrientationWeight self, std::string name, double weight) -> OrientationWeight

        Parameters
        ----------
        name: std::string
        weight: double

        """
        _simulation.OrientationWeight_swiginit(self, _simulation.new_OrientationWeight(*args))

    def setWeight(self, weight):
        r"""
        setWeight(OrientationWeight self, double weight)

        Parameters
        ----------
        weight: double

        """
        return _simulation.OrientationWeight_setWeight(self, weight)

    def getWeight(self):
        r"""getWeight(OrientationWeight self) -> double"""
        return _simulation.OrientationWeight_getWeight(self)
    __swig_destroy__ = _simulation.delete_OrientationWeight

# Register OrientationWeight in _simulation:
_simulation.OrientationWeight_swigregister(OrientationWeight)
class OrientationsReference(StreamableReferenceRotation):
    r"""
    Reference values for the Orientations of model frames that will be used to
    to compute tracking errors. An Orientation is specified by a Rotation
    matrix describing the frame orientation with respect to Ground. The
    reference also contains weightings that identifies the relative importance
    of achieving one orientation's reference value over another.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> OrientationsReference

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.OrientationsReference_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(OrientationsReference self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.OrientationsReference_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.OrientationsReference_getClassName()

    def clone(self):
        r"""clone(OrientationsReference self) -> OrientationsReference"""
        return _simulation.OrientationsReference_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(OrientationsReference self) -> std::string const &"""
        return _simulation.OrientationsReference_getConcreteClassName(self)

    def copyProperty_orientation_file(self, source):
        r"""
        copyProperty_orientation_file(OrientationsReference self, OrientationsReference source)

        Parameters
        ----------
        source: OpenSim::OrientationsReference::Self const &

        """
        return _simulation.OrientationsReference_copyProperty_orientation_file(self, source)

    def append_orientation_file(self, value):
        r"""
        append_orientation_file(OrientationsReference self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.OrientationsReference_append_orientation_file(self, value)

    def constructProperty_orientation_file(self, initValue):
        r"""
        constructProperty_orientation_file(OrientationsReference self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.OrientationsReference_constructProperty_orientation_file(self, initValue)

    def get_orientation_file(self, *args):
        r"""
        get_orientation_file(OrientationsReference self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_orientation_file(OrientationsReference self) -> std::string const &
        """
        return _simulation.OrientationsReference_get_orientation_file(self, *args)

    def upd_orientation_file(self, *args):
        r"""
        upd_orientation_file(OrientationsReference self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_orientation_file(OrientationsReference self) -> std::string &
        """
        return _simulation.OrientationsReference_upd_orientation_file(self, *args)

    def set_orientation_file(self, *args):
        r"""
        set_orientation_file(OrientationsReference self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_orientation_file(OrientationsReference self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.OrientationsReference_set_orientation_file(self, *args)

    def copyProperty_orientation_weights(self, source):
        r"""
        copyProperty_orientation_weights(OrientationsReference self, OrientationsReference source)

        Parameters
        ----------
        source: OpenSim::OrientationsReference::Self const &

        """
        return _simulation.OrientationsReference_copyProperty_orientation_weights(self, source)

    def append_orientation_weights(self, value):
        r"""
        append_orientation_weights(OrientationsReference self, SetOientationWeights value) -> int

        Parameters
        ----------
        value: OpenSim::Set< OpenSim::OrientationWeight > const &

        """
        return _simulation.OrientationsReference_append_orientation_weights(self, value)

    def constructProperty_orientation_weights(self, initValue):
        r"""
        constructProperty_orientation_weights(OrientationsReference self, SetOientationWeights initValue)

        Parameters
        ----------
        initValue: OpenSim::Set< OpenSim::OrientationWeight > const &

        """
        return _simulation.OrientationsReference_constructProperty_orientation_weights(self, initValue)

    def get_orientation_weights(self, *args):
        r"""
        get_orientation_weights(OrientationsReference self, int i) -> SetOientationWeights

        Parameters
        ----------
        i: int

        get_orientation_weights(OrientationsReference self) -> SetOientationWeights
        """
        return _simulation.OrientationsReference_get_orientation_weights(self, *args)

    def upd_orientation_weights(self, *args):
        r"""
        upd_orientation_weights(OrientationsReference self, int i) -> SetOientationWeights

        Parameters
        ----------
        i: int

        upd_orientation_weights(OrientationsReference self) -> SetOientationWeights
        """
        return _simulation.OrientationsReference_upd_orientation_weights(self, *args)

    def set_orientation_weights(self, *args):
        r"""
        set_orientation_weights(OrientationsReference self, int i, SetOientationWeights value)

        Parameters
        ----------
        i: int
        value: OpenSim::Set< OpenSim::OrientationWeight > const &

        set_orientation_weights(OrientationsReference self, SetOientationWeights value)

        Parameters
        ----------
        value: OpenSim::Set< OpenSim::OrientationWeight > const &

        """
        return _simulation.OrientationsReference_set_orientation_weights(self, *args)

    def copyProperty_default_weight(self, source):
        r"""
        copyProperty_default_weight(OrientationsReference self, OrientationsReference source)

        Parameters
        ----------
        source: OpenSim::OrientationsReference::Self const &

        """
        return _simulation.OrientationsReference_copyProperty_default_weight(self, source)

    def append_default_weight(self, value):
        r"""
        append_default_weight(OrientationsReference self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.OrientationsReference_append_default_weight(self, value)

    def constructProperty_default_weight(self, initValue):
        r"""
        constructProperty_default_weight(OrientationsReference self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.OrientationsReference_constructProperty_default_weight(self, initValue)

    def get_default_weight(self, *args):
        r"""
        get_default_weight(OrientationsReference self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_weight(OrientationsReference self) -> double const &
        """
        return _simulation.OrientationsReference_get_default_weight(self, *args)

    def upd_default_weight(self, *args):
        r"""
        upd_default_weight(OrientationsReference self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_weight(OrientationsReference self) -> double &
        """
        return _simulation.OrientationsReference_upd_default_weight(self, *args)

    def set_default_weight(self, *args):
        r"""
        set_default_weight(OrientationsReference self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_weight(OrientationsReference self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.OrientationsReference_set_default_weight(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience load Orientations data from a file in the form of XYZ
               body-fixed Euler angles. Units default to Radians.

        |

        *Overload 2:*
        Convenience load Orientations data from a file in the form of XYZ
               body-fixed Euler angles. Units default to Radians.

        |

        *Overload 3:*
        Form a Reference from TimeSeriesTable of Rotations and corresponding
           orientation weights. The input orientatonWeightSet is used to initialize
           Reference weightings for individual Orientations. Weights are associated
           to Orientations by name.

        |

        *Overload 4:*
        Form a Reference from TimeSeriesTable of Rotations and corresponding
           orientation weights. The input orientatonWeightSet is used to initialize
           Reference weightings for individual Orientations. Weights are associated
           to Orientations by name.
        """
        _simulation.OrientationsReference_swiginit(self, _simulation.new_OrientationsReference(*args))
    __swig_destroy__ = _simulation.delete_OrientationsReference

    def loadOrientationsEulerAnglesFile(self, *args):
        r"""
        load the orientation data for this OrientationsReference from a file
           containing Euler-angles in body-fixed XYZ order.
        """
        return _simulation.OrientationsReference_loadOrientationsEulerAnglesFile(self, *args)

    def getNumRefs(self):
        r"""getNumRefs(OrientationsReference self) -> int"""
        return _simulation.OrientationsReference_getNumRefs(self)

    def getValidTimeRange(self):
        r"""
        get the time range for which the OrientationsReference values are valid,
               based on the loaded orientation data.
        """
        return _simulation.OrientationsReference_getValidTimeRange(self)

    def getTimes(self):
        r"""
        get the times at which the OrientationsReference values are specified,
               based on the loaded orientation data.
        """
        return _simulation.OrientationsReference_getTimes(self)

    def getNames(self):
        r""" get the names of the Orientations serving as references"""
        return _simulation.OrientationsReference_getNames(self)

    def getValuesAtTime(self, time, values):
        r""" get the value of the OrientationsReference"""
        return _simulation.OrientationsReference_getValuesAtTime(self, time, values)

    def getNextValuesAndTime(self, values):
        r""" Default implementation does not support streaming"""
        return _simulation.OrientationsReference_getNextValuesAndTime(self, values)

    def hasNext(self):
        r"""hasNext(OrientationsReference self) -> bool"""
        return _simulation.OrientationsReference_hasNext(self)

    def getWeights(self, s, weights):
        r"""
        get the weighting (importance) of meeting this OrientationsReference in the
               same order as names
        """
        return _simulation.OrientationsReference_getWeights(self, s, weights)

    def getSamplingFrequency(self):
        r"""getSamplingFrequency(OrientationsReference self) -> double"""
        return _simulation.OrientationsReference_getSamplingFrequency(self)

    def updOrientationWeightSet(self):
        r"""updOrientationWeightSet(OrientationsReference self) -> SetOientationWeights"""
        return _simulation.OrientationsReference_updOrientationWeightSet(self)

    def setOrientationWeightSet(self, orientationWeights):
        r"""
        %Set the orientation weights from a set of OrientationWeights, which is
           const and a copy of the Set is used internally. Therefore, subsequent changes
           to the Set of OrientationWeights will have no effect on the orientation weights
           associated with this Reference. You can, however, change the weightings on the
           InverseKinematicsSolver prior to solving at any instant in time.
        """
        return _simulation.OrientationsReference_setOrientationWeightSet(self, orientationWeights)

    def setDefaultWeight(self, weight):
        r"""
        setDefaultWeight(OrientationsReference self, double weight)

        Parameters
        ----------
        weight: double

        """
        return _simulation.OrientationsReference_setDefaultWeight(self, weight)

# Register OrientationsReference in _simulation:
_simulation.OrientationsReference_swigregister(OrientationsReference)
class SetOientationWeights(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetOientationWeights

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.SetOientationWeights_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetOientationWeights self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.SetOientationWeights_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.SetOientationWeights_getClassName()

    def clone(self):
        r"""clone(SetOientationWeights self) -> SetOientationWeights"""
        return _simulation.SetOientationWeights_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetOientationWeights self) -> std::string const &"""
        return _simulation.SetOientationWeights_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetOientationWeights

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::OrientationWeight,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetOientationWeights_swiginit(self, _simulation.new_SetOientationWeights(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetOientationWeights_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetOientationWeights_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetOientationWeights_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetOientationWeights_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetOientationWeights_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _simulation.SetOientationWeights_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetOientationWeights self)"""
        return _simulation.SetOientationWeights_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`OrientationWeight`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`OrientationWeight`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetOientationWeights_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetOientationWeights_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetOientationWeights_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _simulation.SetOientationWeights_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _simulation.SetOientationWeights_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetOientationWeights_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _simulation.SetOientationWeights_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _simulation.SetOientationWeights_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _simulation.SetOientationWeights_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetOientationWeights_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetOientationWeights in _simulation:
_simulation.SetOientationWeights_swigregister(SetOientationWeights)
class SharedOrientationsReference(object):
    r"""Proxy of C++ std::shared_ptr< OpenSim::OrientationsReference > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(SharedOrientationsReference self) -> SharedOrientationsReference"""
        _simulation.SharedOrientationsReference_swiginit(self, _simulation.new_SharedOrientationsReference())
    __swig_destroy__ = _simulation.delete_SharedOrientationsReference

# Register SharedOrientationsReference in _simulation:
_simulation.SharedOrientationsReference_swigregister(SharedOrientationsReference)
class BufferedOrientationsReference(OrientationsReference):
    r"""
    Subclass of OrientationsReference that handles live data by providing a DataQueue
    that allows clients to push data into and allows the InverseKinematicsSolver to
    draw data from for solving.
    Ideally this would be templatized, allowing for all Reference classes to leverage it.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BufferedOrientationsReference

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.BufferedOrientationsReference_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BufferedOrientationsReference self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.BufferedOrientationsReference_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.BufferedOrientationsReference_getClassName()

    def clone(self):
        r"""clone(BufferedOrientationsReference self) -> BufferedOrientationsReference"""
        return _simulation.BufferedOrientationsReference_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BufferedOrientationsReference self) -> std::string const &"""
        return _simulation.BufferedOrientationsReference_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(BufferedOrientationsReference self) -> BufferedOrientationsReference
        __init__(BufferedOrientationsReference self, BufferedOrientationsReference arg2) -> BufferedOrientationsReference

        Parameters
        ----------
        arg2: OpenSim::BufferedOrientationsReference const &

        __init__(BufferedOrientationsReference self, BufferedOrientationsReference arg2) -> BufferedOrientationsReference

        Parameters
        ----------
        arg2: OpenSim::BufferedOrientationsReference &&

        """
        _simulation.BufferedOrientationsReference_swiginit(self, _simulation.new_BufferedOrientationsReference(*args))
    __swig_destroy__ = _simulation.delete_BufferedOrientationsReference

    def getValidTimeRange(self):
        r"""
        get the time range for which this Reference values are valid,
               based on the loaded orientation data.
        """
        return _simulation.BufferedOrientationsReference_getValidTimeRange(self)

    def getValuesAtTime(self, time, values):
        r"""
         get the values from the base OrientationsReference, or from
        the client provided data that was queued earlier using putValues call.
        """
        return _simulation.BufferedOrientationsReference_getValuesAtTime(self, time, values)

    def putValues(self, time, dataRow):
        r""" add passed in values to data procesing Queue"""
        return _simulation.BufferedOrientationsReference_putValues(self, time, dataRow)

    def getNextValuesAndTime(self, values):
        r"""
        getNextValuesAndTime(BufferedOrientationsReference self, SimTKArrayRotation values) -> double

        Parameters
        ----------
        values: SimTK::Array_< SimTK::Rotation_< double >,unsigned int > &

        """
        return _simulation.BufferedOrientationsReference_getNextValuesAndTime(self, values)

    def hasNext(self):
        r"""hasNext(BufferedOrientationsReference self) -> bool"""
        return _simulation.BufferedOrientationsReference_hasNext(self)

    def setFinished(self, finished):
        r"""
        setFinished(BufferedOrientationsReference self, bool finished)

        Parameters
        ----------
        finished: bool

        """
        return _simulation.BufferedOrientationsReference_setFinished(self, finished)

# Register BufferedOrientationsReference in _simulation:
_simulation.BufferedOrientationsReference_swigregister(BufferedOrientationsReference)
class AssemblySolver(Solver):
    r"""
    Solve for the coordinates (degrees-of-freedom) of the model that satisfy the
    set of constraints imposed on the model as well as set of desired coordinate
    values.  The AssembleSolver provides the option to convert the problem to an
    approximate one where the constraint violations are treated as penalties to
    to be minimized rather than strictly enforced. This can speed up the time
    solution and can be used to seed the constrained problem near to a solution.

    The assembly objective: min A = sum(Wq_i*(q_i-qd_i)^2)) + [Wc*sum(c_err)^2]
    iff Wc == Infinity, second term is not included, but
     A is subject to the constraint equations:  G(q)-Go = 0

    When the model (and the number of goals) is guaranteed not to change and the
    the initial state is close to the assembly solution (from initial assembly(),
    then track() is a efficient method for updating the configuration to track
    the small change to the desired coordinate value.

    See SimTK::Assembler for more algorithmic details of the underlying solver.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> AssemblySolver

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.AssemblySolver_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(AssemblySolver self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.AssemblySolver_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.AssemblySolver_getClassName()

    def clone(self):
        r"""clone(AssemblySolver self) -> AssemblySolver"""
        return _simulation.AssemblySolver_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(AssemblySolver self) -> std::string const &"""
        return _simulation.AssemblySolver_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        Construct an Assembly solver with the coordinate references as the goal
               of the assembly and (optional)constraint weight. Default is infinity
               constraint weighting (i.e. rigidly enforced) during assembly.
        """
        _simulation.AssemblySolver_swiginit(self, _simulation.new_AssemblySolver(*args))
    __swig_destroy__ = _simulation.delete_AssemblySolver

    def setAccuracy(self, accuracy):
        r"""
        %Set the unitless accuracy of the assembly solution, which dictates
               the number of significant digits the solution should be resolved to.
               Note, setting the accuracy will invalidate the AssemblySolver and one
               must call assemble() before being able to track().
        """
        return _simulation.AssemblySolver_setAccuracy(self, accuracy)

    def setConstraintWeight(self, weight):
        r"""
        %Set the relative weighting for constraints. Use Infinity to identify the
               strict enforcement of constraints, otherwise any positive weighting will
               append the constraint errors to the assembly cost which the solver will
               minimize.
        """
        return _simulation.AssemblySolver_setConstraintWeight(self, weight)

    def getCoordinateReferences(self):
        r"""
        Specify which coordinates to match, each with a desired value and a
               relative weighting.
        """
        return _simulation.AssemblySolver_getCoordinateReferences(self)

    def updateCoordinateReference(self, coordName, value, weight=1.0):
        r"""
        Once a set of coordinates has been specified its reference value and
               weight can be updated directly
        """
        return _simulation.AssemblySolver_updateCoordinateReference(self, coordName, value, weight)

    def assemble(self, s):
        r"""
        Assemble a model configuration that meets the assembly conditions
               (desired values and constraints) and accuracy, starting from an initial
               state that does not have to satisfy the constraints.
        """
        return _simulation.AssemblySolver_assemble(self, s)

    def track(self, s):
        r"""
        Obtain a model configuration that meets the assembly conditions
               (desired values and constraints) given a state that satisfies or
               is close to satisfying the constraints. Note there can be no change
               in the number of constraints or desired coordinates. Desired
               coordinate values can and should be updated between repeated calls
               to track a desired trajectory of coordinate values. Use assemble()
               first to obtain the first solution and use track() to efficiently
               find a nearby solution due to a small change in the desired value.
        """
        return _simulation.AssemblySolver_track(self, s)

    def getAssembler(self):
        r""" Read access to the underlying SimTK::Assembler."""
        return _simulation.AssemblySolver_getAssembler(self)

# Register AssemblySolver in _simulation:
_simulation.AssemblySolver_swigregister(AssemblySolver)
class InverseKinematicsSolver(AssemblySolver):
    r"""
    Solve for the coordinates (degrees of freedom) of the model that satisfy the
    set of constraints imposed on the model and the set of desired coordinate
    values. The InverseKinematicsSolver provides the option to convert the
    problem to an approximate one where the constraint violations are treated as
    penalties to be minimized rather than strictly enforced. This can speed up
    the solution and can be used to seed the constrained problem closer to the
    solution.

    The InverseKinematicsSolver objective:

    .. math::

        min: J = sum(Wm_i*(m_i-md_i)^T*(m_i-md_i)) + sum(Wq_j*(q_j-qd_j)^2) +
                   [Wc*sum(c_{err})^2]
    where m_i and md_i are the model and desired marker locations (Vec3); q_j
    and qd_j are model and desired joint coordinates. Wm_i and Wq_j are the
    marker and coordinate weightings, respectively, and Wc is the weighting on
    constraint errors. When Wc == Infinity, the second term is not included,
    but instead q is subject to the constraint equations:

         .. math::

             c_{err} = G(q)-Go = 0

    When the model (and the number of goals) is guaranteed not to change and
    the initial state is close to the InverseKinematics solution (e.g., from the
    initial assemble()), then track() is an efficient method for updating the
    configuration to determine the small change in coordinate values, q.

    See SimTK::Assembler for more algorithmic details of the underlying solver.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_InverseKinematicsSolver

    def __init__(self, *args):
        r"""
        __init__(InverseKinematicsSolver self, Model model, SharedMarkersReference markersReference, SimTKArrayCoordinateReference coordinateReferences, double constraintWeight=SimTK::Infinity) -> InverseKinematicsSolver

        Parameters
        ----------
        model: OpenSim::Model const &
        markersReference: std::shared_ptr< OpenSim::MarkersReference >
        coordinateReferences: SimTK::Array_< OpenSim::CoordinateReference,unsigned int > &
        constraintWeight: double

        __init__(InverseKinematicsSolver self, Model model, SharedMarkersReference markersReference, SharedOrientationsReference orientationsReference, SimTKArrayCoordinateReference coordinateReferences, double constraintWeight=SimTK::Infinity) -> InverseKinematicsSolver

        Parameters
        ----------
        model: OpenSim::Model const &
        markersReference: std::shared_ptr< OpenSim::MarkersReference >
        orientationsReference: std::shared_ptr< OpenSim::OrientationsReference >
        coordinateReferences: SimTK::Array_< OpenSim::CoordinateReference,unsigned int > &
        constraintWeight: double

        __init__(InverseKinematicsSolver self, Model model, MarkersReference markersReference, SimTKArrayCoordinateReference coordinateReferences, double constraintWeight=SimTK::Infinity) -> InverseKinematicsSolver

        Parameters
        ----------
        model: OpenSim::Model const &
        markersReference: OpenSim::MarkersReference const &
        coordinateReferences: SimTK::Array_< OpenSim::CoordinateReference,unsigned int > &
        constraintWeight: double

        __init__(InverseKinematicsSolver self, Model model, MarkersReference markersReference, OrientationsReference orientationsReference, SimTKArrayCoordinateReference coordinateReferences, double constraintWeight=SimTK::Infinity) -> InverseKinematicsSolver

        Parameters
        ----------
        model: OpenSim::Model const &
        markersReference: OpenSim::MarkersReference const &
        orientationsReference: OpenSim::OrientationsReference const &
        coordinateReferences: SimTK::Array_< OpenSim::CoordinateReference,unsigned int > &
        constraintWeight: double

        """
        _simulation.InverseKinematicsSolver_swiginit(self, _simulation.new_InverseKinematicsSolver(*args))

    def getNumMarkersInUse(self):
        r"""
        Return the number of markers used to solve for model coordinates.
               It is a count of the number of markers in the intersection of
               the reference markers and model markers.
               This number is guaranteed not to change after assemble() is called
               (i.e. during subsequent calls to track()).
        """
        return _simulation.InverseKinematicsSolver_getNumMarkersInUse(self)

    def getNumOrientationSensorsInUse(self):
        r"""
        Return the number of orientation sensors used to solve for model
           coordinates. It is a count of the number of orientation sensors that
           intersect the reference orientations and model reference frames with
           the same name. This number is guaranteed not to change after assemble()
           is called (i.e. during subsequent calls to track()).
        """
        return _simulation.InverseKinematicsSolver_getNumOrientationSensorsInUse(self)

    def updateMarkerWeight(self, markerName, value):
        r"""
        Change the weighting of a marker, given the marker's name. Takes effect
               when assemble() or track() is called next.
        """
        return _simulation.InverseKinematicsSolver_updateMarkerWeight(self, markerName, value)

    def updateMarkerWeights(self, weights):
        r"""
        Change the weighting of all markers. Takes effect when assemble() or
               track() is called next. Marker weights are specified in the same order
               as they appear in the MarkersReference that was passed in when the
               solver was constructed.
        """
        return _simulation.InverseKinematicsSolver_updateMarkerWeights(self, weights)

    def updateOrientationWeight(self, orientationName, value):
        r"""
        Change the weighting of an orientation sensor, given its name. Takes
           effect when assemble() or track() is called next.
        """
        return _simulation.InverseKinematicsSolver_updateOrientationWeight(self, orientationName, value)

    def updateOrientationWeights(self, weights):
        r"""
        Change the weighting of all orientation sensors. Takes effect when
           assemble() or track() is called next. Orientation weights are specified
           in the same order as they appear in the OrientationsReference that was
           passed in when the solver was constructed.
        """
        return _simulation.InverseKinematicsSolver_updateOrientationWeights(self, weights)

    def computeCurrentMarkerLocation(self, markerName):
        r"""
        Compute and return a marker's spatial location in the ground frame,
               given the marker's name.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerLocation(self, markerName)

    def computeCurrentMarkerLocations(self, markerLocations):
        r"""
        Compute and return the spatial locations of all markers, expressed in
               the ground frame.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerLocations(self, markerLocations)

    def computeCurrentMarkerError(self, markerName):
        r"""
        Compute and return the distance error between a model marker and its
               observation, given the marker's name.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerError(self, markerName)

    def computeCurrentMarkerErrors(self, markerErrors):
        r"""
        Compute and return the distance errors between all model markers and
               their observations.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerErrors(self, markerErrors)

    def computeCurrentSquaredMarkerError(self, markerName):
        r"""
        Compute and return the squared-distance error between a model marker and
               its observation, given the marker's name. This method is cheaper than
               squaring the value returned by computeCurrentMarkerError().
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSquaredMarkerError(self, markerName)

    def computeCurrentSquaredMarkerErrors(self, markerErrors):
        r"""
        Compute and return the squared-distance errors between all model markers
               and their observations. This method is cheaper than squaring the values
               returned by computeCurrentMarkerErrors().
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSquaredMarkerErrors(self, markerErrors)

    def getMarkerNameForIndex(self, markerIndex):
        r"""
        Marker locations and errors may be computed in an order that is different
               from tasks file or listed in the model. Return the corresponding marker
               name for an index in the list of marker locations/errors returned by the
               solver.
        """
        return _simulation.InverseKinematicsSolver_getMarkerNameForIndex(self, markerIndex)

    def computeCurrentSensorOrientation(self, osensorName):
        r"""
        Compute and return an orientation sensor's spatial orientation in the
           ground frame, given the o-sensor's name.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSensorOrientation(self, osensorName)

    def computeCurrentSensorOrientations(self, osensorOrientations):
        r"""
        Compute and return the spatial orientations of all o-sensors, expressed in
           the ground frame.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSensorOrientations(self, osensorOrientations)

    def computeCurrentOrientationError(self, osensorName):
        r"""
        Compute and return the orientation error between the model orientation
           sensor and its observation, given the o-sensor's name.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentOrientationError(self, osensorName)

    def computeCurrentOrientationErrors(self, osensorErrors):
        r"""
        Compute all the orientation errors between the model orientation
           sensors and their observations.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentOrientationErrors(self, osensorErrors)

    def getOrientationSensorNameForIndex(self, osensorIndex):
        r"""
        Orientation sensor locations and errors may be computed in an order that
           may be different from tasks file or listed in the model. Return the
           corresponding orientation sensor name for an index in the list of
           orientations returned by the solver.
        """
        return _simulation.InverseKinematicsSolver_getOrientationSensorNameForIndex(self, osensorIndex)

    def setAdvanceTimeFromReference(self, newValue):
        r""" indicate whether time is provided by Reference objects or driver program"""
        return _simulation.InverseKinematicsSolver_setAdvanceTimeFromReference(self, newValue)

# Register InverseKinematicsSolver in _simulation:
_simulation.InverseKinematicsSolver_swigregister(InverseKinematicsSolver)
class IMUPlacer(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how to place IMUs
    on a model to match placement of experimental sensors (IMUs)

    Calibrates a model by registering IMU frames whose orientations in the
    sensor world frame are specified, assuming the model's default pose is the
    calibration pose. The resultant model with IMU frames registered is optionally
    written to file. Optional properties are available to identify heading correction
    to line up the base IMU by its label in the orientation_file_for_calibration
    e.g. 'pelvis imu' and its heading axis as +/- 'x', 'y', or 'z', are used to
    align all the IMU data so that base imu's heading (forward) is in the X direction
    of OpenSim's ground frame.

    Author: Ayman Habib, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> IMUPlacer

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.IMUPlacer_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(IMUPlacer self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.IMUPlacer_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.IMUPlacer_getClassName()

    def clone(self):
        r"""clone(IMUPlacer self) -> IMUPlacer"""
        return _simulation.IMUPlacer_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(IMUPlacer self) -> std::string const &"""
        return _simulation.IMUPlacer_getConcreteClassName(self)

    def copyProperty_model_file(self, source):
        r"""
        copyProperty_model_file(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_model_file(self, source)

    def append_model_file(self, value):
        r"""
        append_model_file(IMUPlacer self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_append_model_file(self, value)

    def constructProperty_model_file(self, initValue):
        r"""
        constructProperty_model_file(IMUPlacer self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.IMUPlacer_constructProperty_model_file(self, initValue)

    def get_model_file(self, *args):
        r"""
        get_model_file(IMUPlacer self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_model_file(IMUPlacer self) -> std::string const &
        """
        return _simulation.IMUPlacer_get_model_file(self, *args)

    def upd_model_file(self, *args):
        r"""
        upd_model_file(IMUPlacer self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_model_file(IMUPlacer self) -> std::string &
        """
        return _simulation.IMUPlacer_upd_model_file(self, *args)

    def set_model_file(self, *args):
        r"""
        set_model_file(IMUPlacer self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_model_file(IMUPlacer self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_set_model_file(self, *args)

    def copyProperty_base_imu_label(self, source):
        r"""
        copyProperty_base_imu_label(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_base_imu_label(self, source)

    def append_base_imu_label(self, value):
        r"""
        append_base_imu_label(IMUPlacer self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_append_base_imu_label(self, value)

    def constructProperty_base_imu_label(self, initValue):
        r"""
        constructProperty_base_imu_label(IMUPlacer self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.IMUPlacer_constructProperty_base_imu_label(self, initValue)

    def get_base_imu_label(self, *args):
        r"""
        get_base_imu_label(IMUPlacer self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_base_imu_label(IMUPlacer self) -> std::string const &
        """
        return _simulation.IMUPlacer_get_base_imu_label(self, *args)

    def upd_base_imu_label(self, *args):
        r"""
        upd_base_imu_label(IMUPlacer self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_base_imu_label(IMUPlacer self) -> std::string &
        """
        return _simulation.IMUPlacer_upd_base_imu_label(self, *args)

    def set_base_imu_label(self, *args):
        r"""
        set_base_imu_label(IMUPlacer self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_base_imu_label(IMUPlacer self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_set_base_imu_label(self, *args)

    def copyProperty_base_heading_axis(self, source):
        r"""
        copyProperty_base_heading_axis(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_base_heading_axis(self, source)

    def append_base_heading_axis(self, value):
        r"""
        append_base_heading_axis(IMUPlacer self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_append_base_heading_axis(self, value)

    def constructProperty_base_heading_axis(self, initValue):
        r"""
        constructProperty_base_heading_axis(IMUPlacer self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.IMUPlacer_constructProperty_base_heading_axis(self, initValue)

    def get_base_heading_axis(self, *args):
        r"""
        get_base_heading_axis(IMUPlacer self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_base_heading_axis(IMUPlacer self) -> std::string const &
        """
        return _simulation.IMUPlacer_get_base_heading_axis(self, *args)

    def upd_base_heading_axis(self, *args):
        r"""
        upd_base_heading_axis(IMUPlacer self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_base_heading_axis(IMUPlacer self) -> std::string &
        """
        return _simulation.IMUPlacer_upd_base_heading_axis(self, *args)

    def set_base_heading_axis(self, *args):
        r"""
        set_base_heading_axis(IMUPlacer self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_base_heading_axis(IMUPlacer self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_set_base_heading_axis(self, *args)

    def copyProperty_sensor_to_opensim_rotations(self, source):
        r"""
        copyProperty_sensor_to_opensim_rotations(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_sensor_to_opensim_rotations(self, source)

    def append_sensor_to_opensim_rotations(self, value):
        r"""
        append_sensor_to_opensim_rotations(IMUPlacer self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.IMUPlacer_append_sensor_to_opensim_rotations(self, value)

    def constructProperty_sensor_to_opensim_rotations(self, initValue):
        r"""
        constructProperty_sensor_to_opensim_rotations(IMUPlacer self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _simulation.IMUPlacer_constructProperty_sensor_to_opensim_rotations(self, initValue)

    def get_sensor_to_opensim_rotations(self, *args):
        r"""
        get_sensor_to_opensim_rotations(IMUPlacer self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_sensor_to_opensim_rotations(IMUPlacer self) -> Vec3
        """
        return _simulation.IMUPlacer_get_sensor_to_opensim_rotations(self, *args)

    def upd_sensor_to_opensim_rotations(self, *args):
        r"""
        upd_sensor_to_opensim_rotations(IMUPlacer self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_sensor_to_opensim_rotations(IMUPlacer self) -> Vec3
        """
        return _simulation.IMUPlacer_upd_sensor_to_opensim_rotations(self, *args)

    def set_sensor_to_opensim_rotations(self, *args):
        r"""
        set_sensor_to_opensim_rotations(IMUPlacer self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_sensor_to_opensim_rotations(IMUPlacer self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _simulation.IMUPlacer_set_sensor_to_opensim_rotations(self, *args)

    def copyProperty_orientation_file_for_calibration(self, source):
        r"""
        copyProperty_orientation_file_for_calibration(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_orientation_file_for_calibration(self, source)

    def append_orientation_file_for_calibration(self, value):
        r"""
        append_orientation_file_for_calibration(IMUPlacer self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_append_orientation_file_for_calibration(self, value)

    def constructProperty_orientation_file_for_calibration(self, initValue):
        r"""
        constructProperty_orientation_file_for_calibration(IMUPlacer self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.IMUPlacer_constructProperty_orientation_file_for_calibration(self, initValue)

    def get_orientation_file_for_calibration(self, *args):
        r"""
        get_orientation_file_for_calibration(IMUPlacer self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_orientation_file_for_calibration(IMUPlacer self) -> std::string const &
        """
        return _simulation.IMUPlacer_get_orientation_file_for_calibration(self, *args)

    def upd_orientation_file_for_calibration(self, *args):
        r"""
        upd_orientation_file_for_calibration(IMUPlacer self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_orientation_file_for_calibration(IMUPlacer self) -> std::string &
        """
        return _simulation.IMUPlacer_upd_orientation_file_for_calibration(self, *args)

    def set_orientation_file_for_calibration(self, *args):
        r"""
        set_orientation_file_for_calibration(IMUPlacer self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_orientation_file_for_calibration(IMUPlacer self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_set_orientation_file_for_calibration(self, *args)

    def copyProperty_output_model_file(self, source):
        r"""
        copyProperty_output_model_file(IMUPlacer self, IMUPlacer source)

        Parameters
        ----------
        source: OpenSim::IMUPlacer::Self const &

        """
        return _simulation.IMUPlacer_copyProperty_output_model_file(self, source)

    def append_output_model_file(self, value):
        r"""
        append_output_model_file(IMUPlacer self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_append_output_model_file(self, value)

    def constructProperty_output_model_file(self, initValue):
        r"""
        constructProperty_output_model_file(IMUPlacer self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.IMUPlacer_constructProperty_output_model_file(self, initValue)

    def get_output_model_file(self, *args):
        r"""
        get_output_model_file(IMUPlacer self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_output_model_file(IMUPlacer self) -> std::string const &
        """
        return _simulation.IMUPlacer_get_output_model_file(self, *args)

    def upd_output_model_file(self, *args):
        r"""
        upd_output_model_file(IMUPlacer self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_output_model_file(IMUPlacer self) -> std::string &
        """
        return _simulation.IMUPlacer_upd_output_model_file(self, *args)

    def set_output_model_file(self, *args):
        r"""
        set_output_model_file(IMUPlacer self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_output_model_file(IMUPlacer self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.IMUPlacer_set_output_model_file(self, *args)
    __swig_destroy__ = _simulation.delete_IMUPlacer

    def __init__(self, *args):
        r""" Create an IMUPlacer based on a setup file"""
        _simulation.IMUPlacer_swiginit(self, _simulation.new_IMUPlacer(*args))

    def run(self, visualizeResults=False):
        r"""
        Run the calibration method to place IMUs on the model,
            Optionally visualize the model post calibration.
        """
        return _simulation.IMUPlacer_run(self, visualizeResults)

    def setModel(self, aModel):
        r"""
        setModel(IMUPlacer self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _simulation.IMUPlacer_setModel(self, aModel)

    def getCalibratedModel(self):
        r"""
        Retrieve the calibrated model. This method will throw if called before
           the run method is invoked.
        """
        return _simulation.IMUPlacer_getCalibratedModel(self)

# Register IMUPlacer in _simulation:
_simulation.IMUPlacer_swigregister(IMUPlacer)
class IMU(ModelComponent):
    r"""
    IMU is a Model Component that represents a virtual IMU along with its Geometry
    for visualization. This component reports angular velocity and linear
    acceleration (with gravitational acceleration subtracted) vectors expressed in
    the IMU frame to mimic the behavior of real-world IMUs. It also reports
    orientations between the IMU and ground frame as Quaternions, expressed in the
    ground frame.

    TODO: add noise model, limits/saturation, as needed.

    Authors: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> IMU

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.IMU_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(IMU self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.IMU_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.IMU_getClassName()

    def clone(self):
        r"""clone(IMU self) -> IMU"""
        return _simulation.IMU_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(IMU self) -> std::string const &"""
        return _simulation.IMU_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_IMU

    def __init__(self, *args):
        r"""
        __init__(IMU self) -> IMU
        __init__(IMU self, IMU arg2) -> IMU

        Parameters
        ----------
        arg2: OpenSim::IMU const &

        __init__(IMU self, IMU arg2) -> IMU

        Parameters
        ----------
        arg2: OpenSim::IMU &&

        """
        _simulation.IMU_swiginit(self, _simulation.new_IMU(*args))
    PropertyIndex_socket_frame = property(_simulation.IMU_PropertyIndex_socket_frame_get, _simulation.IMU_PropertyIndex_socket_frame_set, doc=r"""PropertyIndex_socket_frame : OpenSim::PropertyIndex""")

    def connectSocket_frame(self, object):
        r"""
        connectSocket_frame(IMU self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _simulation.IMU_connectSocket_frame(self, object)
    _has_output_orientation_as_quaternion = property(_simulation.IMU__has_output_orientation_as_quaternion_get, _simulation.IMU__has_output_orientation_as_quaternion_set, doc=r"""_has_output_orientation_as_quaternion : bool""")
    _has_output_gyroscope_signal = property(_simulation.IMU__has_output_gyroscope_signal_get, _simulation.IMU__has_output_gyroscope_signal_set, doc=r"""_has_output_gyroscope_signal : bool""")
    _has_output_accelerometer_signal = property(_simulation.IMU__has_output_accelerometer_signal_get, _simulation.IMU__has_output_accelerometer_signal_set, doc=r"""_has_output_accelerometer_signal : bool""")

    def calcTransformInGround(self, s):
        r"""
        Report the Transform of this IMU in the Ground frame.
        Notes: Requires realizing the State to SimTK::Stage::Position.
        """
        return _simulation.IMU_calcTransformInGround(self, s)

    def calcOrientationAsQuaternion(self, s):
        r"""
        Report the orientation of this IMU in ground frame expressed as a
        Quaternion.
        Notes: Requires realizing the State to SimTK::Stage::Position.
        """
        return _simulation.IMU_calcOrientationAsQuaternion(self, s)

    def calcGyroscopeSignal(self, s):
        r"""
        Report the angular velocity of this IMU in the frame it is attached to.
        Notes: Requires realizing the State to SimTK::Stage::Velocity.
        """
        return _simulation.IMU_calcGyroscopeSignal(self, s)

    def calcAccelerometerSignal(self, s):
        r"""
        Report the linear acceleration of the frame to which this IMU is
        attached in the Ground grame. Gravity is subtracted and result expressed
        in the frame to which the IMU is attached.
        Notes: Requires realizing the State to SimTK::Stage::Acceleration.
        """
        return _simulation.IMU_calcAccelerometerSignal(self, s)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        generateDecorations(IMU self, bool fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis)

        Parameters
        ----------
        fixed: bool
        hints: OpenSim::ModelDisplayHints const &
        state: SimTK::State const &
        appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int > &

        """
        return _simulation.IMU_generateDecorations(self, fixed, hints, state, appendToThis)

# Register IMU in _simulation:
_simulation.IMU_swigregister(IMU)
class OpenSenseUtilities(object):
    r"""Proxy of C++ OpenSim::OpenSenseUtilities class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def rotateOrientationTable(quaternionsTable, rotationMatrix):
        r"""
        Apply the passed in Rotation matrix to a TimeSeriesTable of Quaternions.
               The rotation is done in place so the table passed in is modified
        """
        return _simulation.OpenSenseUtilities_rotateOrientationTable(quaternionsTable, rotationMatrix)

    @staticmethod
    def convertQuaternionsToRotations(qauternionsTable):
        r"""
        Convert a TimeSeriesTable with quaternions as data elements into a TimeSeriesTable
               of Rotation matrices.
        """
        return _simulation.OpenSenseUtilities_convertQuaternionsToRotations(qauternionsTable)

    @staticmethod
    def computeHeadingCorrection(model, state, quatTimeSeries, baseIMU, arg5):
        r"""
        Compute a SimTK::Vec3 of Space-fixed XYZ Euler angles that aligns the
              specified baseIMU and CoordinateDirection combination with the positive
              X-axis (= typically forward) direction of the base segment in OpenSim
              model. Base segment is typically the segment attached directly to Ground.
              baseIMU is assumed to be placed on Base segment. Passed in state places
              the model in the same configuration as the first frame of the
              passed in table of quaternions quatTimeSeries.
        """
        return _simulation.OpenSenseUtilities_computeHeadingCorrection(model, state, quatTimeSeries, baseIMU, arg5)

    @staticmethod
    def createOrientationsFileFromMarkers(markersFile):
        r"""Create Orientations as a TimeSeriesTable based on passed in markerFile"""
        return _simulation.OpenSenseUtilities_createOrientationsFileFromMarkers(markersFile)

    @staticmethod
    def formTransformFromPoints(op, xp, yp):
        r""" form a Transform from 3 points origin (op), along x (xp - op), along y(yp - op)"""
        return _simulation.OpenSenseUtilities_formTransformFromPoints(op, xp, yp)

    @staticmethod
    def addModelIMUs(model, paths):
        r"""
        Add IMUs to passed in model and return references to them
        based on paths specification.
        - If "paths" refer to user specified list of frames, then one new
            "{Frame}_imu" is added to the model and returned in result.
        """
        return _simulation.OpenSenseUtilities_addModelIMUs(model, paths)

    def __init__(self):
        r"""__init__(OpenSenseUtilities self) -> OpenSenseUtilities"""
        _simulation.OpenSenseUtilities_swiginit(self, _simulation.new_OpenSenseUtilities())
    __swig_destroy__ = _simulation.delete_OpenSenseUtilities

# Register OpenSenseUtilities in _simulation:
_simulation.OpenSenseUtilities_swigregister(OpenSenseUtilities)
class StdVectorIMUs(object):
    r"""Proxy of C++ std::vector< OpenSim::IMU * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(StdVectorIMUs self) -> SwigPyIterator"""
        return _simulation.StdVectorIMUs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(StdVectorIMUs self) -> bool"""
        return _simulation.StdVectorIMUs___nonzero__(self)

    def __bool__(self):
        r"""__bool__(StdVectorIMUs self) -> bool"""
        return _simulation.StdVectorIMUs___bool__(self)

    def __len__(self):
        r"""__len__(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::size_type"""
        return _simulation.StdVectorIMUs___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i, std::vector< OpenSim::IMU * >::difference_type j) -> StdVectorIMUs

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type
        j: std::vector< OpenSim::IMU * >::difference_type

        """
        return _simulation.StdVectorIMUs___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i, std::vector< OpenSim::IMU * >::difference_type j)

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type
        j: std::vector< OpenSim::IMU * >::difference_type

        __setslice__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i, std::vector< OpenSim::IMU * >::difference_type j, StdVectorIMUs v)

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type
        j: std::vector< OpenSim::IMU * >::difference_type
        v: std::vector< OpenSim::IMU *,std::allocator< OpenSim::IMU * > > const &

        """
        return _simulation.StdVectorIMUs___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i, std::vector< OpenSim::IMU * >::difference_type j)

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type
        j: std::vector< OpenSim::IMU * >::difference_type

        """
        return _simulation.StdVectorIMUs___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i)

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type

        __delitem__(StdVectorIMUs self, SWIGPY_SLICEOBJECT * slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _simulation.StdVectorIMUs___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(StdVectorIMUs self, SWIGPY_SLICEOBJECT * slice) -> StdVectorIMUs

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i) -> IMU

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type

        """
        return _simulation.StdVectorIMUs___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(StdVectorIMUs self, SWIGPY_SLICEOBJECT * slice, StdVectorIMUs v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< OpenSim::IMU *,std::allocator< OpenSim::IMU * > > const &

        __setitem__(StdVectorIMUs self, SWIGPY_SLICEOBJECT * slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::difference_type i, IMU x)

        Parameters
        ----------
        i: std::vector< OpenSim::IMU * >::difference_type
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs___setitem__(self, *args)

    def pop(self):
        r"""pop(StdVectorIMUs self) -> IMU"""
        return _simulation.StdVectorIMUs_pop(self)

    def append(self, x):
        r"""
        append(StdVectorIMUs self, IMU x)

        Parameters
        ----------
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs_append(self, x)

    def empty(self):
        r"""empty(StdVectorIMUs self) -> bool"""
        return _simulation.StdVectorIMUs_empty(self)

    def size(self):
        r"""size(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::size_type"""
        return _simulation.StdVectorIMUs_size(self)

    def swap(self, v):
        r"""
        swap(StdVectorIMUs self, StdVectorIMUs v)

        Parameters
        ----------
        v: std::vector< OpenSim::IMU * > &

        """
        return _simulation.StdVectorIMUs_swap(self, v)

    def begin(self):
        r"""begin(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::iterator"""
        return _simulation.StdVectorIMUs_begin(self)

    def end(self):
        r"""end(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::iterator"""
        return _simulation.StdVectorIMUs_end(self)

    def rbegin(self):
        r"""rbegin(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::reverse_iterator"""
        return _simulation.StdVectorIMUs_rbegin(self)

    def rend(self):
        r"""rend(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::reverse_iterator"""
        return _simulation.StdVectorIMUs_rend(self)

    def clear(self):
        r"""clear(StdVectorIMUs self)"""
        return _simulation.StdVectorIMUs_clear(self)

    def get_allocator(self):
        r"""get_allocator(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::allocator_type"""
        return _simulation.StdVectorIMUs_get_allocator(self)

    def pop_back(self):
        r"""pop_back(StdVectorIMUs self)"""
        return _simulation.StdVectorIMUs_pop_back(self)

    def erase(self, *args):
        r"""
        erase(StdVectorIMUs self, std::vector< OpenSim::IMU * >::iterator pos) -> std::vector< OpenSim::IMU * >::iterator

        Parameters
        ----------
        pos: std::vector< OpenSim::IMU * >::iterator

        erase(StdVectorIMUs self, std::vector< OpenSim::IMU * >::iterator first, std::vector< OpenSim::IMU * >::iterator last) -> std::vector< OpenSim::IMU * >::iterator

        Parameters
        ----------
        first: std::vector< OpenSim::IMU * >::iterator
        last: std::vector< OpenSim::IMU * >::iterator

        """
        return _simulation.StdVectorIMUs_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(StdVectorIMUs self) -> StdVectorIMUs
        __init__(StdVectorIMUs self, StdVectorIMUs other) -> StdVectorIMUs

        Parameters
        ----------
        other: std::vector< OpenSim::IMU * > const &

        __init__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type size) -> StdVectorIMUs

        Parameters
        ----------
        size: std::vector< OpenSim::IMU * >::size_type

        __init__(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type size, IMU value) -> StdVectorIMUs

        Parameters
        ----------
        size: std::vector< OpenSim::IMU * >::size_type
        value: std::vector< OpenSim::IMU * >::value_type

        """
        _simulation.StdVectorIMUs_swiginit(self, _simulation.new_StdVectorIMUs(*args))

    def push_back(self, x):
        r"""
        push_back(StdVectorIMUs self, IMU x)

        Parameters
        ----------
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs_push_back(self, x)

    def front(self):
        r"""front(StdVectorIMUs self) -> IMU"""
        return _simulation.StdVectorIMUs_front(self)

    def back(self):
        r"""back(StdVectorIMUs self) -> IMU"""
        return _simulation.StdVectorIMUs_back(self)

    def assign(self, n, x):
        r"""
        assign(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type n, IMU x)

        Parameters
        ----------
        n: std::vector< OpenSim::IMU * >::size_type
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< OpenSim::IMU * >::size_type

        resize(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type new_size, IMU x)

        Parameters
        ----------
        new_size: std::vector< OpenSim::IMU * >::size_type
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(StdVectorIMUs self, std::vector< OpenSim::IMU * >::iterator pos, IMU x) -> std::vector< OpenSim::IMU * >::iterator

        Parameters
        ----------
        pos: std::vector< OpenSim::IMU * >::iterator
        x: std::vector< OpenSim::IMU * >::value_type

        insert(StdVectorIMUs self, std::vector< OpenSim::IMU * >::iterator pos, std::vector< OpenSim::IMU * >::size_type n, IMU x)

        Parameters
        ----------
        pos: std::vector< OpenSim::IMU * >::iterator
        n: std::vector< OpenSim::IMU * >::size_type
        x: std::vector< OpenSim::IMU * >::value_type

        """
        return _simulation.StdVectorIMUs_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(StdVectorIMUs self, std::vector< OpenSim::IMU * >::size_type n)

        Parameters
        ----------
        n: std::vector< OpenSim::IMU * >::size_type

        """
        return _simulation.StdVectorIMUs_reserve(self, n)

    def capacity(self):
        r"""capacity(StdVectorIMUs self) -> std::vector< OpenSim::IMU * >::size_type"""
        return _simulation.StdVectorIMUs_capacity(self)
    __swig_destroy__ = _simulation.delete_StdVectorIMUs

# Register StdVectorIMUs in _simulation:
_simulation.StdVectorIMUs_swigregister(StdVectorIMUs)
class StatesDocument(object):
    r"""
     Class StatesDocument provides a means of writing (serializing) and
    reading (deserializing) a complete time history of model states to and from
    a file. This capability is key when analyzing model behavior, visualizing
    simulation results, and conducting a variety of computationally demanding
    tasks (e.g., fitting a model to experimental data, solving optimal
    control problems, etc.).

    The states of an OpenSim::Model consist of all the independent variables that
    change (or can change) during a simulation. At each time step during a
    simulation, the underlying SimTK infrastructure captures the states in a
    SimTK::State object. A state variable falls into one of the following
    categories:

            1) Continuous Variables (aka OpenSim::StateVariable%s)
            2) Discrete Variables
            3) Modeling Options

    Continuous Variables are governed by differential equations. They are
    numerically integrated during a simulation based on the values of their
    derivatives. Examples include joint coordinates, joint speeds, and muscle
    activations. In OpenSim, because Continuous Variables are the most commonly
    encountered kind of state, they are simply referred to as State Variables. All
    concrete instances of Continuous Variables in OpenSim are derived from the
    abstract class OpenSim::StateVariable.

    Discrete Variable are not governed by differential equations and so can change
    discontinuously during a simulation. Examples can include inputs to a
    simulation, like muscle excitations, coefficients of friction, and torque
    motor voltages. Examples can also include outputs to a simulation, like points
    of contact between colliding bodies and whether those bodies are experiencing
    static or kinetic frictional conditions. Such output discrete variables are
    updated at each time step during numerical integration. Unlike continuous
    states, however, they are updated based on closed-form algebraic expressions
    rather than based on their derivatives. In the underlying SimTK infrastructure,
    an output discrete variable is implemented as a specialized kind of
    discrete variable called an Auto-Update Discrete Variable.

    Modeling Options are flags, usually of type int, that are used to choose
    between viable ways to model a SimTK::System or whether or not to apply a
    constraint. Examples include a flag that specifies whether Euler angles or
    quaternions are used to represent rotation or a flag that specifies whether a
    particular joint coordinate is locked. When a Modeling Option is changed,
    low-level aspects of the System must be reconstituted or, in SimTK
    terminology, re-realized through SimTK::Stage::Model.

    Prior to the introduction of this class, only Continuous Variables (i.e.,
    OpenSim::StateVariable%s) were routinely and systematically serialized,
    most commonly via the OpenSim::Manager as an OpenSim::Storage file
    or via class OpenSim::StatesTrajectory as an OpenSim::TimeSeriesTable.
    Discrete Variables and Modeling Options, if serialized, had to be stored in
    separate files or handled as OpenSim::Property objects. In addition, prior to
    this class, all Discrete Variables in OpenSim were assumed to be type double,
    which is not a requirement of the underlying SimTK infrastructure.

    With the introduction of this class, all state variables {i.e., Continuous
    Variables (OpenSim::StateVariable%s), Discrete Variables, and Modeling Options}
    can be serialized in a single file, which by convention has the `.ostates`
    file name exention. In addition, a variety of types (e.g., bool, int, double,
    Vec3, Vec4, etc.) are supported for Discrete Variables. Continuous States are
    still assumed to be type double, and Modeling Options are still assumed to be
    type `int`. Note, however, that the `.ostates` file format has the
    flexibility to relax these assumptions and include other types if needed.

    Notes: A point of clarification about Data Cache Variables...
    By definition, state variables are independent. That is, the value of one
    cannot be determined from the values of others. If a quantity of interest can
    be computed from values of state variables, particularly if that quantity is
    needed frequently, that quantity is often formalized as a Data Cache Variable.
    The value of a Data Cach Variable is computed at each time step of a simulation
    and stored in the SimTK::State. However, because a Data Cache Variable can
    always be computed from the Continuous Variables, Discrete Variables, and
    Modeling Options, they are not serialized.

            SimTK::State Contents    | Serialized in `.ostates`?
            ------------------------ | -----------------------
            Continuous Variables     | yes
            Discrete Variables       | yes
            Modeling Options         | yes
            Data Cache Variables     | no


    -----------------
    Design Notes
    -----------------

    ### Dependencies
    Most operations in class StatesDocument rely on underlying SimTK classes,
    most notably SimTK::String, SimTK::Array<T>, SimTK::State, and SimTK::Xml.

    StatesDocument has just one key OpenSim dependency: OpenSim::Model.
    OpenSim::Model brings with it all the methods it inherits from class
    OpenSim::Component, which are essential for getting and setting state
    information in OpenSim. StatesDocument does not know about classes like
    OpenSim::Storage, OpenSim::TimeSeriesTable, OpenSim::StatesTrajectory, or
    OpenSim::Manager.

    Exchanges of state information between class StatesDocument and the rest of
    OpenSim are accomplished via objects of type SimTK::Array_<SimTK::State>, or
    alternatively std::vector<SimTK::State>, which are informally referred to as
    state trajectories (see directly below).

    ### Trajectories
    In many methods of this class, as well as in related classes, you will
    encounter the term 'trajectory'. In these contexts, the term connotes a
    time-ordered sequence, or a time-history, of values.

    An array of knee angles (-10.0, -2.3, 4.5, 6.2, 7.1) would be termed a knee
    angle trajectory if those knee angles were recorded sequentially during a
    simulation. Similarly, an array of SimTK::State objects, if time ordered,
    would be called a states trajectory.

    Because of the flexibility and computational speed of the SimTK::Array_<T>
    container class, you will often see trajectories passed in argument lists as
    SimTK::Array_<T>%s. SimTK::Array_<double> might represent the trajectory of a
    knee angle. SimTK::Array_<SimTK::Vec3> might represent the trajectory of the
    center of pressure between a foot and the floor during a walking motion.
    SimTK::Array_<SimTK::State> is used to capture the full trajectory of states
    (continuous variables, discrete variables, and modeling options) recorded
    during a simulation.

    SimTK::Array_<SimTK::State> is preferred over std::vector<SimTK::State>
    for reasons of performance, binary compatibility with Simbody libraries, and
    consistency with Simbody's underlying code base. For a variety of common
    operations, like indexing through an array, SimTK::Array_<T> is about
    twice as fast as std::vector_<T> on Windows systems. Such speed differences
    may not be as large on Mac or Ubuntu systems, but it is safe to assume that
    SimTK::Array_<T> will be just as fast or have a speed advantage.

    Th `StatesDocument` class relies heavily on a few trjectory-centric methods
    available in the OpenSim::Component class. A few examples follow.

    ```
            template<class T>
            Component::getDiscreteVariableTrajectory(
                            const std::string& path,
                            const SimTK::Array_<SimTK::State>& input,
                            SimTK::Array_<T>& output) const
    ```
    A call to the above method first finds a Discrete Variable in the component
    hierarchy based on the specifed path (`path`). Then, from the input states
    trajectory (`input`), the method extracts the values of the specified
    Discrete Variable and returns its trajectory as the output (`output`).
    Notice that the type of the Discrete Variable can be specified by the caller
    (i.e., T = int, double, Vec3, Vec4, etc.).

    ```
            template<class T>
            void setDiscreteVariableTrajectory(
                            const std::string& path,
                            const SimTK::Array_<T>& input,
                            SimTK::Array_<SimTK::State>& output) const
    ```
    On the other hand, based on the input trajectory of a specified Discrete
    Variable (`input`), a call to the above method sets the appropriate
    element in each of the SimTK::State objects held in the states trajectory
    (`output`). Notice again that the type T of the Discrete Variable can be
    specified by the caller.

    ### Complete and Constant XML Document upon Construction
    Upon construction, a StatesDocument instance always contains a complete
    internal XML document that represents a complete serialization of a specific
    model's state trajectory. Moreover, that internal XML document cannot be
    altered after construction!

    If a model is changed (e.g., a muscle or contact element is added) or
    a change has occurred in its state trajectory, the intended way to generate
    an XML document that reflects those changes is to construct a new
    StatesDocument instance. Constructing a new instance is the most reliable
    approach for ensuring an accurate serialization. This approach also greatly
    simplifies the implementation of the StatesDocument class, as methods for
    selectively editing aspects of the internal XML document are consequently
    unnecessary.

    ### Output Precision
    The precision with which numbers are serialized to a `.ostates` file can be
    specified at the time of construction. The `precision` parameter specifies
    the maximum number of significant digits used to represent numbers. If a
    number can be represented without data loss with fewer digits, fewer digits
    are used. In other words, trailing zeros are not written to file, thus
    reducing file size. For example, if `precision` = 5, the number
    1.50000000000000000000 would be represented in a `.ostates` file
    as '1.5'; however, π would be represented as '3.1415'.

    By default, the `precision` parameter of a `StatesDocument` is set to the
    constant `SimTK::LosslessNumDigitsReal`, which results in lossless
    serialization. When `precision` = `SimTK::LosslessNumDigitsReal`, the
    `SimTK::State` can be serialized and deserialized repeatedly without loss
    of information. `SimTK::LosslessNumDigitsReal` is platform dependent but
    typically has a value of about `20`. In applications where exact values of the
    states are needed, lossless precision should be used. In applications where
    exact values of the states are not needed, a smaller number of digits can be
    used (e.g., `precsion = 6`) as a means of reducing the size of a `.ostates`
    file or simplifying some types of post analysis (e.g., plotting where the extra
    significant figures would go unnoticed).


    -------------------
    .ostate File Format
    -------------------
    XML is used as the organizing framework for `.ostates` files
    (see SimTK::Xml), allowing them to be viewed and edited with a text editor.
    Internet browsers can be also be used to view a `.ostate` file but may
    require a `.xml` file extension to be added to the file name for the
    XML format to be recognized.

    ### Sample `.ostates` File
    ```
    <?xml version="1.0" encoding="UTF-8" ?>
    <!--OpenSim States Document (Version 40000)-->
    <ostates model="BouncingBlock" nTime="51" precision="3" date="Tue May 30 2023 03:42:40">
      <time>(0,0.1, ...)<time>
      <continuous>
        <variable path="/jointset/free/free_coord_0/value" type="double">(0,7.14, ...)<variable>
        <variable path="/jointset/free/free_coord_0/speed" type="double">(0,7.81, ...)<variable>
        ...
      <continuous>
      <discrete>
        <variable path="/forceset/EC0/anchor" type="Vec3">(~[2.1,-1.1,0],~[1.82,-1.1,0], ...)<variable>
        <variable path="/forceset/EC0/mu_kinetic" type="double">(0.5,0.5, ...)<variable>
        <variable path="/forceset/EC0/mu_static" type="double">(0.7,0.7, ...)<variable>
        <variable path="/forceset/EC0/sliding" type="double">(1,1, ...)<variable>
        ...
      <discrete>
      <modeling>
        <option path="/jointset/free/free_coord_0/is_clamped" type="int">(0,0, ...)<option>
        <option path="/jointset/free/free_coord_1/is_clamped" type="int">(0,0, ...)<option>
        ...
      <modeling>
    <ostates>
    ```

    ### Deserialization Requirements
    Successful deserialization of a .ostates file and full initialization of a
    states trajectory for an OpenSim::Model requires the following:

        1) The name of the `OpenSim::Model` must match the value of the
        `model` attribute of the top-level `ostates` element.

        2) The number of continuous variables, discrete variables, and modeling
        options in the .ostates file must match the corresponding numbers in the
        OpenSim::Model.

        3) The number of values recorded for each `variable` and each
        `option` in the `.ostates` file must be equal to the value of the
        `nTime` attribute of the top-level `ostates` element.

        4) All `variable` and `option` paths must be found in the model
        OpenSim::Component heirarchy.

        5) The type must be supported. As of September 2024, the following types
        are supported:

                SimTK::State Category    | Supported Type(s)
                ------------------------ | -----------------------
                Continuous Variables     | double
                                         |
                Discrete Variables       | bool, int, float, double,
                                         | Vec2, Vec3, Vec4, Vec5, Vec6
                                         |
                Modeling Options         | int


    --------------------------
    Using Class StatesDocument
    --------------------------
    Below are some code snippets that show how the StatesDocument class can be
    used. Example 1 shows how to obtain a states trajectory from a simulation and
    then serialize those states to file. Example 2 shows how to follow up and
    deserialize those same states and use them to accomplish a few basic things.

    ### Example 1: Serializing Simulated States
    ```
    ---------------
    Build the Model
    ---------------
    Building a model can be done in many ways. The most common approach is
    to construct a model from an OpenSim model file. Here, an empty model is
    constructed with place holders for components that are typically added.
        OpenSim::Model model();
        model.setGravity( Vec3(0.0,-9.8,0.0) );
        model.setName("BouncingBlock");
    Add bodies...
    Add joints...
    Add actuators & contact elements...

    -------------------------------
    Add a StatesTrajectory Reporter
    -------------------------------
    The reporter records the SimTK::State in an std::vector<> at a
    specified time interval.
        OpenSim::StatesTrajectoryReporter* reporter =
            new StatesTrajectoryReporter();
        reporter->setName("states_reporter");
        double interval = 0.01;
        reporter->set_report_time_interval(interval);
        model->addComponent(reporter);

    -----------------------------------------
    Build the System and Initialize the State
    -----------------------------------------
        model.buildSystem();
        SimTK::State& state = model.initializeState();

    ---------
    Integrate
    ---------
        Manager manager(*model);
        manager.getIntegrator().setMaximumStepSize(0.01);
        manager.setIntegratorAccuracy(1.0e-5);
        double ti = 0.0;
        double tf = 5.0;
        state.setTime(ti);
        manager.initialize(state);
        state = manager.integrate(tf);

    -----------------------
    Create a StatesDocument
    -----------------------
    The reporter that was added to the system collects the states in an
    OpenSim::StatesTrajectory object. Underneath the covers, the states are
    accumulated in a private array of state objects (i.e., vector<State>).
    The StatesTrajectory class knows how to export a StatesDocument based
    on those states. This "export" functionality is what is used below.
        const StatesTrajectory& trajectory = reporter->getStates();
        StatesDocument doc = trajectory.exportToStatesDocument(model);

    Alternatively, a read-only reference to the underlying state array
    can be obtained from the reporter and used to construct a
    StatesDocument directly:
        const std::vector<SimTK::State>& traj = reporter->getVectorOfStateObjects();
        StatesDocument doc(model, traj);

    ----------------------------
    Serialize the States to File
    ----------------------------
    The file name (see below), can be any string supported by the file
    system. The recommended convention is for the file name to carry the
    suffix ".ostates". Below, the suffix ".ostates" is simply added to
    the name of the model, and the document is saved to the current working
    directory. The file name can also incorporate a valid system path (e.g.,
    "C:/Users/smith/Documents/Work/BouncingBlock.ostates").
        SimTK::String statesFileName = model.getName() + ".ostates";
        doc.serializeToFile(statesFileName);

    ----------------------
    Save the Model to File
    ----------------------
        SimTK::String modelFileName = model.getName() + ".osim";
        model->print(modelFileName);

    ```

    ### Example 2: Deserializing States
    ```
    -----------------------------
    Construct the Model from File
    -----------------------------
        SimTK::String name = "BouncingBlock";
        SimTK::String modelFileName = name + ".osim";
        OpenSim::Model model(modelFileName);
        model.buildSystem();
        SimTK::State& initState = model->initializeState();

    -----------------------------------------------
    Construct the StatesDocument Instance from File
    -----------------------------------------------
        SimTK::String statesFileName = name + ".ostates";
        StatesDocument doc(statesFileName);

    ----------------------
    Deserialize the States
    ----------------------
    Note that model and document must be entirely consistent with each
    other for the deserialization to be successful.
    See StatesDocument::deserialize() for details.
        SimTK::Array_<SimTK::State> traj;  // Or, std::vector<SimTK::State> traj;
        doc.deserialize(model, traj);

    Below are some things that can be done once a deserialized state
    trajectory has been obtained.

    ---------------------------------------------------
    Iterate through the State Trajectory Getting Values
    ---------------------------------------------------
        std::string path;
        const SimTK::State* iter;
        for(iter = traj.cbegin(); iter!=traj.cend(); ++iter) {

    Get time
            double t = iter->getTime();

    Get the value of a continuous state
            path = "/jointset/free/free_coord_0/value";
            double x = model.getStateVariableValue(*iter, path);

    Get the value of a discrete state of type double
            path = "/forceset/EC0/sliding";
            double sliding = model.getDiscreteVariableValue(*iter, path);

    Get the value of a discrete state of type Vec3
            path = "/forceset/EC0/anchor"
            const SimTK::AbstractValue& valAbs =
                model.getDiscreteVariableAbstractValue(*iter, path);
            SimTK::Value<Vec3> valVec3 = SimTK::Value<Vec3>::downcast( valAbs );
            Vec3 anchor = valVec3.get();

    Get the value of a modeling option
            path = "/jointset/free/free_coord_0/is_clamped";
            int clamped = model.getModelingOption(*iter, path);

    Access the value of a data cache variable. Note that this will
    require state realization at the appropriate stage.
            system.realize(*iter, SimTK::Stage::Dynamics);
            Vec3 force = forces.getContactElement(0)->getForce();
        }

    ----------------------------------------------------
    Extract a Complete Trajectory for a Particular State
    ----------------------------------------------------
    Continuous (double)
        path = "/jointset/free/free_coord_0/value";
        SimTK::Array_<double> xTraj;
        model.getStateVariableTrajectory<double>(path, traj, xTraj);

    Discrete (Vec3)
        path = "/forceset/EC0/anchor";
        SimTK::Array_<Vec3> anchorTraj;
        model.getDiscreteVariableTrajectory<Vec3>(path, traj, anchorTraj);

    Modeling (int)
        path = "/jointset/free/free_coord_0/is_clamped";
        SimTK::Array_<int> clampedTraj;
        model.getModelingOptionTrajectory<int>(path, traj, clampedTraj);

    ----------------------
    Form a TimeSeriesTable
    ----------------------
    Note that the table will only include the continuous states.
    This might be done for plotting, post analysis, etc.
        StatesTrajectory trajectory(model, doc);
        OpenSim::TimesSeriesTable table = traj.exportToTable(model);

    ```

    ### A Final Note
    Because Storage files (*.sto) and TimeSeriesTable files (*.tst) typically
    capture only the continuous states of a system, using these files as the basis
    for deserialization runs the risk of leaving discrete variables and modeling
    options in the SimTK::State uninitialized. In such an approach, additional
    steps may be needed to properly initialize all variables in the SimTK::State
    (e.g., by relying on OpenSim::Properties and/or on supplemental input files).

    In contrast, the StatesDocument class can be relied upon to yield a complete
    serialization and deserialization of the SimTK::State. If the StatesDocument
    class is used to serialize and then deserialize a state trajectory that was
    recorded during a simulation, all state variables in the State (continuous,
    discrete, and modeling) will be saved to a single file during serizaliztion
    and initialized upon deserialization of the document.

    Authors: F. C. Anderson *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor serves no purpose other than satisfying a
           compiler demand.

        |

        *Overload 2:*
        Construct a StatesDocument instance from an XML file in preparation
           for deserialzing the states into a states trajectory. Once constructed,
           the document is not designed to be modified; it is a fixed snapshot of the
           states stored by the file at the time of construction. If the XML file
           changes, the intended mechanism for obtaining a document that is
           consistent with the modifed XML file is simply to construct a new document.
           By convention (and not requirement), a StatesDocument filename has
           ".ostates" as its suffix. To deserialize the states, call
           StatesDocument::deserialize() on the constructed document. Note that the
           validity of the XML file is not tested until StatesDocument::deserialize()
           is called.

           :type filename: SimTK::String
           :param filename: The name of the file, which may be prepended by the system
               path at which the file resides (e.g., "C:/Documents/block.ostates").

        |

        *Overload 3:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: SimTK::Array_< SimTK::State,unsigned int >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :type note: SimTK::String, optional
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :type precision: int, optional
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.

        |

        *Overload 4:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: SimTK::Array_< SimTK::State,unsigned int >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :type note: SimTK::String, optional
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.

        |

        *Overload 5:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: SimTK::Array_< SimTK::State,unsigned int >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.

        |

        *Overload 6:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: std::vector< SimTK::State,std::allocator< SimTK::State > >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :type note: SimTK::String, optional
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :type precision: int, optional
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.

        |

        *Overload 7:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: std::vector< SimTK::State,std::allocator< SimTK::State > >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :type note: SimTK::String, optional
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.

        |

        *Overload 8:*
        Construct a StatesDocument instance from a states trajectory in
           preparation for serializing the trajectory to file. Once constructed, the
           document is not designed to be modified; it is a fixed snapshot of the
           states trajectory at the time of construction. The intended mechanism for
           obtaining a document that is consistent with a modified or new states
           trajectory is simply to construct a new document. To serialize the
           constructed document to file, call StatesDocument::serialize().

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model to which the states belong.
           :type trajectory: std::vector< SimTK::State,std::allocator< SimTK::State > >
           :param trajectory: An array containing the time-ordered sequence of
               SimTK::State objects.
           :param note: Annotation note for this states document. By default, the note
               is an empty string.
           :param precision: The number of significant figures with which numerical
               values are converted to strings. The default value is
               SimTK:LosslessNumDigitsReal (about 20), which allows for lossless
               reproduction of state.
        """
        _simulation.StatesDocument_swiginit(self, _simulation.new_StatesDocument(*args))

    def getNote(self):
        r""" Get the annotation note for this states document."""
        return _simulation.StatesDocument_getNote(self)

    def getPrecision(self):
        r""" Get the precision for this states document."""
        return _simulation.StatesDocument_getPrecision(self)

    def serialize(self, filename):
        r"""
        Serialize the document to file. By convention (and not requirement),
           a StatesDocument filename has ".ostates" as its suffix.

           :type filename: SimTK::String
           :param filename: The name of the file, which may include the file system
               path at which to write the file (e.g., "C:/Documents/block.ostates").
        """
        return _simulation.StatesDocument_serialize(self, filename)

    def deserialize(self, *args):
        r"""
        *Overload 1:*
        Deserialize the states held by this document into a states trajectory.
           If deserialization fails, an exception describing the reason for the
           failure is thrown. For details, see the section called "Deserialization
           Requirements" in the introductory documentation for this class.
           Notes: This method is overloaded to allow users the flexibility to use
           either `SimTK::Array_<>` or `std::vector` as the trajectory container.

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model with which the states are to be associated.
           :type trajectory: SimTK::Array_< SimTK::State,unsigned int >
           :param trajectory: The array into which the time-ordered sequence of
               SimTK::State objects will be deserialized.
           :raises: SimTK::Exception

        |

        *Overload 2:*
        Deserialize the states held by this document into a states trajectory.
           If deserialization fails, an exception describing the reason for the
           failure is thrown. For details, see the section called "Deserialization
           Requirements" in the introductory documentation for this class.
           Notes: This method is overloaded to allow users the flexibility to use
           either `SimTK::Array_<>` or `std::vector` as the trajectory container.

           :type model: :py:class:`Model`
           :param model: The OpenSim::Model with which the states are to be associated.
           :type trajectory: std::vector< SimTK::State,std::allocator< SimTK::State > >
           :param trajectory: The array into which the time-ordered sequence of
               SimTK::State objects will be deserialized.
           :raises: SimTK::Exception
        """
        return _simulation.StatesDocument_deserialize(self, *args)
    __swig_destroy__ = _simulation.delete_StatesDocument

# Register StatesDocument in _simulation:
_simulation.StatesDocument_swigregister(StatesDocument)
class StatesTrajectory(object):
    r"""
    This class holds a sequence of SimTK::State%s. You can obtain a
    StatesTrajectory during a simulation via the StatesTrajectoryReporter. You
    can also create a StatesTrajectory from a states storage (.sto) file (see
    createFromStatesStorage()). Users can modify a trajectory by appending
    states to it, but users cannot modify the individual states that are already
    in a trajectory.

    This class was introduced in OpenSim version 4.0, and enables scripting
    (Python/MATLAB) and C++ users to postprocess their results with greater ease
    and flexibility than with an Analysis.

    Notes: In a future release, we plan to support an OSTATES file format that
    allows one to write the trajectory to a file with full numerical precision.


    This class is designed to ensure the following:
    - The states are ordered nondecreasing in time (adjacent states *can* have
      the same time).
    - All states in the trajectory are consistent with each other (see
      isConsistent()).

    These guarantees apply when using this class through C++, Java,
    or the %OpenSim GUI, but **not** through Python or MATLAB. This is because
    Python and MATLAB do not enforce constness and thus allow modifying the
    trajectory.


    A StatesTrajectory is not very useful on its own, since neither the
    trajectory nor the contained states know how the Component%s name the state
    variables they create. You probably want to use the trajectory with an
    OpenSim::Model, through which the state variables have a meaning (e.g.,
    `model.getStateVariableValue(states[0], "soleus_r/activation")`).

    SimTK::State%s have a tight association with a specific OpenSim::Model
    (actually, with the SimTK::System within an OpenSim::Model). However,
    the StatesTrajectory does not know anything about the model to which
    it corresponds. So, for example, you could use a single StatesTrajectory
    with a generic gait2392 model as well as with a scaled (subject-specific)
    gait2392 model. This flexibility may be beneficial in some scenarios, but
    also allows one to accidentally use the wrong model with a given states
    trajectory, potentially leading to silent errors that could compromise a
    scientific study.

    To increase your confidence that a StatesTrajectory matches a given Model,
    you can perform some weak checks with isCompatibleWith().


    Here are a few basic things you can do with a StatesTrajectory, assuming you
    already have one:

    .. code-block:: c++

        StatesTrajectory states = getStatesTrajectorySomehow();
        const double numStates = states.getSize();
        const double initialTime = states[0].getTime();
        const double finalTime = states.back().getTime();

    Without a model, you can access the state variable values, but you won't
    know the identity of such state variables.

    .. code-block:: c++

        int numGeneralizedCoordinates = states[0].getNQ();
        const SimTK::Vector& generalizedCoordinateValues = states[0].getQ();

    To do most things with the StatesTrajectory, you'll need a model as well as
    its underlying SimTK::System. **It is therefore required that you call
    `Model::initSystem()` before you try to use any states with the model**:

    .. code-block:: c++

        Model model("subject01.osim");
        model.initSystem();
        double knee_angle = model.getStateVariableValue(states[0], "knee/flexion/value");
        Vec3 com = model.calcMassCenterPosition(states[0]);

    Depending on the quantity you want to obtain, you may also need to realize
    the state to a certain stage:

    .. code-block:: c++

        model.getMultibodySystem().realize(states[0], SimTK::Stage::Velocity);
        model.getMuscles().get("soleus_r").getActivation(states[0]);

    You can iterate through a trajectory to access the value of a state variable
    at each time in the trajectory.

    .. code-block:: c++

        for (const auto& state : states) {
            std::cout << state.getTime() << " "
                      << model.getStateVariableValue(state, "knee/flexion/value")
                      << std::endl;
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Create an empty trajectory of states."""
        _simulation.StatesTrajectory_swiginit(self, _simulation.new_StatesTrajectory())

    def getSize(self):
        r""" The number of SimTK::State%s in the trajectory."""
        return _simulation.StatesTrajectory_getSize(self)

    def get(self, index):
        r"""
         Get a const reference to the state at a given index in the trajectory.

        :raises: IndexOutOfRange If the index is greater than the size of the
                                    trajectory.
        """
        return _simulation.StatesTrajectory_get(self, index)

    def front(self):
        r""" Get a const reference to the first state in the trajectory."""
        return _simulation.StatesTrajectory_front(self)

    def back(self):
        r""" Get a const reference to the last state in the trajectory."""
        return _simulation.StatesTrajectory_back(self)

    def begin(self):
        r"""
         Iterator pointing to first SimTK::State; does not allow modifying the
        states. Allows using this class in a range for loop.
        """
        return _simulation.StatesTrajectory_begin(self)

    def end(self):
        r"""
         Iterator pointing past the end of the trajectory. Allows using this
        class in a range for loop.
        """
        return _simulation.StatesTrajectory_end(self)

    def clear(self):
        r""" Clear all the states in the trajectory."""
        return _simulation.StatesTrajectory_clear(self)

    def append(self, state):
        r"""
         Append a SimTK::State to this trajectory.
        This function ensures that the time in the new SimTK::State is greater
        than or equal to the time in the last SimTK::State in the trajectory.

        The state that ends up in the trajectory is a deep copy of the one
        passed in.
        """
        return _simulation.StatesTrajectory_append(self, state)

    def hasIntegrity(self):
        r"""
         Checks isNondecreasingInTime() and isConsistent().
        The design of this class is such that this method should always return
        true. This check may be more useful in Python or MATLAB, in which it's
        possible to edit the trajectory such that this method could return
        false.
        """
        return _simulation.StatesTrajectory_hasIntegrity(self)

    def isNondecreasingInTime(self):
        r""" Returns true if times are non-decreasing; false otherwise."""
        return _simulation.StatesTrajectory_isNondecreasingInTime(self)

    def isConsistent(self):
        r"""
         Checks if the states have the same number of state variables,
        constraints, etc. Returns true if the following quantities are the same
        for all states in the trajectory:
        - number of generalized coordinates (Q's)
        - number of generalized speeds (U's)
        - number of auxiliary state variables (Z's)
        - number of position constraints (QErr's)
        - number of velocity constraints (UErr's)
        - number of acceleration constraints (UDotErr's)
        - number of constraint Lagrange multipliers
        - number of event triggers

        Returns false otherwise.
        """
        return _simulation.StatesTrajectory_isConsistent(self)

    def isCompatibleWith(self, model):
        r"""
         Weak check for if the trajectory can be used with the given model.
        Returns true if the trajectory isConsistent() and if the number of speeds
        in the model matches the number of U's in state.

        Returns false otherwise. This method **cannot** guarantee that the
        trajectory will work with the given model, and makes no attempt to
        determine if the trajectory was generated with the given model.
        """
        return _simulation.StatesTrajectory_isCompatibleWith(self, model)

    def exportToTable(self, *args):
        r"""
         Export the continuous state variables to a data table, perhaps to write
        to a file and postprocess in MATLAB/Python/Excel. The names of the
        columns in the table will be the absolute names of the continuous state
        variables (e.g., `knee/flexion/angle`).

        You must provide a model that is compatible with this trajectory,
        since only the model knows the names of the state variables.

        By default, all continuous state variables are written to the table
        (one per column). If you only want some of them to be written to the
        table, use the `stateVars` argument to specify their absolute names
        (e.g., `knee/flexion/angle`).

        .. code-block:: c++

            auto allStateVars = states.exportToTable(model);
            auto kneeStates = states.exportToTable(model, {"knee/flexion/value",
                                                           "knee/flexion/speed"});

        :raises: IncompatibleModel Thrown if the Model fails the check
                 isCompatibleWith().

        See DataAdapter for details on writing to files.
        """
        return _simulation.StatesTrajectory_exportToTable(self, *args)

    def exportToStatesDocument(self, *args):
        r"""
         Export a complete trajectory of states (i.e., one that includes
        all continuous, discrete, and modeling states) to an
        OpenSim::StatesDocument. That StatesDocument instance can then be
        used to serialize the states to an OSTATES file or document string by
        calling `StatesDocument::serialize()`.

        Once the states have been serialized, they can be deserialized by
        constructing a new StatesDocument by calling
        ```
          StatesDocument(const SimTK::String& filename)
        ```
        and then calling:
        ```
          StatesDocument::deserialize(const OpenSim::Model& model,
                                  std::vector<SimTK::State>& trajectory)
        ```

        The .ostates format is plain-text XML (see SimTK::Xml) with a
        specifiable precision between 1 and 20 significant figures. A precision
        of 20 digits results in losselss de/serialization.

        A note of CAUTION:
        Using either

              StatesTrajectory StatesTrajectory::createFromStatesStorage() or
              StatesTrajectory StatesTrajectory::createFromStatesTable()

        to construct a StatesTrajectory instance will likely leave discrete
        states (i.e., OpenSim::DiscreteVariable%s) and modeling states
        (i.e., OpenSim::ModelingOptions%s) uninitialized. The reason is that
        Storage and TimeSeriesTable objects include only the continuous states
        (i.e., OpenSim::StateVariable%s).

        Thus, when relying on serialization and deserialization to reproduce a
        complete StatesTrajectory, a StatesDocument is the preferred means as
        it will include continuous, discrete, and modeling states.
        """
        return _simulation.StatesTrajectory_exportToStatesDocument(self, *args)

    def getStateArray(self):
        r""" Get a read-only reference to the underlying state array."""
        return _simulation.StatesTrajectory_getStateArray(self)

    @staticmethod
    def createFromStatesTable(model, table, allowMissingColumns=False, allowExtraColumns=False, assemble=False):
        r"""
         Create a partial trajectory of States from a states table.
        The resulting StatesTrajectory will restore continuous state
        variable values, but not discrete state variable values, modeling
        option values, etc. Also, keep in mind that states files usually
        do not contain the state values to full precision, and thus cannot
        exactly reproduce results from the initial state trajectory. Lastly,
        this function optionally modifies each state to obey any constraints in
        the model (by calling Model::assemble()).

        The states in the resulting trajectory will be realized to
        SimTK::Stage::Instance. You should not use the resulting trajectory with
        an instance of the model other than the one you passed to this function
        (the state contains Instance-stage cache variables that are pointers to
        objects in the model; e.g., force elements).

        Notes: The naming convention for state variables changed in OpenSim v4.0;
        `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,
        `soleus_r/activation` used to be `soleus_r.activation`, etc. This
        function can handle column labels that use the pre-v4.0 naming
        convention.

        :type model: :py:class:`Model`
        :param model: The Model to which the states belong. A Model is necessary
                 because the data file lists the state variables by name.
        :type table: :py:class:`TimeSeriesTable`
        :param table: The table containing state values.
        :type allowMissingColumns: boolean, optional
        :param allowMissingColumns: If false, throws exception if there are
                 continuous state variables in the Model for which there is no
                 column in the table. If true, no exception is thrown but such
                 state variables are set to NaN.
        :type allowExtraColumns: boolean, optional
        :param allowExtraColumns: If false, throws exception if there are
                 columns in the table that do not correspond to continuous state
                 variables in the Model. If true, such columns of the table are
                 ignored.
        :type assemble: boolean, optional
        :param assemble: Modify state variable values to satisfy
                 kinematic constraints (by calling Model::assemble()).
                 Use this option if the provided states are incomplete (for example,
                 the values for dependent coordinates are unspecified).
                 Caution: enforcing constraints can drastically alter the
                 provided states if they do not already obey the constraints.
                 Do not use this option with results from a forward simulation: the
                 states trajectory from a forward simulation may not meet the
                 model's assembly accuracy, and therefore assembling could
                 alter the trajectory and cause inconsistency between coordinate
                 values and speeds.

        Here is how you might use this function in python:

        .. code-block:: python

            import opensim
            model = opensim.Model("subject01.osim")
            table = opensim.TimeSeriesTable("subject01_states.sto")
            states = opensim.StatesTrajectory.createFromStatesTable(model, table)
            print(states[0].getTime())
            print(model.getStateVariableValue(states[0], "knee/flexion/value"))

        :raises: MissingColumns See the description of the
                 `allowMissingColumns` argument.

        :raises: ExtraColumns See the description of the
                 `allowExtraColumns` argument.

        :raises: NonUniqueLabels Thrown if multiple columns in
                 the table have the same name.

        :raises: DataIsInDegrees Thrown if the table is in degrees
                 (inDegrees=yes); angular quantities must use radians to properly
                 create the trajectory.
        """
        return _simulation.StatesTrajectory_createFromStatesTable(model, table, allowMissingColumns, allowExtraColumns, assemble)

    @staticmethod
    def createFromStatesStorage(*args):
        r"""
        *Overload 1:*

        This function is identical to createFromStatesTable() except that this
        function accepts a Storage instead of a TimeSeriesTable.

        |

        *Overload 2:*
         Convenience form of createFromStatesStorage() that takes the path to a
        Storage file instead of a Storage object. This convenience form uses the
        default values for `allowMissingColumns` and `allowExtraColumns`.
        """
        return _simulation.StatesTrajectory_createFromStatesStorage(*args)


    def __iter__(self):
        """Get an iterator for this Set, to be used as such (where `states` is
        the StatesTrajectory object)::

            for state in states:
                model.calcMassCenterPosition(state)
        """
        it = self.begin()
        while it != self.end():
            yield it.next()

    def getBetween(self, *args, **kwargs):
        iter_range = self._getBetween(*args, **kwargs)
        it = iter_range.begin()
        while it != iter_range.end():
            yield it.next()


    def __getitem__(self, i):
        r"""
        __getitem__(StatesTrajectory self, int i) -> State

        Parameters
        ----------
        i: int

        """
        return _simulation.StatesTrajectory___getitem__(self, i)
    __swig_destroy__ = _simulation.delete_StatesTrajectory

# Register StatesTrajectory in _simulation:
_simulation.StatesTrajectory_swigregister(StatesTrajectory)
class IteratorRangeStatesTrajectoryIterator(object):
    r"""
     Helper class to use range-based for loops with a pair of iterators. This
    class should only be used when you're sure the iterators are valid. Don't
    use this class directly; instead, use makeIteratorRange().

    Here's an example of using iterators `first` and `last` to iterate over the
    range `[first, last)` (that is, `last` won't be reached):

    .. code-block:: c++

        std::vector<int> v {5, 10, 15, 20, 22};
        auto first = std::lower_bound(v.begin(), v.end(), 10);
        auto last = std::lower_bound(v.begin(), v.end(), 15); // actually points to 20.
        for (auto& x : makeIteratorRange(first, last)) {
            ...
        }

    You can also use this class with an std::pair of iterators, such as that
    returned by std::multimap::equal_range(). We assume the first iterator in the
    pair is the first iterator in the range, and the second iterator in the pair is
    the last iterator in the range.

    .. code-block:: c++

        std::multimap<std::string, int> map;
        ...
        for (auto& x : makeIteratorRange(map.equal_range("some_key"))) {
            ...
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IteratorRangeStatesTrajectoryIterator self, std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator first, std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator last) -> IteratorRangeStatesTrajectoryIterator

        Parameters
        ----------
        first: std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator
        last: std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator

        __init__(IteratorRangeStatesTrajectoryIterator self, std::pair< std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator,std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator > const & range) -> IteratorRangeStatesTrajectoryIterator

        Parameters
        ----------
        range: std::pair< std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator,std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator > const &

        """
        _simulation.IteratorRangeStatesTrajectoryIterator_swiginit(self, _simulation.new_IteratorRangeStatesTrajectoryIterator(*args))

    def begin(self):
        r"""begin(IteratorRangeStatesTrajectoryIterator self) -> std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator"""
        return _simulation.IteratorRangeStatesTrajectoryIterator_begin(self)

    def end(self):
        r"""end(IteratorRangeStatesTrajectoryIterator self) -> std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator"""
        return _simulation.IteratorRangeStatesTrajectoryIterator_end(self)
    __swig_destroy__ = _simulation.delete_IteratorRangeStatesTrajectoryIterator

# Register IteratorRangeStatesTrajectoryIterator in _simulation:
_simulation.IteratorRangeStatesTrajectoryIterator_swigregister(IteratorRangeStatesTrajectoryIterator)
class StatesTrajectoryReporter(opensim.common.AbstractReporter):
    r"""
     Stores the states during a simulation in a StatesTrajectory.

    This class was introduced in v4.0 and is intended to replace the
    StatesReporter analysis.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> StatesTrajectoryReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.StatesTrajectoryReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(StatesTrajectoryReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.StatesTrajectoryReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.StatesTrajectoryReporter_getClassName()

    def clone(self):
        r"""clone(StatesTrajectoryReporter self) -> StatesTrajectoryReporter"""
        return _simulation.StatesTrajectoryReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(StatesTrajectoryReporter self) -> std::string const &"""
        return _simulation.StatesTrajectoryReporter_getConcreteClassName(self)

    def getStates(self):
        r""" Obtain the accumulated states as a StatesTrajectory object."""
        return _simulation.StatesTrajectoryReporter_getStates(self)

    def getVectorOfStateObjects(self):
        r""" Obtain the accumulated states as a low-level array of states."""
        return _simulation.StatesTrajectoryReporter_getVectorOfStateObjects(self)

    def clear(self):
        r""" Clear the accumulated states."""
        return _simulation.StatesTrajectoryReporter_clear(self)

    def __init__(self):
        r"""__init__(StatesTrajectoryReporter self) -> StatesTrajectoryReporter"""
        _simulation.StatesTrajectoryReporter_swiginit(self, _simulation.new_StatesTrajectoryReporter())
    __swig_destroy__ = _simulation.delete_StatesTrajectoryReporter

# Register StatesTrajectoryReporter in _simulation:
_simulation.StatesTrajectoryReporter_swigregister(StatesTrajectoryReporter)
class PositionMotion(ModelComponent):
    r"""
     This class prescribes the value, speed, and acceleration of all coordinates
    in the model using SimTK::Motion. SimTK::Motion%s remove degrees of freedom
    from the system rather than add constraints. This is an alternative to
    prescribing kinematics using Coordinate's prescribed_function, which uses a
    kinematic constraint. When prescribing motion, the system must compute
    constraint forces to apply to enforce the prescribed motion;
    such forces are available via SimbodyMatterSubsystem::findMotionForces().
    Notes: This class requires that *all* coordinates are prescribed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PositionMotion

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.PositionMotion_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PositionMotion self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.PositionMotion_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.PositionMotion_getClassName()

    def clone(self):
        r"""clone(PositionMotion self) -> PositionMotion"""
        return _simulation.PositionMotion_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PositionMotion self) -> std::string const &"""
        return _simulation.PositionMotion_getConcreteClassName(self)

    def copyProperty_default_enabled(self, source):
        r"""
        copyProperty_default_enabled(PositionMotion self, PositionMotion source)

        Parameters
        ----------
        source: OpenSim::PositionMotion::Self const &

        """
        return _simulation.PositionMotion_copyProperty_default_enabled(self, source)

    def append_default_enabled(self, value):
        r"""
        append_default_enabled(PositionMotion self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PositionMotion_append_default_enabled(self, value)

    def constructProperty_default_enabled(self, initValue):
        r"""
        constructProperty_default_enabled(PositionMotion self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.PositionMotion_constructProperty_default_enabled(self, initValue)

    def get_default_enabled(self, *args):
        r"""
        get_default_enabled(PositionMotion self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_default_enabled(PositionMotion self) -> bool const &
        """
        return _simulation.PositionMotion_get_default_enabled(self, *args)

    def upd_default_enabled(self, *args):
        r"""
        upd_default_enabled(PositionMotion self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_default_enabled(PositionMotion self) -> bool &
        """
        return _simulation.PositionMotion_upd_default_enabled(self, *args)

    def set_default_enabled(self, *args):
        r"""
        set_default_enabled(PositionMotion self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_default_enabled(PositionMotion self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.PositionMotion_set_default_enabled(self, *args)

    def copyProperty_functions(self, source):
        r"""
        copyProperty_functions(PositionMotion self, PositionMotion source)

        Parameters
        ----------
        source: OpenSim::PositionMotion::Self const &

        """
        return _simulation.PositionMotion_copyProperty_functions(self, source)

    def append_functions(self, value):
        r"""
        append_functions(PositionMotion self, FunctionSet value) -> int

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PositionMotion_append_functions(self, value)

    def constructProperty_functions(self, initValue):
        r"""
        constructProperty_functions(PositionMotion self, FunctionSet initValue)

        Parameters
        ----------
        initValue: OpenSim::FunctionSet const &

        """
        return _simulation.PositionMotion_constructProperty_functions(self, initValue)

    def get_functions(self, *args):
        r"""
        get_functions(PositionMotion self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        get_functions(PositionMotion self) -> FunctionSet
        """
        return _simulation.PositionMotion_get_functions(self, *args)

    def upd_functions(self, *args):
        r"""
        upd_functions(PositionMotion self, int i) -> FunctionSet

        Parameters
        ----------
        i: int

        upd_functions(PositionMotion self) -> FunctionSet
        """
        return _simulation.PositionMotion_upd_functions(self, *args)

    def set_functions(self, *args):
        r"""
        set_functions(PositionMotion self, int i, FunctionSet value)

        Parameters
        ----------
        i: int
        value: OpenSim::FunctionSet const &

        set_functions(PositionMotion self, FunctionSet value)

        Parameters
        ----------
        value: OpenSim::FunctionSet const &

        """
        return _simulation.PositionMotion_set_functions(self, *args)

    def __init__(self, *args):
        r"""
        __init__(PositionMotion self) -> PositionMotion
        __init__(PositionMotion self, std::string name) -> PositionMotion

        Parameters
        ----------
        name: std::string

        """
        _simulation.PositionMotion_swiginit(self, _simulation.new_PositionMotion(*args))
    __swig_destroy__ = _simulation.delete_PositionMotion

    def setPositionForCoordinate(self, coord, position):
        r"""
        Set a function to calculate the position for a given coordinate.
        The speed and acceleration of the coordinate are obtained as derivatives
        of the provided function.
        """
        return _simulation.PositionMotion_setPositionForCoordinate(self, coord, position)

    def setDefaultEnabled(self, enabled):
        r"""
        This determines if, after Model::initSystem(), these prescribed
        motions are enabled or disabled.
        """
        return _simulation.PositionMotion_setDefaultEnabled(self, enabled)

    def getDefaultEnabled(self):
        r"""getDefaultEnabled(PositionMotion self) -> bool"""
        return _simulation.PositionMotion_getDefaultEnabled(self)

    def setEnabled(self, state, enabled):
        r"""
        Use this after Model::initSystem() to set if the prescribed motions
        are enforced.
        """
        return _simulation.PositionMotion_setEnabled(self, state, enabled)

    def getEnabled(self, state):
        r"""
        getEnabled(PositionMotion self, State state) -> bool

        Parameters
        ----------
        state: SimTK::State const &

        """
        return _simulation.PositionMotion_getEnabled(self, state)

    @staticmethod
    def createFromTable(model, coords, allowExtraColumns=False):
        r"""
        Create a PositionMotion that prescribes kinematics for all coordinates
        in a model, given a data table containing coordinate values for all
        coordinates using GCVSpline. If the table contains any columns that are
        not the names of coordinate value state variables, an exception is
        thrown (unless allowExtraColumns is true).

        Notes: If the data in the table violates kinematic constraints in the
        model, the resulting PositionMotion will also violate the kinematic
        constraints.

        This fuction ignores the inDegrees header metadata.
        """
        return _simulation.PositionMotion_createFromTable(model, coords, allowExtraColumns)

    @staticmethod
    def createFromStatesTrajectory(model, statesTraj):
        r"""
        Create a PositionMotion that prescribes kinematics for all coordinates
        in a model, given a StatesTrajectory.

        Notes: If the states trajectory violates kinematic constraints in the
        model, the resulting PositionMotion will also violate the kinematic
        constraints.
        """
        return _simulation.PositionMotion_createFromStatesTrajectory(model, statesTraj)

    def exportToTable(self, time):
        r"""
        exportToTable(PositionMotion self, StdVectorDouble time) -> TimeSeriesTable

        Parameters
        ----------
        time: std::vector< double,std::allocator< double > > const &

        """
        return _simulation.PositionMotion_exportToTable(self, time)

# Register PositionMotion in _simulation:
_simulation.PositionMotion_swigregister(PositionMotion)

def simulate(model, initialState, finalTime, saveStatesFile=False):
    r"""
    Simulate a model from an initial state and return the final state.
       If the model's useVisualizer flag is true, the user is repeatedly prompted
       to either begin simulating or quit. The provided state is not updated but
       the final state is returned at the end of the simulation, when finalTime is
       reached. %Set saveStatesFile=true to save the states to a storage file as:
       "<model_name>_states.sto".
    """
    return _simulation.simulate(model, initialState, finalTime, saveStatesFile)

def updateStateLabels40(model, labels):
    r"""
    Update a vector of state labels (in place) to use post-4.0 state paths
    instead of pre-4.0 state names. For example, this converts labels as
    follows:
      - `pelvis_tilt` -> `/jointset/ground_pelvis/pelvis_tilt/value`
      - `pelvis_tilt_u` -> `/jointset/ground_pelvis/pelvis_tilt/speed`
      - `soleus.activation` -> `/forceset/soleus/activation`
      - `soleus.fiber_length` -> `/forceset/soleus/fiber_length`
    This can also be used to update the column labels of an Inverse
    Kinematics Tool solution MOT file so that the data can be used as
    states. If a label does not identify a state in the model, the column
    label is not changed.
    :raises: Exception if labels are not unique.
    """
    return _simulation.updateStateLabels40(model, labels)

def updatePre40KinematicsFilesFor40MotionType(*args):
    r"""
    This function can be used to upgrade MOT files generated with versions
       before 4.0 in which some data columns are associated with coordinates
       that were incorrectly marked as Rotational (rather than Coupled). Specific
       instances of the issue are the patella coordinate in the Rajagopal 2015 and
       leg6dof9musc models. In these cases, the patella will visualize incorrectly
       in the GUI when replaying the kinematics from the MOT file, and Static
       Optimization will yield incorrect results.

       The new files are written to the same directories as the original files,
       but with the provided suffix (before the file extension). To overwrite your
       original files, set the suffix to an emtpty string.

       If the file does not need to be updated, no new file is written.

       Conversion of the data only occurs for files in degrees ("inDegrees=yes"
       in the header).

       Do not use this function with MOT files generated by 4.0 or later; doing
       so will cause your data to be altered incorrectly. We do not detect whether
       or not your MOT file is pre-4.0.

       In OpenSim 4.0, MotionTypes for
       Coordinates are now determined strictly by the coordinates' owning Joint.
       In older models, the MotionType, particularly for CustomJoints, were user-
       specified. That entailed in some cases, incorrectly labeling a Coordinate
       as being Rotational, for example, when it is in fact Coupled. For the above
       models, for example, the patella Coordinate had been user-specified to be
       Rotational, but the angle of the patella about the Z-axis of the patella
       body, is a spline function (e.g. coupled function) of the patella
       Coordinate. Thus, the patella Coordinate is not an angle measurement
       and is not classified as Rotational. Use this utility to remove any unit
       conversions from Coordinates that were incorrectly labeled
       as Rotational in the past. For these Coordinates only, the utility will undo
       the incorrect radians to degrees conversion.
    """
    return _simulation.updatePre40KinematicsFilesFor40MotionType(*args)

def updateSocketConnecteesBySearch(model):
    r"""
     This function attempts to update the connectee path for any Socket anywhere
    in the model whose connectee path does not point to an existing component.
    The paths are updated by searching the model for a component with the
    correct name. For example, a connectee path like
    `../../some/invalid/path/to/foo` will be updated to `/bodyset/foo` if a Body
    named `foo` exists in the Model's BodySet. If a socket specifies a Body `foo` and
    more than one Body `foo` exists in the model, we emit a warning and the
    socket that specified `foo` is not altered.

    This method is intended for use with models loaded from version-30516 XML
    files to bring them up to date with the 4.0 interface.

    """
    return _simulation.updateSocketConnecteesBySearch(model)

def createStateVariableNamesInSystemOrder(model):
    r"""
    The map provides the index of each state variable in
    SimTK::State::getY() from its each state variable path string.
    Empty slots in Y (e.g., for quaternions) are ignored.
    """
    return _simulation.createStateVariableNamesInSystemOrder(model)

def createControlNamesFromModel(*args):
    r"""
    *Overload 1:*
    Create a vector of control names based on the actuators in the model for
    which appliesForce == True. For actuators with one control (e.g.
    ScalarActuator) the control name is simply the actuator name. For actuators
    with multiple controls, each control name is the actuator name appended by
    the control index (e.g. "/actuator_0"); modelControlIndices has length equal
    to the number of controls associated with actuators that apply a force
    (appliesForce == True). Its elements are the indices of the controls in the
    Model::updControls() that are associated with actuators that apply a force.


    |

    *Overload 2:*
    Same as above, but when there is no mapping to the modelControlIndices.
    """
    return _simulation.createControlNamesFromModel(*args)

def createSystemControlIndexMap(model):
    r"""
    The map provides the index of each control variable in the SimTK::Vector
    returned by Model::getControls(), using the control name as the
    key.

    :raises: Exception if the order of actuators in the model does not match
            the order of controls in Model::getControls(). This is an internal
            error, but you may be able to avoid the error by ensuring all Actuator%s
            are in the Model's ForceSet.
    """
    return _simulation.createSystemControlIndexMap(model)

def checkOrderSystemControls(model):
    r"""
    Throws an exception if the order of the controls in the model is not the
    same as the order of the actuators in the model.
    """
    return _simulation.checkOrderSystemControls(model)

def checkLabelsMatchModelStates(model, labels):
    r"""
    Throws an exception if any label in the provided list does not match any
    state variable names in the model.
    """
    return _simulation.checkLabelsMatchModelStates(model, labels)

def createSyntheticIMUAccelerationSignals(model, statesTable, controlsTable, framePaths):
    r"""
    Calculate "synthetic" acceleration signals equivalent to signals recorded
    from inertial measurement units (IMUs). First, this utility computes the
    linear acceleration for each frame included in 'framePaths' using Frame's
    'linear_acceleration' Output. Then, to mimic acceleration signals measured
    from IMUs, the model's gravitational acceleration vector is subtracted from
    the linear accelerations and the resulting accelerations are re-expressed in
    the bases of the associated Frame%s.

    Notes: The linear acceleration Output%s are computed using the analyze()
    simulation utility, and therefore the 'statesTable' and 'controlsTable'
    arguments must contain the same time points and we assume that the states
    obey any kinematic constraints in the Model.

    The passed in model must have the correct mass and inertia properties
    included, since computing accelerations requires realizing to
    SimTK::Stage::Acceleration which depends on SimTK::Stage::Dynamics.

    """
    return _simulation.createSyntheticIMUAccelerationSignals(model, statesTable, controlsTable, framePaths)

def appendCoupledCoordinateValues(table, model, overwriteExistingColumns=True):
    r"""
    Compute the values of coordinates defined by `CoordinateCouplerConstraint`s
    in the model and append them to the provided `TimeSeriesTable`. The table
    should contain columns with values for all the independent coordinates that
    define the coupled coordinate. The column labels must be the full path to
    the coordinate values (e.g., `/jointset/ground_pelvis/pelvis_tx/value`).
    """
    return _simulation.appendCoupledCoordinateValues(table, model, overwriteExistingColumns)

def appendCoordinateValueDerivativesAsSpeeds(table, model, overwriteExistingColumns=True):
    r"""
    Compute and append the coordinate speeds in the model by taking the first
    derivative of the coordinate values in the provided `TimeSeriesTable`. The
    table should contain columns with values for valid coordinates in the model.
    Columns that do not match a coordinate in the model are ignored. The column
    labels must be the full path to the coordinate values (e.g.,
    `/jointset/ground_pelvis/pelvis_tx/value`).
    """
    return _simulation.appendCoordinateValueDerivativesAsSpeeds(table, model, overwriteExistingColumns)

def analyze(*args):
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyze(*args)

def analyzeVec3(*args):
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyzeVec3(*args)

def analyzeSpatialVec(*args):
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyzeSpatialVec(*args)

def analyzeRotation(*args):
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyzeRotation(*args)
class VisualizerUtilities(object):
    r"""Proxy of C++ OpenSim::VisualizerUtilities class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def showMotion(arg1, arg2):
        r"""
        Play back an existing motion (from the table) in the
        simbody-visualizer. The Storage should contain all generalized
        coordinates. The visualizer window allows the user to control playback
        speed. This function blocks until the user exits the simbody-visualizer
        window.
        """
        return _simulation.VisualizerUtilities_showMotion(arg1, arg2)

    @staticmethod
    def showModel(arg1):
        r"""
        Visualize the passed in model in a simbody-visualizer window.
        This function blocks until the user exits the simbody-visualizer
        window.
        """
        return _simulation.VisualizerUtilities_showModel(arg1)

    @staticmethod
    def showMarkerData(arg1):
        r"""
        Show markers with time histories specified by the passed in
               TimeSeriesTableVec3. Visualization is shown in the simbody visualizer.
               Function blocks waiting for user to hit a key to start.
        """
        return _simulation.VisualizerUtilities_showMarkerData(arg1)

    @staticmethod
    def showOrientationData(*args):
        r"""
        Show frames with time histories specified by the passed in
               TimeSeriesTableQuaternion. Visualization is shown in the simbody
              visualizer.
              - layout options:
                   -'line' default layout frames in a row along Z axis
                   -'circle' frames laid out around a half-circle in the Y-Z plane
                   -'model' Load passed in model and overlay frames at origins of
                       corresponding bodies at default pose. Must have invoked
                       initSystem() on the model.

              Function blocks waiting for user to hit a key to start.
        """
        return _simulation.VisualizerUtilities_showOrientationData(*args)

    def __init__(self):
        r"""__init__(VisualizerUtilities self) -> VisualizerUtilities"""
        _simulation.VisualizerUtilities_swiginit(self, _simulation.new_VisualizerUtilities())
    __swig_destroy__ = _simulation.delete_VisualizerUtilities

# Register VisualizerUtilities in _simulation:
_simulation.VisualizerUtilities_swigregister(VisualizerUtilities)
class TableOperator(opensim.common.OpenSimObject):
    r"""
     This abstract class describes *any* operation that consumes and modifies a
    TimeSeriesTable as part of a TableProcessor.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TableOperator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TableOperator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TableOperator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TableOperator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TableOperator_getClassName()

    def clone(self):
        r"""clone(TableOperator self) -> TableOperator"""
        return _simulation.TableOperator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TableOperator self) -> std::string const &"""
        return _simulation.TableOperator_getConcreteClassName(self)

    def operate(self, table, model):
        r"""
        This function may or may not be provided with a model. If the operation
           requires a model and model == nullptr, an exception is thrown.
        """
        return _simulation.TableOperator_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TableOperator

# Register TableOperator in _simulation:
_simulation.TableOperator_swigregister(TableOperator)
class TableProcessor(opensim.common.OpenSimObject):
    r"""
     This class describes a workflow for processing a table using
    TableOperator%s. The user must provide a source table either as a filepath
    to a table or an in-memory TimeSeriesTable. In C++, one can easily chain
    together the operators in a processor using the C++ pipe operator:

    .. code-block:: c++

        TableProcessor proc = TableProcessor("file.sto") | TabOpLowPassFilter(6);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TableProcessor

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TableProcessor_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TableProcessor self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TableProcessor_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TableProcessor_getClassName()

    def clone(self):
        r"""clone(TableProcessor self) -> TableProcessor"""
        return _simulation.TableProcessor_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TableProcessor self) -> std::string const &"""
        return _simulation.TableProcessor_getConcreteClassName(self)

    def copyProperty_filepath(self, source):
        r"""
        copyProperty_filepath(TableProcessor self, TableProcessor source)

        Parameters
        ----------
        source: OpenSim::TableProcessor::Self const &

        """
        return _simulation.TableProcessor_copyProperty_filepath(self, source)

    def append_filepath(self, value):
        r"""
        append_filepath(TableProcessor self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.TableProcessor_append_filepath(self, value)

    def constructProperty_filepath(self, initValue):
        r"""
        constructProperty_filepath(TableProcessor self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _simulation.TableProcessor_constructProperty_filepath(self, initValue)

    def get_filepath(self, *args):
        r"""
        get_filepath(TableProcessor self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_filepath(TableProcessor self) -> std::string const &
        """
        return _simulation.TableProcessor_get_filepath(self, *args)

    def upd_filepath(self, *args):
        r"""
        upd_filepath(TableProcessor self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_filepath(TableProcessor self) -> std::string &
        """
        return _simulation.TableProcessor_upd_filepath(self, *args)

    def set_filepath(self, *args):
        r"""
        set_filepath(TableProcessor self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_filepath(TableProcessor self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _simulation.TableProcessor_set_filepath(self, *args)

    def copyProperty_operators(self, source):
        r"""
        copyProperty_operators(TableProcessor self, TableProcessor source)

        Parameters
        ----------
        source: OpenSim::TableProcessor::Self const &

        """
        return _simulation.TableProcessor_copyProperty_operators(self, source)

    def get_operators(self, i):
        r"""
        get_operators(TableProcessor self, int i) -> TableOperator

        Parameters
        ----------
        i: int

        """
        return _simulation.TableProcessor_get_operators(self, i)

    def upd_operators(self, i):
        r"""
        upd_operators(TableProcessor self, int i) -> TableOperator

        Parameters
        ----------
        i: int

        """
        return _simulation.TableProcessor_upd_operators(self, i)

    def set_operators(self, i, value):
        r"""
        set_operators(TableProcessor self, int i, TableOperator value)

        Parameters
        ----------
        i: int
        value: OpenSim::TableOperator const &

        """
        return _simulation.TableProcessor_set_operators(self, i, value)

    def append_operators(self, value):
        r"""
        append_operators(TableProcessor self, TableOperator value) -> int

        Parameters
        ----------
        value: OpenSim::TableOperator const &

        """
        return _simulation.TableProcessor_append_operators(self, value)

    def constructProperty_operators(self):
        r"""constructProperty_operators(TableProcessor self)"""
        return _simulation.TableProcessor_constructProperty_operators(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        This constructor is only for use when reading (deserializing) from an
           XML file.

        |

        *Overload 2:*
        Use an in-memory TimeSeriesTable as the source table.
           Since this constructor is not explicit, you can provide a
           TimeSeriesTable to any function that takes a TableProcessor (in C++).

        |

        *Overload 3:*
        Use a filepath as the source table.
           Since this constructor is not explicit, you can provide a string
           filepath to any function that takes a TableProcessor.
        """
        _simulation.TableProcessor_swiginit(self, _simulation.new_TableProcessor(*args))

    def process(self, *args):
        r"""
        *Overload 1:*
        Process and obtain the table. If a filepath is provided, it will be
           evaluated relative to `relativeToDirectory`.
           Certain TableOperator%s require a Model (e.g.,
           TabOpConvertDegreesToRadians, TabOpUseAbsoluteStateNames). If this processor
           contains such an operator, then the operator will throw an exception
           if you do not provide a model when invoking this function.

        |

        *Overload 2:*
        Same as above, but paths are evaluated with respect to the current
           working directory.

        |

        *Overload 3:*
        Same as above, but paths are evaluated with respect to the current
           working directory.
        """
        return _simulation.TableProcessor_process(self, *args)

    def processAndConvertToRadians(self, *args):
        r"""
        *Overload 1:*
        Same as process(), but the columns of processed table are converted from
           degrees to radians, if applicable. This conversion requires a model.

        |

        *Overload 2:*
        Same as above, but paths are evaluated with respect to the current
           working directory.
        """
        return _simulation.TableProcessor_processAndConvertToRadians(self, *args)

    def empty(self):
        r"""
        Returns true if neither a filepath nor an in-memory table have been
           provided.
        """
        return _simulation.TableProcessor_empty(self)

    def append(self, *args):
        r"""
        *Overload 1:*
        Append an operation to the end of the operations in this processor.

        |

        *Overload 2:*
        Append all operations in another processor to this processor.
           The source table of the provided trajectory is ignored.
        """
        return _simulation.TableProcessor_append(self, *args)

    def __or__(self, right):
        r"""
        This operator allows one to write the following code in C++:

           .. code-block:: c++

               TableProcessor proc = TableProcessor("file.sto") |
                       TabOpLowPassFilter(6);
        """
        return _simulation.TableProcessor___or__(self, right)
    __swig_destroy__ = _simulation.delete_TableProcessor

# Register TableProcessor in _simulation:
_simulation.TableProcessor_swigregister(TableProcessor)
class TabOpConvertDegreesToRadians(TableOperator):
    r"""Proxy of C++ OpenSim::TabOpConvertDegreesToRadians class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TabOpConvertDegreesToRadians

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TabOpConvertDegreesToRadians_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TabOpConvertDegreesToRadians self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TabOpConvertDegreesToRadians_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TabOpConvertDegreesToRadians_getClassName()

    def clone(self):
        r"""clone(TabOpConvertDegreesToRadians self) -> TabOpConvertDegreesToRadians"""
        return _simulation.TabOpConvertDegreesToRadians_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TabOpConvertDegreesToRadians self) -> std::string const &"""
        return _simulation.TabOpConvertDegreesToRadians_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(TabOpConvertDegreesToRadians self) -> TabOpConvertDegreesToRadians"""
        _simulation.TabOpConvertDegreesToRadians_swiginit(self, _simulation.new_TabOpConvertDegreesToRadians())
    __swig_destroy__ = _simulation.delete_TabOpConvertDegreesToRadians

# Register TabOpConvertDegreesToRadians in _simulation:
_simulation.TabOpConvertDegreesToRadians_swigregister(TabOpConvertDegreesToRadians)
class TabOpLowPassFilter(TableOperator):
    r""" Apply a low-pass filter to the trajectory."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TabOpLowPassFilter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TabOpLowPassFilter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TabOpLowPassFilter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TabOpLowPassFilter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TabOpLowPassFilter_getClassName()

    def clone(self):
        r"""clone(TabOpLowPassFilter self) -> TabOpLowPassFilter"""
        return _simulation.TabOpLowPassFilter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TabOpLowPassFilter self) -> std::string const &"""
        return _simulation.TabOpLowPassFilter_getConcreteClassName(self)

    def copyProperty_cutoff_frequency(self, source):
        r"""
        copyProperty_cutoff_frequency(TabOpLowPassFilter self, TabOpLowPassFilter source)

        Parameters
        ----------
        source: OpenSim::TabOpLowPassFilter::Self const &

        """
        return _simulation.TabOpLowPassFilter_copyProperty_cutoff_frequency(self, source)

    def append_cutoff_frequency(self, value):
        r"""
        append_cutoff_frequency(TabOpLowPassFilter self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TabOpLowPassFilter_append_cutoff_frequency(self, value)

    def constructProperty_cutoff_frequency(self, initValue):
        r"""
        constructProperty_cutoff_frequency(TabOpLowPassFilter self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.TabOpLowPassFilter_constructProperty_cutoff_frequency(self, initValue)

    def get_cutoff_frequency(self, *args):
        r"""
        get_cutoff_frequency(TabOpLowPassFilter self, int i) -> double const

        Parameters
        ----------
        i: int

        get_cutoff_frequency(TabOpLowPassFilter self) -> double const &
        """
        return _simulation.TabOpLowPassFilter_get_cutoff_frequency(self, *args)

    def upd_cutoff_frequency(self, *args):
        r"""
        upd_cutoff_frequency(TabOpLowPassFilter self, int i) -> double

        Parameters
        ----------
        i: int

        upd_cutoff_frequency(TabOpLowPassFilter self) -> double &
        """
        return _simulation.TabOpLowPassFilter_upd_cutoff_frequency(self, *args)

    def set_cutoff_frequency(self, *args):
        r"""
        set_cutoff_frequency(TabOpLowPassFilter self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_cutoff_frequency(TabOpLowPassFilter self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TabOpLowPassFilter_set_cutoff_frequency(self, *args)

    def copyProperty_trim_to_original_time_range(self, source):
        r"""
        copyProperty_trim_to_original_time_range(TabOpLowPassFilter self, TabOpLowPassFilter source)

        Parameters
        ----------
        source: OpenSim::TabOpLowPassFilter::Self const &

        """
        return _simulation.TabOpLowPassFilter_copyProperty_trim_to_original_time_range(self, source)

    def append_trim_to_original_time_range(self, value):
        r"""
        append_trim_to_original_time_range(TabOpLowPassFilter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpLowPassFilter_append_trim_to_original_time_range(self, value)

    def constructProperty_trim_to_original_time_range(self, initValue):
        r"""
        constructProperty_trim_to_original_time_range(TabOpLowPassFilter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.TabOpLowPassFilter_constructProperty_trim_to_original_time_range(self, initValue)

    def get_trim_to_original_time_range(self, *args):
        r"""
        get_trim_to_original_time_range(TabOpLowPassFilter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_trim_to_original_time_range(TabOpLowPassFilter self) -> bool const &
        """
        return _simulation.TabOpLowPassFilter_get_trim_to_original_time_range(self, *args)

    def upd_trim_to_original_time_range(self, *args):
        r"""
        upd_trim_to_original_time_range(TabOpLowPassFilter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_trim_to_original_time_range(TabOpLowPassFilter self) -> bool &
        """
        return _simulation.TabOpLowPassFilter_upd_trim_to_original_time_range(self, *args)

    def set_trim_to_original_time_range(self, *args):
        r"""
        set_trim_to_original_time_range(TabOpLowPassFilter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_trim_to_original_time_range(TabOpLowPassFilter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpLowPassFilter_set_trim_to_original_time_range(self, *args)

    def __init__(self, *args):
        r"""
        __init__(TabOpLowPassFilter self) -> TabOpLowPassFilter
        __init__(TabOpLowPassFilter self, double cutoffFrequency) -> TabOpLowPassFilter

        Parameters
        ----------
        cutoffFrequency: double

        __init__(TabOpLowPassFilter self, double cutoffFrequency, bool trimToOriginalTimeRange) -> TabOpLowPassFilter

        Parameters
        ----------
        cutoffFrequency: double
        trimToOriginalTimeRange: bool

        """
        _simulation.TabOpLowPassFilter_swiginit(self, _simulation.new_TabOpLowPassFilter(*args))

    def operate(self, table, model=None):
        r"""
        operate(TabOpLowPassFilter self, TimeSeriesTable table, Model model=None)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &
        model: OpenSim::Model const *

        """
        return _simulation.TabOpLowPassFilter_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpLowPassFilter

# Register TabOpLowPassFilter in _simulation:
_simulation.TabOpLowPassFilter_swigregister(TabOpLowPassFilter)
class TabOpUseAbsoluteStateNames(TableOperator):
    r"""
     Update table column labels to use post-4.0 state paths instead of pre-4.0
    state names. For example, this converts column labels as follows:
      - `pelvis_tilt` -> `/jointset/ground_pelvis/pelvis_tilt/value`
      - `pelvis_tilt_u` -> `/jointset/ground_pelvis/pelvis_tilt/speed`
      - `soleus.activation` -> `/forceset/soleus/activation`
      - `soleus.fiber_length` -> `/forceset/soleus/fiber_length`

    This can also be used to convert an Inverse Kinematics Tool solution MOT
    file to be used as a states file (with only coordinate values).
    If a column label does not identify a state in the model,
    the column label is not changed. Column labels must be unique. This operator is
    implemented using SimulationUtilities::updateStateLabels40().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TabOpUseAbsoluteStateNames

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TabOpUseAbsoluteStateNames_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TabOpUseAbsoluteStateNames self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TabOpUseAbsoluteStateNames_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TabOpUseAbsoluteStateNames_getClassName()

    def clone(self):
        r"""clone(TabOpUseAbsoluteStateNames self) -> TabOpUseAbsoluteStateNames"""
        return _simulation.TabOpUseAbsoluteStateNames_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TabOpUseAbsoluteStateNames self) -> std::string const &"""
        return _simulation.TabOpUseAbsoluteStateNames_getConcreteClassName(self)

    def __init__(self):
        r"""__init__(TabOpUseAbsoluteStateNames self) -> TabOpUseAbsoluteStateNames"""
        _simulation.TabOpUseAbsoluteStateNames_swiginit(self, _simulation.new_TabOpUseAbsoluteStateNames())

    def operate(self, table, model):
        r"""
        operate(TabOpUseAbsoluteStateNames self, TimeSeriesTable table, Model model)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &
        model: OpenSim::Model const *

        """
        return _simulation.TabOpUseAbsoluteStateNames_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpUseAbsoluteStateNames

# Register TabOpUseAbsoluteStateNames in _simulation:
_simulation.TabOpUseAbsoluteStateNames_swigregister(TabOpUseAbsoluteStateNames)
class TabOpAppendCoupledCoordinateValues(TableOperator):
    r""" Invoke SimulationUtilities::appendCoupledCoordinateValues() on the table."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TabOpAppendCoupledCoordinateValues

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TabOpAppendCoupledCoordinateValues self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TabOpAppendCoupledCoordinateValues_getClassName()

    def clone(self):
        r"""clone(TabOpAppendCoupledCoordinateValues self) -> TabOpAppendCoupledCoordinateValues"""
        return _simulation.TabOpAppendCoupledCoordinateValues_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TabOpAppendCoupledCoordinateValues self) -> std::string const &"""
        return _simulation.TabOpAppendCoupledCoordinateValues_getConcreteClassName(self)

    def copyProperty_overwrite_existing_columns(self, source):
        r"""
        copyProperty_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, TabOpAppendCoupledCoordinateValues source)

        Parameters
        ----------
        source: OpenSim::TabOpAppendCoupledCoordinateValues::Self const &

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_copyProperty_overwrite_existing_columns(self, source)

    def append_overwrite_existing_columns(self, value):
        r"""
        append_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_append_overwrite_existing_columns(self, value)

    def constructProperty_overwrite_existing_columns(self, initValue):
        r"""
        constructProperty_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_constructProperty_overwrite_existing_columns(self, initValue)

    def get_overwrite_existing_columns(self, *args):
        r"""
        get_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self) -> bool const &
        """
        return _simulation.TabOpAppendCoupledCoordinateValues_get_overwrite_existing_columns(self, *args)

    def upd_overwrite_existing_columns(self, *args):
        r"""
        upd_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self) -> bool &
        """
        return _simulation.TabOpAppendCoupledCoordinateValues_upd_overwrite_existing_columns(self, *args)

    def set_overwrite_existing_columns(self, *args):
        r"""
        set_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_overwrite_existing_columns(TabOpAppendCoupledCoordinateValues self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_set_overwrite_existing_columns(self, *args)

    def __init__(self, *args):
        r"""
        __init__(TabOpAppendCoupledCoordinateValues self) -> TabOpAppendCoupledCoordinateValues
        __init__(TabOpAppendCoupledCoordinateValues self, bool overwriteExistingColumns) -> TabOpAppendCoupledCoordinateValues

        Parameters
        ----------
        overwriteExistingColumns: bool

        """
        _simulation.TabOpAppendCoupledCoordinateValues_swiginit(self, _simulation.new_TabOpAppendCoupledCoordinateValues(*args))

    def operate(self, table, model):
        r"""
        operate(TabOpAppendCoupledCoordinateValues self, TimeSeriesTable table, Model model)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &
        model: OpenSim::Model const *

        """
        return _simulation.TabOpAppendCoupledCoordinateValues_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpAppendCoupledCoordinateValues

# Register TabOpAppendCoupledCoordinateValues in _simulation:
_simulation.TabOpAppendCoupledCoordinateValues_swigregister(TabOpAppendCoupledCoordinateValues)
class TabOpAppendCoordinateValueDerivativesAsSpeeds(TableOperator):
    r"""
     Invoke SimulationUtilities::appendCoordinateValueDerivativesAsSpeeds() on
    the table.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TabOpAppendCoordinateValueDerivativesAsSpeeds

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TabOpAppendCoordinateValueDerivativesAsSpeeds self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_getClassName()

    def clone(self):
        r"""clone(TabOpAppendCoordinateValueDerivativesAsSpeeds self) -> TabOpAppendCoordinateValueDerivativesAsSpeeds"""
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TabOpAppendCoordinateValueDerivativesAsSpeeds self) -> std::string const &"""
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_getConcreteClassName(self)

    def copyProperty_overwrite_existing_columns(self, source):
        r"""
        copyProperty_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, TabOpAppendCoordinateValueDerivativesAsSpeeds source)

        Parameters
        ----------
        source: OpenSim::TabOpAppendCoordinateValueDerivativesAsSpeeds::Self const &

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_copyProperty_overwrite_existing_columns(self, source)

    def append_overwrite_existing_columns(self, value):
        r"""
        append_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_append_overwrite_existing_columns(self, value)

    def constructProperty_overwrite_existing_columns(self, initValue):
        r"""
        constructProperty_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_constructProperty_overwrite_existing_columns(self, initValue)

    def get_overwrite_existing_columns(self, *args):
        r"""
        get_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self) -> bool const &
        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_get_overwrite_existing_columns(self, *args)

    def upd_overwrite_existing_columns(self, *args):
        r"""
        upd_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self) -> bool &
        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_upd_overwrite_existing_columns(self, *args)

    def set_overwrite_existing_columns(self, *args):
        r"""
        set_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_overwrite_existing_columns(TabOpAppendCoordinateValueDerivativesAsSpeeds self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_set_overwrite_existing_columns(self, *args)

    def __init__(self, *args):
        r"""
        __init__(TabOpAppendCoordinateValueDerivativesAsSpeeds self) -> TabOpAppendCoordinateValueDerivativesAsSpeeds
        __init__(TabOpAppendCoordinateValueDerivativesAsSpeeds self, bool overwriteExistingColumns) -> TabOpAppendCoordinateValueDerivativesAsSpeeds

        Parameters
        ----------
        overwriteExistingColumns: bool

        """
        _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_swiginit(self, _simulation.new_TabOpAppendCoordinateValueDerivativesAsSpeeds(*args))

    def operate(self, table, model):
        r"""
        operate(TabOpAppendCoordinateValueDerivativesAsSpeeds self, TimeSeriesTable table, Model model)

        Parameters
        ----------
        table: OpenSim::TimeSeriesTable &
        model: OpenSim::Model const *

        """
        return _simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpAppendCoordinateValueDerivativesAsSpeeds

# Register TabOpAppendCoordinateValueDerivativesAsSpeeds in _simulation:
_simulation.TabOpAppendCoordinateValueDerivativesAsSpeeds_swigregister(TabOpAppendCoordinateValueDerivativesAsSpeeds)
class FrameList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Frame const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.FrameList_swiginit(self, _simulation.new_FrameList(*args))
    __swig_destroy__ = _simulation.delete_FrameList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.FrameList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.FrameList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.FrameList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.FrameList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.FrameList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register FrameList in _simulation:
_simulation.FrameList_swigregister(FrameList)
class FrameIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.FrameIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(FrameIterator self, FrameIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Frame const > const &

        """
        return _simulation.FrameIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(FrameIterator self, FrameIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Frame const > const &

        """
        return _simulation.FrameIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.FrameIterator___ref__(self)

    def deref(self):
        r"""deref(FrameIterator self) -> Frame"""
        return _simulation.FrameIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.FrameIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.FrameIterator_next(self)
    __swig_destroy__ = _simulation.delete_FrameIterator

    def clone(self):
        r"""clone(FrameIterator self) -> Frame"""
        return _simulation.FrameIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FrameIterator self) -> std::string const &"""
        return _simulation.FrameIterator_getConcreteClassName(self)

    def get_frame_geometry(self, *args):
        r"""
        get_frame_geometry(FrameIterator self, int i) -> FrameGeometry

        Parameters
        ----------
        i: int

        get_frame_geometry(FrameIterator self) -> FrameGeometry
        """
        return _simulation.FrameIterator_get_frame_geometry(self, *args)

    def get_attached_geometry(self, i):
        r"""
        get_attached_geometry(FrameIterator self, int i) -> Geometry

        Parameters
        ----------
        i: int

        """
        return _simulation.FrameIterator_get_attached_geometry(self, i)
    _has_output_position = property(_simulation.FrameIterator__has_output_position_get, doc=r"""_has_output_position : bool""")
    _has_output_rotation = property(_simulation.FrameIterator__has_output_rotation_get, doc=r"""_has_output_rotation : bool""")
    _has_output_transform = property(_simulation.FrameIterator__has_output_transform_get, doc=r"""_has_output_transform : bool""")
    _has_output_velocity = property(_simulation.FrameIterator__has_output_velocity_get, doc=r"""_has_output_velocity : bool""")
    _has_output_angular_velocity = property(_simulation.FrameIterator__has_output_angular_velocity_get, doc=r"""_has_output_angular_velocity : bool""")
    _has_output_linear_velocity = property(_simulation.FrameIterator__has_output_linear_velocity_get, doc=r"""_has_output_linear_velocity : bool""")
    _has_output_acceleration = property(_simulation.FrameIterator__has_output_acceleration_get, doc=r"""_has_output_acceleration : bool""")
    _has_output_angular_acceleration = property(_simulation.FrameIterator__has_output_angular_acceleration_get, doc=r"""_has_output_angular_acceleration : bool""")
    _has_output_linear_acceleration = property(_simulation.FrameIterator__has_output_linear_acceleration_get, doc=r"""_has_output_linear_acceleration : bool""")

    def getTransformInGround(self, state):
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.FrameIterator_getTransformInGround(self, state)

    def getVelocityInGround(self, state):
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.FrameIterator_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state):
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.FrameIterator_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state):
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.FrameIterator_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state):
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.FrameIterator_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state):
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.FrameIterator_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state):
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.FrameIterator_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state, otherFrame):
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.FrameIterator_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state, vec_F, otherFrame):
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.FrameIterator_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state, vec_F):
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.FrameIterator_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state, station_F, otherFrame):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.FrameIterator_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.FrameIterator_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.FrameIterator_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.FrameIterator_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self):
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.FrameIterator_findBaseFrame(self)

    def findTransformInBaseFrame(self):
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.FrameIterator_findTransformInBaseFrame(self)

    def getPositionInGround(self, state):
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.FrameIterator_getPositionInGround(self, state)

    def getRotationInGround(self, state):
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.FrameIterator_getRotationInGround(self, state)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.FrameIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.FrameIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.FrameIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.FrameIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.FrameIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.FrameIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.FrameIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.FrameIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.FrameIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.FrameIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.FrameIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.FrameIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.FrameIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.FrameIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.FrameIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.FrameIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.FrameIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.FrameIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.FrameIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(FrameIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.FrameIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.FrameIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.FrameIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.FrameIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.FrameIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.FrameIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.FrameIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.FrameIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(FrameIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(FrameIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.FrameIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(FrameIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(FrameIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.FrameIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.FrameIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.FrameIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.FrameIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.FrameIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.FrameIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.FrameIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.FrameIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.FrameIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.FrameIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.FrameIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.FrameIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.FrameIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.FrameIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.FrameIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.FrameIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.FrameIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.FrameIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.FrameIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.FrameIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.FrameIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.FrameIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.FrameIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.FrameIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.FrameIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.FrameIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.FrameIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.FrameIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.FrameIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.FrameIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.FrameIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.FrameIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.FrameIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.FrameIterator_toString(self)

# Register FrameIterator in _simulation:
_simulation.FrameIterator_swigregister(FrameIterator)
class BodyList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Body const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.BodyList_swiginit(self, _simulation.new_BodyList(*args))
    __swig_destroy__ = _simulation.delete_BodyList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.BodyList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.BodyList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.BodyList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.BodyList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.BodyList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register BodyList in _simulation:
_simulation.BodyList_swigregister(BodyList)
class BodyIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.BodyIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(BodyIterator self, BodyIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Body const > const &

        """
        return _simulation.BodyIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(BodyIterator self, BodyIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Body const > const &

        """
        return _simulation.BodyIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.BodyIterator___ref__(self)

    def deref(self):
        r"""deref(BodyIterator self) -> Body"""
        return _simulation.BodyIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.BodyIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.BodyIterator_next(self)
    __swig_destroy__ = _simulation.delete_BodyIterator

    def clone(self):
        r"""clone(BodyIterator self) -> Body"""
        return _simulation.BodyIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodyIterator self) -> std::string const &"""
        return _simulation.BodyIterator_getConcreteClassName(self)

    def get_mass(self, *args):
        r"""
        get_mass(BodyIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_mass(BodyIterator self) -> double const &
        """
        return _simulation.BodyIterator_get_mass(self, *args)

    def get_mass_center(self, *args):
        r"""
        get_mass_center(BodyIterator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_mass_center(BodyIterator self) -> Vec3
        """
        return _simulation.BodyIterator_get_mass_center(self, *args)

    def get_inertia(self, *args):
        r"""
        get_inertia(BodyIterator self, int i) -> Vec6

        Parameters
        ----------
        i: int

        get_inertia(BodyIterator self) -> Vec6
        """
        return _simulation.BodyIterator_get_inertia(self, *args)
    _has_output_momentum_about_origin = property(_simulation.BodyIterator__has_output_momentum_about_origin_get, doc=r"""_has_output_momentum_about_origin : bool""")
    _has_output_angular_momentum_about_origin = property(_simulation.BodyIterator__has_output_angular_momentum_about_origin_get, doc=r"""_has_output_angular_momentum_about_origin : bool""")
    _has_output_linear_momentum_about_origin = property(_simulation.BodyIterator__has_output_linear_momentum_about_origin_get, doc=r"""_has_output_linear_momentum_about_origin : bool""")
    _has_output_momentum_about_mass_center = property(_simulation.BodyIterator__has_output_momentum_about_mass_center_get, doc=r"""_has_output_momentum_about_mass_center : bool""")
    _has_output_angular_momentum_about_mass_center = property(_simulation.BodyIterator__has_output_angular_momentum_about_mass_center_get, doc=r"""_has_output_angular_momentum_about_mass_center : bool""")
    _has_output_linear_momentum_about_mass_center = property(_simulation.BodyIterator__has_output_linear_momentum_about_mass_center_get, doc=r"""_has_output_linear_momentum_about_mass_center : bool""")

    def getMass(self):
        r""" Access Properties of the Body  The mass of the body in kg"""
        return _simulation.BodyIterator_getMass(self)

    def getMassCenter(self):
        r""" The body center of mass location (Vec3) in the Body frame."""
        return _simulation.BodyIterator_getMassCenter(self)

    def getInertia(self):
        r""" The body's inertia about the center of mass location."""
        return _simulation.BodyIterator_getInertia(self)

    def getMassProperties(self):
        r"""
        Assemble body inertial properties: mass, center of mass location, moment
               of inertia about the origin of the body and return as
               SimTK::MassProperties.
        """
        return _simulation.BodyIterator_getMassProperties(self)

    def calcMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's spatial momentum (angular, linear) measured and
           expressed in Ground, but taken about the Body origin.
        """
        return _simulation.BodyIterator_calcMomentumAboutOrigin(self, s)

    def calcAngularMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's angular momentum measured and expressed in Ground,
           but taken about the Body origin.
        """
        return _simulation.BodyIterator_calcAngularMomentumAboutOrigin(self, s)

    def calcLinearMomentumAboutOrigin(self, s):
        r"""
        Calculate the Body's linear momentum measured and expressed in Ground,
           but taken about the Body origin.
        """
        return _simulation.BodyIterator_calcLinearMomentumAboutOrigin(self, s)

    def calcMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's spatial momentum (angular, linear) measured and
           expressed in Ground, but taken about the Body mass center.
        """
        return _simulation.BodyIterator_calcMomentumAboutMassCenter(self, s)

    def calcAngularMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's angular momentum measured and expressed in Ground,
           but taken about the Body mass center.
        """
        return _simulation.BodyIterator_calcAngularMomentumAboutMassCenter(self, s)

    def calcLinearMomentumAboutMassCenter(self, s):
        r"""
        Calculate the Body's linear momentum measured and expressed in Ground,
           but taken about the Body mass center.
        """
        return _simulation.BodyIterator_calcLinearMomentumAboutMassCenter(self, s)

    def get_WrapObjectSet(self, *args):
        r"""
        get_WrapObjectSet(BodyIterator self, int i) -> WrapObjectSet

        Parameters
        ----------
        i: int

        get_WrapObjectSet(BodyIterator self) -> WrapObjectSet
        """
        return _simulation.BodyIterator_get_WrapObjectSet(self, *args)

    def getMobilizedBodyIndex(self):
        r"""
        This method returns the MobilizedBodyIndex of the MobilizedBody for this
        PhysicalFrame. This index is only available after Model::initSystem() has
        been invoked.

        The MobilizedBodyIndex is necessary to access the underlying MobilizedBody
        in the System. It allows access to physical quantities (e.g. forces)
        associated with individual PhysicalFrames. For examples, the underlying
        MultibodySystem's net body forces are represented as a Vector of spatial
        forces (torque and force on each body) and it is indexed by the
        MobilizedBodyIndex.

        :rtype: int
        :return: index The MobilizedBodyIndex corresponding to this PhysicalFrame's
                       underlying MobilizedBody

        See also: getMobilizedBody, updMobilizedBody
        """
        return _simulation.BodyIterator_getMobilizedBodyIndex(self)

    def getMobilizedBody(self):
        r"""
        Access a readable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.BodyIterator_getMobilizedBody(self)

    def getWrapObject(self, aName):
        r"""
        Deprecated methods for intermediate integration of Frames  Get the named wrap object, if it exists.

        :type aName: string
        :param aName: Name of the wrap object.
        :rtype: :py:class:`WrapObject`
        :return: const Pointer to the wrap object.
        """
        return _simulation.BodyIterator_getWrapObject(self, aName)

    def getWrapObjectSet(self):
        r"""getWrapObjectSet(BodyIterator self) -> WrapObjectSet"""
        return _simulation.BodyIterator_getWrapObjectSet(self)

    def get_frame_geometry(self, *args):
        r"""
        get_frame_geometry(BodyIterator self, int i) -> FrameGeometry

        Parameters
        ----------
        i: int

        get_frame_geometry(BodyIterator self) -> FrameGeometry
        """
        return _simulation.BodyIterator_get_frame_geometry(self, *args)

    def get_attached_geometry(self, i):
        r"""
        get_attached_geometry(BodyIterator self, int i) -> Geometry

        Parameters
        ----------
        i: int

        """
        return _simulation.BodyIterator_get_attached_geometry(self, i)
    _has_output_position = property(_simulation.BodyIterator__has_output_position_get, doc=r"""_has_output_position : bool""")
    _has_output_rotation = property(_simulation.BodyIterator__has_output_rotation_get, doc=r"""_has_output_rotation : bool""")
    _has_output_transform = property(_simulation.BodyIterator__has_output_transform_get, doc=r"""_has_output_transform : bool""")
    _has_output_velocity = property(_simulation.BodyIterator__has_output_velocity_get, doc=r"""_has_output_velocity : bool""")
    _has_output_angular_velocity = property(_simulation.BodyIterator__has_output_angular_velocity_get, doc=r"""_has_output_angular_velocity : bool""")
    _has_output_linear_velocity = property(_simulation.BodyIterator__has_output_linear_velocity_get, doc=r"""_has_output_linear_velocity : bool""")
    _has_output_acceleration = property(_simulation.BodyIterator__has_output_acceleration_get, doc=r"""_has_output_acceleration : bool""")
    _has_output_angular_acceleration = property(_simulation.BodyIterator__has_output_angular_acceleration_get, doc=r"""_has_output_angular_acceleration : bool""")
    _has_output_linear_acceleration = property(_simulation.BodyIterator__has_output_linear_acceleration_get, doc=r"""_has_output_linear_acceleration : bool""")

    def getTransformInGround(self, state):
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.BodyIterator_getTransformInGround(self, state)

    def getVelocityInGround(self, state):
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.BodyIterator_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state):
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.BodyIterator_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state):
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.BodyIterator_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state):
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.BodyIterator_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state):
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.BodyIterator_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state):
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.BodyIterator_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state, otherFrame):
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.BodyIterator_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state, vec_F, otherFrame):
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.BodyIterator_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state, vec_F):
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.BodyIterator_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state, station_F, otherFrame):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.BodyIterator_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.BodyIterator_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.BodyIterator_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state, station_F):
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.BodyIterator_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self):
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.BodyIterator_findBaseFrame(self)

    def findTransformInBaseFrame(self):
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.BodyIterator_findTransformInBaseFrame(self)

    def getPositionInGround(self, state):
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.BodyIterator_getPositionInGround(self, state)

    def getRotationInGround(self, state):
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.BodyIterator_getRotationInGround(self, state)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.BodyIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.BodyIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.BodyIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.BodyIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.BodyIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.BodyIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.BodyIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.BodyIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.BodyIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.BodyIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.BodyIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.BodyIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.BodyIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.BodyIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.BodyIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.BodyIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.BodyIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.BodyIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.BodyIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(BodyIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.BodyIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.BodyIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.BodyIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.BodyIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.BodyIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.BodyIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.BodyIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.BodyIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(BodyIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(BodyIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.BodyIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(BodyIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(BodyIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.BodyIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.BodyIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.BodyIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.BodyIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.BodyIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.BodyIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.BodyIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.BodyIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.BodyIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.BodyIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.BodyIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.BodyIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.BodyIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.BodyIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.BodyIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.BodyIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.BodyIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.BodyIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.BodyIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.BodyIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.BodyIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.BodyIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.BodyIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.BodyIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.BodyIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.BodyIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.BodyIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.BodyIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.BodyIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.BodyIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.BodyIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.BodyIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.BodyIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.BodyIterator_toString(self)

# Register BodyIterator in _simulation:
_simulation.BodyIterator_swigregister(BodyIterator)
class MuscleList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Muscle const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.MuscleList_swiginit(self, _simulation.new_MuscleList(*args))
    __swig_destroy__ = _simulation.delete_MuscleList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.MuscleList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.MuscleList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.MuscleList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.MuscleList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.MuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register MuscleList in _simulation:
_simulation.MuscleList_swigregister(MuscleList)
class MuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.MuscleIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(MuscleIterator self, MuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Muscle const > const &

        """
        return _simulation.MuscleIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(MuscleIterator self, MuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Muscle const > const &

        """
        return _simulation.MuscleIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.MuscleIterator___ref__(self)

    def deref(self):
        r"""deref(MuscleIterator self) -> Muscle"""
        return _simulation.MuscleIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.MuscleIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.MuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_MuscleIterator

    def clone(self):
        r"""clone(MuscleIterator self) -> Muscle"""
        return _simulation.MuscleIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MuscleIterator self) -> std::string const &"""
        return _simulation.MuscleIterator_getConcreteClassName(self)

    def get_max_isometric_force(self, *args):
        r"""
        get_max_isometric_force(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_isometric_force(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args):
        r"""
        get_optimal_fiber_length(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_fiber_length(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args):
        r"""
        get_tendon_slack_length(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_slack_length(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args):
        r"""
        get_pennation_angle_at_optimal(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pennation_angle_at_optimal(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args):
        r"""
        get_max_contraction_velocity(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_contraction_velocity(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args):
        r"""
        get_ignore_tendon_compliance(MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_tendon_compliance(MuscleIterator self) -> bool const &
        """
        return _simulation.MuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args):
        r"""
        get_ignore_activation_dynamics(MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_activation_dynamics(MuscleIterator self) -> bool const &
        """
        return _simulation.MuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.MuscleIterator__has_output_excitation_get, doc=r"""_has_output_excitation : bool""")
    _has_output_activation = property(_simulation.MuscleIterator__has_output_activation_get, doc=r"""_has_output_activation : bool""")
    _has_output_fiber_length = property(_simulation.MuscleIterator__has_output_fiber_length_get, doc=r"""_has_output_fiber_length : bool""")
    _has_output_pennation_angle = property(_simulation.MuscleIterator__has_output_pennation_angle_get, doc=r"""_has_output_pennation_angle : bool""")
    _has_output_cos_pennation_angle = property(_simulation.MuscleIterator__has_output_cos_pennation_angle_get, doc=r"""_has_output_cos_pennation_angle : bool""")
    _has_output_tendon_length = property(_simulation.MuscleIterator__has_output_tendon_length_get, doc=r"""_has_output_tendon_length : bool""")
    _has_output_normalized_fiber_length = property(_simulation.MuscleIterator__has_output_normalized_fiber_length_get, doc=r"""_has_output_normalized_fiber_length : bool""")
    _has_output_fiber_length_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_length_along_tendon_get, doc=r"""_has_output_fiber_length_along_tendon : bool""")
    _has_output_tendon_strain = property(_simulation.MuscleIterator__has_output_tendon_strain_get, doc=r"""_has_output_tendon_strain : bool""")
    _has_output_passive_force_multiplier = property(_simulation.MuscleIterator__has_output_passive_force_multiplier_get, doc=r"""_has_output_passive_force_multiplier : bool""")
    _has_output_active_force_length_multiplier = property(_simulation.MuscleIterator__has_output_active_force_length_multiplier_get, doc=r"""_has_output_active_force_length_multiplier : bool""")
    _has_output_fiber_velocity = property(_simulation.MuscleIterator__has_output_fiber_velocity_get, doc=r"""_has_output_fiber_velocity : bool""")
    _has_output_normalized_fiber_velocity = property(_simulation.MuscleIterator__has_output_normalized_fiber_velocity_get, doc=r"""_has_output_normalized_fiber_velocity : bool""")
    _has_output_fiber_velocity_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_velocity_along_tendon_get, doc=r"""_has_output_fiber_velocity_along_tendon : bool""")
    _has_output_tendon_velocity = property(_simulation.MuscleIterator__has_output_tendon_velocity_get, doc=r"""_has_output_tendon_velocity : bool""")
    _has_output_force_velocity_multiplier = property(_simulation.MuscleIterator__has_output_force_velocity_multiplier_get, doc=r"""_has_output_force_velocity_multiplier : bool""")
    _has_output_pennation_angular_velocity = property(_simulation.MuscleIterator__has_output_pennation_angular_velocity_get, doc=r"""_has_output_pennation_angular_velocity : bool""")
    _has_output_fiber_force = property(_simulation.MuscleIterator__has_output_fiber_force_get, doc=r"""_has_output_fiber_force : bool""")
    _has_output_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_force_along_tendon_get, doc=r"""_has_output_fiber_force_along_tendon : bool""")
    _has_output_active_fiber_force = property(_simulation.MuscleIterator__has_output_active_fiber_force_get, doc=r"""_has_output_active_fiber_force : bool""")
    _has_output_passive_fiber_force = property(_simulation.MuscleIterator__has_output_passive_fiber_force_get, doc=r"""_has_output_passive_fiber_force : bool""")
    _has_output_active_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_active_fiber_force_along_tendon_get, doc=r"""_has_output_active_fiber_force_along_tendon : bool""")
    _has_output_passive_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_passive_fiber_force_along_tendon_get, doc=r"""_has_output_passive_fiber_force_along_tendon : bool""")
    _has_output_tendon_force = property(_simulation.MuscleIterator__has_output_tendon_force_get, doc=r"""_has_output_tendon_force : bool""")
    _has_output_fiber_stiffness = property(_simulation.MuscleIterator__has_output_fiber_stiffness_get, doc=r"""_has_output_fiber_stiffness : bool""")
    _has_output_fiber_stiffness_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_stiffness_along_tendon_get, doc=r"""_has_output_fiber_stiffness_along_tendon : bool""")
    _has_output_tendon_stiffness = property(_simulation.MuscleIterator__has_output_tendon_stiffness_get, doc=r"""_has_output_tendon_stiffness : bool""")
    _has_output_muscle_stiffness = property(_simulation.MuscleIterator__has_output_muscle_stiffness_get, doc=r"""_has_output_muscle_stiffness : bool""")
    _has_output_fiber_active_power = property(_simulation.MuscleIterator__has_output_fiber_active_power_get, doc=r"""_has_output_fiber_active_power : bool""")
    _has_output_fiber_passive_power = property(_simulation.MuscleIterator__has_output_fiber_passive_power_get, doc=r"""_has_output_fiber_passive_power : bool""")
    _has_output_tendon_power = property(_simulation.MuscleIterator__has_output_tendon_power_get, doc=r"""_has_output_tendon_power : bool""")
    _has_output_muscle_power = property(_simulation.MuscleIterator__has_output_muscle_power_get, doc=r"""_has_output_muscle_power : bool""")

    def getMaxIsometricForce(self):
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.MuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self):
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.MuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self):
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.MuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self):
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.MuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self):
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.MuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.MuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s, ignore):
        r"""
        setIgnoreTendonCompliance(MuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.MuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.MuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s, ignore):
        r"""
        setIgnoreActivationDynamics(MuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.MuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s):
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.MuscleIterator_getActivation(self, s)

    def getFiberLength(self, s):
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.MuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s):
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.MuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s):
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.MuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s):
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.MuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s):
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.MuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s):
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.MuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s):
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.MuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.MuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.MuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s):
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.MuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s):
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.MuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s):
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.MuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s):
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.MuscleIterator_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s):
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.MuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s):
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.MuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s):
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.MuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s):
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.MuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s):
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.MuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s):
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.MuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s):
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.MuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s):
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.MuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s):
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.MuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s):
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.MuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s):
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.MuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s):
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.MuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s):
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.MuscleIterator_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.MuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s):
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.MuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s):
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.MuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s):
        r""" get the current active fiber power (W)"""
        return _simulation.MuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s):
        r""" get the current passive fiber power (W)"""
        return _simulation.MuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s):
        r""" get the current tendon power (W)"""
        return _simulation.MuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s):
        r""" get the current muscle power (W)"""
        return _simulation.MuscleIterator_getMusclePower(self, s)

    def getStress(self, s):
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.MuscleIterator_getStress(self, s)

    def setExcitation(self, s, excitation):
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.MuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s):
        r"""
        getExcitation(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getExcitation(self, s)

    def setActivation(self, s, activation):
        r""" DEPRECATED: only for backward compatibility"""
        return _simulation.MuscleIterator_setActivation(self, s, activation)

    def computeActuation(self, s):
        r"""
        Actuator interface for a muscle computes the tension in the muscle
               and applied by the tendon to bones (i.e. not the fiber force)
        """
        return _simulation.MuscleIterator_computeActuation(self, s)

    def computeEquilibrium(self, s):
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.MuscleIterator_computeEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""Conditional comment:"""
        return _simulation.MuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_path(self, *args):
        r"""
        get_path(MuscleIterator self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(MuscleIterator self) -> AbstractGeometryPath
        """
        return _simulation.MuscleIterator_get_path(self, *args)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.MuscleIterator__has_output_tension_get, doc=r"""_has_output_tension : bool""")

    def getPath(self):
        r"""getPath(MuscleIterator self) -> AbstractGeometryPath"""
        return _simulation.MuscleIterator_getPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(MuscleIterator self) -> GeometryPath"""
        return _simulation.MuscleIterator_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(MuscleIterator self) -> bool"""
        return _simulation.MuscleIterator_hasVisualPath(self)

    def getOptimalForce(self):
        r"""getOptimalForce(MuscleIterator self) -> double"""
        return _simulation.MuscleIterator_getOptimalForce(self)

    def getLength(self, s):
        r"""
        getLength(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getLengtheningSpeed(self, s)

    def getSpeed(self, s):
        r"""
        getSpeed(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getSpeed(self, s)

    def getPower(self, s):
        r"""
        getPower(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getPower(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(MuscleIterator self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.MuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args):
        r"""
        get_min_control(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_min_control(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args):
        r"""
        get_max_control(MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_control(MuscleIterator self) -> double const &
        """
        return _simulation.MuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.MuscleIterator__has_output_actuation_get, doc=r"""_has_output_actuation : bool""")
    _has_output_speed = property(_simulation.MuscleIterator__has_output_speed_get, doc=r"""_has_output_speed : bool""")

    def getControl(self, s):
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.MuscleIterator_getControl(self, s)

    def numControls(self):
        r"""numControls(MuscleIterator self) -> int"""
        return _simulation.MuscleIterator_numControls(self)

    def setActuation(self, s, aActuation):
        r"""
        setActuation(MuscleIterator self, State s, double aActuation)

        Parameters
        ----------
        s: SimTK::State const &
        aActuation: double

        """
        return _simulation.MuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s):
        r"""
        getActuation(MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.MuscleIterator_getActuation(self, s)

    def getMinControl(self):
        r"""getMinControl(MuscleIterator self) -> double"""
        return _simulation.MuscleIterator_getMinControl(self)

    def getMaxControl(self):
        r"""getMaxControl(MuscleIterator self) -> double"""
        return _simulation.MuscleIterator_getMaxControl(self)

    def overrideActuation(self, s, flag):
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.MuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s):
        r""" return ScalarActuator's override status"""
        return _simulation.MuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s, value):
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.MuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s):
        r"""return override actuation"""
        return _simulation.MuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls, actuatorControls):
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.MuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls, modelControls):
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.MuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls, modelControls):
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.MuscleIterator_addInControls(self, actuatorControls, modelControls)

    def produceForces(self, state, forceConsumer):
        r"""
        Uses `implProduceForces` to produce (emit) forces evaluated from `state` into the
        provided `ForceConsumer`.

        Notes: this function only produces the forces and does not apply them to anything. It's
              up to the `ForceConsumer` implementation to handle the forces. Therefore,
              `Force::appliesForces` is ignored by this method.

        :type state: :py:class:`State`
        :param state:       the state used to evaluate forces
        :param consumer:    a `ForceConsumer` that shall receive each of the produced forces
        """
        return _simulation.MuscleIterator_produceForces(self, state, forceConsumer)

    def get_appliesForce(self, *args):
        r"""
        get_appliesForce(MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_appliesForce(MuscleIterator self) -> bool const &
        """
        return _simulation.MuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.MuscleIterator__has_output_potential_energy_get, doc=r"""_has_output_potential_energy : bool""")

    def shouldBeParallelized(self):
        r"""
        Tell Simbody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.MuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s):
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.MuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s, applyForce):
        r""" %Set whether or not the Force is applied."""
        return _simulation.MuscleIterator_setAppliesForce(self, s, applyForce)

    def getForceIndex(self):
        r""" Return the index to the SimTK::Force in the underlying system."""
        return _simulation.MuscleIterator_getForceIndex(self)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.MuscleIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.MuscleIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.MuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.MuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.MuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.MuscleIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.MuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.MuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.MuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.MuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.MuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.MuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.MuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.MuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.MuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.MuscleIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.MuscleIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.MuscleIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.MuscleIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(MuscleIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.MuscleIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.MuscleIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.MuscleIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.MuscleIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.MuscleIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.MuscleIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.MuscleIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.MuscleIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(MuscleIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(MuscleIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.MuscleIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(MuscleIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(MuscleIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.MuscleIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.MuscleIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.MuscleIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.MuscleIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.MuscleIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.MuscleIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.MuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.MuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.MuscleIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.MuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.MuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.MuscleIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.MuscleIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.MuscleIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.MuscleIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.MuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.MuscleIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.MuscleIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.MuscleIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.MuscleIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.MuscleIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.MuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.MuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.MuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.MuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.MuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.MuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.MuscleIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.MuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.MuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.MuscleIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.MuscleIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.MuscleIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.MuscleIterator_toString(self)

# Register MuscleIterator in _simulation:
_simulation.MuscleIterator_swigregister(MuscleIterator)
class ModelComponentList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::ModelComponent const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.ModelComponentList_swiginit(self, _simulation.new_ModelComponentList(*args))
    __swig_destroy__ = _simulation.delete_ModelComponentList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.ModelComponentList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.ModelComponentList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.ModelComponentList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.ModelComponentList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.ModelComponentList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register ModelComponentList in _simulation:
_simulation.ModelComponentList_swigregister(ModelComponentList)
class ModelComponentIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.ModelComponentIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(ModelComponentIterator self, ModelComponentIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::ModelComponent const > const &

        """
        return _simulation.ModelComponentIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(ModelComponentIterator self, ModelComponentIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::ModelComponent const > const &

        """
        return _simulation.ModelComponentIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.ModelComponentIterator___ref__(self)

    def deref(self):
        r"""deref(ModelComponentIterator self) -> ModelComponent"""
        return _simulation.ModelComponentIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.ModelComponentIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.ModelComponentIterator_next(self)
    __swig_destroy__ = _simulation.delete_ModelComponentIterator

    def clone(self):
        r"""clone(ModelComponentIterator self) -> ModelComponent"""
        return _simulation.ModelComponentIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelComponentIterator self) -> std::string const &"""
        return _simulation.ModelComponentIterator_getConcreteClassName(self)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ModelComponentIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ModelComponentIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.ModelComponentIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.ModelComponentIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.ModelComponentIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.ModelComponentIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.ModelComponentIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.ModelComponentIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.ModelComponentIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.ModelComponentIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.ModelComponentIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.ModelComponentIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.ModelComponentIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.ModelComponentIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.ModelComponentIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.ModelComponentIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.ModelComponentIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.ModelComponentIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.ModelComponentIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(ModelComponentIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.ModelComponentIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.ModelComponentIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.ModelComponentIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.ModelComponentIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.ModelComponentIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.ModelComponentIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.ModelComponentIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.ModelComponentIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(ModelComponentIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(ModelComponentIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.ModelComponentIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(ModelComponentIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(ModelComponentIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.ModelComponentIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.ModelComponentIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.ModelComponentIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.ModelComponentIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.ModelComponentIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.ModelComponentIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.ModelComponentIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.ModelComponentIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.ModelComponentIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.ModelComponentIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.ModelComponentIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.ModelComponentIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.ModelComponentIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.ModelComponentIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.ModelComponentIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.ModelComponentIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.ModelComponentIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.ModelComponentIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.ModelComponentIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.ModelComponentIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.ModelComponentIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.ModelComponentIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.ModelComponentIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.ModelComponentIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.ModelComponentIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.ModelComponentIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.ModelComponentIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.ModelComponentIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.ModelComponentIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.ModelComponentIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.ModelComponentIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.ModelComponentIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.ModelComponentIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.ModelComponentIterator_toString(self)

# Register ModelComponentIterator in _simulation:
_simulation.ModelComponentIterator_swigregister(ModelComponentIterator)
class JointList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Joint const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.JointList_swiginit(self, _simulation.new_JointList(*args))
    __swig_destroy__ = _simulation.delete_JointList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.JointList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.JointList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.JointList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.JointList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.JointList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register JointList in _simulation:
_simulation.JointList_swigregister(JointList)
class JointIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.JointIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(JointIterator self, JointIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Joint const > const &

        """
        return _simulation.JointIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(JointIterator self, JointIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Joint const > const &

        """
        return _simulation.JointIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.JointIterator___ref__(self)

    def deref(self):
        r"""deref(JointIterator self) -> Joint"""
        return _simulation.JointIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.JointIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.JointIterator_next(self)
    __swig_destroy__ = _simulation.delete_JointIterator

    def clone(self):
        r"""clone(JointIterator self) -> Joint"""
        return _simulation.JointIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(JointIterator self) -> std::string const &"""
        return _simulation.JointIterator_getConcreteClassName(self)

    def get_coordinates(self, i):
        r"""
        get_coordinates(JointIterator self, int i) -> Coordinate

        Parameters
        ----------
        i: int

        """
        return _simulation.JointIterator_get_coordinates(self, i)

    def get_frames(self, i):
        r"""
        get_frames(JointIterator self, int i) -> PhysicalOffsetFrame

        Parameters
        ----------
        i: int

        """
        return _simulation.JointIterator_get_frames(self, i)
    PropertyIndex_socket_parent_frame = property(_simulation.JointIterator_PropertyIndex_socket_parent_frame_get, doc=r"""PropertyIndex_socket_parent_frame : OpenSim::PropertyIndex""")
    PropertyIndex_socket_child_frame = property(_simulation.JointIterator_PropertyIndex_socket_child_frame_get, doc=r"""PropertyIndex_socket_child_frame : OpenSim::PropertyIndex""")
    _has_output_power = property(_simulation.JointIterator__has_output_power_get, doc=r"""_has_output_power : bool""")
    _has_output_reaction_on_parent = property(_simulation.JointIterator__has_output_reaction_on_parent_get, doc=r"""_has_output_reaction_on_parent : bool""")
    _has_output_reaction_on_child = property(_simulation.JointIterator__has_output_reaction_on_child_get, doc=r"""_has_output_reaction_on_child : bool""")

    def getChildFrame(self):
        r"""
        Get the child joint frame.

        :rtype: :py:class:`PhysicalFrame`
        :return: const PhysicalFrame reference.
        """
        return _simulation.JointIterator_getChildFrame(self)

    def getParentFrame(self):
        r"""
        Get the parent frame to which this joint attaches.

        :rtype: :py:class:`PhysicalFrame`
        :return: const ref to parent PhysicalFrame.
        """
        return _simulation.JointIterator_getParentFrame(self)

    def getCoordinate(self):
        r"""
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.
        """
        return _simulation.JointIterator_getCoordinate(self)

    def numCoordinates(self):
        r"""numCoordinates(JointIterator self) -> int"""
        return _simulation.JointIterator_numCoordinates(self)

    def isCoordinateUsed(self, aCoordinate):
        r"""
        isCoordinateUsed(JointIterator self, Coordinate aCoordinate) -> bool

        Parameters
        ----------
        aCoordinate: OpenSim::Coordinate const &

        """
        return _simulation.JointIterator_isCoordinateUsed(self, aCoordinate)

    def calcEquivalentSpatialForce(self, state, mobilityForces):
        r"""
        Given some system mobility (generalized) forces, calculate the
           equivalent spatial body force for this Joint. Keep in mind that there are
           typically nm < 6 mobilities per joint with an infinite set of solutions that
           can map nm gen forces to 6 spatial force components (3 for torque + 3 for
           force). The solution returned provides the "most" effective force and torque
           in the joint frame. This means the smallest magnitude force and/or torque
           that will result in the same generalized force. If a generalized force is
           defined along/about a joint axis, then this should be evident in the
           reported results as a force or torque on the same axis.  NOTE: Joints
           comprised of multiple mobilizers and/or constraints, should override this
           method and account for multiple internal components.

           :type state: :py:class:`State`
           :param state: containing the generalized coordinate and speed values
           :type mobilityForces: :py:class:`Vector`
           :param mobilityForces: for the system as computed by inverse dynamics,
                                     for example
           :rtype: :py:class:`SpatialVec`
           :return: spatial force, FB_G, acting on the body connected by this joint at
               its location B, expressed in ground.
        """
        return _simulation.JointIterator_calcEquivalentSpatialForce(self, state, mobilityForces)

    def calcReactionOnParentExpressedInGround(self, state):
        r"""
        Joint Reaction forces  Calculate the joint reaction force and moment acting on the parent frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on parent frame, P,
                           and expressed in ground, G.
        """
        return _simulation.JointIterator_calcReactionOnParentExpressedInGround(self, state)

    def calcReactionOnChildExpressedInGround(self, state):
        r"""
        Calculate the joint reaction force and moment acting on the child frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on child frame, C,
                           and expressed in ground, G.
        """
        return _simulation.JointIterator_calcReactionOnChildExpressedInGround(self, state)

    def calcPower(self, s):
        r"""
        Joints in general do not contribute power since the reaction space
               forces are orthogonal to the mobility space. However, when joint motion
               is prescribed, the internal forces that move the joint will do work. In
               that case, the power is non-zero and the supplied SimTK::State
               must already have been realized to %Acceleration stage so that
               constraint forces are available.
        """
        return _simulation.JointIterator_calcPower(self, s)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.JointIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.JointIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.JointIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.JointIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.JointIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.JointIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.JointIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.JointIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.JointIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.JointIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.JointIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.JointIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.JointIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.JointIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.JointIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.JointIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.JointIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.JointIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.JointIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(JointIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.JointIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.JointIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.JointIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.JointIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.JointIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.JointIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.JointIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.JointIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(JointIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(JointIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.JointIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(JointIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(JointIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.JointIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.JointIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.JointIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.JointIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.JointIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.JointIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.JointIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.JointIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.JointIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.JointIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.JointIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.JointIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.JointIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.JointIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.JointIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.JointIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.JointIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.JointIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.JointIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.JointIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.JointIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.JointIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.JointIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.JointIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.JointIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.JointIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.JointIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.JointIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.JointIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.JointIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.JointIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.JointIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.JointIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.JointIterator_toString(self)

# Register JointIterator in _simulation:
_simulation.JointIterator_swigregister(JointIterator)
class ActuatorList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Actuator const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.ActuatorList_swiginit(self, _simulation.new_ActuatorList(*args))
    __swig_destroy__ = _simulation.delete_ActuatorList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.ActuatorList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.ActuatorList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.ActuatorList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.ActuatorList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.ActuatorList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register ActuatorList in _simulation:
_simulation.ActuatorList_swigregister(ActuatorList)
class ActuatorIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.ActuatorIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(ActuatorIterator self, ActuatorIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Actuator const > const &

        """
        return _simulation.ActuatorIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(ActuatorIterator self, ActuatorIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Actuator const > const &

        """
        return _simulation.ActuatorIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.ActuatorIterator___ref__(self)

    def deref(self):
        r"""deref(ActuatorIterator self) -> Actuator"""
        return _simulation.ActuatorIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.ActuatorIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.ActuatorIterator_next(self)
    __swig_destroy__ = _simulation.delete_ActuatorIterator

    def clone(self):
        r"""clone(ActuatorIterator self) -> Actuator"""
        return _simulation.ActuatorIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActuatorIterator self) -> std::string const &"""
        return _simulation.ActuatorIterator_getConcreteClassName(self)

    def numControls(self):
        r"""numControls(ActuatorIterator self) -> int"""
        return _simulation.ActuatorIterator_numControls(self)

    def getControls(self, modelControls, actuatorControls):
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.ActuatorIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls, modelControls):
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.ActuatorIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls, modelControls):
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.ActuatorIterator_addInControls(self, actuatorControls, modelControls)

    def getPower(self, s):
        r"""
        getPower(ActuatorIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.ActuatorIterator_getPower(self, s)

    def computeEquilibrium(self, s):
        r"""
        computeEquilibrium(ActuatorIterator self, State s)

        Parameters
        ----------
        s: SimTK::State &

        """
        return _simulation.ActuatorIterator_computeEquilibrium(self, s)

    def produceForces(self, state, forceConsumer):
        r"""
        Uses `implProduceForces` to produce (emit) forces evaluated from `state` into the
        provided `ForceConsumer`.

        Notes: this function only produces the forces and does not apply them to anything. It's
              up to the `ForceConsumer` implementation to handle the forces. Therefore,
              `Force::appliesForces` is ignored by this method.

        :type state: :py:class:`State`
        :param state:       the state used to evaluate forces
        :param consumer:    a `ForceConsumer` that shall receive each of the produced forces
        """
        return _simulation.ActuatorIterator_produceForces(self, state, forceConsumer)

    def computeForce(self, state, bodyForces, generalizedForces):
        r"""
        Inhereted from `OpenSim::Force`.

        `ForceProducer` overrides `OpenSim::Force::computeForce` with a default
        implementation that, provided `OpenSim::Force::appliesForces` is `true`,
        internally uses `produceForces` to mutate the provided `bodyForces` in a
        manner that's compatible with the `OpenSim::Force` API.
        """
        return _simulation.ActuatorIterator_computeForce(self, state, bodyForces, generalizedForces)

    def get_appliesForce(self, *args):
        r"""
        get_appliesForce(ActuatorIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_appliesForce(ActuatorIterator self) -> bool const &
        """
        return _simulation.ActuatorIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.ActuatorIterator__has_output_potential_energy_get, doc=r"""_has_output_potential_energy : bool""")

    def shouldBeParallelized(self):
        r"""
        Tell Simbody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.ActuatorIterator_shouldBeParallelized(self)

    def appliesForce(self, s):
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.ActuatorIterator_appliesForce(self, s)

    def setAppliesForce(self, s, applyForce):
        r""" %Set whether or not the Force is applied."""
        return _simulation.ActuatorIterator_setAppliesForce(self, s, applyForce)

    def getRecordLabels(self):
        r"""
        Methods to query a Force for the value actually applied during
        simulation. The names of the quantities (column labels) is returned by
        this first function getRecordLabels().
        """
        return _simulation.ActuatorIterator_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.ActuatorIterator_getRecordValues(self, state)

    def hasVisualPath(self):
        r"""
         Return a flag indicating whether the Force is applied along a path that
        can be visualized. If you override this method to return true for a
        specific subclass, it must also implement the getPath() method.
        """
        return _simulation.ActuatorIterator_hasVisualPath(self)

    def getForceIndex(self):
        r""" Return the index to the SimTK::Force in the underlying system."""
        return _simulation.ActuatorIterator_getForceIndex(self)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ActuatorIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ActuatorIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.ActuatorIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.ActuatorIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.ActuatorIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.ActuatorIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.ActuatorIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.ActuatorIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.ActuatorIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.ActuatorIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.ActuatorIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.ActuatorIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.ActuatorIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.ActuatorIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.ActuatorIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.ActuatorIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.ActuatorIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.ActuatorIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.ActuatorIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(ActuatorIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.ActuatorIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.ActuatorIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.ActuatorIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.ActuatorIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.ActuatorIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.ActuatorIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.ActuatorIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.ActuatorIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(ActuatorIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(ActuatorIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.ActuatorIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(ActuatorIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(ActuatorIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.ActuatorIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.ActuatorIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.ActuatorIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.ActuatorIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.ActuatorIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.ActuatorIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.ActuatorIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.ActuatorIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.ActuatorIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.ActuatorIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.ActuatorIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.ActuatorIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.ActuatorIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.ActuatorIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.ActuatorIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.ActuatorIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.ActuatorIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.ActuatorIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.ActuatorIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.ActuatorIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.ActuatorIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.ActuatorIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.ActuatorIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.ActuatorIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.ActuatorIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.ActuatorIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.ActuatorIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.ActuatorIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.ActuatorIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.ActuatorIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.ActuatorIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.ActuatorIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.ActuatorIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.ActuatorIterator_toString(self)

# Register ActuatorIterator in _simulation:
_simulation.ActuatorIterator_swigregister(ActuatorIterator)
class Thelen2003MuscleList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Thelen2003Muscle const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.Thelen2003MuscleList_swiginit(self, _simulation.new_Thelen2003MuscleList(*args))
    __swig_destroy__ = _simulation.delete_Thelen2003MuscleList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.Thelen2003MuscleList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.Thelen2003MuscleList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.Thelen2003MuscleList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.Thelen2003MuscleList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.Thelen2003MuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register Thelen2003MuscleList in _simulation:
_simulation.Thelen2003MuscleList_swigregister(Thelen2003MuscleList)
class Thelen2003MuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.Thelen2003MuscleIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(Thelen2003MuscleIterator self, Thelen2003MuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Thelen2003Muscle const > const &

        """
        return _simulation.Thelen2003MuscleIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(Thelen2003MuscleIterator self, Thelen2003MuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Thelen2003Muscle const > const &

        """
        return _simulation.Thelen2003MuscleIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.Thelen2003MuscleIterator___ref__(self)

    def deref(self):
        r"""deref(Thelen2003MuscleIterator self) -> Thelen2003Muscle"""
        return _simulation.Thelen2003MuscleIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.Thelen2003MuscleIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.Thelen2003MuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_Thelen2003MuscleIterator

    def clone(self):
        r"""clone(Thelen2003MuscleIterator self) -> Thelen2003Muscle"""
        return _simulation.Thelen2003MuscleIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Thelen2003MuscleIterator self) -> std::string const &"""
        return _simulation.Thelen2003MuscleIterator_getConcreteClassName(self)

    def get_FmaxTendonStrain(self, *args):
        r"""
        get_FmaxTendonStrain(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_FmaxTendonStrain(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_FmaxTendonStrain(self, *args)

    def get_FmaxMuscleStrain(self, *args):
        r"""
        get_FmaxMuscleStrain(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_FmaxMuscleStrain(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_FmaxMuscleStrain(self, *args)

    def get_KshapeActive(self, *args):
        r"""
        get_KshapeActive(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_KshapeActive(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_KshapeActive(self, *args)

    def get_KshapePassive(self, *args):
        r"""
        get_KshapePassive(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_KshapePassive(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_KshapePassive(self, *args)

    def get_Af(self, *args):
        r"""
        get_Af(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_Af(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_Af(self, *args)

    def get_Flen(self, *args):
        r"""
        get_Flen(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_Flen(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_Flen(self, *args)

    def get_fv_linear_extrap_threshold(self, *args):
        r"""
        get_fv_linear_extrap_threshold(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fv_linear_extrap_threshold(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_fv_linear_extrap_threshold(self, *args)

    def get_maximum_pennation_angle(self, *args):
        r"""
        get_maximum_pennation_angle(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maximum_pennation_angle(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_maximum_pennation_angle(self, *args)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_activation_time_constant(self, *args)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_deactivation_time_constant(self, *args)

    def get_minimum_activation(self, *args):
        r"""
        get_minimum_activation(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_activation(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_minimum_activation(self, *args)

    def getActivationTimeConstant(self):
        r"""*"""
        return _simulation.Thelen2003MuscleIterator_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self):
        r"""getDeactivationTimeConstant(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getDeactivationTimeConstant(self)

    def getMinimumActivation(self):
        r"""getMinimumActivation(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getMinimumActivation(self)

    def getMaximumPennationAngle(self):
        r"""getMaximumPennationAngle(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getMaximumPennationAngle(self)

    def getMinimumFiberLength(self):
        r"""
        *
             :rtype: float
             :return: the minimum fiber length, which is the maximum of two values:
                    the smallest fiber length allowed by the pennation model, and the
                    minimum fiber length in the active force length curve. When the fiber
                    length reaches this value, it is constrained to this value until the
                    fiber velocity goes positive.
        """
        return _simulation.Thelen2003MuscleIterator_getMinimumFiberLength(self)

    def getActivationModel(self):
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003MuscleIterator_getActivationModel(self)

    def getPennationModel(self):
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003MuscleIterator_getPennationModel(self)

    def printCurveToCSVFile(self, ctype, path):
        r"""
        printCurveToCSVFile(Thelen2003MuscleIterator self, OpenSim::Thelen2003Muscle::CurveType const ctype, std::string const & path)

        Parameters
        ----------
        ctype: enum OpenSim::Thelen2003Muscle::CurveType const
        path: std::string const &

        """
        return _simulation.Thelen2003MuscleIterator_printCurveToCSVFile(self, ctype, path)

    def computeActuation(self, s):
        r"""
        computeActuation(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        Compute initial fiber length (velocity) such that muscle fiber and
               tendon are in static equilibrium and update the state

               Part of the Muscle.h interface

               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Thelen2003MuscleIterator_computeInitialFiberEquilibrium(self, s)

    def calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity):
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Thelen2003MuscleIterator_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""
        calcInextensibleTendonActiveFiberForce(Thelen2003MuscleIterator self, State s, double aActivation) -> double

        Parameters
        ----------
        s: SimTK::State &
        aActivation: double

        """
        return _simulation.Thelen2003MuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_default_activation(self, *args)

    def get_default_fiber_length(self, *args):
        r"""
        get_default_fiber_length(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_length(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_default_fiber_length(self, *args)

    def getDefaultActivation(self):
        r"""getDefaultActivation(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getDefaultActivation(self)

    def getDefaultFiberLength(self):
        r"""getDefaultFiberLength(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getDefaultFiberLength(self)

    def setActivation(self, s, activation):
        r"""
        setActivation(Thelen2003MuscleIterator self, State s, double activation)

        Parameters
        ----------
        s: SimTK::State &
        activation: double

        """
        return _simulation.Thelen2003MuscleIterator_setActivation(self, s, activation)

    def setFiberLength(self, s, fiberLength):
        r"""
        setFiberLength(Thelen2003MuscleIterator self, State s, double fiberLength)

        Parameters
        ----------
        s: SimTK::State &
        fiberLength: double

        """
        return _simulation.Thelen2003MuscleIterator_setFiberLength(self, s, fiberLength)

    def getActivationRate(self, s):
        r"""
        getActivationRate(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getActivationRate(self, s)

    def get_max_isometric_force(self, *args):
        r"""
        get_max_isometric_force(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_isometric_force(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args):
        r"""
        get_optimal_fiber_length(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_fiber_length(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args):
        r"""
        get_tendon_slack_length(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_slack_length(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args):
        r"""
        get_pennation_angle_at_optimal(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pennation_angle_at_optimal(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args):
        r"""
        get_max_contraction_velocity(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_contraction_velocity(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args):
        r"""
        get_ignore_tendon_compliance(Thelen2003MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_tendon_compliance(Thelen2003MuscleIterator self) -> bool const &
        """
        return _simulation.Thelen2003MuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args):
        r"""
        get_ignore_activation_dynamics(Thelen2003MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_activation_dynamics(Thelen2003MuscleIterator self) -> bool const &
        """
        return _simulation.Thelen2003MuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Thelen2003MuscleIterator__has_output_excitation_get, doc=r"""_has_output_excitation : bool""")
    _has_output_activation = property(_simulation.Thelen2003MuscleIterator__has_output_activation_get, doc=r"""_has_output_activation : bool""")
    _has_output_fiber_length = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_length_get, doc=r"""_has_output_fiber_length : bool""")
    _has_output_pennation_angle = property(_simulation.Thelen2003MuscleIterator__has_output_pennation_angle_get, doc=r"""_has_output_pennation_angle : bool""")
    _has_output_cos_pennation_angle = property(_simulation.Thelen2003MuscleIterator__has_output_cos_pennation_angle_get, doc=r"""_has_output_cos_pennation_angle : bool""")
    _has_output_tendon_length = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_length_get, doc=r"""_has_output_tendon_length : bool""")
    _has_output_normalized_fiber_length = property(_simulation.Thelen2003MuscleIterator__has_output_normalized_fiber_length_get, doc=r"""_has_output_normalized_fiber_length : bool""")
    _has_output_fiber_length_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_length_along_tendon_get, doc=r"""_has_output_fiber_length_along_tendon : bool""")
    _has_output_tendon_strain = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_strain_get, doc=r"""_has_output_tendon_strain : bool""")
    _has_output_passive_force_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_passive_force_multiplier_get, doc=r"""_has_output_passive_force_multiplier : bool""")
    _has_output_active_force_length_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_active_force_length_multiplier_get, doc=r"""_has_output_active_force_length_multiplier : bool""")
    _has_output_fiber_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_velocity_get, doc=r"""_has_output_fiber_velocity : bool""")
    _has_output_normalized_fiber_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_normalized_fiber_velocity_get, doc=r"""_has_output_normalized_fiber_velocity : bool""")
    _has_output_fiber_velocity_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_velocity_along_tendon_get, doc=r"""_has_output_fiber_velocity_along_tendon : bool""")
    _has_output_tendon_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_velocity_get, doc=r"""_has_output_tendon_velocity : bool""")
    _has_output_force_velocity_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_force_velocity_multiplier_get, doc=r"""_has_output_force_velocity_multiplier : bool""")
    _has_output_pennation_angular_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_pennation_angular_velocity_get, doc=r"""_has_output_pennation_angular_velocity : bool""")
    _has_output_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_force_get, doc=r"""_has_output_fiber_force : bool""")
    _has_output_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_force_along_tendon_get, doc=r"""_has_output_fiber_force_along_tendon : bool""")
    _has_output_active_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_active_fiber_force_get, doc=r"""_has_output_active_fiber_force : bool""")
    _has_output_passive_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_passive_fiber_force_get, doc=r"""_has_output_passive_fiber_force : bool""")
    _has_output_active_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_active_fiber_force_along_tendon_get, doc=r"""_has_output_active_fiber_force_along_tendon : bool""")
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_passive_fiber_force_along_tendon_get, doc=r"""_has_output_passive_fiber_force_along_tendon : bool""")
    _has_output_tendon_force = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_force_get, doc=r"""_has_output_tendon_force : bool""")
    _has_output_fiber_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_stiffness_get, doc=r"""_has_output_fiber_stiffness : bool""")
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_stiffness_along_tendon_get, doc=r"""_has_output_fiber_stiffness_along_tendon : bool""")
    _has_output_tendon_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_stiffness_get, doc=r"""_has_output_tendon_stiffness : bool""")
    _has_output_muscle_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_muscle_stiffness_get, doc=r"""_has_output_muscle_stiffness : bool""")
    _has_output_fiber_active_power = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_active_power_get, doc=r"""_has_output_fiber_active_power : bool""")
    _has_output_fiber_passive_power = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_passive_power_get, doc=r"""_has_output_fiber_passive_power : bool""")
    _has_output_tendon_power = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_power_get, doc=r"""_has_output_tendon_power : bool""")
    _has_output_muscle_power = property(_simulation.Thelen2003MuscleIterator__has_output_muscle_power_get, doc=r"""_has_output_muscle_power : bool""")

    def getMaxIsometricForce(self):
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Thelen2003MuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self):
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Thelen2003MuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self):
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Thelen2003MuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self):
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self):
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Thelen2003MuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Thelen2003MuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s, ignore):
        r"""
        setIgnoreTendonCompliance(Thelen2003MuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Thelen2003MuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Thelen2003MuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s, ignore):
        r"""
        setIgnoreActivationDynamics(Thelen2003MuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Thelen2003MuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s):
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Thelen2003MuscleIterator_getActivation(self, s)

    def getFiberLength(self, s):
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Thelen2003MuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s):
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s):
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s):
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Thelen2003MuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s):
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Thelen2003MuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s):
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s):
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Thelen2003MuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Thelen2003MuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Thelen2003MuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s):
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Thelen2003MuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s):
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Thelen2003MuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s):
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s):
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.Thelen2003MuscleIterator_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s):
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Thelen2003MuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s):
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s):
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s):
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Thelen2003MuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s):
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Thelen2003MuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s):
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Thelen2003MuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s):
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Thelen2003MuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s):
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Thelen2003MuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s):
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Thelen2003MuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s):
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s):
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Thelen2003MuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s):
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Thelen2003MuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s):
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Thelen2003MuscleIterator_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.Thelen2003MuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s):
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Thelen2003MuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s):
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Thelen2003MuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s):
        r""" get the current active fiber power (W)"""
        return _simulation.Thelen2003MuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s):
        r""" get the current passive fiber power (W)"""
        return _simulation.Thelen2003MuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s):
        r""" get the current tendon power (W)"""
        return _simulation.Thelen2003MuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s):
        r""" get the current muscle power (W)"""
        return _simulation.Thelen2003MuscleIterator_getMusclePower(self, s)

    def getStress(self, s):
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Thelen2003MuscleIterator_getStress(self, s)

    def setExcitation(self, s, excitation):
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Thelen2003MuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s):
        r"""
        getExcitation(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getExcitation(self, s)

    def computeEquilibrium(self, s):
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Thelen2003MuscleIterator_computeEquilibrium(self, s)

    def get_path(self, *args):
        r"""
        get_path(Thelen2003MuscleIterator self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(Thelen2003MuscleIterator self) -> AbstractGeometryPath
        """
        return _simulation.Thelen2003MuscleIterator_get_path(self, *args)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.Thelen2003MuscleIterator__has_output_tension_get, doc=r"""_has_output_tension : bool""")

    def getPath(self):
        r"""getPath(Thelen2003MuscleIterator self) -> AbstractGeometryPath"""
        return _simulation.Thelen2003MuscleIterator_getPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(Thelen2003MuscleIterator self) -> GeometryPath"""
        return _simulation.Thelen2003MuscleIterator_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(Thelen2003MuscleIterator self) -> bool"""
        return _simulation.Thelen2003MuscleIterator_hasVisualPath(self)

    def getOptimalForce(self):
        r"""getOptimalForce(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getOptimalForce(self)

    def getLength(self, s):
        r"""
        getLength(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getLengtheningSpeed(self, s)

    def getSpeed(self, s):
        r"""
        getSpeed(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getSpeed(self, s)

    def getPower(self, s):
        r"""
        getPower(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getPower(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(Thelen2003MuscleIterator self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.Thelen2003MuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args):
        r"""
        get_min_control(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_min_control(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args):
        r"""
        get_max_control(Thelen2003MuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_control(Thelen2003MuscleIterator self) -> double const &
        """
        return _simulation.Thelen2003MuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.Thelen2003MuscleIterator__has_output_actuation_get, doc=r"""_has_output_actuation : bool""")
    _has_output_speed = property(_simulation.Thelen2003MuscleIterator__has_output_speed_get, doc=r"""_has_output_speed : bool""")

    def getControl(self, s):
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.Thelen2003MuscleIterator_getControl(self, s)

    def numControls(self):
        r"""numControls(Thelen2003MuscleIterator self) -> int"""
        return _simulation.Thelen2003MuscleIterator_numControls(self)

    def setActuation(self, s, aActuation):
        r"""
        setActuation(Thelen2003MuscleIterator self, State s, double aActuation)

        Parameters
        ----------
        s: SimTK::State const &
        aActuation: double

        """
        return _simulation.Thelen2003MuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s):
        r"""
        getActuation(Thelen2003MuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003MuscleIterator_getActuation(self, s)

    def getMinControl(self):
        r"""getMinControl(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getMinControl(self)

    def getMaxControl(self):
        r"""getMaxControl(Thelen2003MuscleIterator self) -> double"""
        return _simulation.Thelen2003MuscleIterator_getMaxControl(self)

    def overrideActuation(self, s, flag):
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.Thelen2003MuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s):
        r""" return ScalarActuator's override status"""
        return _simulation.Thelen2003MuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s, value):
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.Thelen2003MuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s):
        r"""return override actuation"""
        return _simulation.Thelen2003MuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls, actuatorControls):
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Thelen2003MuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls, modelControls):
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Thelen2003MuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls, modelControls):
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Thelen2003MuscleIterator_addInControls(self, actuatorControls, modelControls)

    def produceForces(self, state, forceConsumer):
        r"""
        Uses `implProduceForces` to produce (emit) forces evaluated from `state` into the
        provided `ForceConsumer`.

        Notes: this function only produces the forces and does not apply them to anything. It's
              up to the `ForceConsumer` implementation to handle the forces. Therefore,
              `Force::appliesForces` is ignored by this method.

        :type state: :py:class:`State`
        :param state:       the state used to evaluate forces
        :param consumer:    a `ForceConsumer` that shall receive each of the produced forces
        """
        return _simulation.Thelen2003MuscleIterator_produceForces(self, state, forceConsumer)

    def get_appliesForce(self, *args):
        r"""
        get_appliesForce(Thelen2003MuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_appliesForce(Thelen2003MuscleIterator self) -> bool const &
        """
        return _simulation.Thelen2003MuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Thelen2003MuscleIterator__has_output_potential_energy_get, doc=r"""_has_output_potential_energy : bool""")

    def shouldBeParallelized(self):
        r"""
        Tell Simbody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Thelen2003MuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s):
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Thelen2003MuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s, applyForce):
        r""" %Set whether or not the Force is applied."""
        return _simulation.Thelen2003MuscleIterator_setAppliesForce(self, s, applyForce)

    def getForceIndex(self):
        r""" Return the index to the SimTK::Force in the underlying system."""
        return _simulation.Thelen2003MuscleIterator_getForceIndex(self)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.Thelen2003MuscleIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.Thelen2003MuscleIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.Thelen2003MuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.Thelen2003MuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.Thelen2003MuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.Thelen2003MuscleIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.Thelen2003MuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.Thelen2003MuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.Thelen2003MuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.Thelen2003MuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.Thelen2003MuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.Thelen2003MuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.Thelen2003MuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.Thelen2003MuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.Thelen2003MuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.Thelen2003MuscleIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.Thelen2003MuscleIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.Thelen2003MuscleIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.Thelen2003MuscleIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(Thelen2003MuscleIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.Thelen2003MuscleIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.Thelen2003MuscleIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.Thelen2003MuscleIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.Thelen2003MuscleIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.Thelen2003MuscleIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.Thelen2003MuscleIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.Thelen2003MuscleIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.Thelen2003MuscleIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(Thelen2003MuscleIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(Thelen2003MuscleIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.Thelen2003MuscleIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(Thelen2003MuscleIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(Thelen2003MuscleIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.Thelen2003MuscleIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.Thelen2003MuscleIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.Thelen2003MuscleIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.Thelen2003MuscleIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.Thelen2003MuscleIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.Thelen2003MuscleIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.Thelen2003MuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.Thelen2003MuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.Thelen2003MuscleIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.Thelen2003MuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.Thelen2003MuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.Thelen2003MuscleIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.Thelen2003MuscleIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.Thelen2003MuscleIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.Thelen2003MuscleIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.Thelen2003MuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.Thelen2003MuscleIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.Thelen2003MuscleIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.Thelen2003MuscleIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.Thelen2003MuscleIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.Thelen2003MuscleIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.Thelen2003MuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.Thelen2003MuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.Thelen2003MuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.Thelen2003MuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.Thelen2003MuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.Thelen2003MuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.Thelen2003MuscleIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.Thelen2003MuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.Thelen2003MuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.Thelen2003MuscleIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.Thelen2003MuscleIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.Thelen2003MuscleIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.Thelen2003MuscleIterator_toString(self)

# Register Thelen2003MuscleIterator in _simulation:
_simulation.Thelen2003MuscleIterator_swigregister(Thelen2003MuscleIterator)
class Millard2012EquilibriumMuscleList(object):
    r"""Proxy of C++ OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). You can change the filter using setFilter() method.
        """
        _simulation.Millard2012EquilibriumMuscleList_swiginit(self, _simulation.new_Millard2012EquilibriumMuscleList(*args))
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscleList

    def begin(self, *args):
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.Millard2012EquilibriumMuscleList_begin(self, *args)

    def cbegin(self):
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.Millard2012EquilibriumMuscleList_cbegin(self)

    def end(self, *args):
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.Millard2012EquilibriumMuscleList_end(self, *args)

    def cend(self):
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.Millard2012EquilibriumMuscleList_cend(self)

    def setFilter(self, filter):
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.Millard2012EquilibriumMuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register Millard2012EquilibriumMuscleList in _simulation:
_simulation.Millard2012EquilibriumMuscleList_swigregister(Millard2012EquilibriumMuscleList)
class Millard2012EquilibriumMuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other):
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_equals(self, other)

    def __eq__(self, other):
        r"""
        __eq__(Millard2012EquilibriumMuscleIterator self, Millard2012EquilibriumMuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Millard2012EquilibriumMuscle const > const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(Millard2012EquilibriumMuscleIterator self, Millard2012EquilibriumMuscleIterator other) -> bool

        Parameters
        ----------
        other: OpenSim::ComponentListIterator< OpenSim::Millard2012EquilibriumMuscle const > const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator___ne__(self, other)

    def __ref__(self):
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator___ref__(self)

    def deref(self):
        r"""deref(Millard2012EquilibriumMuscleIterator self) -> Millard2012EquilibriumMuscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_deref(self)

    def __deref__(self):
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.Millard2012EquilibriumMuscleIterator___deref__(self)

    def next(self):
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscleIterator

    def clone(self):
        r"""clone(Millard2012EquilibriumMuscleIterator self) -> Millard2012EquilibriumMuscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Millard2012EquilibriumMuscleIterator self) -> std::string const &"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getConcreteClassName(self)

    def get_fiber_damping(self, *args):
        r"""
        get_fiber_damping(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_damping(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_fiber_damping(self, *args)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_default_activation(self, *args)

    def get_default_fiber_length(self, *args):
        r"""
        get_default_fiber_length(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_length(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_default_fiber_length(self, *args)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_activation_time_constant(self, *args)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_deactivation_time_constant(self, *args)

    def get_minimum_activation(self, *args):
        r"""
        get_minimum_activation(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_activation(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_minimum_activation(self, *args)

    def get_maximum_pennation_angle(self, *args):
        r"""
        get_maximum_pennation_angle(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maximum_pennation_angle(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_maximum_pennation_angle(self, *args)

    def get_ActiveForceLengthCurve(self, *args):
        r"""
        get_ActiveForceLengthCurve(Millard2012EquilibriumMuscleIterator self, int i) -> ActiveForceLengthCurve

        Parameters
        ----------
        i: int

        get_ActiveForceLengthCurve(Millard2012EquilibriumMuscleIterator self) -> ActiveForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ActiveForceLengthCurve(self, *args)

    def get_ForceVelocityCurve(self, *args):
        r"""
        get_ForceVelocityCurve(Millard2012EquilibriumMuscleIterator self, int i) -> ForceVelocityCurve

        Parameters
        ----------
        i: int

        get_ForceVelocityCurve(Millard2012EquilibriumMuscleIterator self) -> ForceVelocityCurve
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ForceVelocityCurve(self, *args)

    def get_FiberForceLengthCurve(self, *args):
        r"""
        get_FiberForceLengthCurve(Millard2012EquilibriumMuscleIterator self, int i) -> FiberForceLengthCurve

        Parameters
        ----------
        i: int

        get_FiberForceLengthCurve(Millard2012EquilibriumMuscleIterator self) -> FiberForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_FiberForceLengthCurve(self, *args)

    def get_TendonForceLengthCurve(self, *args):
        r"""
        get_TendonForceLengthCurve(Millard2012EquilibriumMuscleIterator self, int i) -> TendonForceLengthCurve

        Parameters
        ----------
        i: int

        get_TendonForceLengthCurve(Millard2012EquilibriumMuscleIterator self) -> TendonForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_TendonForceLengthCurve(self, *args)
    _has_output_passive_fiber_elastic_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_get, doc=r"""_has_output_passive_fiber_elastic_force : bool""")
    _has_output_passive_fiber_elastic_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_along_tendon_get, doc=r"""_has_output_passive_fiber_elastic_force_along_tendon : bool""")
    _has_output_passive_fiber_damping_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_get, doc=r"""_has_output_passive_fiber_damping_force : bool""")
    _has_output_passive_fiber_damping_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_along_tendon_get, doc=r"""_has_output_passive_fiber_damping_force_along_tendon : bool""")

    def getUseFiberDamping(self):
        r"""
        :rtype: boolean
        :return: A boolean indicating whether fiber damping is being used.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getUseFiberDamping(self)

    def getFiberDamping(self):
        r"""
        :rtype: float
        :return: The fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberDamping(self)

    def getDefaultActivation(self):
        r"""
        :rtype: float
        :return: The default activation level that is used as an initial
               condition if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDefaultActivation(self)

    def getDefaultFiberLength(self):
        r"""
        :rtype: float
        :return: The default fiber length that is used as an initial condition
               if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDefaultFiberLength(self)

    def getActivationTimeConstant(self):
        r"""
        :rtype: float
        :return: The activation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self):
        r"""
        :rtype: float
        :return: The deactivation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDeactivationTimeConstant(self)

    def getMinimumActivation(self):
        r"""
        :rtype: float
        :return: The minimum activation level permitted by the muscle model.
               Note that this equilibrium model, like all equilibrium models, has a
               singularity when activation approaches 0, which means that a non-zero lower
               bound is required.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumActivation(self)

    def getActiveForceLengthCurve(self):
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: The ActiveForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self):
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: The ForceVelocityCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self):
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: The FiberForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self):
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: The TendonForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForceLengthCurve(self)

    def getPennationModel(self):
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: The MuscleFixedWidthPennationModel owned by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationModel(self)

    def getActivationModel(self):
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: The MuscleFirstOrderActivationDynamicModel owned by this
               model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationModel(self)

    def getMinimumFiberLength(self):
        r"""
        :rtype: float
        :return: The minimum fiber length, which is the maximum of two values:
               the smallest fiber length allowed by the pennation model, and the minimum
               fiber length on the active-force-length curve. When the fiber reaches this
               length, it is constrained to this value until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self):
        r"""
        :rtype: float
        :return: The minimum fiber length along the tendon, which is the maximum
               of two values: the smallest fiber length along the tendon permitted by the
               pennation model, and the minimum fiber length along the tendon on the
               active-force-length curve. When the fiber length reaches this value, it is
               constrained to this length along the tendon until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumFiberLengthAlongTendon(self)

    def getTendonForceMultiplier(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :rtype: float
               :return: The normalized force term associated with the tendon element,
               :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForceMultiplier(self, s)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        :rtype: float
        :return: The stiffness of the muscle fibers along the tendon (N/m).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getFiberVelocity(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The velocity of the fiber (m/s).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberVelocity(self, s)

    def getActivationDerivative(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The time derivative of activation.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationDerivative(self, s)

    def getPassiveFiberElasticForce(self, s):
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s):
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s):
        r"""
        get the portion of the passive fiber force generated by the damping
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s):
        r"""
        get the portion of the passive fiber force generated by the damping
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForceAlongTendon(self, s)

    def setActivation(self, s, activation):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :type activation: float
               :param activation: The desired activation level.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setActivation(self, s, activation)

    def setFiberLength(self, s, fiberLength):
        r"""
        :type s: :py:class:`State`, out
        :param s: The state of the system.
               :type fiberLength: float
               :param fiberLength: The desired fiber length (m).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setFiberLength(self, s, fiberLength)

    def computeActuation(self, s):
        r"""
        :type s: :py:class:`State`, in
        :param s: The state of the system.
               :rtype: float
               :return: The tensile force the muscle is generating (N).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        Computes the fiber length such that the fiber and tendon are developing
           the same force, distributing the velocity of the entire musculotendon
           actuator between the fiber and tendon according to their relative
           stiffnesses.
               :type s: :py:class:`State`, in/out
               :param s: The state of the system.
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeInitialFiberEquilibrium(self, s)

    def computeFiberEquilibrium(self, s, solveForVelocity=False):
        r"""
        Computes the fiber length such that the fiber and tendon are developing
               the same force, either assuming muscle-tendon velocity as provided
               by the state or zero as designated by the useZeroVelocity flag.
               :type s: :py:class:`State`, in/out
               :param s:         The state of the system.
               :type solveForVelocity: boolean, optional
               :param solveForVelocity:  Flag indicating to solve for fiber velocity,
                                            which by default is false (zero fiber-velocity)
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeFiberEquilibrium(self, s, solveForVelocity)

    def calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity):
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Millard2012EquilibriumMuscleIterator_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT):
        r"""
        calcFiberStateGivenBoundaryCond(Millard2012EquilibriumMuscleIterator self, double lengthMT, double velocityMT, double tendonForce, double dTendonForceDT) -> Vec4

        Parameters
        ----------
        lengthMT: double
        velocityMT: double
        tendonForce: double
        dTendonForceDT: double

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""
        calcInextensibleTendonActiveFiberForce(Millard2012EquilibriumMuscleIterator self, State s, double aActivation) -> double

        Parameters
        ----------
        s: SimTK::State &
        aActivation: double

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_max_isometric_force(self, *args):
        r"""
        get_max_isometric_force(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_isometric_force(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args):
        r"""
        get_optimal_fiber_length(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_fiber_length(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args):
        r"""
        get_tendon_slack_length(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_slack_length(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args):
        r"""
        get_pennation_angle_at_optimal(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pennation_angle_at_optimal(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args):
        r"""
        get_max_contraction_velocity(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_contraction_velocity(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args):
        r"""
        get_ignore_tendon_compliance(Millard2012EquilibriumMuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_tendon_compliance(Millard2012EquilibriumMuscleIterator self) -> bool const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args):
        r"""
        get_ignore_activation_dynamics(Millard2012EquilibriumMuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_activation_dynamics(Millard2012EquilibriumMuscleIterator self) -> bool const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_excitation_get, doc=r"""_has_output_excitation : bool""")
    _has_output_activation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_activation_get, doc=r"""_has_output_activation : bool""")
    _has_output_fiber_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_get, doc=r"""_has_output_fiber_length : bool""")
    _has_output_pennation_angle = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_pennation_angle_get, doc=r"""_has_output_pennation_angle : bool""")
    _has_output_cos_pennation_angle = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_cos_pennation_angle_get, doc=r"""_has_output_cos_pennation_angle : bool""")
    _has_output_tendon_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_length_get, doc=r"""_has_output_tendon_length : bool""")
    _has_output_normalized_fiber_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_length_get, doc=r"""_has_output_normalized_fiber_length : bool""")
    _has_output_fiber_length_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_along_tendon_get, doc=r"""_has_output_fiber_length_along_tendon : bool""")
    _has_output_tendon_strain = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_strain_get, doc=r"""_has_output_tendon_strain : bool""")
    _has_output_passive_force_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_force_multiplier_get, doc=r"""_has_output_passive_force_multiplier : bool""")
    _has_output_active_force_length_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_force_length_multiplier_get, doc=r"""_has_output_active_force_length_multiplier : bool""")
    _has_output_fiber_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_get, doc=r"""_has_output_fiber_velocity : bool""")
    _has_output_normalized_fiber_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_velocity_get, doc=r"""_has_output_normalized_fiber_velocity : bool""")
    _has_output_fiber_velocity_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_along_tendon_get, doc=r"""_has_output_fiber_velocity_along_tendon : bool""")
    _has_output_tendon_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_velocity_get, doc=r"""_has_output_tendon_velocity : bool""")
    _has_output_force_velocity_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_force_velocity_multiplier_get, doc=r"""_has_output_force_velocity_multiplier : bool""")
    _has_output_pennation_angular_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_pennation_angular_velocity_get, doc=r"""_has_output_pennation_angular_velocity : bool""")
    _has_output_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_get, doc=r"""_has_output_fiber_force : bool""")
    _has_output_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_along_tendon_get, doc=r"""_has_output_fiber_force_along_tendon : bool""")
    _has_output_active_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_get, doc=r"""_has_output_active_fiber_force : bool""")
    _has_output_passive_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_get, doc=r"""_has_output_passive_fiber_force : bool""")
    _has_output_active_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_along_tendon_get, doc=r"""_has_output_active_fiber_force_along_tendon : bool""")
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_along_tendon_get, doc=r"""_has_output_passive_fiber_force_along_tendon : bool""")
    _has_output_tendon_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_force_get, doc=r"""_has_output_tendon_force : bool""")
    _has_output_fiber_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_get, doc=r"""_has_output_fiber_stiffness : bool""")
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_along_tendon_get, doc=r"""_has_output_fiber_stiffness_along_tendon : bool""")
    _has_output_tendon_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_stiffness_get, doc=r"""_has_output_tendon_stiffness : bool""")
    _has_output_muscle_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_muscle_stiffness_get, doc=r"""_has_output_muscle_stiffness : bool""")
    _has_output_fiber_active_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_active_power_get, doc=r"""_has_output_fiber_active_power : bool""")
    _has_output_fiber_passive_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_passive_power_get, doc=r"""_has_output_fiber_passive_power : bool""")
    _has_output_tendon_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_power_get, doc=r"""_has_output_tendon_power : bool""")
    _has_output_muscle_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_muscle_power_get, doc=r"""_has_output_muscle_power : bool""")

    def getMaxIsometricForce(self):
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self):
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self):
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self):
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self):
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s, ignore):
        r"""
        setIgnoreTendonCompliance(Millard2012EquilibriumMuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s):
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s, ignore):
        r"""
        setIgnoreActivationDynamics(Millard2012EquilibriumMuscleIterator self, State s, bool ignore)

        Parameters
        ----------
        s: SimTK::State &
        ignore: bool

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s):
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivation(self, s)

    def getFiberLength(self, s):
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s):
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s):
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s):
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s):
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s):
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s):
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s):
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s):
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s):
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s):
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getNormalizedFiberVelocity(self, s):
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s):
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s):
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s):
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s):
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s):
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s):
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s):
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s):
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s):
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s):
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s):
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s):
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberStiffness(self, s)

    def getTendonStiffness(self, s):
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s):
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s):
        r""" get the current active fiber power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s):
        r""" get the current passive fiber power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s):
        r""" get the current tendon power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s):
        r""" get the current muscle power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMusclePower(self, s)

    def getStress(self, s):
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getStress(self, s)

    def setExcitation(self, s, excitation):
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s):
        r"""
        getExcitation(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getExcitation(self, s)

    def computeEquilibrium(self, s):
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_computeEquilibrium(self, s)

    def get_path(self, *args):
        r"""
        get_path(Millard2012EquilibriumMuscleIterator self, int i) -> AbstractGeometryPath

        Parameters
        ----------
        i: int

        get_path(Millard2012EquilibriumMuscleIterator self) -> AbstractGeometryPath
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_path(self, *args)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tension_get, doc=r"""_has_output_tension : bool""")

    def getPath(self):
        r"""getPath(Millard2012EquilibriumMuscleIterator self) -> AbstractGeometryPath"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPath(self)

    def getGeometryPath(self):
        r"""getGeometryPath(Millard2012EquilibriumMuscleIterator self) -> GeometryPath"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getGeometryPath(self)

    def hasVisualPath(self):
        r"""hasVisualPath(Millard2012EquilibriumMuscleIterator self) -> bool"""
        return _simulation.Millard2012EquilibriumMuscleIterator_hasVisualPath(self)

    def getOptimalForce(self):
        r"""getOptimalForce(Millard2012EquilibriumMuscleIterator self) -> double"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getOptimalForce(self)

    def getLength(self, s):
        r"""
        getLength(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s):
        r"""
        getLengtheningSpeed(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getLengtheningSpeed(self, s)

    def getSpeed(self, s):
        r"""
        getSpeed(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getSpeed(self, s)

    def getPower(self, s):
        r"""
        getPower(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPower(self, s)

    def computeMomentArm(self, s, aCoord):
        r"""
        computeMomentArm(Millard2012EquilibriumMuscleIterator self, State s, Coordinate aCoord) -> double

        Parameters
        ----------
        s: SimTK::State const &
        aCoord: OpenSim::Coordinate &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args):
        r"""
        get_min_control(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_min_control(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args):
        r"""
        get_max_control(Millard2012EquilibriumMuscleIterator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_control(Millard2012EquilibriumMuscleIterator self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_actuation_get, doc=r"""_has_output_actuation : bool""")
    _has_output_speed = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_speed_get, doc=r"""_has_output_speed : bool""")

    def getControl(self, s):
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getControl(self, s)

    def numControls(self):
        r"""numControls(Millard2012EquilibriumMuscleIterator self) -> int"""
        return _simulation.Millard2012EquilibriumMuscleIterator_numControls(self)

    def setActuation(self, s, aActuation):
        r"""
        setActuation(Millard2012EquilibriumMuscleIterator self, State s, double aActuation)

        Parameters
        ----------
        s: SimTK::State const &
        aActuation: double

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s):
        r"""
        getActuation(Millard2012EquilibriumMuscleIterator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActuation(self, s)

    def getMinControl(self):
        r"""getMinControl(Millard2012EquilibriumMuscleIterator self) -> double"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinControl(self)

    def getMaxControl(self):
        r"""getMaxControl(Millard2012EquilibriumMuscleIterator self) -> double"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxControl(self)

    def overrideActuation(self, s, flag):
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s):
        r""" return ScalarActuator's override status"""
        return _simulation.Millard2012EquilibriumMuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s, value):
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s):
        r"""return override actuation"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls, actuatorControls):
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls, modelControls):
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Millard2012EquilibriumMuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls, modelControls):
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Millard2012EquilibriumMuscleIterator_addInControls(self, actuatorControls, modelControls)

    def produceForces(self, state, forceConsumer):
        r"""
        Uses `implProduceForces` to produce (emit) forces evaluated from `state` into the
        provided `ForceConsumer`.

        Notes: this function only produces the forces and does not apply them to anything. It's
              up to the `ForceConsumer` implementation to handle the forces. Therefore,
              `Force::appliesForces` is ignored by this method.

        :type state: :py:class:`State`
        :param state:       the state used to evaluate forces
        :param consumer:    a `ForceConsumer` that shall receive each of the produced forces
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_produceForces(self, state, forceConsumer)

    def get_appliesForce(self, *args):
        r"""
        get_appliesForce(Millard2012EquilibriumMuscleIterator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_appliesForce(Millard2012EquilibriumMuscleIterator self) -> bool const &
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_potential_energy_get, doc=r"""_has_output_potential_energy : bool""")

    def shouldBeParallelized(self):
        r"""
        Tell Simbody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s):
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Millard2012EquilibriumMuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s, applyForce):
        r""" %Set whether or not the Force is applied."""
        return _simulation.Millard2012EquilibriumMuscleIterator_setAppliesForce(self, s, applyForce)

    def getForceIndex(self):
        r""" Return the index to the SimTK::Force in the underlying system."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getForceIndex(self)

    def getModel(self):
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getModel(self)

    def hasModel(self):
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.Millard2012EquilibriumMuscleIterator_hasModel(self)

    def addToSystem(self, system):
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.Millard2012EquilibriumMuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state):
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.Millard2012EquilibriumMuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed, hints, state, appendToThis):
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self):
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getSystem(self)

    def hasSystem(self):
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component):
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self):
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self):
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt):
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname):
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname):
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring):
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self):
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self):
        r"""
        Get the names of continuous state variables maintained by the
        Component and its subcomponents. Each variable's name is prepended
        by its path in the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableNames(self)

    def getDiscreteVariableNames(self):
        r"""
        Get the names of discrete state variables maintained by the Component
        and its subcomponents. Each variable's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDiscreteVariableNames(self)

    def getModelingOptionNames(self):
        r"""
        Get the names of the modeling options maintained by the Component
        and its subcomponents. Each options's name is prepended by its path in
        the component hierarchy.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getModelingOptionNames(self)

    def getNumSockets(self):
        r""" Get the number of Sockets in this Component."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumSockets(self)

    def getSocketNames(self):
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getSocketNames(self)

    def getConnectee(self, *args):
        r"""
        *Overload 1:*
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)

        |

        *Overload 2:*
         Get the connectee at the provided index as an Object. This means you
        will not have access to the methods on the concrete connectee. This is the
        method you must use in scripts to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = controller.getConnectee("actuators", 1);
            obj.getName(); // method on Object works.
            obj.getDefaultControls(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "actuators" are Actuators:

        .. code-block:: c++

            actu = controller.getConnectee('actuators', 1);
            controls = Actuator.safeDownCast(f).getDefaultControls();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            actu = controller.getConnectee("actuators", 1);
            controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getConnectee(self, *args)

    def tryGetSocket(self, name):
        r"""
        Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`
        if the socket with the given name does not exist on the component.

        See `getSocket()` for more details about how the socket is looked up.

        **C++ example**

        .. code-block:: c++

            if (const AbstractSocket* s = component.tryGetSocket("frame")) {
                // do something with *s
            }
            else {
                // handle the no-socket-by-that-name case
            }
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_tryGetSocket(self, name)

    def getSocket(self, name):
        r"""
        getSocket(Millard2012EquilibriumMuscleIterator self, std::string const & name) -> AbstractSocket

        Parameters
        ----------
        name: std::string const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getSocket(self, name)

    def getNumInputs(self):
        r""" Access the number of Inputs that this component has."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumInputs(self)

    def getNumOutputs(self):
        r""" Access the number of Outputs that this component has."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumOutputs(self)

    def getInputNames(self):
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInputNames(self)

    def getOutputNames(self):
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOutputNames(self)

    def getInput(self, name):
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInput(self, name)

    def tryGetOutput(self, name):
        r"""
        If it exists on the component, returns a pointer to the named `Output`; otherwise,
        returns a `nullptr`.

        Related: `getOutput`

        :type name: string
        :param name:  the name the `Output` to find
        :rtype: :py:class:`AbstractOutput`
        :return: if it exists, a pointer to the `Output`; otherwise, `nullptr`
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_tryGetOutput(self, name)

    def getOutput(self, name):
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOutput(self, name)

    def getModelingOption(self, *args):
        r"""
        getModelingOption(Millard2012EquilibriumMuscleIterator self, State state, std::string const & path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: std::string const &

        getModelingOption(Millard2012EquilibriumMuscleIterator self, State state, ComponentPath path) -> int

        Parameters
        ----------
        state: SimTK::State const &
        path: OpenSim::ComponentPath const &

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getModelingOption(self, *args)

    def setModelingOption(self, *args):
        r"""
        setModelingOption(Millard2012EquilibriumMuscleIterator self, State state, std::string const & path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: std::string const &
        flag: int

        setModelingOption(Millard2012EquilibriumMuscleIterator self, State state, ComponentPath path, int flag)

        Parameters
        ----------
        state: SimTK::State &
        path: OpenSim::ComponentPath const &
        flag: int

        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setModelingOption(self, *args)

    def getStateVariableValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state, name, value):
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state):
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state, values):
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, *args):
        r"""
        *Overload 1:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type path: :py:class:`ComponentPath`
        :param path:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableDerivativeValue(self, *args)

    def resolveVariableNameAndOwner(self, path, varName):
        r"""
        Based on a specified path, resolve the name of a state variable,
        discrete variable, or modeling option and resolve the component that
        owns it (i.e., its parent).

        The path consists of the name of the state variable, discrete variable,
        or modeling option prepended by its absolute or relative path in the
        component hierarchy.

        This method does not verify that the variable or option can actually be
        found at the spcified path. It simply parses the path, returning the
        variable name and candidate owner.

        Notes: Calling Component::traversPathToComponent<Component>() will not
        work for state variables, discrete variables, and modeling options
        because these obects are not themselves Components. However, a pointer
        to a StateVariable can be obtained in a single step by calling
        Component::traverseToStateVariable(). A similar dedicated method is not
        available for discrete variables or for modeling options.

        #### Example Paths

        A relative path in which this component is the owner:
          ```variable_name```

        An absolute path from the root of the component hierarchy:
          ```/grandparent_name/parent_name/variable_name```

        A relative path in which a sibling of this component is the owner:
          ```../sibling_name/variable_name```

        :type path: :py:class:`ComponentPath`
        :param path: Path of the state variable, discrete variable, or modeling
            option in the component heirarchy.
        :type varName: string
        :param varName: The name of the state variable, discrete variable,
            or modeling option is returned in this parameter.
        :rtype: :py:class:`Component`
        :return: Pointer to the component that, according to the path, owns the
            state variable, discrete variable, or modeling option. If the specified
            path consists only of the name of the state variable, discrete variable,
            or modeling option, a pointer to this component is returned.
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            cannot be found at the specified path.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_resolveVariableNameAndOwner(self, path, varName)

    def getDiscreteVariableValue(self, state, path):
        r"""
        Based on a specified path, get the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: float
        :return: Value of the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
            System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDiscreteVariableValue(self, state, path)

    def getDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a read-only reference to the
        abstract value of the discrete variable at a specified path. This method
        provides a more general interface that is not limited to values of type
        double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable from an
        AbstractValue, perform a cast using the templated methods provided in
        class SimTK::Value<T>. When the type is unknown, it can be queried using
        the SimTK::Value<T>::isA() method. For example,

        ```
             const SimTK::AbstractValue& valAbstract =
                 getDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 const SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::downcast(valAbstract);
                 double x = valDbl + 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 const SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::downcast(valAbstract);
                 Vec3 x = valVec3 + Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See getDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Specified path of the variable in the component heirarchy.
        :rtype: SimTK::AbstractValue
        :return: Read-only reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDiscreteVariableAbstractValue(self, state, path)

    def setDiscreteVariableValue(self, state, path, value):
        r"""
        Based on a specified path, set the value of a discrete variable.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        :type state: :py:class:`State`
        :param state: State in which to set the discrete variable.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :type value: float
        :param value: Value to which to set the discrete variable.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            the candidate owner.
        See also: Component::resolveVariableNameAndOwner()
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setDiscreteVariableValue(self, state, path, value)

    def updDiscreteVariableAbstractValue(self, state, path):
        r"""
        Based on a specified path, retrieve a writable reference to the abstract
        value of the discrete variable. This method provides a more general
        interface that is not limited to values of type double.

        The specified path consists of the name of the discrete variable
        prepended by its absolute or relative path in the component hierarchy.

        If this component is the owner of the discrete variable, the specified
        path should simply be the name of the discrete variable.

        To obtain the type-specific value of a discrete variable, perform
        a cast using the template methods provided in class SimTK::Value<T>.
        When the type is unknown, it can be queried using the
        SimTK::Value<T>::isA() method. For example,

        ```
             SimTK::AbstractValue& valAbstract =
                 updDiscreteVariableAbstractValue(state, pathName);

             if (SimTK::Value<double>::isA(valAbstract)) {
                 SimTK::Value<double>& valDbl =
                     SimTK::Value<double>::updDowncast(valAbstract);
                 valDbl = 0.4;

             } else if (SimTK::Value<Vec3>::isA(valAbstract)) {
                 SimTK::Value<Vec3>& valVec3 =
                     SimTK::Value<Vec3>::updDowncast(valAbstract);
                 valVec3 = Vec3(0.4);
             }
        ```
        For convenience, a templated method that implements basic downcasting
        internally is available. See setDiscreteVariableValue<T>().

        :type state: :py:class:`State`
        :param state: State from which to get the value.
        :type path: string
        :param path: Path of the discrete variable in the component hierarchy.
        :rtype: SimTK::AbstractValue
        :return: Writable reference to the discrete variable's AbstractValue.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called).
        :raises: EmptyComponentPath if the specified path is an empty string
            (i.e., path == "").
        :raises: VariableOwnerNotFoundOnSpecifiedPath if the candidate owner
            of the variable cannot be found at the specified path.
        :raises: VariableNotFound if the specified variable cannot be found in
            this Component.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_updDiscreteVariableAbstractValue(self, state, path)

    def getCacheVariableIndex(self, name):
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state, name):
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state, name):
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self):
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self):
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printSocketInfo(self)

    def printInputInfo(self):
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants=True):
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self):
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOwner(self)

    def hasOwner(self):
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasOwner(self)

    def getRoot(self):
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getRoot(self)

    def findComponent(self, *args):
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_findComponent(self, *args)

    def getComponentsList(self):
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject):
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isEqualTo(self, aObject)

    def getName(self):
        r""" Get the name of this Object."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getName(self)

    def getDescription(self):
        r""" Get description, a one-liner summary."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getDescription(self)

    def getAuthors(self):
        r""" Get Authors of this Object"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getAuthors(self)

    def getReferences(self):
        r""" Get references or publications to cite if using this object."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getReferences(self)

    def getNumProperties(self):
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex):
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name):
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name):
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self):
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent, prop=None):
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self):
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInlined(self)

    def getDocumentFileName(self):
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self):
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName):
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printToXML(self, fileName)

    def dump(self):
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_dump(self)

    def isA(self, type):
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isA(self, type)

    def toString(self):
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_toString(self)

# Register Millard2012EquilibriumMuscleIterator in _simulation:
_simulation.Millard2012EquilibriumMuscleIterator_swigregister(Millard2012EquilibriumMuscleIterator)
class ActiveForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ActiveForceLengthCurve, commonly used
       to model the active element in muscle models. The active-force-length curve
       is dimensionless: force is normalized to maximum isometric force and length
       is normalized to resting fiber length. Five properties are used to construct
       a curve:

       :param minActiveNormFiberLength:
               The normalized fiber length where the steep ascending limb of the
               active-force-length curve transitions to the minimum value and has first
               and second derivatives of 0.
       :param transitionNormFiberLength:
               The normalized fiber length where the steep ascending limb transitions
               to the shallow ascending limb.
       :param maxActiveNormFiberLength:
               The normalized fiber length where the descending limb transitions to the
               minimum value and has first and second derivatives of 0.
       :param shallowAscendingSlope:
               The slope of the shallow ascending limb.
       :param minimumValue:
               The minimum value of the active-force-length curve. If you are using an
               equilibrium model, this value must be greater than 0, as a value of 0
               will cause a singularity in the muscle dynamic equations.

       Image: fig_ActiveForceLengthCurve.png

       **Conditions**
           0 < minActiveNormFiberLength < transitionNormFiberLength < 1 < maxActiveNormFiberLength
       0 <= shallowAscendingSlope < 1/(1-transitionNormFiberLength)
       0 <= minimumValue

       **Default Parameter Values**
       The default parameters have been chosen so that the resulting curve closely
       matches the active-force-length curve for human sarcomeres, as documented by
       Nigg and Herzog (1994). The descending limb has been adjusted to match the
       in-vitro human fiber data reported by Gollapudi and Lin (2009). The default
       shoulder value is set to 0.1. This relatively large value is used to ensure
       that muscle model dynamic equations with an active-force-length singularity
       do not take an unreasonable amount of time to simulate (simulation time
       grows as the value of the active-force-length curve approaches 0). %Muscle
       model formulations that do not have this singularity (e.g., the
       Millard2012AccelerationMuscle model) can use a minimumValue of 0.

           minActiveNormFiberLength ..... 0.4441
       transitionNormFiberLength .... 0.73
       maxActiveNormFiberLength ..... 1.8123
       shallowAscendingSlope ........ 0.8616
       minimumValue ................. 0.1

       **Example**

       .. code-block:: c++

           ActiveForceLengthCurve falCurve1(0.44, 0.73, 1.8, 0.86, 0.1);
           double falVal  = falCurve1.calcValue(1.0);
           double dfalVal = falCurve1.calcDerivative(1.0, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       **References**
       * Gollapudi, S.K., Lin, D.C. (2009) Experimental determination of
           sarcomere force-length relationship in type-I human skeletal muscle
           fibers. Journal of Biomechanics 42(13), 2011--2016.
       * Nigg, B.M., Herzog, W. Biomechanics of the Musculo-skeletal System.
           Wiley, 1994.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ActiveForceLengthCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ActiveForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ActiveForceLengthCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ActiveForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ActiveForceLengthCurve_getClassName()

    def clone(self):
        r"""clone(ActiveForceLengthCurve self) -> ActiveForceLengthCurve"""
        return _simulation.ActiveForceLengthCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActiveForceLengthCurve self) -> std::string const &"""
        return _simulation.ActiveForceLengthCurve_getConcreteClassName(self)

    def copyProperty_min_norm_active_fiber_length(self, source):
        r"""
        copyProperty_min_norm_active_fiber_length(ActiveForceLengthCurve self, ActiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::ActiveForceLengthCurve::Self const &

        """
        return _simulation.ActiveForceLengthCurve_copyProperty_min_norm_active_fiber_length(self, source)

    def append_min_norm_active_fiber_length(self, value):
        r"""
        append_min_norm_active_fiber_length(ActiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_append_min_norm_active_fiber_length(self, value)

    def constructProperty_min_norm_active_fiber_length(self, initValue):
        r"""
        constructProperty_min_norm_active_fiber_length(ActiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActiveForceLengthCurve_constructProperty_min_norm_active_fiber_length(self, initValue)

    def get_min_norm_active_fiber_length(self, *args):
        r"""
        get_min_norm_active_fiber_length(ActiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_min_norm_active_fiber_length(ActiveForceLengthCurve self) -> double const &
        """
        return _simulation.ActiveForceLengthCurve_get_min_norm_active_fiber_length(self, *args)

    def upd_min_norm_active_fiber_length(self, *args):
        r"""
        upd_min_norm_active_fiber_length(ActiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_min_norm_active_fiber_length(ActiveForceLengthCurve self) -> double &
        """
        return _simulation.ActiveForceLengthCurve_upd_min_norm_active_fiber_length(self, *args)

    def set_min_norm_active_fiber_length(self, *args):
        r"""
        set_min_norm_active_fiber_length(ActiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_min_norm_active_fiber_length(ActiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_set_min_norm_active_fiber_length(self, *args)

    def copyProperty_transition_norm_fiber_length(self, source):
        r"""
        copyProperty_transition_norm_fiber_length(ActiveForceLengthCurve self, ActiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::ActiveForceLengthCurve::Self const &

        """
        return _simulation.ActiveForceLengthCurve_copyProperty_transition_norm_fiber_length(self, source)

    def append_transition_norm_fiber_length(self, value):
        r"""
        append_transition_norm_fiber_length(ActiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_append_transition_norm_fiber_length(self, value)

    def constructProperty_transition_norm_fiber_length(self, initValue):
        r"""
        constructProperty_transition_norm_fiber_length(ActiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActiveForceLengthCurve_constructProperty_transition_norm_fiber_length(self, initValue)

    def get_transition_norm_fiber_length(self, *args):
        r"""
        get_transition_norm_fiber_length(ActiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_transition_norm_fiber_length(ActiveForceLengthCurve self) -> double const &
        """
        return _simulation.ActiveForceLengthCurve_get_transition_norm_fiber_length(self, *args)

    def upd_transition_norm_fiber_length(self, *args):
        r"""
        upd_transition_norm_fiber_length(ActiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_transition_norm_fiber_length(ActiveForceLengthCurve self) -> double &
        """
        return _simulation.ActiveForceLengthCurve_upd_transition_norm_fiber_length(self, *args)

    def set_transition_norm_fiber_length(self, *args):
        r"""
        set_transition_norm_fiber_length(ActiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_transition_norm_fiber_length(ActiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_set_transition_norm_fiber_length(self, *args)

    def copyProperty_max_norm_active_fiber_length(self, source):
        r"""
        copyProperty_max_norm_active_fiber_length(ActiveForceLengthCurve self, ActiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::ActiveForceLengthCurve::Self const &

        """
        return _simulation.ActiveForceLengthCurve_copyProperty_max_norm_active_fiber_length(self, source)

    def append_max_norm_active_fiber_length(self, value):
        r"""
        append_max_norm_active_fiber_length(ActiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_append_max_norm_active_fiber_length(self, value)

    def constructProperty_max_norm_active_fiber_length(self, initValue):
        r"""
        constructProperty_max_norm_active_fiber_length(ActiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActiveForceLengthCurve_constructProperty_max_norm_active_fiber_length(self, initValue)

    def get_max_norm_active_fiber_length(self, *args):
        r"""
        get_max_norm_active_fiber_length(ActiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_norm_active_fiber_length(ActiveForceLengthCurve self) -> double const &
        """
        return _simulation.ActiveForceLengthCurve_get_max_norm_active_fiber_length(self, *args)

    def upd_max_norm_active_fiber_length(self, *args):
        r"""
        upd_max_norm_active_fiber_length(ActiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_norm_active_fiber_length(ActiveForceLengthCurve self) -> double &
        """
        return _simulation.ActiveForceLengthCurve_upd_max_norm_active_fiber_length(self, *args)

    def set_max_norm_active_fiber_length(self, *args):
        r"""
        set_max_norm_active_fiber_length(ActiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_norm_active_fiber_length(ActiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_set_max_norm_active_fiber_length(self, *args)

    def copyProperty_shallow_ascending_slope(self, source):
        r"""
        copyProperty_shallow_ascending_slope(ActiveForceLengthCurve self, ActiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::ActiveForceLengthCurve::Self const &

        """
        return _simulation.ActiveForceLengthCurve_copyProperty_shallow_ascending_slope(self, source)

    def append_shallow_ascending_slope(self, value):
        r"""
        append_shallow_ascending_slope(ActiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_append_shallow_ascending_slope(self, value)

    def constructProperty_shallow_ascending_slope(self, initValue):
        r"""
        constructProperty_shallow_ascending_slope(ActiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActiveForceLengthCurve_constructProperty_shallow_ascending_slope(self, initValue)

    def get_shallow_ascending_slope(self, *args):
        r"""
        get_shallow_ascending_slope(ActiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_shallow_ascending_slope(ActiveForceLengthCurve self) -> double const &
        """
        return _simulation.ActiveForceLengthCurve_get_shallow_ascending_slope(self, *args)

    def upd_shallow_ascending_slope(self, *args):
        r"""
        upd_shallow_ascending_slope(ActiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_shallow_ascending_slope(ActiveForceLengthCurve self) -> double &
        """
        return _simulation.ActiveForceLengthCurve_upd_shallow_ascending_slope(self, *args)

    def set_shallow_ascending_slope(self, *args):
        r"""
        set_shallow_ascending_slope(ActiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_shallow_ascending_slope(ActiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_set_shallow_ascending_slope(self, *args)

    def copyProperty_minimum_value(self, source):
        r"""
        copyProperty_minimum_value(ActiveForceLengthCurve self, ActiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::ActiveForceLengthCurve::Self const &

        """
        return _simulation.ActiveForceLengthCurve_copyProperty_minimum_value(self, source)

    def append_minimum_value(self, value):
        r"""
        append_minimum_value(ActiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_append_minimum_value(self, value)

    def constructProperty_minimum_value(self, initValue):
        r"""
        constructProperty_minimum_value(ActiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ActiveForceLengthCurve_constructProperty_minimum_value(self, initValue)

    def get_minimum_value(self, *args):
        r"""
        get_minimum_value(ActiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_value(ActiveForceLengthCurve self) -> double const &
        """
        return _simulation.ActiveForceLengthCurve_get_minimum_value(self, *args)

    def upd_minimum_value(self, *args):
        r"""
        upd_minimum_value(ActiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_minimum_value(ActiveForceLengthCurve self) -> double &
        """
        return _simulation.ActiveForceLengthCurve_upd_minimum_value(self, *args)

    def set_minimum_value(self, *args):
        r"""
        set_minimum_value(ActiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_minimum_value(ActiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ActiveForceLengthCurve_set_minimum_value(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an active-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs an active-force-length curve using the provided parameters
           and assigns a default name.
        """
        _simulation.ActiveForceLengthCurve_swiginit(self, _simulation.new_ActiveForceLengthCurve(*args))

    def getMinActiveFiberLength(self):
        r"""
        :rtype: float
        :return: The normalized fiber length where the steep ascending limb of
               the active-force-length curve transitions to the minimum activation value
               and simultaneously achieves a first and second derivative of 0.
        """
        return _simulation.ActiveForceLengthCurve_getMinActiveFiberLength(self)

    def getTransitionFiberLength(self):
        r"""
        :rtype: float
        :return: The normalized fiber length where the steep ascending limb
               of the active-force-length curve transitions to the shallow ascending limb.
        """
        return _simulation.ActiveForceLengthCurve_getTransitionFiberLength(self)

    def getMaxActiveFiberLength(self):
        r"""
        :rtype: float
        :return: The normalized fiber length where the descending limb of the
               active-force-length curve transitions to the minimum activation value and
               simultaneously achieves first and second derivatives of 0.
        """
        return _simulation.ActiveForceLengthCurve_getMaxActiveFiberLength(self)

    def getShallowAscendingSlope(self):
        r"""
        :rtype: float
        :return: The slope of the shallow ascending limb
               (d active_force_length / d normalized_fiber_length).
        """
        return _simulation.ActiveForceLengthCurve_getShallowAscendingSlope(self)

    def getMinValue(self):
        r"""
        :rtype: float
        :return: The minimum active-force-length value permitted in the
               simulation. This value must be non-zero for an equilibrium model.
        """
        return _simulation.ActiveForceLengthCurve_getMinValue(self)

    def setActiveFiberLengths(self, minActiveNormFiberLength, transitionNormFiberLength, maxActiveNormFiberLength, shallowAscendingSlope):
        r"""
        :type minActiveNormFiberLength: float
        :param minActiveNormFiberLength:
                The normalized fiber length where the steep ascending limb of the
                active-force-length curve transitions to the minimum value and has first
                and second derivatives of 0.
        :type transitionNormFiberLength: float
        :param transitionNormFiberLength:
                The normalized fiber length where the steep ascending limb transitions
                to the shallow ascending limb.
        :type maxActiveNormFiberLength: float
        :param maxActiveNormFiberLength:
                The normalized fiber length where the descending limb transitions to the
                minimum value and has first and second derivatives of 0.
        :type shallowAscendingSlope: float
        :param shallowAscendingSlope:
                The slope of the shallow ascending limb.

        **Conditions**
            0 < minActiveNormFiberLength < transitionNormFiberLength < 1 < maxActiveNormFiberLength
        0 <= shallowAscendingSlope < 1/(1-transitionNormFiberLength)
        """
        return _simulation.ActiveForceLengthCurve_setActiveFiberLengths(self, minActiveNormFiberLength, transitionNormFiberLength, maxActiveNormFiberLength, shallowAscendingSlope)

    def setMinValue(self, minimumValue):
        r"""
        :type minimumValue: float
        :param minimumValue:
                The minimum value of the active-force-length curve. If you are using an
                equilibrium model, this value must be greater than 0, as a value of 0
                will cause a singularity in the muscle dynamic equations.
        """
        return _simulation.ActiveForceLengthCurve_setMinValue(self, minimumValue)

    def calcValue(self, *args):
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the active-force-length curve at a normalized fiber length of
           'normFiberLength'.
        """
        return _simulation.ActiveForceLengthCurve_calcValue(self, *args)

    def calcValueAndDerivative(self, normFiberLength):
        r"""
         Evaluates the active-force-length curve value and derivative at a
        normalized fiber length of 'normFiberLength'.
        """
        return _simulation.ActiveForceLengthCurve_calcValueAndDerivative(self, normFiberLength)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*
        Calculates the derivative of the active-force-length multiplier with
           respect to the normalized fiber length.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the active-force-length curve with respect to the
                   normalized fiber length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ActiveForceLengthCurve_calcDerivative(self, *args)

    def getCurveDomain(self):
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ActiveForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ActiveForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the linear extrapolation region (the region less
           than minActiveNormFiberLength), through the curve, out to the other linear
           extrapolation region (the region greater than maxActiveNormFiberLength). The
           width of each linear extrapolation region is 10% of the curve domain, or
           0.1*(maxActiveNormFiberLength-minActiveNormFiberLength). The curve is
           sampled quite densely: the active-force-length .csv file will have 500+20
           rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ActiveForceLengthCurve.csv', 1, 0);
        """
        return _simulation.ActiveForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(ActiveForceLengthCurve self)"""
        return _simulation.ActiveForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ActiveForceLengthCurve

# Register ActiveForceLengthCurve in _simulation:
_simulation.ActiveForceLengthCurve_swigregister(ActiveForceLengthCurve)
class FiberCompressiveForceCosPennationCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberCompressiveForceCosPennationCurve,
    which is used to ensure that the pennation angle approaches but never reaches
    an angle of 90 degrees. Preventing the fibers from achieving a pennation
    angle of 90 degrees is important for equilibrium muscle models which
    have a singularity at this value.

    This curve is designed to work with the muscle model
    in such a way that it acts like a spring that the pennated muscle fibers
    contact it as the fiber rotates (circled in red). When the spring engages it
    will exert a force on the fiber that will prevent it from shortening further,
    thus preventing the pennation angle from reaching 90 degrees.

    Note that this object should be updated through the set methods provided.
    These set methods will take care of rebuilding the curve correctly. If you
    modify the properties directly, the curve will not be rebuilt, and upon
    calling a function like calcValue, calcDerivative, or printCurveToCSVFile
    an exception will be thrown because the curve is out of date with its
    properties.

    Image: fig_FiberCompressiveForceCosPennationCurve.png

     Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FiberCompressiveForceCosPennationCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FiberCompressiveForceCosPennationCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FiberCompressiveForceCosPennationCurve_getClassName()

    def clone(self):
        r"""clone(FiberCompressiveForceCosPennationCurve self) -> FiberCompressiveForceCosPennationCurve"""
        return _simulation.FiberCompressiveForceCosPennationCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FiberCompressiveForceCosPennationCurve self) -> std::string const &"""
        return _simulation.FiberCompressiveForceCosPennationCurve_getConcreteClassName(self)

    def copyProperty_engagement_angle_in_degrees(self, source):
        r"""
        copyProperty_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, FiberCompressiveForceCosPennationCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceCosPennationCurve::Self const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_engagement_angle_in_degrees(self, source)

    def append_engagement_angle_in_degrees(self, value):
        r"""
        append_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_append_engagement_angle_in_degrees(self, value)

    def constructProperty_engagement_angle_in_degrees(self, initValue):
        r"""
        constructProperty_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_engagement_angle_in_degrees(self, initValue)

    def get_engagement_angle_in_degrees(self, *args):
        r"""
        get_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_get_engagement_angle_in_degrees(self, *args)

    def upd_engagement_angle_in_degrees(self, *args):
        r"""
        upd_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_engagement_angle_in_degrees(self, *args)

    def set_engagement_angle_in_degrees(self, *args):
        r"""
        set_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_engagement_angle_in_degrees(FiberCompressiveForceCosPennationCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_set_engagement_angle_in_degrees(self, *args)

    def copyProperty_stiffness_at_perpendicular(self, source):
        r"""
        copyProperty_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, FiberCompressiveForceCosPennationCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceCosPennationCurve::Self const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_stiffness_at_perpendicular(self, source)

    def append_stiffness_at_perpendicular(self, value):
        r"""
        append_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_append_stiffness_at_perpendicular(self, value)

    def constructProperty_stiffness_at_perpendicular(self, *args):
        r"""
        constructProperty_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self)
        constructProperty_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_stiffness_at_perpendicular(self, *args)

    def get_stiffness_at_perpendicular(self, *args):
        r"""
        get_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_get_stiffness_at_perpendicular(self, *args)

    def upd_stiffness_at_perpendicular(self, *args):
        r"""
        upd_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_stiffness_at_perpendicular(self, *args)

    def set_stiffness_at_perpendicular(self, *args):
        r"""
        set_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness_at_perpendicular(FiberCompressiveForceCosPennationCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_set_stiffness_at_perpendicular(self, *args)

    def copyProperty_curviness(self, source):
        r"""
        copyProperty_curviness(FiberCompressiveForceCosPennationCurve self, FiberCompressiveForceCosPennationCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceCosPennationCurve::Self const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value):
        r"""
        append_curviness(FiberCompressiveForceCosPennationCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args):
        r"""
        constructProperty_curviness(FiberCompressiveForceCosPennationCurve self)
        constructProperty_curviness(FiberCompressiveForceCosPennationCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args):
        r"""
        get_curviness(FiberCompressiveForceCosPennationCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_curviness(FiberCompressiveForceCosPennationCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_get_curviness(self, *args)

    def upd_curviness(self, *args):
        r"""
        upd_curviness(FiberCompressiveForceCosPennationCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_curviness(FiberCompressiveForceCosPennationCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_curviness(self, *args)

    def set_curviness(self, *args):
        r"""
        set_curviness(FiberCompressiveForceCosPennationCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_curviness(FiberCompressiveForceCosPennationCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceCosPennationCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor creates an curve with the default property values,
           and assigns it a default name *

        |

        *Overload 2:*
        Constructs a C2 continuous compressive fiber force cos pennation curve.
           The sole purpose of this curve is to prevent the pennation angle from
           reaching an angle of 90 degrees. Details to appear in Millard et al. 2012.

           :type engagementAngleInDegrees: float
           :param engagementAngleInDegrees:
                       The pennation angle engagement angle of the fiber compressive
                       force pennation curve. Making the spring engage too
                       far from 90 degrees may unrealistically limit the force
                       production capability of the muscle. An engagement angle of
                       80 degrees is a good place to start.

           :type stiffnessAtPerpendicular: float
           :param stiffnessAtPerpendicular:
                       This is the stiffness of the compressive elastic force length
                       spring when the pennation angle reaches 90 degrees. Note that
                       the units of this stiffness are
                       (normalized force) / cos(engagmentAngleInDegrees). If the
                       engagement angle is 80 degrees, a good stiffness to start with
                       is -2*(1/cosd(engagementAngleInDegrees))

           :type curviness: float
           :param curviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtPerpendicularFiber' and the
                       x axis as shown in the figure. A good curviness parameter value
                       to start with is 0.5.

           :type muscleName: string
           :param muscleName:
                       The name of the muscle this curve belongs to. This name is used
                       to create the name of this curve, which is formed simply by
                       appending "_FiberCompressiveForceCosPennationCurve" to the
                       string in muscleName. This name is used for making intelligible
                       error messages and also for naming the XML version of this curve
                       when it is serialized.

           **Conditions**
                   0 < engagmentAngleInDegrees < 90
               stiffnessAtPerpendicular < -1/engagmentAngleInDegrees
               0 <= curviness <= 1

           **Computational Costs**
                   ~174,100 flops

           **Default Parameter Values**
                   engagmentAngleInDegrees = 80

        |

        *Overload 3:*

            Constructs a C2 continuous compressive fiber force cos pennation curve
            using only the mandatory property, engagmentAngleInDegrees. The
            sole purpose of this curve is to prevent the pennation angle from reaching
            an angle of 90 degrees. Details to appear in Millard et al. 2012.

           :type engagementAngleInDegrees: float
           :param engagementAngleInDegrees:
                           The pennation angle engagement angle of the fiber compressive
                           force pennation curve. Making the spring engage too
                           far from 90 degrees may unrealistically limit the force
                           production capability of the muscle. An engagement angle of
                           80 degrees is a good place to start.

           :type muscleName: string
           :param muscleName:
                           The name of the muscle this curve belongs to. This name is used
                           to create the name of this curve, which is formed simply by
                           appending "_FiberCompressiveForceCosPennationCurve" to the
                           string in muscleName. This name is used for making intelligible
                           error messages and also for naming the XML version of this curve
                           when it is serialized.

           ** Optional Parameters **
               If the optional parameters have not yet been set, they are computed when
               functions getStiffnessAtPerpendicularInUse(), and getCurvinessInUse()
               are called. See the documentation for these functions for details

           **Conditions:**
                           0 < engagmentAngleInDegrees < 90

           **Computational Costs**

                   ~174,100 flops

           ** Default Parameter Values **


                             engagmentAngleInDegrees = 80

           **Example:**
        """
        _simulation.FiberCompressiveForceCosPennationCurve_swiginit(self, _simulation.new_FiberCompressiveForceCosPennationCurve(*args))

    def getEngagementAngleInDegrees(self):
        r"""
        :rtype: float
        :return: The pennation angle engagement angle of the fiber compressive
                        force pennation curve.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getEngagementAngleInDegrees(self)

    def getStiffnessAtPerpendicularInUse(self):
        r"""
        :rtype: float
        :return: This is the stiffness of the compressive elastic force length
                       spring when the pennation angle reaches 90 degrees. If this
                       property has been set, the property value is returned. If this
                       property is empty, then a value is computed and returned. The
                       value is computed using the following:

                                   stiffnessAtPerpendicular = -2 * 1/cosd(engagementAngleInDegrees)

                   where cosd is a cosine function that takes its argument in units
                   of degrees
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getStiffnessAtPerpendicularInUse(self)

    def getCurvinessInUse(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'StiffnessAtPerpendicularFiber'.

                   If this property is empty, then a value is computed and
                   returned. The value is computed using the following:

                                   curviness = 0.1
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self):
        r"""
        :rtype: boolean
        :return: true if the internal fitting routine (which takes only one
            argument, the engagementAngleInDegrees) is being used. False is returned if
            the user has set the optional parameters.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_isFittedCurveBeingUsed(self)

    def setEngagementAngleInDegrees(self, aEngagementAngleInDegrees):
        r"""
        :type aEngagementAngleInDegrees: float
        :param aEngagementAngleInDegrees:
                    Sets the pennation angle engagement angle of the fiber compressive
                    force pennation curve.
            **Cost **
             The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_setEngagementAngleInDegrees(self, aEngagementAngleInDegrees)

    def setOptionalProperties(self, aStiffnessAtPerpendicular, aCurviness):
        r"""
        :type aStiffnessAtPerpendicular: float
        :param aStiffnessAtPerpendicular:
                   This is the stiffness of the compressive elastic force length
                   spring when the pennation angle reaches 90 degrees.

        :type aCurviness: float
        :param aCurviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure.

        **Cost **
        The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_setOptionalProperties(self, aStiffnessAtPerpendicular, aCurviness)

    def calcValue(self, *args):
        r"""
        *Overload 1:*

           Calculates the value of the curve evaluated at cosPennationAngle.
           :type cosPennationAngle: float
           :param cosPennationAngle:: The cosine of the fiber pennation angle

           :rtype: float
           :return: the normalized force generated by the compressive force element


           **Computational Costs**
                   x in curve domain  : ~282 flops
               x in linear section:   ~5 flops


        |

        *Overload 2:*
        Implement the generic OpenSim::Function interface *
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcValue(self, *args)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*

           Calculates the derivative of the fiber compressive force pennation angle
           curve w.r.t. to cosPennationAngle.

           :type cosPennationAngle: float
           :param cosPennationAngle::
                           The cosine of the fiber pennation angle

           :type order: int
           :param order:: the order of the derivative. Only values of 0,1 and 2 are
                             acceptable.

           :rtype: float
           :return: the derivative of the fiber compressive force pennation angle
               curve w.r.t. to cosPennationAngle

           **Computational Costs**
                   x in curve domain  : ~391 flops
               x in linear section:   ~2 flops


        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcDerivative(self, *args)

    def calcIntegral(self, cosPennationAngle):
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                        The cosine of the pennation angle

        :rtype: float
        :return: Computes the normalized area under the curve. For this curve,
                    this quantity corresponds to the normalized potential energy stored
                    in the fiber compressive force cos pennation spring - simply
                    multiply this quantity by the number of NormForce
                    (where NormForce corresponds to the number of
                    Newtons that 1 normalized force corresponds to) to obtain
                    the potential energy stored in the fiber in units of Joules. Note
                    that NormDistance is omitted because the length dimension of this
                    curve is not normalized, only the force dimension.

        **Computational Costs**

                x in curve domain  : ~13 flops
            x in linear section: ~19 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcIntegral(self, cosPennationAngle)

    def getCurveDomain(self):
        r"""
        This function returns a SimTK::Vec2 that contains in its 0th element
        the lowest value of the curve domain, and in its 1st element the highest
        value in the curve domain of the curve. Outside of this domain the curve
        is approximated using linear extrapolation.

        :rtype: :py:class:`Vec2`
        :return: The minimum and maximum value of the domain, x, of the curve
                       y(x). Within this range y(x) is a curve, outside of this range
                       the function y(x) is a C2 (continuous to the second
                       derivative) linear extrapolation
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        This function will generate a csv file with a name that matches the
               curve name (e.g. "bicepfemoris_FiberCompressiveForceCosPennationCurve.csv").
              This function is not const to permit the curve to be rebuilt if it is out of
               date with its properties.

               :type path: string
               :param path: The full path to the location. Note '/' slashes must be used,
                        and do not put a '/' after the last folder.

               The file will contain the following columns:

                      Col# 1, 2,     3,       4,  
                    x, y, dy/dx, d2y/dx2,

               The curve will be sampled from its linear extrapolation region
               (the region with normalized fiber velocities < -1), through
               the curve, out to the other linear extrapolation region
               (the region with normalized fiber velocities > 1). The width of
               each linear extrapolation region is 10% of the entire range of x, or
               0.1*(x1-x0).

               The curve is sampled quite densely: there are 200+20 rows

               **Computational Costs**
                           ~194,800 flops

               **Example**
               To read the csv file with a header in from Matlab, you need to use
               csvread set so that it will ignore the header row. This is accomplished
               by using the extra two numerical arguments for csvread to tell the
               function to begin reading from the 1st row, and the 0th index (csvread
               is 0 indexed). This is necessary to skip reading in the text header
                       data=csvread('bicepfemoris_FiberCompressiveForceCosPennationCurve.csv',1,0);
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(FiberCompressiveForceCosPennationCurve self)"""
        return _simulation.FiberCompressiveForceCosPennationCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberCompressiveForceCosPennationCurve

# Register FiberCompressiveForceCosPennationCurve in _simulation:
_simulation.FiberCompressiveForceCosPennationCurve_swigregister(FiberCompressiveForceCosPennationCurve)
class FiberCompressiveForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberCompressiveForceLengthCurve,
    which is used to ensure that the fiber cannot generate force at, nor shorten
    beyond a minimum normalized length.

    Image: fig_FiberCompressiveForceLengthCurve.png

     Note that this object should be updated through the set methods provided.
    These set methods will take care of rebuilding the curve correctly. If you
    modify the properties directly, the curve will not be rebuilt, and upon
    calling a function like calcValue, calcDerivative, or printCurveToCSVFile
    an exception will be thrown because the curve is out of date with its
    properties.

     Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FiberCompressiveForceLengthCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FiberCompressiveForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FiberCompressiveForceLengthCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FiberCompressiveForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FiberCompressiveForceLengthCurve_getClassName()

    def clone(self):
        r"""clone(FiberCompressiveForceLengthCurve self) -> FiberCompressiveForceLengthCurve"""
        return _simulation.FiberCompressiveForceLengthCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FiberCompressiveForceLengthCurve self) -> std::string const &"""
        return _simulation.FiberCompressiveForceLengthCurve_getConcreteClassName(self)

    def copyProperty_norm_length_at_zero_force(self, source):
        r"""
        copyProperty_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, FiberCompressiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceLengthCurve::Self const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_norm_length_at_zero_force(self, source)

    def append_norm_length_at_zero_force(self, value):
        r"""
        append_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_append_norm_length_at_zero_force(self, value)

    def constructProperty_norm_length_at_zero_force(self, initValue):
        r"""
        constructProperty_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_norm_length_at_zero_force(self, initValue)

    def get_norm_length_at_zero_force(self, *args):
        r"""
        get_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceLengthCurve_get_norm_length_at_zero_force(self, *args)

    def upd_norm_length_at_zero_force(self, *args):
        r"""
        upd_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceLengthCurve_upd_norm_length_at_zero_force(self, *args)

    def set_norm_length_at_zero_force(self, *args):
        r"""
        set_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_norm_length_at_zero_force(FiberCompressiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_set_norm_length_at_zero_force(self, *args)

    def copyProperty_stiffness_at_zero_length(self, source):
        r"""
        copyProperty_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, FiberCompressiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceLengthCurve::Self const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_stiffness_at_zero_length(self, source)

    def append_stiffness_at_zero_length(self, value):
        r"""
        append_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_append_stiffness_at_zero_length(self, value)

    def constructProperty_stiffness_at_zero_length(self, *args):
        r"""
        constructProperty_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self)
        constructProperty_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_stiffness_at_zero_length(self, *args)

    def get_stiffness_at_zero_length(self, *args):
        r"""
        get_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceLengthCurve_get_stiffness_at_zero_length(self, *args)

    def upd_stiffness_at_zero_length(self, *args):
        r"""
        upd_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceLengthCurve_upd_stiffness_at_zero_length(self, *args)

    def set_stiffness_at_zero_length(self, *args):
        r"""
        set_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness_at_zero_length(FiberCompressiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_set_stiffness_at_zero_length(self, *args)

    def copyProperty_curviness(self, source):
        r"""
        copyProperty_curviness(FiberCompressiveForceLengthCurve self, FiberCompressiveForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberCompressiveForceLengthCurve::Self const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value):
        r"""
        append_curviness(FiberCompressiveForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args):
        r"""
        constructProperty_curviness(FiberCompressiveForceLengthCurve self)
        constructProperty_curviness(FiberCompressiveForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args):
        r"""
        get_curviness(FiberCompressiveForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_curviness(FiberCompressiveForceLengthCurve self) -> double const &
        """
        return _simulation.FiberCompressiveForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args):
        r"""
        upd_curviness(FiberCompressiveForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_curviness(FiberCompressiveForceLengthCurve self) -> double &
        """
        return _simulation.FiberCompressiveForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args):
        r"""
        set_curviness(FiberCompressiveForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_curviness(FiberCompressiveForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberCompressiveForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor creates an object with a default name that doesn't
           yet define a curve. *

        |

        *Overload 2:*
        Constructs a C2 continuous compressive fiber force length curve. This
           curve is used in the fiber model as a means of ensuring that the fiber
           cannot generate a tensile force at, nor shorten beyond, some minimum length.
           Details to appear in Millard et al. 2012.

           :type normLengthAtZeroForce: float
           :param normLengthAtZeroForce:
                       The normalized fiber length at which the compressive element
                       begins to engage. Normalized length is defined as
                       length_norm = l/l0, where l is the length of the fiber,
                       and l0 is the resting length of the fiber.

           :type stiffnessAtZeroLength: float
           :param stiffnessAtZeroLength:
                       This is the stiffness of the compressive elastic force length
                       spring when the fiber reaches a normalized length of 0.

           :type curviness: float
           :param curviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtZeroLength' and the
                       x axis as shown in the figure.

           :type muscleName: string
           :param muscleName:
                       The name of the muscle this curve belongs to. This name is used
                       to create the name of this curve, which is formed simply by
                       appending "_FiberCompressiveForceLengthCurve" to the string in
                       muscleName. This name is used for making intelligible error
                       messages and also for naming the XML version of this curve when
                       it is serialized.

           **Conditions**
                   normLengthAtZeroForce > 0
               stiffnessAtZeroLength < -1/normLengthAtZeroForce
               0 <= curviness <= 1

           **Computational Costs**
                   ~174,100 flops

           **Default Parameter Values**

                   normLengthAtZeroForce   = 0.6
               stiffnessAtZeroLength   = -8.4
               curviness               = 0.5
        """
        _simulation.FiberCompressiveForceLengthCurve_swiginit(self, _simulation.new_FiberCompressiveForceLengthCurve(*args))

    def getNormLengthAtZeroForce(self):
        r"""
        :rtype: float
        :return: The normalized fiber length at which the compressive element
                        begins to engage. Normalized length is defined as
                        length_norm = l/l0, where l is the length of the fiber,
                        and l0 is the resting length of the fiber.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getNormLengthAtZeroForce(self)

    def getStiffnessAtZeroLengthInUse(self):
        r"""
        :rtype: float
        :return: This is the stiffness of the compressive elastic force length
                       spring when the fiber reaches a normalized length of 0. If this
                       optional property is not specified, a suitable value will be
                       calculated and used instead.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getStiffnessAtZeroLengthInUse(self)

    def getCurvinessInUse(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure. If this optional property
                       is not specified, a suitable value will be calculated and used
                       instead.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getCurvinessInUse(self)

    def setNormLengthAtZeroForce(self, aNormLengthAtZeroForce):
        r"""
        :type aNormLengthAtZeroForce: float
        :param aNormLengthAtZeroForce:
                    Sets the normalized fiber length at which the compressive element
                    begins to engage. Normalized length is defined as
                    length_norm = l/l0, where l is the length of the fiber,
                    and l0 is the resting length of the fiber. This length must be
                    greater than 0.

        **Cost **
        The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_setNormLengthAtZeroForce(self, aNormLengthAtZeroForce)

    def setOptionalProperties(self, aStiffnessAtZeroLength, aCurviness):
        r"""
        :type aStiffnessAtZeroLength: float
        :param aStiffnessAtZeroLength:
                   Sets the stiffness of the compressive elastic force length
                   spring when the fiber reaches a normalized length of 0. This
                   stiffness must be less than -1/normLengthAtZeroForce

        :type aCurviness: float
        :param aCurviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure.
            **Cost **
            The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_setOptionalProperties(self, aStiffnessAtZeroLength, aCurviness)

    def isFittedCurveBeingUsed(self):
        r"""
        :rtype: boolean
        :return: true if the optional properties are empty and the fitted curve is
                     being used. This function returns false if the optional properties
                     are filled and are being used to construct the curve.
        """
        return _simulation.FiberCompressiveForceLengthCurve_isFittedCurveBeingUsed(self)

    def calcValue(self, *args):
        r"""
        *Overload 1:*

           Calculates the value of the curve evaluated at the desired normalized fiber
           length.

           :type aNormLength: float
           :param aNormLength::
                           The normalized fiber length used to evaluate the fiber
                           compressive force length curve for the corresponding normalized
                           force. Here aNormLength = l/l0, where l is the length of the fiber and
                           l0 is the resting length of the fiber.  Thus normalized length
                           of 1.0 means the fiber is at its resting length.

           :rtype: float
           :return: the value of the normalized force generated by the fiber

           **Computational Costs**
                   x in curve domain  : ~282 flops
               x in linear section:   ~5 flops


        |

        *Overload 2:*
        Implement the generic OpenSim::Function interface *
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcValue(self, *args)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*

           Calculates the derivative of the fiber force length curve w.r.t.
           to the normalized fiber length.

           :type aNormLength: float
           :param aNormLength::
                           The normalized fiber length used to evaluate the compressive
                           fiber force length curve for the corresponding normalized force. Here
                           aNormLength = l/l0, where l is the length of the fiber and l0
                           is the resting length of the fiber.  Thus normalized length of
                           1.0 means the fiber is at its resting length.

           :type order: int
           :param order:: the order of the derivative. Only values of 0,1 and 2 are
                             acceptable.

           :rtype: float
           :return: the derivative of the normalized fiber force length curve w.r.t.
                   normalized fiber length

           **Computational Costs**
                   x in curve domain  : ~391 flops
               x in linear section:   ~2 flops


        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, aNormLength):
        r"""
        :type aNormLength: float
        :param aNormLength:
                        Here aNormLength = l/l0, where l is the length
                        of the fiber and l0 is the resting length of the fiber.
                        Thus normalized length of 1.0 means the fiber is at its
                        resting length.

        :rtype: float
        :return: Computes the normalized area under the curve. For this curve,
                    this quantity corresponds to the normalized potential energy stored
                    in the fiber compressive force length spring - simply
                    multiply this quantity by the number of NormForce*NormDistance
                    (where NormForce corresponds to the number of
                    Newtons that 1 normalized force corresponds to, and NormDistance
                    is the distance in meters that a normalized value of 1 corresponds
                    to) to obtain the potential energy stored in the fiber in units of
                    Joules.

        **Computational Costs**

                x in curve domain  : ~13 flops
            x in linear section: ~19 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcIntegral(self, aNormLength)

    def getCurveDomain(self):
        r"""
        This function returns a SimTK::Vec2 that contains in its 0th element
        the lowest value of the curve domain, and in its 1st element the highest
        value in the curve domain of the curve. Outside of this domain the curve
        is approximated using linear extrapolation.

        :rtype: :py:class:`Vec2`
        :return: The minimum and maximum value of the domain, x, of the curve
                       y(x). Within this range y(x) is a curve, outside of this range
                       the function y(x) is a C2 (continuous to the second
                       derivative) linear extrapolation
        """
        return _simulation.FiberCompressiveForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        This function will generate a csv file with a name that matches the
               curve name (e.g. "bicepfemoris_FiberCompressiveForceLengthCurve.csv");
               This function is not const to permit the curve to be rebuilt if it is out
               of date with its properties.

               :type path: string
               :param path: The full path to the location. Note '/' slashes must be used,
                        and do not put a '/' after the last folder.

               The file will contain the following columns:

                      Col# 1, 2,     3,       4,  
                    x, y, dy/dx, d2y/dx2,

               The curve will be sampled from its linear extrapolation region
               (the region with normalized fiber velocities < -1), through
               the curve, out to the other linear extrapolation region
               (the region with normalized fiber velocities > 1). The width of
               each linear extrapolation region is 10% of the entire range of x, or
               0.1*(x1-x0).

               The curve is sampled quite densely: there are 200+20 rows

               **Computational Costs**
                           ~194,800 flops

               **Example**
               To read the csv file with a header in from Matlab, you need to use
               csvread set so that it will ignore the header row. This is accomplished
               by using the extra two numerical arguments for csvread to tell the
               function to begin reading from the 1st row, and the 0th index (csvread
               is 0 indexed). This is necessary to skip reading in the text header
                       data=csvread('bicepfemoris_fiberCompressiveForceLengthCurve.csv',1,0);
        """
        return _simulation.FiberCompressiveForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(FiberCompressiveForceLengthCurve self)"""
        return _simulation.FiberCompressiveForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberCompressiveForceLengthCurve

# Register FiberCompressiveForceLengthCurve in _simulation:
_simulation.FiberCompressiveForceLengthCurve_swigregister(FiberCompressiveForceLengthCurve)
class FiberForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberForceLengthCurve, commonly used to
       model the parallel elastic element in muscle models. The fiber-force-length
       curve is dimensionless: force is normalized to maximum isometric force and
       length is normalized to resting fiber length. The user can adjust the
       maximum strain at no load and the strain developed under 1 normalized unit
       of force using the fitted curve. Additionally, if desired, it is possible to
       directly set the low-force stiffness of the fiber, the stiffness of the
       fiber at 1 normalized unit of force, and the shape of the curve (its
       'curviness'):

       ### Properties
       - ``strainAtZeroForce``

           The fiber strain at which the fiber starts to develop force.
           strainAtZeroForce = 0.0 means that the fiber will begin developing
           tension when it is at its resting length.

       - ``strainAtOneNormForce``

           The fiber strain at which the fiber develops 1 unit of normalized force.
           strainAtOneNormForce = 0.6 means that the fiber will develop a tension
           of 1 normalized force when it is strained by 60% of its resting length
           or, equivalently, when it is stretched to 1.6 times its resting length.

       - ``stiffnessAtLowForce``

           The normalized stiffness (slope of the curve) when the fiber is just
           beginning to develop tensile force.

       - ``stiffnessAtOneNormForce``

           The normalized stiffness (slope of the curve) when the fiber develops a
           tension of 1 normalized unit of force.

       - ``curviness``

           A dimensionless parameter between 0 and 1 that describes the shape of
           the curve: a value of 0 indicates a curve that is very close to a
           straight line segment and a value of 1 indicates a curve that smoothly
           fills the corner formed by the linear extrapolation of
           'stiffnessAtOneNormForce' and the x-axis, as shown in the figure.

       Note that we use the Cauchy or engineering definition of strain throughout:
       strain = (l-l0)/l0, where l is the current fiber length and l0 is its
       resting length.

       ### Required Properties
       - ``strainAtZeroForce``
       - ``strainAtOneNormForce``

       ### Optional Properties
       - ``stiffnessAtLowForce``
       - ``stiffnessAtOneNormForce``
       - ``curviness``

       Image: fig_FiberForceLengthCurve.png

       ### Conditions
           strainAtZeroForce < strainAtOneNormForce
       stiffnessAtOneNormForce > 1/(strainAtOneNormForce-strainAtZeroForce)
       0 < stiffnessAtLowForce < stiffnessAtOneNormForce
       0 <= curviness <= 1

       The required parameters can be set using either the constructor or the
       setCurveStrains function; the optional parameters can be set using the
       setOptionalProperties function. Note that filling in one optional parameter
       but not the others will throw an exception when the curve is built. The
       optional parameters can be used to vary the shape of the curve from a close
       approximation of a line to a sharply-bent curve.

       The advantage of this curve over the typical exponential curve used in the
       literature is that it is continuous to the second derivative; the usual
       linearly-extrapolated exponential curve is only C0-continuous. The improved
       smoothness of this curve makes the equations somewhat easier to simulate
       and, more importantly, permits the use of derivative-based numerical methods
       on the curve. In addition, the extra parameters in this curve formulation
       can be adjusted to match a wide variety of shapes, should it be desired to
       fit the curve to a different set of experimental data.

       ### Default Parameter Values
       If the optional parameters are not specified, the curve is fit to the
       experimentally measured fiber-force-length curves of Winters et al. (2010,
       Fig. 3a).

           strainAtZeroForce .......... 0.0
       strainAtOneNormForce ....... 0.7
       stiffnessAtLowForce ........ 0.2
       stiffnessAtOneNormForce .... 2.0 / (strainAtOneNormForce-strainAtZeroForce) = 2.86
       curviness .................. 0.75

       ### Example

       .. code-block:: c++

       Make a fitted fiber-force-length curve.
           FiberForceLengthCurve fpeCurve1;
           fpeCurve1.setCurveStrains(0.0, 0.7);
           double fpeVal1 = fpeCurve1.calcValue(0.1);

       Make a custom fiber-force-length curve by supplying all parameters.
           FiberForceLengthCurve fpeCurve2(0.0, 0.7, 0.2, 2.86, 0.75);
           double fpeVal2  = fpeCurve2.calcValue(0.02);
           double dfpeVal2 = fpeCurve2.calcDerivative(0.02, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       ### References
       - Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
         simulate dynamic contractions in older adults. ASME Journal of
         Biomechanical Engineering 125:70--77.
       - Winters, T.M., Takahashi, M., Lieber, R.L., and Ward, S. (2010) Whole
         muscle length-tension relationships are accurately modeled as scaled
         sarcomeres in rabbit hindlimb muscles. Journal of Biomechanics
         44:109--115.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> FiberForceLengthCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.FiberForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(FiberForceLengthCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.FiberForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.FiberForceLengthCurve_getClassName()

    def clone(self):
        r"""clone(FiberForceLengthCurve self) -> FiberForceLengthCurve"""
        return _simulation.FiberForceLengthCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(FiberForceLengthCurve self) -> std::string const &"""
        return _simulation.FiberForceLengthCurve_getConcreteClassName(self)

    def copyProperty_strain_at_zero_force(self, source):
        r"""
        copyProperty_strain_at_zero_force(FiberForceLengthCurve self, FiberForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberForceLengthCurve::Self const &

        """
        return _simulation.FiberForceLengthCurve_copyProperty_strain_at_zero_force(self, source)

    def append_strain_at_zero_force(self, value):
        r"""
        append_strain_at_zero_force(FiberForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_append_strain_at_zero_force(self, value)

    def constructProperty_strain_at_zero_force(self, initValue):
        r"""
        constructProperty_strain_at_zero_force(FiberForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberForceLengthCurve_constructProperty_strain_at_zero_force(self, initValue)

    def get_strain_at_zero_force(self, *args):
        r"""
        get_strain_at_zero_force(FiberForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_strain_at_zero_force(FiberForceLengthCurve self) -> double const &
        """
        return _simulation.FiberForceLengthCurve_get_strain_at_zero_force(self, *args)

    def upd_strain_at_zero_force(self, *args):
        r"""
        upd_strain_at_zero_force(FiberForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_strain_at_zero_force(FiberForceLengthCurve self) -> double &
        """
        return _simulation.FiberForceLengthCurve_upd_strain_at_zero_force(self, *args)

    def set_strain_at_zero_force(self, *args):
        r"""
        set_strain_at_zero_force(FiberForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_strain_at_zero_force(FiberForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_set_strain_at_zero_force(self, *args)

    def copyProperty_strain_at_one_norm_force(self, source):
        r"""
        copyProperty_strain_at_one_norm_force(FiberForceLengthCurve self, FiberForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberForceLengthCurve::Self const &

        """
        return _simulation.FiberForceLengthCurve_copyProperty_strain_at_one_norm_force(self, source)

    def append_strain_at_one_norm_force(self, value):
        r"""
        append_strain_at_one_norm_force(FiberForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_append_strain_at_one_norm_force(self, value)

    def constructProperty_strain_at_one_norm_force(self, initValue):
        r"""
        constructProperty_strain_at_one_norm_force(FiberForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberForceLengthCurve_constructProperty_strain_at_one_norm_force(self, initValue)

    def get_strain_at_one_norm_force(self, *args):
        r"""
        get_strain_at_one_norm_force(FiberForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_strain_at_one_norm_force(FiberForceLengthCurve self) -> double const &
        """
        return _simulation.FiberForceLengthCurve_get_strain_at_one_norm_force(self, *args)

    def upd_strain_at_one_norm_force(self, *args):
        r"""
        upd_strain_at_one_norm_force(FiberForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_strain_at_one_norm_force(FiberForceLengthCurve self) -> double &
        """
        return _simulation.FiberForceLengthCurve_upd_strain_at_one_norm_force(self, *args)

    def set_strain_at_one_norm_force(self, *args):
        r"""
        set_strain_at_one_norm_force(FiberForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_strain_at_one_norm_force(FiberForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_set_strain_at_one_norm_force(self, *args)

    def copyProperty_stiffness_at_low_force(self, source):
        r"""
        copyProperty_stiffness_at_low_force(FiberForceLengthCurve self, FiberForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberForceLengthCurve::Self const &

        """
        return _simulation.FiberForceLengthCurve_copyProperty_stiffness_at_low_force(self, source)

    def append_stiffness_at_low_force(self, value):
        r"""
        append_stiffness_at_low_force(FiberForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_append_stiffness_at_low_force(self, value)

    def constructProperty_stiffness_at_low_force(self, *args):
        r"""
        constructProperty_stiffness_at_low_force(FiberForceLengthCurve self)
        constructProperty_stiffness_at_low_force(FiberForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberForceLengthCurve_constructProperty_stiffness_at_low_force(self, *args)

    def get_stiffness_at_low_force(self, *args):
        r"""
        get_stiffness_at_low_force(FiberForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness_at_low_force(FiberForceLengthCurve self) -> double const &
        """
        return _simulation.FiberForceLengthCurve_get_stiffness_at_low_force(self, *args)

    def upd_stiffness_at_low_force(self, *args):
        r"""
        upd_stiffness_at_low_force(FiberForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness_at_low_force(FiberForceLengthCurve self) -> double &
        """
        return _simulation.FiberForceLengthCurve_upd_stiffness_at_low_force(self, *args)

    def set_stiffness_at_low_force(self, *args):
        r"""
        set_stiffness_at_low_force(FiberForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness_at_low_force(FiberForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_set_stiffness_at_low_force(self, *args)

    def copyProperty_stiffness_at_one_norm_force(self, source):
        r"""
        copyProperty_stiffness_at_one_norm_force(FiberForceLengthCurve self, FiberForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberForceLengthCurve::Self const &

        """
        return _simulation.FiberForceLengthCurve_copyProperty_stiffness_at_one_norm_force(self, source)

    def append_stiffness_at_one_norm_force(self, value):
        r"""
        append_stiffness_at_one_norm_force(FiberForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_append_stiffness_at_one_norm_force(self, value)

    def constructProperty_stiffness_at_one_norm_force(self, *args):
        r"""
        constructProperty_stiffness_at_one_norm_force(FiberForceLengthCurve self)
        constructProperty_stiffness_at_one_norm_force(FiberForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberForceLengthCurve_constructProperty_stiffness_at_one_norm_force(self, *args)

    def get_stiffness_at_one_norm_force(self, *args):
        r"""
        get_stiffness_at_one_norm_force(FiberForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness_at_one_norm_force(FiberForceLengthCurve self) -> double const &
        """
        return _simulation.FiberForceLengthCurve_get_stiffness_at_one_norm_force(self, *args)

    def upd_stiffness_at_one_norm_force(self, *args):
        r"""
        upd_stiffness_at_one_norm_force(FiberForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness_at_one_norm_force(FiberForceLengthCurve self) -> double &
        """
        return _simulation.FiberForceLengthCurve_upd_stiffness_at_one_norm_force(self, *args)

    def set_stiffness_at_one_norm_force(self, *args):
        r"""
        set_stiffness_at_one_norm_force(FiberForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness_at_one_norm_force(FiberForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_set_stiffness_at_one_norm_force(self, *args)

    def copyProperty_curviness(self, source):
        r"""
        copyProperty_curviness(FiberForceLengthCurve self, FiberForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::FiberForceLengthCurve::Self const &

        """
        return _simulation.FiberForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value):
        r"""
        append_curviness(FiberForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args):
        r"""
        constructProperty_curviness(FiberForceLengthCurve self)
        constructProperty_curviness(FiberForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.FiberForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args):
        r"""
        get_curviness(FiberForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_curviness(FiberForceLengthCurve self) -> double const &
        """
        return _simulation.FiberForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args):
        r"""
        upd_curviness(FiberForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_curviness(FiberForceLengthCurve self) -> double &
        """
        return _simulation.FiberForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args):
        r"""
        set_curviness(FiberForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_curviness(FiberForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.FiberForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a fiber-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a fiber-force-length curve using the provided parameters and
           assigns a default name. See class documentation for the meaning of these
           parameters, each of which corresponds to a property.
        """
        _simulation.FiberForceLengthCurve_swiginit(self, _simulation.new_FiberForceLengthCurve(*args))

    def getStrainAtZeroForce(self):
        r"""
        :rtype: float
        :return: The fiber strain at which the fiber starts to develop force.
               strainAtZeroForce = 0.0 means that the fiber will begin developing tension
               when it is at its resting length. This property is set to 0 by default.
        """
        return _simulation.FiberForceLengthCurve_getStrainAtZeroForce(self)

    def getStrainAtOneNormForce(self):
        r"""
        :rtype: float
        :return: The fiber strain at which the fiber develops 1 unit of
               normalized force. strainAtOneNormForce = 0.6 means that the fiber will
               develop a tension of 1 normalized force when it is strained by 60% of its
               resting length or, equivalently, when it is stretched to 1.6 times its
               resting length. This property is set to 0.6 by default.
        """
        return _simulation.FiberForceLengthCurve_getStrainAtOneNormForce(self)

    def getStiffnessAtLowForceInUse(self):
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the curve) when the fiber is
               just beginning to develop tensile force. This property is set to 0.125 by
               default.
        """
        return _simulation.FiberForceLengthCurve_getStiffnessAtLowForceInUse(self)

    def getStiffnessAtOneNormForceInUse(self):
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the curve) when the fiber
               develops a tension of 1 normalized unit of force. This property is set to
               5.0 by default.
        """
        return _simulation.FiberForceLengthCurve_getStiffnessAtOneNormForceInUse(self)

    def getCurvinessInUse(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the curve: a value of 0 indicates a curve that is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly fills
               the corner formed by the linear extrapolation of 'stiffnessAtOneNormForce'
               and the x-axis, as shown in the figure in the class description. This
               property is set to 0.75 by default.
        """
        return _simulation.FiberForceLengthCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self):
        r"""
        :rtype: boolean
        :return: True if the optional properties are empty and the fitted curve
               is being used, false if the optional properties are filled and are being
               used to construct the curve.
        """
        return _simulation.FiberForceLengthCurve_isFittedCurveBeingUsed(self)

    def setCurveStrains(self, aStrainAtZeroForce, aStrainAtOneNormForce):
        r"""
        :type aStrainAtZeroForce: float
        :param aStrainAtZeroForce:
                The fiber strain at which the fiber starts to develop force.
                strainAtZeroForce = 0.0 means that the fiber will begin developing
                tension when it is at its resting length.
        :type aStrainAtOneNormForce: float
        :param aStrainAtOneNormForce:
                The fiber strain at which the fiber develops 1 unit of normalized force.
                strainAtOneNormForce = 0.6 means that the fiber will develop a tension
                of 1 normalized force when it is strained by 60% of its resting length
                or, equivalently, when it is stretched to 1.6 times its resting length.

        **Conditions**
            strainAtZeroForce < strainAtOneNormForce
        """
        return _simulation.FiberForceLengthCurve_setCurveStrains(self, aStrainAtZeroForce, aStrainAtOneNormForce)

    def setOptionalProperties(self, stiffnessAtLowForce, stiffnessAtOneNormForce, curviness):
        r"""
        :type stiffnessAtLowForce: float
        :param stiffnessAtLowForce:
                The normalized stiffness (slope of the curve) when the fiber is just
                beginning to develop tensile force.
        :type stiffnessAtOneNormForce: float
        :param stiffnessAtOneNormForce:
                The normalized stiffness (slope of the curve) when the fiber develops a
                tension of 1 normalized unit of force.
        :type curviness: float
        :param curviness:
                A dimensionless parameter between 0 and 1 that controls the shape of the
                curve: a value of 0 will create a curve that is very close to a straight
                line segment and a value of 1 will create a curve that smoothly fills
                the corner formed by the linear extrapolation of
                'stiffnessAtOneNormForce' and the x-axis, as shown in the figure in the
                class description.

        **Conditions**
            stiffnessAtOneNormForce > 1/(strainAtOneNormForce-strainAtZeroForce)
        0 < stiffnessAtLowForce < stiffnessAtOneNormForce
        0 <= curviness <= 1
        """
        return _simulation.FiberForceLengthCurve_setOptionalProperties(self, stiffnessAtLowForce, stiffnessAtOneNormForce, curviness)

    def calcValue(self, *args):
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the fiber-force-length curve at a normalized fiber length of
           'normFiberLength'.
        """
        return _simulation.FiberForceLengthCurve_calcValue(self, *args)

    def calcValueAndDerivative(self, normFiberLength):
        r"""
        Evaluates the fiber-force-length curve value and derivative at a
           normalized fiber length of 'normFiberLength'.
        """
        return _simulation.FiberForceLengthCurve_calcValueAndDerivative(self, normFiberLength)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*
        Calculates the derivative of the fiber-force-length multiplier with
           respect to the normalized fiber length.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the fiber-force-length curve with respect to the
                   normalized fiber length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, normFiberLength):
        r"""
        Calculates the normalized area under the curve. Since it is expensive to
           construct, the curve is built only when necessary.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :rtype: float
           :return: The normalized area under the curve, which corresponds to the
                   normalized potential energy stored in the fiber. To calculate the
                   potential energy stored in the fiber in units of Joules, multiply the
                   returned quantity by normForce*normLength (where normForce is the number
                   of Newtons represented by a normalized force of 1.0 and normLength is
                   the number of meters represented by a normalized length of 1.0).
        """
        return _simulation.FiberForceLengthCurve_calcIntegral(self, normFiberLength)

    def getCurveDomain(self):
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.FiberForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_FiberForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the zero-force region, through the curve, out to
           strains beyond which the fiber generates passive normalized forces greater
           than 1. The curve is sampled quite densely: the fiber-force-length .csv file
           will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_FiberForceLengthCurve.csv', 1, 0);
        """
        return _simulation.FiberForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(FiberForceLengthCurve self)"""
        return _simulation.FiberForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberForceLengthCurve

# Register FiberForceLengthCurve in _simulation:
_simulation.FiberForceLengthCurve_swigregister(FiberForceLengthCurve)
class ForceVelocityCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ForceVelocityCurve for use in muscle
       models. The force-velocity curve is dimensionless: force is normalized to
       maximum isometric force and velocity is normalized to the maximum muscle
       contraction velocity (vmax), where vmax is expressed in units of
       optimal_fiber_lengths per second. Negative normalized velocities correspond
       to concentric contraction (i.e., shortening). The force-velocity curve is
       constructed from 8 properties:

       :param concentricSlopeAtVmax:
               The slope of the force-velocity curve at a normalized velocity of -1,
               which is the minimum slope of the concentric side of the force-velocity
               curve. A physiologically accurate value for this parameter is 0, though
               values greater than 0 are necessary when the force-velocity curve must
               be inverted.
       :param concentricSlopeNearVmax:
               The slope of the force-velocity curve near the maximum normalized
               concentric (shortening) contraction velocity (between approximately -0.8
               and -1).
       :param isometricSlope:
               The slope of the force-velocity curve at a normalized velocity of 0,
               which is the maximum slope of the force-velocity curve. A
               physiologically accurate value for this parameter is 5 (according to
               Lieber, page 55), which is the default value. Although this parameter
               can be changed, it must be positive and greater than
               max( (maxEccentricMultiplier-1)/1, 1). The value of this parameter also
               affects how much the eccentric and concentric curves can be bent by the
               'eccentricCurviness' and 'concentricCurviness' parameters, as it places
               an upper limit on the maximum slope of the force-velocity curve.
       :param eccentricSlopeAtVmax:
               The slope of the force-velocity curve at a normalized velocity of 1,
               which is the minimum slope of the eccentric side of the force-velocity
               curve.
       :param eccentricSlopeNearVmax:
               The slope of the force-velocity curve near the maximum normalized
               eccentric (lengthening) contraction velocity (between approximately 0.8
               and 1).
       :param maxEccentricVelocityForceMultiplier:
               The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
               Physiologically accurate values for this parameter range between 1.1
               and 1.8, and may vary between subjects.
       :param concentricCurviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the concentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure.
       :param eccentricCurviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the eccentric curve: a value of 0 indicates that the curve is very close
               to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure.

       Image: fig_ForceVelocityCurve.png

       **Conditions**
            1)  0 <= concentricSlopeAtVmax < 1
       2a)  1 < isometricSlope
       2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3)  0 <= eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        4)  1 < maxEccentricVelocityForceMultiplier
        5)  0 <= concentricCurviness <= 1
        6)  0 <= eccentricCurviness <= 1

       **Default Parameter Values**
           concentricSlopeAtVmax .................. 0.0
       concentricSlopeNearVmax ................ 0.25
       isometricSlope ......................... 5.0
       eccentricSlopeAtVmax ................... 0.0
       eccentricSlopeNearVmax ................. 0.15
       maxEccentricVelocityForceMultiplier .... 1.4
       concentricCurviness .................... 0.6
       eccentricCurviness ..................... 0.9

       **Example**

       .. code-block:: c++

               ForceVelocityCurve fvCurve(0.0, 0.25, 5.0, 0.0, 0.15, 1.4, 0.6, 0.9);
               double falVal  = fvCurve.calcValue(1.0);
               double dfalVal = fvCurve.calcDerivative(1.0, 1);

       **References**
       * Lieber, R.L. (2010) Skeletal %Muscle Structure, %Function, and
           Plasticity: The Physiological Basis of Rehabilitation, 3rd ed.
           Baltimore: Lippincott Williams & Wilkins.

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ForceVelocityCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ForceVelocityCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ForceVelocityCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ForceVelocityCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ForceVelocityCurve_getClassName()

    def clone(self):
        r"""clone(ForceVelocityCurve self) -> ForceVelocityCurve"""
        return _simulation.ForceVelocityCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ForceVelocityCurve self) -> std::string const &"""
        return _simulation.ForceVelocityCurve_getConcreteClassName(self)

    def copyProperty_concentric_slope_at_vmax(self, source):
        r"""
        copyProperty_concentric_slope_at_vmax(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_concentric_slope_at_vmax(self, source)

    def append_concentric_slope_at_vmax(self, value):
        r"""
        append_concentric_slope_at_vmax(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_concentric_slope_at_vmax(self, value)

    def constructProperty_concentric_slope_at_vmax(self, initValue):
        r"""
        constructProperty_concentric_slope_at_vmax(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_concentric_slope_at_vmax(self, initValue)

    def get_concentric_slope_at_vmax(self, *args):
        r"""
        get_concentric_slope_at_vmax(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_slope_at_vmax(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_concentric_slope_at_vmax(self, *args)

    def upd_concentric_slope_at_vmax(self, *args):
        r"""
        upd_concentric_slope_at_vmax(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_slope_at_vmax(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_concentric_slope_at_vmax(self, *args)

    def set_concentric_slope_at_vmax(self, *args):
        r"""
        set_concentric_slope_at_vmax(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_slope_at_vmax(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_concentric_slope_at_vmax(self, *args)

    def copyProperty_concentric_slope_near_vmax(self, source):
        r"""
        copyProperty_concentric_slope_near_vmax(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_concentric_slope_near_vmax(self, source)

    def append_concentric_slope_near_vmax(self, value):
        r"""
        append_concentric_slope_near_vmax(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_concentric_slope_near_vmax(self, value)

    def constructProperty_concentric_slope_near_vmax(self, initValue):
        r"""
        constructProperty_concentric_slope_near_vmax(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_concentric_slope_near_vmax(self, initValue)

    def get_concentric_slope_near_vmax(self, *args):
        r"""
        get_concentric_slope_near_vmax(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_slope_near_vmax(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_concentric_slope_near_vmax(self, *args)

    def upd_concentric_slope_near_vmax(self, *args):
        r"""
        upd_concentric_slope_near_vmax(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_slope_near_vmax(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_concentric_slope_near_vmax(self, *args)

    def set_concentric_slope_near_vmax(self, *args):
        r"""
        set_concentric_slope_near_vmax(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_slope_near_vmax(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_concentric_slope_near_vmax(self, *args)

    def copyProperty_isometric_slope(self, source):
        r"""
        copyProperty_isometric_slope(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_isometric_slope(self, source)

    def append_isometric_slope(self, value):
        r"""
        append_isometric_slope(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_isometric_slope(self, value)

    def constructProperty_isometric_slope(self, initValue):
        r"""
        constructProperty_isometric_slope(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_isometric_slope(self, initValue)

    def get_isometric_slope(self, *args):
        r"""
        get_isometric_slope(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_isometric_slope(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_isometric_slope(self, *args)

    def upd_isometric_slope(self, *args):
        r"""
        upd_isometric_slope(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_isometric_slope(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_isometric_slope(self, *args)

    def set_isometric_slope(self, *args):
        r"""
        set_isometric_slope(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_isometric_slope(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_isometric_slope(self, *args)

    def copyProperty_eccentric_slope_at_vmax(self, source):
        r"""
        copyProperty_eccentric_slope_at_vmax(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_slope_at_vmax(self, source)

    def append_eccentric_slope_at_vmax(self, value):
        r"""
        append_eccentric_slope_at_vmax(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_eccentric_slope_at_vmax(self, value)

    def constructProperty_eccentric_slope_at_vmax(self, initValue):
        r"""
        constructProperty_eccentric_slope_at_vmax(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_slope_at_vmax(self, initValue)

    def get_eccentric_slope_at_vmax(self, *args):
        r"""
        get_eccentric_slope_at_vmax(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_slope_at_vmax(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_eccentric_slope_at_vmax(self, *args)

    def upd_eccentric_slope_at_vmax(self, *args):
        r"""
        upd_eccentric_slope_at_vmax(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_slope_at_vmax(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_eccentric_slope_at_vmax(self, *args)

    def set_eccentric_slope_at_vmax(self, *args):
        r"""
        set_eccentric_slope_at_vmax(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_slope_at_vmax(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_eccentric_slope_at_vmax(self, *args)

    def copyProperty_eccentric_slope_near_vmax(self, source):
        r"""
        copyProperty_eccentric_slope_near_vmax(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_slope_near_vmax(self, source)

    def append_eccentric_slope_near_vmax(self, value):
        r"""
        append_eccentric_slope_near_vmax(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_eccentric_slope_near_vmax(self, value)

    def constructProperty_eccentric_slope_near_vmax(self, initValue):
        r"""
        constructProperty_eccentric_slope_near_vmax(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_slope_near_vmax(self, initValue)

    def get_eccentric_slope_near_vmax(self, *args):
        r"""
        get_eccentric_slope_near_vmax(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_slope_near_vmax(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_eccentric_slope_near_vmax(self, *args)

    def upd_eccentric_slope_near_vmax(self, *args):
        r"""
        upd_eccentric_slope_near_vmax(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_slope_near_vmax(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_eccentric_slope_near_vmax(self, *args)

    def set_eccentric_slope_near_vmax(self, *args):
        r"""
        set_eccentric_slope_near_vmax(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_slope_near_vmax(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_eccentric_slope_near_vmax(self, *args)

    def copyProperty_max_eccentric_velocity_force_multiplier(self, source):
        r"""
        copyProperty_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_max_eccentric_velocity_force_multiplier(self, source)

    def append_max_eccentric_velocity_force_multiplier(self, value):
        r"""
        append_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_max_eccentric_velocity_force_multiplier(self, value)

    def constructProperty_max_eccentric_velocity_force_multiplier(self, initValue):
        r"""
        constructProperty_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_max_eccentric_velocity_force_multiplier(self, initValue)

    def get_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        get_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_max_eccentric_velocity_force_multiplier(self, *args)

    def upd_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        upd_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_max_eccentric_velocity_force_multiplier(self, *args)

    def set_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        set_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_eccentric_velocity_force_multiplier(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_max_eccentric_velocity_force_multiplier(self, *args)

    def copyProperty_concentric_curviness(self, source):
        r"""
        copyProperty_concentric_curviness(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_concentric_curviness(self, source)

    def append_concentric_curviness(self, value):
        r"""
        append_concentric_curviness(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_concentric_curviness(self, value)

    def constructProperty_concentric_curviness(self, initValue):
        r"""
        constructProperty_concentric_curviness(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_concentric_curviness(self, initValue)

    def get_concentric_curviness(self, *args):
        r"""
        get_concentric_curviness(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_curviness(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_concentric_curviness(self, *args)

    def upd_concentric_curviness(self, *args):
        r"""
        upd_concentric_curviness(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_curviness(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_concentric_curviness(self, *args)

    def set_concentric_curviness(self, *args):
        r"""
        set_concentric_curviness(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_curviness(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_concentric_curviness(self, *args)

    def copyProperty_eccentric_curviness(self, source):
        r"""
        copyProperty_eccentric_curviness(ForceVelocityCurve self, ForceVelocityCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityCurve::Self const &

        """
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_curviness(self, source)

    def append_eccentric_curviness(self, value):
        r"""
        append_eccentric_curviness(ForceVelocityCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_append_eccentric_curviness(self, value)

    def constructProperty_eccentric_curviness(self, initValue):
        r"""
        constructProperty_eccentric_curviness(ForceVelocityCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_curviness(self, initValue)

    def get_eccentric_curviness(self, *args):
        r"""
        get_eccentric_curviness(ForceVelocityCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_curviness(ForceVelocityCurve self) -> double const &
        """
        return _simulation.ForceVelocityCurve_get_eccentric_curviness(self, *args)

    def upd_eccentric_curviness(self, *args):
        r"""
        upd_eccentric_curviness(ForceVelocityCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_curviness(ForceVelocityCurve self) -> double &
        """
        return _simulation.ForceVelocityCurve_upd_eccentric_curviness(self, *args)

    def set_eccentric_curviness(self, *args):
        r"""
        set_eccentric_curviness(ForceVelocityCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_curviness(ForceVelocityCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityCurve_set_eccentric_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a force-velocity curve using the default
           property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a force-velocity curve using the provided parameters and
           assigns a default name.
        """
        _simulation.ForceVelocityCurve_swiginit(self, _simulation.new_ForceVelocityCurve(*args))

    def getConcentricSlopeAtVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of -1, which is the minimum slope of the concentric side of the
               force-velocity curve.
        """
        return _simulation.ForceVelocityCurve_getConcentricSlopeAtVmax(self)

    def getConcentricSlopeNearVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized concentric (shortening) contraction velocity (between
               approximately -0.8 and -1).
        """
        return _simulation.ForceVelocityCurve_getConcentricSlopeNearVmax(self)

    def getIsometricSlope(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 0, which is the maximum slope of the force-velocity curve.
        """
        return _simulation.ForceVelocityCurve_getIsometricSlope(self)

    def getEccentricSlopeAtVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 1, which is the minimum slope of the eccentric side of the force-velocity
               curve.
        """
        return _simulation.ForceVelocityCurve_getEccentricSlopeAtVmax(self)

    def getEccentricSlopeNearVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized eccentric (lengthening) contraction velocity (between
               approximately 0.8 and 1).
        """
        return _simulation.ForceVelocityCurve_getEccentricSlopeNearVmax(self)

    def getMaxEccentricVelocityForceMultiplier(self):
        r"""
        :rtype: float
        :return: The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
        """
        return _simulation.ForceVelocityCurve_getMaxEccentricVelocityForceMultiplier(self)

    def getConcentricCurviness(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the concentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure in
               the class description.
        """
        return _simulation.ForceVelocityCurve_getConcentricCurviness(self)

    def getEccentricCurviness(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the eccentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure in the
               class description.
        """
        return _simulation.ForceVelocityCurve_getEccentricCurviness(self)

    def setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier):
        r"""
        :type aConcentricSlopeAtVmax: float
        :param aConcentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of -1,
                which is the minimum slope of the concentric side of the force-velocity
                curve.
        :type aConcentricSlopeNearVmax: float
        :param aConcentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                concentric (shortening) contraction velocity (between approximately
                -0.8 and -1).
        :type aIsometricSlope: float
        :param aIsometricSlope:
                The slope of the force-velocity curve at a normalized velocity of 0,
                which is the maximum slope of the force-velocity curve.
        :type aEccentricSlopeAtVmax: float
        :param aEccentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of 1,
                which is the minimum slope of the eccentric side of the force-velocity
                curve.
        :type aEccentricSlopeNearVmax: float
        :param aEccentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                eccentric (lengthening) contraction velocity (between approximately 0.8
                and 1).
        :type aMaxForceMultiplier: float
        :param aMaxForceMultiplier:
                The value of the force-velocity curve (i.e., the force-velocity
                multiplier) at the maximum eccentric contraction velocity.

        **Conditions**
            1a)  0 <= concentricSlopeAtVmax < 1
        1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
        2a)  1 < isometricSlope
        2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3a)  0 <= eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        3b)  eccentricSlopeAtVmax < eccentricSlopeNearVmax < (maxEccentricVelocityForceMultiplier-1)/1
         4)  1 < maxEccentricVelocityForceMultiplier
        """
        return _simulation.ForceVelocityCurve_setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier)

    def setConcentricCurviness(self, aConcentricCurviness):
        r"""
        :type aConcentricCurviness: float
        :param aConcentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the concentric curve: a value of 0 indicates that the curve is very
                close to a straight line segment and a value of 1 indicates a curve that
                smoothly fills the corner formed by the linear extrapolation of
                'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure
                in the class description.

        **Conditions**
            0 <= concentricCurviness <= 1
        """
        return _simulation.ForceVelocityCurve_setConcentricCurviness(self, aConcentricCurviness)

    def setEccentricCurviness(self, aEccentricCurviness):
        r"""
        :type aEccentricCurviness: float
        :param aEccentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the eccentric curve: a value of 0 indicates that the curve is very close
                to a straight line segment and a value of 1 indicates a curve that
                smoothly fills the corner formed by the linear extrapolation of
                'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure in
                the class description.

        **Conditions**
            0 <= eccentricCurviness <= 1
        """
        return _simulation.ForceVelocityCurve_setEccentricCurviness(self, aEccentricCurviness)

    def calcValue(self, *args):
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the force-velocity curve at a normalized fiber velocity of
           'normFiberVelocity'.
        """
        return _simulation.ForceVelocityCurve_calcValue(self, *args)

    def calcValueAndDerivative(self, normFiberVelocity):
        r"""
        Evaluates the force-velocity curve value and derivative at a normalized
           fiber velocity of 'normFiberVelocity'.
        """
        return _simulation.ForceVelocityCurve_calcValueAndDerivative(self, normFiberVelocity)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*
        Calculates the derivative of the force-velocity multiplier with respect
           to the normalized fiber velocity.
           :type normFiberVelocity: float
           :param normFiberVelocity:
                   The normalized velocity of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the force-velocity curve with respect to the
                   normalized fiber velocity.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ForceVelocityCurve_calcDerivative(self, *args)

    def getCurveDomain(self):
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ForceVelocityCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ForceVelocityCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the concentric linear extrapolation region (the
           region with normalized fiber velocities < -1), through the curve, out to the
           eccentric linear extrapolation region (the region with normalized fiber
           velocities > 1). The width of each linear extrapolation region is 10% of the
           curve domain, or 0.1*(x1-x0). The curve is sampled quite densely: the
           force-velocity .csv file will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ForceVelocityCurve.csv', 1, 0);
        """
        return _simulation.ForceVelocityCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(ForceVelocityCurve self)"""
        return _simulation.ForceVelocityCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ForceVelocityCurve

# Register ForceVelocityCurve in _simulation:
_simulation.ForceVelocityCurve_swigregister(ForceVelocityCurve)
class ForceVelocityInverseCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ForceVelocityInverseCurve for use in
       equilibrium muscle models. The inverse force-velocity curve is
       dimensionless: force is normalized to maximum isometric force and velocity
       is normalized to the maximum muscle contraction velocity (vmax), where vmax
       is expressed in units of optimal_fiber_lengths per second. Negative
       normalized velocities correspond to concentric contraction (i.e.,
       shortening). The inverse force-velocity curve is constructed from 8
       properties, which are identical to those used to construct the
       corresponding force-velocity curve. See ForceVelocityCurve for descriptions
       of these parameters.

       :param concentricSlopeAtVmax:
               An exception will be thrown if this parameter is set to 0.
       :param concentricSlopeNearVmax:
               An exception will be thrown if this parameter is set to 0.
       :param isometricSlope:
       :param eccentricSlopeAtVmax:
               An exception will be thrown if this parameter is set to 0.
       :param eccentricSlopeNearVmax:
               An exception will be thrown if this parameter is set to 0.
       :param maxEccentricVelocityForceMultiplier:
       :param concentricCurviness:
       :param eccentricCurviness:

       Image: fig_ForceVelocityInverseCurve.png


       Image: fig_ForceVelocityCurve.png

       **Conditions**
           1a)  0 < concentricSlopeAtVmax < 1
       1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
       2a)  1 < isometricSlope
       2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricSlope
        3)  0 < eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        4)  1 < maxEccentricVelocityForceMultiplier
        5)  0 <= concentricCurviness <= 1
        6)  0 <= eccentricCurviness <= 1

       **Default Parameter Values**
           concentricSlopeAtVmax .................. 0.1
       concentricSlopeNearVmax ................ 0.25
       isometricSlope ......................... 5.0
       eccentricSlopeAtVmax ................... 0.1
       eccentricSlopeNearVmax ................. 0.15
       maxEccentricVelocityForceMultiplier .... 1.4
       concentricCurviness .................... 0.6
       eccentricCurviness ..................... 0.9

       **Example**

       .. code-block:: c++

               ForceVelocityInverseCurve fvInvCurve(0.1, 0.25, 5.0, 0.1, 0.15, 1.4, 0.6, 0.9);
               double fvInvVal  = fvInvCurve.calcValue(1.0);
               double dfvInvVal = fvInvCurve.calcDerivative(1.0, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ForceVelocityInverseCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.ForceVelocityInverseCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ForceVelocityInverseCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.ForceVelocityInverseCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.ForceVelocityInverseCurve_getClassName()

    def clone(self):
        r"""clone(ForceVelocityInverseCurve self) -> ForceVelocityInverseCurve"""
        return _simulation.ForceVelocityInverseCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ForceVelocityInverseCurve self) -> std::string const &"""
        return _simulation.ForceVelocityInverseCurve_getConcreteClassName(self)

    def copyProperty_concentric_slope_at_vmax(self, source):
        r"""
        copyProperty_concentric_slope_at_vmax(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_slope_at_vmax(self, source)

    def append_concentric_slope_at_vmax(self, value):
        r"""
        append_concentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_concentric_slope_at_vmax(self, value)

    def constructProperty_concentric_slope_at_vmax(self, initValue):
        r"""
        constructProperty_concentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_slope_at_vmax(self, initValue)

    def get_concentric_slope_at_vmax(self, *args):
        r"""
        get_concentric_slope_at_vmax(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_slope_at_vmax(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_concentric_slope_at_vmax(self, *args)

    def upd_concentric_slope_at_vmax(self, *args):
        r"""
        upd_concentric_slope_at_vmax(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_slope_at_vmax(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_concentric_slope_at_vmax(self, *args)

    def set_concentric_slope_at_vmax(self, *args):
        r"""
        set_concentric_slope_at_vmax(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_concentric_slope_at_vmax(self, *args)

    def copyProperty_concentric_slope_near_vmax(self, source):
        r"""
        copyProperty_concentric_slope_near_vmax(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_slope_near_vmax(self, source)

    def append_concentric_slope_near_vmax(self, value):
        r"""
        append_concentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_concentric_slope_near_vmax(self, value)

    def constructProperty_concentric_slope_near_vmax(self, initValue):
        r"""
        constructProperty_concentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_slope_near_vmax(self, initValue)

    def get_concentric_slope_near_vmax(self, *args):
        r"""
        get_concentric_slope_near_vmax(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_slope_near_vmax(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_concentric_slope_near_vmax(self, *args)

    def upd_concentric_slope_near_vmax(self, *args):
        r"""
        upd_concentric_slope_near_vmax(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_slope_near_vmax(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_concentric_slope_near_vmax(self, *args)

    def set_concentric_slope_near_vmax(self, *args):
        r"""
        set_concentric_slope_near_vmax(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_concentric_slope_near_vmax(self, *args)

    def copyProperty_isometric_slope(self, source):
        r"""
        copyProperty_isometric_slope(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_isometric_slope(self, source)

    def append_isometric_slope(self, value):
        r"""
        append_isometric_slope(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_isometric_slope(self, value)

    def constructProperty_isometric_slope(self, initValue):
        r"""
        constructProperty_isometric_slope(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_isometric_slope(self, initValue)

    def get_isometric_slope(self, *args):
        r"""
        get_isometric_slope(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_isometric_slope(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_isometric_slope(self, *args)

    def upd_isometric_slope(self, *args):
        r"""
        upd_isometric_slope(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_isometric_slope(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_isometric_slope(self, *args)

    def set_isometric_slope(self, *args):
        r"""
        set_isometric_slope(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_isometric_slope(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_isometric_slope(self, *args)

    def copyProperty_eccentric_slope_at_vmax(self, source):
        r"""
        copyProperty_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_slope_at_vmax(self, source)

    def append_eccentric_slope_at_vmax(self, value):
        r"""
        append_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_eccentric_slope_at_vmax(self, value)

    def constructProperty_eccentric_slope_at_vmax(self, initValue):
        r"""
        constructProperty_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_slope_at_vmax(self, initValue)

    def get_eccentric_slope_at_vmax(self, *args):
        r"""
        get_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_slope_at_vmax(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_eccentric_slope_at_vmax(self, *args)

    def upd_eccentric_slope_at_vmax(self, *args):
        r"""
        upd_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_slope_at_vmax(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_slope_at_vmax(self, *args)

    def set_eccentric_slope_at_vmax(self, *args):
        r"""
        set_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_slope_at_vmax(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_eccentric_slope_at_vmax(self, *args)

    def copyProperty_eccentric_slope_near_vmax(self, source):
        r"""
        copyProperty_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_slope_near_vmax(self, source)

    def append_eccentric_slope_near_vmax(self, value):
        r"""
        append_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_eccentric_slope_near_vmax(self, value)

    def constructProperty_eccentric_slope_near_vmax(self, initValue):
        r"""
        constructProperty_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_slope_near_vmax(self, initValue)

    def get_eccentric_slope_near_vmax(self, *args):
        r"""
        get_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_slope_near_vmax(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_eccentric_slope_near_vmax(self, *args)

    def upd_eccentric_slope_near_vmax(self, *args):
        r"""
        upd_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_slope_near_vmax(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_slope_near_vmax(self, *args)

    def set_eccentric_slope_near_vmax(self, *args):
        r"""
        set_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_slope_near_vmax(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_eccentric_slope_near_vmax(self, *args)

    def copyProperty_max_eccentric_velocity_force_multiplier(self, source):
        r"""
        copyProperty_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_max_eccentric_velocity_force_multiplier(self, source)

    def append_max_eccentric_velocity_force_multiplier(self, value):
        r"""
        append_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_max_eccentric_velocity_force_multiplier(self, value)

    def constructProperty_max_eccentric_velocity_force_multiplier(self, initValue):
        r"""
        constructProperty_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_max_eccentric_velocity_force_multiplier(self, initValue)

    def get_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        get_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_max_eccentric_velocity_force_multiplier(self, *args)

    def upd_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        upd_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_max_eccentric_velocity_force_multiplier(self, *args)

    def set_max_eccentric_velocity_force_multiplier(self, *args):
        r"""
        set_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_max_eccentric_velocity_force_multiplier(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_max_eccentric_velocity_force_multiplier(self, *args)

    def copyProperty_concentric_curviness(self, source):
        r"""
        copyProperty_concentric_curviness(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_curviness(self, source)

    def append_concentric_curviness(self, value):
        r"""
        append_concentric_curviness(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_concentric_curviness(self, value)

    def constructProperty_concentric_curviness(self, initValue):
        r"""
        constructProperty_concentric_curviness(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_curviness(self, initValue)

    def get_concentric_curviness(self, *args):
        r"""
        get_concentric_curviness(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_concentric_curviness(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_concentric_curviness(self, *args)

    def upd_concentric_curviness(self, *args):
        r"""
        upd_concentric_curviness(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_concentric_curviness(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_concentric_curviness(self, *args)

    def set_concentric_curviness(self, *args):
        r"""
        set_concentric_curviness(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_concentric_curviness(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_concentric_curviness(self, *args)

    def copyProperty_eccentric_curviness(self, source):
        r"""
        copyProperty_eccentric_curviness(ForceVelocityInverseCurve self, ForceVelocityInverseCurve source)

        Parameters
        ----------
        source: OpenSim::ForceVelocityInverseCurve::Self const &

        """
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_curviness(self, source)

    def append_eccentric_curviness(self, value):
        r"""
        append_eccentric_curviness(ForceVelocityInverseCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_append_eccentric_curviness(self, value)

    def constructProperty_eccentric_curviness(self, initValue):
        r"""
        constructProperty_eccentric_curviness(ForceVelocityInverseCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_curviness(self, initValue)

    def get_eccentric_curviness(self, *args):
        r"""
        get_eccentric_curviness(ForceVelocityInverseCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_eccentric_curviness(ForceVelocityInverseCurve self) -> double const &
        """
        return _simulation.ForceVelocityInverseCurve_get_eccentric_curviness(self, *args)

    def upd_eccentric_curviness(self, *args):
        r"""
        upd_eccentric_curviness(ForceVelocityInverseCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_eccentric_curviness(ForceVelocityInverseCurve self) -> double &
        """
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_curviness(self, *args)

    def set_eccentric_curviness(self, *args):
        r"""
        set_eccentric_curviness(ForceVelocityInverseCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_eccentric_curviness(ForceVelocityInverseCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.ForceVelocityInverseCurve_set_eccentric_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an inverse force-velocity curve using
           the default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs an inverse force-velocity curve using the provided parameters
           and assigns a default name.
        """
        _simulation.ForceVelocityInverseCurve_swiginit(self, _simulation.new_ForceVelocityInverseCurve(*args))

    def getConcentricSlopeAtVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of -1, which is the minimum slope of the concentric side of the
               force-velocity curve.
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricSlopeAtVmax(self)

    def getConcentricSlopeNearVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized concentric (shortening) contraction velocity (between
               approximately -0.8 and -1).
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricSlopeNearVmax(self)

    def getIsometricSlope(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 0, which is the maximum slope of the force-velocity curve.
        """
        return _simulation.ForceVelocityInverseCurve_getIsometricSlope(self)

    def getEccentricSlopeAtVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 1, which is the minimum slope of the eccentric side of the force-velocity
               curve.
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricSlopeAtVmax(self)

    def getEccentricSlopeNearVmax(self):
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized eccentric (lengthening) contraction velocity (between
               approximately 0.8 and 1).
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricSlopeNearVmax(self)

    def getMaxEccentricVelocityForceMultiplier(self):
        r"""
        :rtype: float
        :return: The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
        """
        return _simulation.ForceVelocityInverseCurve_getMaxEccentricVelocityForceMultiplier(self)

    def getConcentricCurviness(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the concentric branch of the force-velocity curve: a value of 0
               indicates that the curve is very close to a straight line segment and a
               value of 1 indicates a curve that smoothly fills the corner formed by the
               linear extrapolation of 'concentricSlopeNearVmax' and 'isometricSlope', as
               shown in the figure in the class description.
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricCurviness(self)

    def getEccentricCurviness(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the eccentric branch of the force-velocity curve: a value of 0
               indicates that the curve is very close to a straight line segment and a
               value of 1 indicates a curve that smoothly fills the corner formed by the
               linear extrapolation of 'isometricSlope' and 'eccentricSlopeNearVmax', as
               shown in the figure in the class description.
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricCurviness(self)

    def setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier):
        r"""
        :type aConcentricSlopeAtVmax: float
        :param aConcentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of -1,
                which is the minimum slope of the concentric side of the force-velocity
                curve.
        :type aConcentricSlopeNearVmax: float
        :param aConcentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                concentric (shortening) contraction velocity (between approximately
                -0.8 and -1).
        :type aIsometricSlope: float
        :param aIsometricSlope:
                The slope of the force-velocity curve at a normalized velocity of 0,
                which is the maximum slope of the force-velocity curve.
        :type aEccentricSlopeAtVmax: float
        :param aEccentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of 1,
                which is the minimum slope of the eccentric side of the force-velocity
                curve.
        :type aEccentricSlopeNearVmax: float
        :param aEccentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                eccentric (lengthening) contraction velocity (between approximately 0.8
                and 1).
        :type aMaxForceMultiplier: float
        :param aMaxForceMultiplier:
                The value of the force-velocity curve (i.e., the force-velocity
                multiplier) at the maximum eccentric contraction velocity.

        **Conditions**
            1a)  0 < concentricSlopeAtVmax < 1
        1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
        2a)  1 < isometricSlope
        2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3a)  0 < eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        3b)  eccentricSlopeAtVmax < eccentricSlopeNearVmax < (maxEccentricVelocityForceMultiplier-1)/1
         4)  1 < maxEccentricVelocityForceMultiplier
        """
        return _simulation.ForceVelocityInverseCurve_setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier)

    def setConcentricCurviness(self, aConcentricCurviness):
        r"""
        :type aConcentricCurviness: float
        :param aConcentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the concentric branch of the force-velocity curve: a value of 0
                indicates that the curve is very close to a straight line segment and a
                value of 1 indicates a curve that smoothly fills the corner formed by
                the linear extrapolation of 'concentricSlopeNearVmax' and
                'isometricSlope', as shown in the figure in the class description.

        **Conditions**
            0 <= concentricCurviness <= 1
        """
        return _simulation.ForceVelocityInverseCurve_setConcentricCurviness(self, aConcentricCurviness)

    def setEccentricCurviness(self, aEccentricCurviness):
        r"""
        :type aEccentricCurviness: float
        :param aEccentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the eccentric branch of the force-velocity curve: a value of 0 indicates
                that the curve is very close to a straight line segment and a value of 1
                indicates a curve that smoothly fills the corner formed by the linear
                extrapolation of 'isometricSlope' and 'eccentricSlopeNearVmax', as shown
                in the figure in the class description.

        **Conditions**
            0 <= eccentricCurviness <= 1
        """
        return _simulation.ForceVelocityInverseCurve_setEccentricCurviness(self, aEccentricCurviness)

    def calcValue(self, *args):
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the inverse force-velocity curve at a force-velocity
           multiplier value of 'aForceVelocityMultiplier'.
        """
        return _simulation.ForceVelocityInverseCurve_calcValue(self, *args)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*
        Calculates the derivative of the inverse force-velocity curve with
           respect to the force-velocity multiplier.
           :type aForceVelocityMultiplier: float
           :param aForceVelocityMultiplier:
                   The force-velocity multiplier value.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the inverse force-velocity curve with respect to the
                   force-velocity multiplier.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ForceVelocityInverseCurve_calcDerivative(self, *args)

    def getCurveDomain(self):
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ForceVelocityInverseCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ForceVelocityInverseCurve.csv"). This function is not const
           to permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the concentric linear extrapolation region (the
           region with normalized fiber velocities < -1), through the curve, out to the
           eccentric linear extrapolation region (the region with normalized fiber
           velocities > 1). The width of each linear extrapolation region is 10% of the
           curve domain, or 0.1*(x1-x0). The curve is sampled quite densely: the
           inverse force-velocity .csv file will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ForceVelocityInverseCurve.csv', 1, 0);
        """
        return _simulation.ForceVelocityInverseCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(ForceVelocityInverseCurve self)"""
        return _simulation.ForceVelocityInverseCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ForceVelocityInverseCurve

# Register ForceVelocityInverseCurve in _simulation:
_simulation.ForceVelocityInverseCurve_swigregister(ForceVelocityInverseCurve)
class TendonForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable TendonForceLengthCurve for use in muscle
       models. The tendon-force-length curve is dimensionless: force is normalized
       to maximum isometric force and length is normalized to tendon slack length.
       The user can adjust the strain the tendon undergoes at 1 unit load (e0), its
       stiffness at a strain of e0, and the shape of the tendon curve (its
       'curviness'):

       :param strainAtOneNormForce:
               The tendon strain at which the tendon develops 1 unit of normalized
               force. strainAtOneNormForce = 0.04 means that the tendon will develop a
               tension of 1 normalized force when it is strained by 4% of its slack
               length or, equivalently, is stretched to 1.04 times its resting length.
       :param stiffnessAtOneNormForce:
               The normalized stiffness (slope of the tendon curve) when the tendon is
               strained by strainAtOneNormForce under a load of 1 normalized unit of
               force.
       :param normForceAtToeEnd:
               The normalized force developed at the end of the 'toe' region. The toe
               region lies between 0 strain and some intermediate strain less than the
               strain required to develop 1 unit of normalized force. The toe region is
               nonlinear and more compliant than the rest of the tendon curve.
       :param curviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the curve: a value of 0 indicates that the curve is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly
               fills the corner formed by the linear extrapolation of
               'stiffnessAtOneNormForce' and the x-axis, as shown in the figure.

       Note that we use the Cauchy or engineering definition of strain throughout:
       strain = (l-l0)/l0, where l is the current tendon length and l0 is its slack
       length.

       **Required Parameters**
       * strainAtOneNormForce

       **Optional Parameters**
       * stiffnessAtOneNormForce
       * normForceAtToeEnd
       * curviness

       Image: fig_TendonForceLengthCurve.png

       **Conditions**
           strainAtOneNormForce > 0
       stiffnessAtOneNormForce > 1/strainAtOneNormForce
       0 < normForceAtToeEnd < 1
       0 <= curviness <= 1

       All parameters but the strain of the tendon at 1 unit load (e0) are
       optional. Note that filling in one optional parameter but not the others
       will throw an exception when the curve is built. The optional parameters can
       be used to vary the shape of the curve from a close approximation of a line
       to a sharply-bent curve.

       This curve has the advantage of being C2-continuous, which results in faster
       simulations when compared to the popular method of using a linearly
       extrapolated exponential (C0-continuous) curve to parameterize the
       tendon-force-length relationship. See Millard et al. (2013) for details.

       **Default Parameter Values**
       If the optional parameters are not specified, the curve is fit to match the
       average dimensionless in-vivo tendon curve reported by Maganaris et al. and
       Magnusson et al. In addition, the generated curve will have a characteristic
       toe region that is fit to the in-vivo literature. Note that this curve is
       not being fit to the commonly used linearly extrapolated exponential curve
       documented by Thelen, as it makes the toe region about half as stiff as both
       the in-vitro and in-vivo data indicate is reasonable. Additionally, the
       linear section of the curve would be nearly twice as stiff as the data
       indicates is reasonable.

           strainAtOneNormForce ....... 0.049
       stiffnessAtOneNormForce .... 1.375/strainAtOneNormForce
       normForceAtToeEnd .......... 2.0/3.0
       curviness .................. 0.5

       **Example**

       .. code-block:: c++

               TendonForceLengthCurve fseCurve(0.049, 28.1, 0.67, 0.5);
               double fseVal   = fseCurve.calcValue(0.02);
               double dfselVal = fseCurve.calcDerivative(0.02, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       **References**
       * Lewis, G., Shaw, K.M. (1997) Tensile properties of human tendo Achillis:
           effect of donor age and strain rate. The Journal of Foot and Ankle
           Surgery 36:435--445.
       * Maganaris, C.N., Paul, J.P. (2002) Tensile properties of the in vivo
           gastrocnemius tendon. Journal of Biomechanics 35:1639--1646.
       * Magnusson, S.P., Aagaard, P., Rosager, S., Dyhre-Poulsen, P., Kjaer, M.
           (2001) Load-displacement properties of the human triceps surae
           aponeurosis in vivo. Journal of Physiology 531:277--288.
       * Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
           simulate dynamic contractions in older adults. ASME Journal of
           Biomechanical Engineering 125:70--77.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TendonForceLengthCurve

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.TendonForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TendonForceLengthCurve self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.TendonForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.TendonForceLengthCurve_getClassName()

    def clone(self):
        r"""clone(TendonForceLengthCurve self) -> TendonForceLengthCurve"""
        return _simulation.TendonForceLengthCurve_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TendonForceLengthCurve self) -> std::string const &"""
        return _simulation.TendonForceLengthCurve_getConcreteClassName(self)

    def copyProperty_strain_at_one_norm_force(self, source):
        r"""
        copyProperty_strain_at_one_norm_force(TendonForceLengthCurve self, TendonForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::TendonForceLengthCurve::Self const &

        """
        return _simulation.TendonForceLengthCurve_copyProperty_strain_at_one_norm_force(self, source)

    def append_strain_at_one_norm_force(self, value):
        r"""
        append_strain_at_one_norm_force(TendonForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_append_strain_at_one_norm_force(self, value)

    def constructProperty_strain_at_one_norm_force(self, initValue):
        r"""
        constructProperty_strain_at_one_norm_force(TendonForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.TendonForceLengthCurve_constructProperty_strain_at_one_norm_force(self, initValue)

    def get_strain_at_one_norm_force(self, *args):
        r"""
        get_strain_at_one_norm_force(TendonForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_strain_at_one_norm_force(TendonForceLengthCurve self) -> double const &
        """
        return _simulation.TendonForceLengthCurve_get_strain_at_one_norm_force(self, *args)

    def upd_strain_at_one_norm_force(self, *args):
        r"""
        upd_strain_at_one_norm_force(TendonForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_strain_at_one_norm_force(TendonForceLengthCurve self) -> double &
        """
        return _simulation.TendonForceLengthCurve_upd_strain_at_one_norm_force(self, *args)

    def set_strain_at_one_norm_force(self, *args):
        r"""
        set_strain_at_one_norm_force(TendonForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_strain_at_one_norm_force(TendonForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_set_strain_at_one_norm_force(self, *args)

    def copyProperty_stiffness_at_one_norm_force(self, source):
        r"""
        copyProperty_stiffness_at_one_norm_force(TendonForceLengthCurve self, TendonForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::TendonForceLengthCurve::Self const &

        """
        return _simulation.TendonForceLengthCurve_copyProperty_stiffness_at_one_norm_force(self, source)

    def append_stiffness_at_one_norm_force(self, value):
        r"""
        append_stiffness_at_one_norm_force(TendonForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_append_stiffness_at_one_norm_force(self, value)

    def constructProperty_stiffness_at_one_norm_force(self, *args):
        r"""
        constructProperty_stiffness_at_one_norm_force(TendonForceLengthCurve self)
        constructProperty_stiffness_at_one_norm_force(TendonForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.TendonForceLengthCurve_constructProperty_stiffness_at_one_norm_force(self, *args)

    def get_stiffness_at_one_norm_force(self, *args):
        r"""
        get_stiffness_at_one_norm_force(TendonForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness_at_one_norm_force(TendonForceLengthCurve self) -> double const &
        """
        return _simulation.TendonForceLengthCurve_get_stiffness_at_one_norm_force(self, *args)

    def upd_stiffness_at_one_norm_force(self, *args):
        r"""
        upd_stiffness_at_one_norm_force(TendonForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness_at_one_norm_force(TendonForceLengthCurve self) -> double &
        """
        return _simulation.TendonForceLengthCurve_upd_stiffness_at_one_norm_force(self, *args)

    def set_stiffness_at_one_norm_force(self, *args):
        r"""
        set_stiffness_at_one_norm_force(TendonForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness_at_one_norm_force(TendonForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_set_stiffness_at_one_norm_force(self, *args)

    def copyProperty_norm_force_at_toe_end(self, source):
        r"""
        copyProperty_norm_force_at_toe_end(TendonForceLengthCurve self, TendonForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::TendonForceLengthCurve::Self const &

        """
        return _simulation.TendonForceLengthCurve_copyProperty_norm_force_at_toe_end(self, source)

    def append_norm_force_at_toe_end(self, value):
        r"""
        append_norm_force_at_toe_end(TendonForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_append_norm_force_at_toe_end(self, value)

    def constructProperty_norm_force_at_toe_end(self, *args):
        r"""
        constructProperty_norm_force_at_toe_end(TendonForceLengthCurve self)
        constructProperty_norm_force_at_toe_end(TendonForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.TendonForceLengthCurve_constructProperty_norm_force_at_toe_end(self, *args)

    def get_norm_force_at_toe_end(self, *args):
        r"""
        get_norm_force_at_toe_end(TendonForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_norm_force_at_toe_end(TendonForceLengthCurve self) -> double const &
        """
        return _simulation.TendonForceLengthCurve_get_norm_force_at_toe_end(self, *args)

    def upd_norm_force_at_toe_end(self, *args):
        r"""
        upd_norm_force_at_toe_end(TendonForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_norm_force_at_toe_end(TendonForceLengthCurve self) -> double &
        """
        return _simulation.TendonForceLengthCurve_upd_norm_force_at_toe_end(self, *args)

    def set_norm_force_at_toe_end(self, *args):
        r"""
        set_norm_force_at_toe_end(TendonForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_norm_force_at_toe_end(TendonForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_set_norm_force_at_toe_end(self, *args)

    def copyProperty_curviness(self, source):
        r"""
        copyProperty_curviness(TendonForceLengthCurve self, TendonForceLengthCurve source)

        Parameters
        ----------
        source: OpenSim::TendonForceLengthCurve::Self const &

        """
        return _simulation.TendonForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value):
        r"""
        append_curviness(TendonForceLengthCurve self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args):
        r"""
        constructProperty_curviness(TendonForceLengthCurve self)
        constructProperty_curviness(TendonForceLengthCurve self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.TendonForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args):
        r"""
        get_curviness(TendonForceLengthCurve self, int i) -> double const

        Parameters
        ----------
        i: int

        get_curviness(TendonForceLengthCurve self) -> double const &
        """
        return _simulation.TendonForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args):
        r"""
        upd_curviness(TendonForceLengthCurve self, int i) -> double

        Parameters
        ----------
        i: int

        upd_curviness(TendonForceLengthCurve self) -> double &
        """
        return _simulation.TendonForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args):
        r"""
        set_curviness(TendonForceLengthCurve self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_curviness(TendonForceLengthCurve self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.TendonForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a tendon-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a tendon-force-length curve using the provided parameters and
           assigns a default name.

        |

        *Overload 3:*
        This constructor will create a C2-continuous tendon-force-length curve
           that is fit to match the average dimensionless in-vivo tendon curve reported
           by Maganaris et al. and Magnusson et al. In addition, the generated curve
           will have a characteristic toe region that is fit to the in-vivo literature.
           :type strainAtOneNormForce: float
           :param strainAtOneNormForce:
                   The tendon strain at which the tendon develops 1 unit of normalized
                   force. strainAtOneNormForce = 0.04 means that the tendon will develop a
                   tension of 1 normalized force when it is strained by 4% of its slack
                   length or, equivalently, is stretched to 1.04 times its resting length.

           **Conditions**
               strainAtOneNormForce > 0
        """
        _simulation.TendonForceLengthCurve_swiginit(self, _simulation.new_TendonForceLengthCurve(*args))

    def getStrainAtOneNormForce(self):
        r"""
        :rtype: float
        :return: The tendon strain at which the tendon develops 1 unit of
               normalized force. strainAtOneNormForce = 0.04 means that the tendon will
               develop a tension of 1 normalized force when it is strained by 4% of its
               slack length or, equivalently, is stretched to 1.04 times its resting
               length. This property is set to 0.049 by default.
        """
        return _simulation.TendonForceLengthCurve_getStrainAtOneNormForce(self)

    def getStiffnessAtOneNormForceInUse(self):
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the tendon curve) when the
               tendon is strained by strainAtOneNormForce under a load of 1 normalized unit
               of force. This property is set to 1.375/strainAtOneNormForce by default.
        """
        return _simulation.TendonForceLengthCurve_getStiffnessAtOneNormForceInUse(self)

    def getNormForceAtToeEndInUse(self):
        r"""
        :rtype: float
        :return: The normalized force developed at the end of the 'toe' region.
               The toe region lies between 0 strain and some intermediate strain less than
               the strain required to develop 1 unit of normalized force. The toe region is
               nonlinear and more compliant than the rest of the tendon curve. This
               property is set to 2.0/3.0 by default.
        """
        return _simulation.TendonForceLengthCurve_getNormForceAtToeEndInUse(self)

    def getCurvinessInUse(self):
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the curve: a value of 0 indicates that the curve is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly fills
               the corner formed by the linear extrapolation of 'stiffnessAtOneNormForce'
               and the x-axis, as shown in the figure in the class description. This
               property is set to 0.5 by default.
        """
        return _simulation.TendonForceLengthCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self):
        r"""
        :rtype: boolean
        :return: True if the optional properties are empty and the fitted curve
               is being used, false if the optional properties are filled and are being
               used to construct the curve.
        """
        return _simulation.TendonForceLengthCurve_isFittedCurveBeingUsed(self)

    def setStrainAtOneNormForce(self, aStrainAtOneNormForce):
        r"""
        :type aStrainAtOneNormForce: float
        :param aStrainAtOneNormForce:
                The tendon strain at which the tendon develops 1 unit of normalized
                force. strainAtOneNormForce = 0.04 means that the tendon will develop a
                tension of 1 normalized force when it is strained by 4% of its slack
                length or, equivalently, is stretched to 1.04 times its resting length.
        """
        return _simulation.TendonForceLengthCurve_setStrainAtOneNormForce(self, aStrainAtOneNormForce)

    def setOptionalProperties(self, stiffnessAtOneNormForce, normForceAtToeEnd, curviness):
        r"""
        :type stiffnessAtOneNormForce: float
        :param stiffnessAtOneNormForce:
                The normalized stiffness (slope of the tendon curve) when the tendon is
                strained by strainAtOneNormForce under a load of 1 normalized unit of
                force.
        :type normForceAtToeEnd: float
        :param normForceAtToeEnd:
                The normalized force developed at the end of the 'toe' region. The toe
                region lies between 0 strain and some intermediate strain less than the
                strain required to develop 1 unit of normalized force. The toe region is
                nonlinear and more compliant than the rest of the tendon curve.
        :type curviness: float
        :param curviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the curve: a value of 0 indicates that the curve is very close to a
                straight line segment and a value of 1 indicates a curve that smoothly
                fills the corner formed by the linear extrapolation of
                'stiffnessAtOneNormForce' and the x-axis, as shown in the figure in the
                class description.
        """
        return _simulation.TendonForceLengthCurve_setOptionalProperties(self, stiffnessAtOneNormForce, normForceAtToeEnd, curviness)

    def calcValue(self, *args):
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the tendon-force-length curve at a normalized tendon length of
           'aNormLength'.
        """
        return _simulation.TendonForceLengthCurve_calcValue(self, *args)

    def calcValueAndDerivative(self, aNormLength):
        r"""
        Evaluates the tendon-force-length curve value and derivative at a
           normalized tendon length of 'aNormLength'.
        """
        return _simulation.TendonForceLengthCurve_calcValueAndDerivative(self, aNormLength)

    def calcDerivative(self, *args):
        r"""
        *Overload 1:*
        Calculates the derivative of the tendon-force-length multiplier with
           respect to the normalized tendon length.
           :type aNormLength: float
           :param aNormLength:
                   The normalized length of the tendon.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the tendon-force-length curve with respect to the
                   normalized tendon length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.TendonForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, aNormLength):
        r"""
        Calculates the normalized area under the curve. Since it is expensive to
           construct, the curve is built only when necessary.
           :type aNormLength: float
           :param aNormLength:
                   The normalized length of the tendon.
           :rtype: float
           :return: The normalized area under the curve, which corresponds to the
                   normalized potential energy stored in the tendon. To calculate the
                   potential energy stored in the tendon in units of Joules, multiply the
                   returned quantity by normForce*normLength (where normForce is the number
                   of Newtons represented by a normalized force of 1.0 and normLength is
                   the number of meters represented by a normalized length of 1.0).
        """
        return _simulation.TendonForceLengthCurve_calcIntegral(self, aNormLength)

    def getCurveDomain(self):
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.TendonForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path):
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_TendonForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the zero-force region, through the curve, out to
           strains beyond which the tendon generates normalized forces greater than 1.
           The curve is sampled quite densely: the tendon-force-length .csv file will
           have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_TendonForceLengthCurve.csv', 1, 0);
        """
        return _simulation.TendonForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self):
        r"""ensureCurveUpToDate(TendonForceLengthCurve self)"""
        return _simulation.TendonForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_TendonForceLengthCurve

# Register TendonForceLengthCurve in _simulation:
_simulation.TendonForceLengthCurve_swigregister(TendonForceLengthCurve)
class MuscleFirstOrderActivationDynamicModel(ModelComponent):
    r"""
    This is a muscle modeling utility class that computes the time derivative of
       activation using a first-order dynamic model. This activation model is a
       modification of those used by Thelen (2003) and Winters (1995). The time
       derivative of activation (/dt:math:`) is calculated as follows:    \f[ \frac{da}{dt} = \frac{u-a}{\tau(u,a)}     where` is excitation, \f$a:math:`is activation, and`\tau(u,a):math:`is a    variable time constant:     \tau(u,a) = t_{\rm{act}} (0.5 + 1.5a) \quad {\rm{if}}\ u > a      \tau(u,a) = t_{\rm{deact}} / (0.5 + 1.5a) \quad {\rm{otherwise}}     Since equilibrium muscle models typically have a numerical singularity in    their state equations when activation is zero, we apply a lower activation    bound (_{`) to both activation and excitation.

       @param tauActivation
           Activation time constant. A typical value is 0.010 s (10 ms).
       @param tauDeactivation
           Deactivation time constant. A typical value is 0.040 s (40 ms).
       @param minActivation
           The minimum permissible activation. To avoid a numerical singularity at
           a = 0, this value is typically set to between 0.01 and 0.1 for use with
           an equilibrium muscle model.
       @param muscleName
           The name of the muscle to which this activation dynamic model belongs.
           This string is used for reporting meaningful error messages.

       <B>Conditions</B>
       \verbatim
       tauActivation > 0
       tauDeactivation > 0
       0 <= minActivation < 1


       **Default Parameter Values**
           tauActivation ...... 0.010
       tauDeactivation .... 0.040
       minActivation ...... 0.01

       **References**
       * Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
           simulate dynamic contractions in older adults. ASME Journal of
           Biomechanical Engineering 125(1):70--77.
       * Winters, J.M. (1995) An improved muscle-reflex actuator for use in
           large-scale neuromusculoskeletal models. Annals of Biomedical
           Engineering 23(4):359--374.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MuscleFirstOrderActivationDynamicModel

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MuscleFirstOrderActivationDynamicModel self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MuscleFirstOrderActivationDynamicModel_getClassName()

    def clone(self):
        r"""clone(MuscleFirstOrderActivationDynamicModel self) -> MuscleFirstOrderActivationDynamicModel"""
        return _simulation.MuscleFirstOrderActivationDynamicModel_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MuscleFirstOrderActivationDynamicModel self) -> std::string const &"""
        return _simulation.MuscleFirstOrderActivationDynamicModel_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source):
        r"""
        copyProperty_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, MuscleFirstOrderActivationDynamicModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFirstOrderActivationDynamicModel::Self const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value):
        r"""
        append_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue):
        r"""
        constructProperty_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(MuscleFirstOrderActivationDynamicModel self) -> double const &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args):
        r"""
        upd_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_time_constant(MuscleFirstOrderActivationDynamicModel self) -> double &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args):
        r"""
        set_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source):
        r"""
        copyProperty_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, MuscleFirstOrderActivationDynamicModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFirstOrderActivationDynamicModel::Self const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value):
        r"""
        append_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue):
        r"""
        constructProperty_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self) -> double const &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args):
        r"""
        upd_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self) -> double &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args):
        r"""
        set_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_deactivation_time_constant(MuscleFirstOrderActivationDynamicModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source):
        r"""
        copyProperty_minimum_activation(MuscleFirstOrderActivationDynamicModel self, MuscleFirstOrderActivationDynamicModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFirstOrderActivationDynamicModel::Self const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value):
        r"""
        append_minimum_activation(MuscleFirstOrderActivationDynamicModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue):
        r"""
        constructProperty_minimum_activation(MuscleFirstOrderActivationDynamicModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args):
        r"""
        get_minimum_activation(MuscleFirstOrderActivationDynamicModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_activation(MuscleFirstOrderActivationDynamicModel self) -> double const &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args):
        r"""
        upd_minimum_activation(MuscleFirstOrderActivationDynamicModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_minimum_activation(MuscleFirstOrderActivationDynamicModel self) -> double &
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args):
        r"""
        set_minimum_activation(MuscleFirstOrderActivationDynamicModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_minimum_activation(MuscleFirstOrderActivationDynamicModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_minimum_activation(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an activation dynamic model with the
           default property values and assigns it a default name. *

        |

        *Overload 2:*
        Creates an activation dynamic model using the provided parameters.
        """
        _simulation.MuscleFirstOrderActivationDynamicModel_swiginit(self, _simulation.new_MuscleFirstOrderActivationDynamicModel(*args))

    def clampActivation(self, activation):
        r"""
        :rtype: float
        :return: Activation clamped to the range [minActivation, 1.0].
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_clampActivation(self, activation)

    def calcDerivative(self, activation, excitation):
        r""" Calculates the time derivative of activation."""
        return _simulation.MuscleFirstOrderActivationDynamicModel_calcDerivative(self, activation, excitation)
    __swig_destroy__ = _simulation.delete_MuscleFirstOrderActivationDynamicModel

# Register MuscleFirstOrderActivationDynamicModel in _simulation:
_simulation.MuscleFirstOrderActivationDynamicModel_swigregister(MuscleFirstOrderActivationDynamicModel)
class MuscleFixedWidthPennationModel(ModelComponent):
    r"""
    This is a muscle modeling utility class containing kinematic equations that
       describe the deformation of muscle fibers as they change length using a
       fixed-width-parallelogram pennation model. This pennation model makes
       several assumptions:
       * Fibers are straight, parallel, of equal length, and coplanar.
       * The area and height of the parallelogram remains constant.

       The parallelogram maintains a constant area and height by shearing as the
       muscle fibers change length, as shown in the figure below. The constant-area
       assumption is intended to mimic the constant-volume property of
       incompressible biological muscle. For details, please refer to Zajac (1989)
       and Millard et al. (2013).

       :param optimalFiberLength:
               The optimal length of the muscle fibers (meters).
       :param optimalPennationAngle:
               The angle between the tendon and fibers at optimal fiber length
               (radians).
       :param maximumPennationAngle:
               The maximum pennation angle permitted (radians). This parameter is
               particularly useful for avoiding a pennation angle singularity at Pi/2
               radians.

       Image: fig_MuscleFixedWidthPennationModel.png

       **Conditions**
           optimalFiberLength > 0
       0 <= optimalPennationAngle < Pi/2
       0 <= maximumPennationAngle <= Pi/2

       **Default Parameter Values**
           optimalFiberLength ....... 0.1
       optimalPennationAngle .... 0.0
       maximumPennationAngle .... acos(0.1) = 84.3 degrees

       **Example**

       .. code-block:: c++

           double optFibLen = 0.1;
           double optPenAng = SimTK::Pi/4.0;
           double maxPenAng = acos(0.001);
           MuscleFixedWidthPennationModel fibKin = MuscleFixedWidthPennationModel(optFibLen, optPenAng, maxPenAng);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the object correctly. If you
       modify the properties directly, the object will not be rebuilt, and upon
       calling any function, an exception will be thrown because the object is
       out-of-date with its properties.

       **References**
       * Zajac, F.E. (1989) %Muscle and tendon: properties, models, scaling, and
           application to biomechanics and motor control. Critical Reviews in
           Biomedical Engineering 17(4):359--411.
       * Millard, M., Uchida, T., Seth, A., Delp, S.L. (2013) Flexing
           computational muscle: modeling and simulation of musculotendon dynamics.
           ASME Journal of Biomechanical Engineering 135(2):021005.
           http://dx.doi.org/10.1115/1.4023390.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MuscleFixedWidthPennationModel

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.MuscleFixedWidthPennationModel_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MuscleFixedWidthPennationModel self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.MuscleFixedWidthPennationModel_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.MuscleFixedWidthPennationModel_getClassName()

    def clone(self):
        r"""clone(MuscleFixedWidthPennationModel self) -> MuscleFixedWidthPennationModel"""
        return _simulation.MuscleFixedWidthPennationModel_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MuscleFixedWidthPennationModel self) -> std::string const &"""
        return _simulation.MuscleFixedWidthPennationModel_getConcreteClassName(self)

    def copyProperty_optimal_fiber_length(self, source):
        r"""
        copyProperty_optimal_fiber_length(MuscleFixedWidthPennationModel self, MuscleFixedWidthPennationModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFixedWidthPennationModel::Self const &

        """
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_optimal_fiber_length(self, source)

    def append_optimal_fiber_length(self, value):
        r"""
        append_optimal_fiber_length(MuscleFixedWidthPennationModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_append_optimal_fiber_length(self, value)

    def constructProperty_optimal_fiber_length(self, initValue):
        r"""
        constructProperty_optimal_fiber_length(MuscleFixedWidthPennationModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_optimal_fiber_length(self, initValue)

    def get_optimal_fiber_length(self, *args):
        r"""
        get_optimal_fiber_length(MuscleFixedWidthPennationModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_fiber_length(MuscleFixedWidthPennationModel self) -> double const &
        """
        return _simulation.MuscleFixedWidthPennationModel_get_optimal_fiber_length(self, *args)

    def upd_optimal_fiber_length(self, *args):
        r"""
        upd_optimal_fiber_length(MuscleFixedWidthPennationModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_fiber_length(MuscleFixedWidthPennationModel self) -> double &
        """
        return _simulation.MuscleFixedWidthPennationModel_upd_optimal_fiber_length(self, *args)

    def set_optimal_fiber_length(self, *args):
        r"""
        set_optimal_fiber_length(MuscleFixedWidthPennationModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_fiber_length(MuscleFixedWidthPennationModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_set_optimal_fiber_length(self, *args)

    def copyProperty_pennation_angle_at_optimal(self, source):
        r"""
        copyProperty_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, MuscleFixedWidthPennationModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFixedWidthPennationModel::Self const &

        """
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_pennation_angle_at_optimal(self, source)

    def append_pennation_angle_at_optimal(self, value):
        r"""
        append_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_append_pennation_angle_at_optimal(self, value)

    def constructProperty_pennation_angle_at_optimal(self, initValue):
        r"""
        constructProperty_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_pennation_angle_at_optimal(self, initValue)

    def get_pennation_angle_at_optimal(self, *args):
        r"""
        get_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self) -> double const &
        """
        return _simulation.MuscleFixedWidthPennationModel_get_pennation_angle_at_optimal(self, *args)

    def upd_pennation_angle_at_optimal(self, *args):
        r"""
        upd_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self) -> double &
        """
        return _simulation.MuscleFixedWidthPennationModel_upd_pennation_angle_at_optimal(self, *args)

    def set_pennation_angle_at_optimal(self, *args):
        r"""
        set_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_pennation_angle_at_optimal(MuscleFixedWidthPennationModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_set_pennation_angle_at_optimal(self, *args)

    def copyProperty_maximum_pennation_angle(self, source):
        r"""
        copyProperty_maximum_pennation_angle(MuscleFixedWidthPennationModel self, MuscleFixedWidthPennationModel source)

        Parameters
        ----------
        source: OpenSim::MuscleFixedWidthPennationModel::Self const &

        """
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value):
        r"""
        append_maximum_pennation_angle(MuscleFixedWidthPennationModel self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue):
        r"""
        constructProperty_maximum_pennation_angle(MuscleFixedWidthPennationModel self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args):
        r"""
        get_maximum_pennation_angle(MuscleFixedWidthPennationModel self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maximum_pennation_angle(MuscleFixedWidthPennationModel self) -> double const &
        """
        return _simulation.MuscleFixedWidthPennationModel_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args):
        r"""
        upd_maximum_pennation_angle(MuscleFixedWidthPennationModel self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maximum_pennation_angle(MuscleFixedWidthPennationModel self) -> double &
        """
        return _simulation.MuscleFixedWidthPennationModel_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args):
        r"""
        set_maximum_pennation_angle(MuscleFixedWidthPennationModel self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maximum_pennation_angle(MuscleFixedWidthPennationModel self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.MuscleFixedWidthPennationModel_set_maximum_pennation_angle(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a fixed-width-parallelogram pennation
           model with the default property values.

        |

        *Overload 2:*
        Creates a fixed-width-parallelogram pennation model using the provided
           parameters.
        """
        _simulation.MuscleFixedWidthPennationModel_swiginit(self, _simulation.new_MuscleFixedWidthPennationModel(*args))

    def getParallelogramHeight(self):
        r"""
        :rtype: float
        :return: The height of the fixed-width parallelogram.
        """
        return _simulation.MuscleFixedWidthPennationModel_getParallelogramHeight(self)

    def getMinimumFiberLength(self):
        r"""
        :rtype: float
        :return: The minimum possible fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self):
        r"""
        :rtype: float
        :return: The minimum possible fiber length along the tendon.
        """
        return _simulation.MuscleFixedWidthPennationModel_getMinimumFiberLengthAlongTendon(self)

    def calcPennationAngle(self, fiberLength):
        r"""
        Calculates the pennation angle (the orientation of the parallelogram)
           given the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngle(self, fiberLength)

    def calcTendonLength(self, cosPennationAngle, fiberLength, muscleLength):
        r"""
        Calculates the length of the tendon given the cosine of the pennation
           angle, the length of the fiber, and the length of the entire musculotendon
           actuator.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcTendonLength(self, cosPennationAngle, fiberLength, muscleLength)

    def calcFiberLengthAlongTendon(self, fiberLength, cosPennationAngle):
        r"""
        Calculates the length of the fiber projected onto the axis of the
           tendon.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberLengthAlongTendon(self, fiberLength, cosPennationAngle)

    def calcPennationAngularVelocity(self, tanPennationAngle, fiberLength, fiberVelocity):
        r"""
        Calculates the angular velocity of the parallelogram (i.e., the time
           derivative of the pennation angle.
           :type tanPennationAngle: float
           :param tanPennationAngle:
                   The tangent of the pennation angle.
           :type fiberLength: float
           :param fiberLength:
                   The length of the fiber (m).
           :type fiberVelocity: float
           :param fiberVelocity:
                   The lengthening velocity of the fiber (m/s).
           :rtype: float
           :return: 
                   The angular velocity of the parallelogram (rad/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngularVelocity(self, tanPennationAngle, fiberLength, fiberVelocity)

    def calcTendonVelocity(self, cosPennationAngle, sinPennationAngle, pennationAngularVelocity, fiberLength, fiberVelocity, muscleVelocity):
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type muscleVelocity: float
        :param muscleVelocity:
                The lengthening velocity of the muscle path (m/s).
        :rtype: float
        :return: 
                The lengthening velocity of the tendon (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcTendonVelocity(self, cosPennationAngle, sinPennationAngle, pennationAngularVelocity, fiberLength, fiberVelocity, muscleVelocity)

    def calcFiberVelocityAlongTendon(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity):
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :rtype: float
        :return: 
                The lengthening velocity of the fiber projected onto the axis of the
                tendon (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberVelocityAlongTendon(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity)

    def calcPennationAngularAcceleration(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity):
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type fiberAcceleration: float
        :param fiberAcceleration:
                The lengthening acceleration of the fiber (m/s^2).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :rtype: float
        :return: 
                The angular acceleration of the parallelogram (rad/s^2).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngularAcceleration(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity)

    def calcFiberAccelerationAlongTendon(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, pennationAngularAcceleration):
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type fiberAcceleration: float
        :param fiberAcceleration:
                The lengthening acceleration of the fiber (m/s^2).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :type pennationAngularAcceleration: float
        :param pennationAngularAcceleration:
                The angular acceleration of the parallelogram (rad/s^2).
        :rtype: float
        :return: 
                The acceleration of the fiber projected onto the axis of the tendon
                (m/s^2).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberAccelerationAlongTendon(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, pennationAngularAcceleration)

    def calc_DFiberLengthAlongTendon_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength):
        r"""
        Calculates the partial derivative of the fiber length along the tendon
           with respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DFiberLengthAlongTendon_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength)

    def calc_DPennationAngularVelocity_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength):
        r"""
        Calculates the partial derivative of the pennation angular velocity with
           respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DPennationAngularVelocity_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength)

    def calc_DFiberVelocityAlongTendon_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength, DpennationAngularVelocity_DfiberLength):
        r"""
        Calculates the partial derivative of the fiber velocity along the tendon
           with respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DFiberVelocityAlongTendon_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength, DpennationAngularVelocity_DfiberLength)

    def calc_DPennationAngle_DfiberLength(self, fiberLength):
        r"""
        Calculates the partial derivative of the pennation angle with respect to
           the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DPennationAngle_DfiberLength(self, fiberLength)

    def calc_DTendonLength_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength):
        r"""
        Calculates the partial derivative of the tendon length with respect to
           the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DTendonLength_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength)

    def calcFiberLength(self, muscleLength, tendonLength):
        r"""
        :type muscleLength: float
        :param muscleLength:
                The length of the musculotendon actuator (m).
        :type tendonLength: float
        :param tendonLength:
                The length of the tendon (m).
        :rtype: float
        :return: 
                The length of the fiber (m).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberLength(self, muscleLength, tendonLength)

    def calcFiberVelocity(self, cosPennationAngle, muscleVelocity, tendonVelocity):
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type muscleVelocity: float
        :param muscleVelocity:
                The lengthening velocity of the musculotendon actuator (m/s).
        :type tendonVelocity: float
        :param tendonVelocity:
                The lengthening velocity of the tendon (m/s).
        :rtype: float
        :return: 
                The lengthening velocity of the fiber (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberVelocity(self, cosPennationAngle, muscleVelocity, tendonVelocity)
    __swig_destroy__ = _simulation.delete_MuscleFixedWidthPennationModel

# Register MuscleFixedWidthPennationModel in _simulation:
_simulation.MuscleFixedWidthPennationModel_swigregister(MuscleFixedWidthPennationModel)
class Thelen2003Muscle(ActivationFiberLengthMuscle):
    r"""
    Implementation of a two state (activation and fiber-length) Muscle model by
    Thelen 2003.\ This a complete rewrite of a previous implementation (present in
    OpenSim 2.4 and earlier) contained numerous errors.

    The Thelen2003Muscle model uses a standard equilibrium muscle equation

    .. math::

        (a(t) f_{AL}(l_{CE}) f_{V}(\dot{l}_{CE}) 
         - f_{PE}(l_{CE}))\cos \phi - f_{SE}(l_{T}) = 0

    Rearranging the above equation and solving for :math:`f_{V}(\dot{l}_{CE})`
    yields

    .. math::

        f_{V}(\dot{l}_{CE}) = 
         \frac{ \frac{f_{SE}(l_{T})}{\cos\phi} - f_{PE}(l_{CE}) }{ a(t) f_{AL}(l_{CE}) }

    The force velocity curve is usually inverted to compute the fiber velocity,

    .. math::

        \dot{l}_{CE} = f_{V}^{-1}( 
         \frac{ \frac{f_{SE}(l_{T})}{\cos\phi} - f_{PE}(l_{CE}) }{ a(t) f_{AL}(l_{CE}) }
         )

    which is then integrated to simulate the musculotendon dynamics. In general,
    the previous equation has 4 singularity conditions:

    -# :math:`a(t) \rightarrow 0`
    -# :math:`f_{AL}(l_{CE}) \rightarrow 0`
    -# :math:`\phi \rightarrow \frac{\pi}{2}`
    -# :math:`f_{V}(\dot{l}_{CE}) \le 0` or
       :math:`f_{V}(\dot{l}_{CE}) \ge F^M_{len}`

    This implementation has been slightly modified from the model presented in the
    journal paper (marked with a *) to prevent some of these singularities:

    -# *:math:`a(t) \rightarrow a_{min} > 0` : A modified activation dynamic
       equation is used - MuscleFirstOrderActivationDynamicModel - which smoothly
       approaches some minimum value that is greater than zero.
    -# :math:`f_{AL}(l_{CE}) > 0` . The active force length curve of the Thelen
       muscle is a Gaussian, which is always greater than 0.
    -# :math:`\phi \rightarrow \frac{\pi}{2}` . This singularity cannot be removed
       without changing the first equation, and still exists in the present
       Thelen2003Muscle formulation.
    -# *:math:`f_{V}(\dot{l}_{CE}) \le 0` or
       :math:`f_{V}(\dot{l}_{CE}) \ge F^M_{len}`: Equation 6 in Thelen 2003 has been
       modified so that :math:`V^M` is linearly extrapolated when :math:`F^M < 0`
       (during a concentric contraction), and when :math:`F^M > 0.95 F^M_{len}`
       (during an eccentric contraction). These two modifications make the force
       velocity curve invertible. The original force velocity curve as published
       by Thelen was not invertible.
    -# A unilateral constraint has been implemented to prevent the fiber from
       approaching a fiber length that is smaller than 0.01*optimal fiber length,
       or a fiber length that creates a pennation angle greater than the maximum
       pennation angle specified by the pennation model. Note that this unilateral
       constraint does not prevent the muscle fiber from becoming shorter than is
       physiologically possible (that is shorter than approximately half a
       normalized fiber length).

     ** References **

      DG Thelen, Adjustment of muscle mechanics model parameters to simulate dynamic
    contractions in older adults. Journal of biomechanical engineering, 2003.

    Author: Matt Millard
    Ajay Seth
    Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Thelen2003Muscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Thelen2003Muscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Thelen2003Muscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Thelen2003Muscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Thelen2003Muscle_getClassName()

    def clone(self):
        r"""clone(Thelen2003Muscle self) -> Thelen2003Muscle"""
        return _simulation.Thelen2003Muscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Thelen2003Muscle self) -> std::string const &"""
        return _simulation.Thelen2003Muscle_getConcreteClassName(self)

    def copyProperty_FmaxTendonStrain(self, source):
        r"""
        copyProperty_FmaxTendonStrain(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_FmaxTendonStrain(self, source)

    def append_FmaxTendonStrain(self, value):
        r"""
        append_FmaxTendonStrain(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_FmaxTendonStrain(self, value)

    def constructProperty_FmaxTendonStrain(self, initValue):
        r"""
        constructProperty_FmaxTendonStrain(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_FmaxTendonStrain(self, initValue)

    def get_FmaxTendonStrain(self, *args):
        r"""
        get_FmaxTendonStrain(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_FmaxTendonStrain(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_FmaxTendonStrain(self, *args)

    def upd_FmaxTendonStrain(self, *args):
        r"""
        upd_FmaxTendonStrain(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_FmaxTendonStrain(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_FmaxTendonStrain(self, *args)

    def set_FmaxTendonStrain(self, *args):
        r"""
        set_FmaxTendonStrain(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_FmaxTendonStrain(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_FmaxTendonStrain(self, *args)

    def copyProperty_FmaxMuscleStrain(self, source):
        r"""
        copyProperty_FmaxMuscleStrain(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_FmaxMuscleStrain(self, source)

    def append_FmaxMuscleStrain(self, value):
        r"""
        append_FmaxMuscleStrain(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_FmaxMuscleStrain(self, value)

    def constructProperty_FmaxMuscleStrain(self, initValue):
        r"""
        constructProperty_FmaxMuscleStrain(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_FmaxMuscleStrain(self, initValue)

    def get_FmaxMuscleStrain(self, *args):
        r"""
        get_FmaxMuscleStrain(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_FmaxMuscleStrain(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_FmaxMuscleStrain(self, *args)

    def upd_FmaxMuscleStrain(self, *args):
        r"""
        upd_FmaxMuscleStrain(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_FmaxMuscleStrain(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_FmaxMuscleStrain(self, *args)

    def set_FmaxMuscleStrain(self, *args):
        r"""
        set_FmaxMuscleStrain(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_FmaxMuscleStrain(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_FmaxMuscleStrain(self, *args)

    def copyProperty_KshapeActive(self, source):
        r"""
        copyProperty_KshapeActive(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_KshapeActive(self, source)

    def append_KshapeActive(self, value):
        r"""
        append_KshapeActive(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_KshapeActive(self, value)

    def constructProperty_KshapeActive(self, initValue):
        r"""
        constructProperty_KshapeActive(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_KshapeActive(self, initValue)

    def get_KshapeActive(self, *args):
        r"""
        get_KshapeActive(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_KshapeActive(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_KshapeActive(self, *args)

    def upd_KshapeActive(self, *args):
        r"""
        upd_KshapeActive(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_KshapeActive(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_KshapeActive(self, *args)

    def set_KshapeActive(self, *args):
        r"""
        set_KshapeActive(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_KshapeActive(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_KshapeActive(self, *args)

    def copyProperty_KshapePassive(self, source):
        r"""
        copyProperty_KshapePassive(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_KshapePassive(self, source)

    def append_KshapePassive(self, value):
        r"""
        append_KshapePassive(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_KshapePassive(self, value)

    def constructProperty_KshapePassive(self, initValue):
        r"""
        constructProperty_KshapePassive(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_KshapePassive(self, initValue)

    def get_KshapePassive(self, *args):
        r"""
        get_KshapePassive(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_KshapePassive(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_KshapePassive(self, *args)

    def upd_KshapePassive(self, *args):
        r"""
        upd_KshapePassive(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_KshapePassive(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_KshapePassive(self, *args)

    def set_KshapePassive(self, *args):
        r"""
        set_KshapePassive(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_KshapePassive(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_KshapePassive(self, *args)

    def copyProperty_Af(self, source):
        r"""
        copyProperty_Af(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_Af(self, source)

    def append_Af(self, value):
        r"""
        append_Af(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_Af(self, value)

    def constructProperty_Af(self, initValue):
        r"""
        constructProperty_Af(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_Af(self, initValue)

    def get_Af(self, *args):
        r"""
        get_Af(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_Af(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_Af(self, *args)

    def upd_Af(self, *args):
        r"""
        upd_Af(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_Af(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_Af(self, *args)

    def set_Af(self, *args):
        r"""
        set_Af(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_Af(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_Af(self, *args)

    def copyProperty_Flen(self, source):
        r"""
        copyProperty_Flen(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_Flen(self, source)

    def append_Flen(self, value):
        r"""
        append_Flen(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_Flen(self, value)

    def constructProperty_Flen(self, initValue):
        r"""
        constructProperty_Flen(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_Flen(self, initValue)

    def get_Flen(self, *args):
        r"""
        get_Flen(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_Flen(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_Flen(self, *args)

    def upd_Flen(self, *args):
        r"""
        upd_Flen(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_Flen(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_Flen(self, *args)

    def set_Flen(self, *args):
        r"""
        set_Flen(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_Flen(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_Flen(self, *args)

    def copyProperty_fv_linear_extrap_threshold(self, source):
        r"""
        copyProperty_fv_linear_extrap_threshold(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_fv_linear_extrap_threshold(self, source)

    def append_fv_linear_extrap_threshold(self, value):
        r"""
        append_fv_linear_extrap_threshold(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_fv_linear_extrap_threshold(self, value)

    def constructProperty_fv_linear_extrap_threshold(self, initValue):
        r"""
        constructProperty_fv_linear_extrap_threshold(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_fv_linear_extrap_threshold(self, initValue)

    def get_fv_linear_extrap_threshold(self, *args):
        r"""
        get_fv_linear_extrap_threshold(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fv_linear_extrap_threshold(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_fv_linear_extrap_threshold(self, *args)

    def upd_fv_linear_extrap_threshold(self, *args):
        r"""
        upd_fv_linear_extrap_threshold(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fv_linear_extrap_threshold(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_fv_linear_extrap_threshold(self, *args)

    def set_fv_linear_extrap_threshold(self, *args):
        r"""
        set_fv_linear_extrap_threshold(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fv_linear_extrap_threshold(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_fv_linear_extrap_threshold(self, *args)

    def copyProperty_maximum_pennation_angle(self, source):
        r"""
        copyProperty_maximum_pennation_angle(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value):
        r"""
        append_maximum_pennation_angle(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue):
        r"""
        constructProperty_maximum_pennation_angle(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args):
        r"""
        get_maximum_pennation_angle(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maximum_pennation_angle(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args):
        r"""
        upd_maximum_pennation_angle(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maximum_pennation_angle(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args):
        r"""
        set_maximum_pennation_angle(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maximum_pennation_angle(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_maximum_pennation_angle(self, *args)

    def copyProperty_activation_time_constant(self, source):
        r"""
        copyProperty_activation_time_constant(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value):
        r"""
        append_activation_time_constant(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue):
        r"""
        constructProperty_activation_time_constant(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args):
        r"""
        upd_activation_time_constant(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_time_constant(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args):
        r"""
        set_activation_time_constant(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_time_constant(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source):
        r"""
        copyProperty_deactivation_time_constant(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value):
        r"""
        append_deactivation_time_constant(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue):
        r"""
        constructProperty_deactivation_time_constant(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args):
        r"""
        upd_deactivation_time_constant(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_deactivation_time_constant(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args):
        r"""
        set_deactivation_time_constant(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_deactivation_time_constant(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source):
        r"""
        copyProperty_minimum_activation(Thelen2003Muscle self, Thelen2003Muscle source)

        Parameters
        ----------
        source: OpenSim::Thelen2003Muscle::Self const &

        """
        return _simulation.Thelen2003Muscle_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value):
        r"""
        append_minimum_activation(Thelen2003Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue):
        r"""
        constructProperty_minimum_activation(Thelen2003Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Thelen2003Muscle_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args):
        r"""
        get_minimum_activation(Thelen2003Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_activation(Thelen2003Muscle self) -> double const &
        """
        return _simulation.Thelen2003Muscle_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args):
        r"""
        upd_minimum_activation(Thelen2003Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_minimum_activation(Thelen2003Muscle self) -> double &
        """
        return _simulation.Thelen2003Muscle_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args):
        r"""
        set_minimum_activation(Thelen2003Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_minimum_activation(Thelen2003Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Thelen2003Muscle_set_minimum_activation(self, *args)
    FiberActiveForceLength = _simulation.Thelen2003Muscle_FiberActiveForceLength
    
    FiberPassiveForceLength = _simulation.Thelen2003Muscle_FiberPassiveForceLength
    
    FiberForceVelocity = _simulation.Thelen2003Muscle_FiberForceVelocity
    
    TendonForceLength = _simulation.Thelen2003Muscle_TendonForceLength
    

    def __init__(self, *args):
        r"""
        __init__(Thelen2003Muscle self) -> Thelen2003Muscle
        __init__(Thelen2003Muscle self, std::string const & aName, double aMaxIsometricForce, double aOptimalFiberLength, double aTendonSlackLength, double aPennationAngle) -> Thelen2003Muscle

        Parameters
        ----------
        aName: std::string const &
        aMaxIsometricForce: double
        aOptimalFiberLength: double
        aTendonSlackLength: double
        aPennationAngle: double

        """
        _simulation.Thelen2003Muscle_swiginit(self, _simulation.new_Thelen2003Muscle(*args))

    def getActivationTimeConstant(self):
        r"""*"""
        return _simulation.Thelen2003Muscle_getActivationTimeConstant(self)

    def setActivationTimeConstant(self, actTimeConstant):
        r"""
        setActivationTimeConstant(Thelen2003Muscle self, double actTimeConstant)

        Parameters
        ----------
        actTimeConstant: double

        """
        return _simulation.Thelen2003Muscle_setActivationTimeConstant(self, actTimeConstant)

    def getDeactivationTimeConstant(self):
        r"""getDeactivationTimeConstant(Thelen2003Muscle self) -> double"""
        return _simulation.Thelen2003Muscle_getDeactivationTimeConstant(self)

    def setDeactivationTimeConstant(self, deactTimeConstant):
        r"""
        setDeactivationTimeConstant(Thelen2003Muscle self, double deactTimeConstant)

        Parameters
        ----------
        deactTimeConstant: double

        """
        return _simulation.Thelen2003Muscle_setDeactivationTimeConstant(self, deactTimeConstant)

    def getMinimumActivation(self):
        r"""getMinimumActivation(Thelen2003Muscle self) -> double"""
        return _simulation.Thelen2003Muscle_getMinimumActivation(self)

    def setMinimumActivation(self, minimumActivation):
        r"""
        setMinimumActivation(Thelen2003Muscle self, double minimumActivation)

        Parameters
        ----------
        minimumActivation: double

        """
        return _simulation.Thelen2003Muscle_setMinimumActivation(self, minimumActivation)

    def getMaximumPennationAngle(self):
        r"""getMaximumPennationAngle(Thelen2003Muscle self) -> double"""
        return _simulation.Thelen2003Muscle_getMaximumPennationAngle(self)

    def setMaximumPennationAngle(self, maximumPennationAngle):
        r"""
        setMaximumPennationAngle(Thelen2003Muscle self, double maximumPennationAngle)

        Parameters
        ----------
        maximumPennationAngle: double

        """
        return _simulation.Thelen2003Muscle_setMaximumPennationAngle(self, maximumPennationAngle)

    def getMinimumFiberLength(self):
        r"""
        *
             :rtype: float
             :return: the minimum fiber length, which is the maximum of two values:
                    the smallest fiber length allowed by the pennation model, and the
                    minimum fiber length in the active force length curve. When the fiber
                    length reaches this value, it is constrained to this value until the
                    fiber velocity goes positive.
        """
        return _simulation.Thelen2003Muscle_getMinimumFiberLength(self)

    def getActivationModel(self):
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003Muscle_getActivationModel(self)

    def getPennationModel(self):
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003Muscle_getPennationModel(self)

    def printCurveToCSVFile(self, ctype, path):
        r"""
        printCurveToCSVFile(Thelen2003Muscle self, OpenSim::Thelen2003Muscle::CurveType const ctype, std::string const & path)

        Parameters
        ----------
        ctype: enum OpenSim::Thelen2003Muscle::CurveType const
        path: std::string const &

        """
        return _simulation.Thelen2003Muscle_printCurveToCSVFile(self, ctype, path)

    def computeActuation(self, s):
        r"""
        computeActuation(Thelen2003Muscle self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _simulation.Thelen2003Muscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        Compute initial fiber length (velocity) such that muscle fiber and
               tendon are in static equilibrium and update the state

               Part of the Muscle.h interface

               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Thelen2003Muscle_computeInitialFiberEquilibrium(self, s)

    def calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity):
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Thelen2003Muscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""
        calcInextensibleTendonActiveFiberForce(Thelen2003Muscle self, State s, double aActivation) -> double

        Parameters
        ----------
        s: SimTK::State &
        aActivation: double

        """
        return _simulation.Thelen2003Muscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)
    __swig_destroy__ = _simulation.delete_Thelen2003Muscle

# Register Thelen2003Muscle in _simulation:
_simulation.Thelen2003Muscle_swigregister(Thelen2003Muscle)
class Millard2012EquilibriumMuscle(Muscle):
    r"""
    This class implements a configurable equilibrium muscle model, as described in
    Millard et al.\ (2013). An equilibrium model assumes that the forces generated
    by the fiber and tendon are equal:

    .. math::

        f_{ISO}\Big(\mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE}) \mathbf{f}_V(\hat{v}_{CE})
        + \mathbf{f}_{PE}(\hat{l}_{CE}) + \beta \hat{v}_{CE}\Big) \cos \phi
        -  f_{ISO}\mathbf{f}_{SE}(\hat{l}_{T}) = 0

    Image: fig_Millard2012EquilibriumMuscle.png

    This model can be simulated in several configurations by adjusting three flags:

    * ignore_tendon_compliance: set to *true* to make the tendon rigid. This
    assumption is usually reasonable for short tendons, and can result in a
    performance improvement by eliminating high-frequency dynamics and removing the
    fiber length from the state vector.

    * ignore_activation_dynamics: set to *true* to use the excitation input
    as the activation signal. This results in faster simulations by reducing the
    size of the state vector.

    * fiber_damping: set to a value greater than 0.001 to include fiber damping in
    the model. The addition of damping reduces simulation time while allowing the
    muscle model to be more physiological (it can have an activation of zero, its
    active-force-length curve can go to zero, and its force-velocity curve can be
    asymptotic).

    **Elastic Tendon, No Fiber Damping**

    The most typical configuration used in the literature is to simulate a muscle
    with an elastic tendon, full fiber dynamics, and activation dynamics. The
    resulting formulation suffers from three singularities: :math:`\mathbf{a}(t)\rightarrow 0`, :math:`\phi \rightarrow 90^\circ`, and
    :math:`\mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0`. These situations are all
    handled in this model to ensure that it does not produce singularities and does
    not result in intolerably long simulation times.

    Numerical singularities arise from the manner in which the equilibrium equation
    is rearranged to yield an ordinary differential equation (ODE). The above
    equation is rearranged to isolate :math:`\mathbf{f}_V(\hat{v}_{CE})`. We then
    invert to solve for :math:`\hat{v}_{CE}`, which is then numerically integrated
    during a simulation:

    .. math::

        \hat{v}_{CE} = \mathbf{f}_V ^{-1} \Big(
         \frac{ ( \mathbf{f}_{SE}(\hat{l}_{T}) ) /
         \cos \phi
          -  \mathbf{f}_{PE}(\hat{l}_{CE}) }
          { \mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE})} \Big)

    The above equation becomes numerically stiff when terms in the denominator
    approach zero (when :math:`\mathbf{a}(t) \rightarrow 0`, :math:`\phi\rightarrow 90^\circ`, or :math:`\mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0`)
    or, additionally, when the slope of :math:`\mathbf{f}_V ^{-1}` is steep (which
    occurs at fiber velocities close to the maximum concentric and maximum
    eccentric fiber velocities).

    Singularities can be managed by ensuring that the muscle model is always
    activated (:math:`\mathbf{a}(t) > 0`), the fiber will stop contracting when a
    pennation angle of 90 degrees is approached (:math:`\phi < 90^\circ`), and the
    fiber will also stop contracting as its length approaches a lower bound
    (:math:`\hat{l}_{CE} > lowerbound`), which is typically around half the fiber's
    resting length (to ensure :math:`\mathbf{f}_L(\hat{l}_{CE}) > 0`). The fiber is
    prevented from reaching unphysiological lengths or its maximum pennation angle
    using a unilateral constraint. Additionally, the force-velocity curve is
    modified so that it is invertible.

    When an elastic tendon without fiber damping is selected, the minimum
    active-force-length value is set to 0.1, the minimum permissible activation is
    set to 0.01, and the maximum permissible pennation angle is set to acos(0.1) or
    84.3 degrees. This is done as a convenience for the user to prevent the model
    from taking an unreasonable amount of time to simulate.

    **(Rigid Tendon) or (Elastic Tendon with Fiber Damping)**

    Neither of these formulations has any singularities. The lower bound of the
    active-force-length curve can be zero (min( :math:`\mathbf{f}_L(\hat{l}_{CE})) = 0`), activation can be zero (i.e., the muscle can be turned off completely),
    and the force-velocity curve need not be invertible.

    The rigid tendon formulation removes the singularities by ignoring the
    elasticity of the tendon. This assumption is reasonable for many muscles, but it
    is up to the user to determine whether this assumption is valid.

    The formulation that uses an elastic tendon with fiber damping removes
    singularities by solving the equilibrium equation with Newton's method. This is
    possible because the partial derivative of the equilibrium equation with respect
    to fiber velocity is always positive if :math:`\beta > 0` and, thus, Newton's
    method can find a solution to the equilibrium equation.

    When either of these singularity-free formulations is selected, the minimum
    active-force-length value and the minimum permissible activation are set to
    zero. This is done as a convenience for the user, as these changes make the
    results of the model more realistic yet incur no performance penalty. The
    maximum pennation angle is left as acos(0.1) or 84.3 degrees, as allowing higher
    pennation angles results in an increasingly stiff fiber velocity state as
    pennation angle increases.

    **Usage**

    This object should be updated through the *set* methods provided.

    **Example**

    .. code-block:: c++

        double maxIsometricForce  = 5000;   //N
        double optimalFiberLength = 0.025;  //m
        double tendonSlackLength  = 0.25;   //m
        double pennationAngle     = 0.5;    //rad

        bool ignoreTendonCompliance   = false;
        bool ignoreActivationDynamics = false;
        double dampingCoefficient     = 0.001;

        Millard2012EquilibriumMuscle myMuscle("myMuscle",
                                              maxIsometricForce,
                                              optimalFiberLength,
                                              tendonSlackLength,
                                              pennationAngle);

        myMuscle.setMuscleConfiguration(ignoreTendonCompliance,
                                        ignoreActivationDynamics,
                                        dampingCoefficient);

    Please refer to the doxygen for more information on the properties that are
    objects themselves (MuscleFixedWidthPennationModel, ActiveForceLengthCurve,
    FiberForceLengthCurve, TendonForceLengthCurve, and ForceVelocityInverseCurve).

    **Reference**

    Millard, M., Uchida, T., Seth, A., Delp, S.L. (2013) Flexing computational
    muscle: modeling and simulation of musculotendon dynamics. ASME Journal of
    Biomechanical Engineering 135(2):021005. http://dx.doi.org/10.1115/1.4023390.

    Author: Matt Millard
    Tom Uchida
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Millard2012EquilibriumMuscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _simulation.Millard2012EquilibriumMuscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Millard2012EquilibriumMuscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _simulation.Millard2012EquilibriumMuscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _simulation.Millard2012EquilibriumMuscle_getClassName()

    def clone(self):
        r"""clone(Millard2012EquilibriumMuscle self) -> Millard2012EquilibriumMuscle"""
        return _simulation.Millard2012EquilibriumMuscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Millard2012EquilibriumMuscle self) -> std::string const &"""
        return _simulation.Millard2012EquilibriumMuscle_getConcreteClassName(self)

    def copyProperty_fiber_damping(self, source):
        r"""
        copyProperty_fiber_damping(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value):
        r"""
        append_fiber_damping(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue):
        r"""
        constructProperty_fiber_damping(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args):
        r"""
        get_fiber_damping(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_damping(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args):
        r"""
        upd_fiber_damping(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_damping(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args):
        r"""
        set_fiber_damping(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_damping(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_fiber_damping(self, *args)

    def copyProperty_default_activation(self, source):
        r"""
        copyProperty_default_activation(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value):
        r"""
        append_default_activation(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue):
        r"""
        constructProperty_default_activation(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args):
        r"""
        upd_default_activation(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_activation(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args):
        r"""
        set_default_activation(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_activation(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source):
        r"""
        copyProperty_default_fiber_length(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value):
        r"""
        append_default_fiber_length(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue):
        r"""
        constructProperty_default_fiber_length(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args):
        r"""
        get_default_fiber_length(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_length(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args):
        r"""
        upd_default_fiber_length(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_fiber_length(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args):
        r"""
        set_default_fiber_length(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_fiber_length(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_default_fiber_length(self, *args)

    def copyProperty_activation_time_constant(self, source):
        r"""
        copyProperty_activation_time_constant(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value):
        r"""
        append_activation_time_constant(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue):
        r"""
        constructProperty_activation_time_constant(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args):
        r"""
        upd_activation_time_constant(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_time_constant(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args):
        r"""
        set_activation_time_constant(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_time_constant(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source):
        r"""
        copyProperty_deactivation_time_constant(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value):
        r"""
        append_deactivation_time_constant(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue):
        r"""
        constructProperty_deactivation_time_constant(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args):
        r"""
        upd_deactivation_time_constant(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_deactivation_time_constant(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args):
        r"""
        set_deactivation_time_constant(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_deactivation_time_constant(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source):
        r"""
        copyProperty_minimum_activation(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value):
        r"""
        append_minimum_activation(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue):
        r"""
        constructProperty_minimum_activation(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args):
        r"""
        get_minimum_activation(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_minimum_activation(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args):
        r"""
        upd_minimum_activation(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_minimum_activation(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args):
        r"""
        set_minimum_activation(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_minimum_activation(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_minimum_activation(self, *args)

    def copyProperty_maximum_pennation_angle(self, source):
        r"""
        copyProperty_maximum_pennation_angle(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value):
        r"""
        append_maximum_pennation_angle(Millard2012EquilibriumMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue):
        r"""
        constructProperty_maximum_pennation_angle(Millard2012EquilibriumMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args):
        r"""
        get_maximum_pennation_angle(Millard2012EquilibriumMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_maximum_pennation_angle(Millard2012EquilibriumMuscle self) -> double const &
        """
        return _simulation.Millard2012EquilibriumMuscle_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args):
        r"""
        upd_maximum_pennation_angle(Millard2012EquilibriumMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_maximum_pennation_angle(Millard2012EquilibriumMuscle self) -> double &
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args):
        r"""
        set_maximum_pennation_angle(Millard2012EquilibriumMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_maximum_pennation_angle(Millard2012EquilibriumMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_maximum_pennation_angle(self, *args)

    def copyProperty_ActiveForceLengthCurve(self, source):
        r"""
        copyProperty_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_ActiveForceLengthCurve(self, source)

    def append_ActiveForceLengthCurve(self, value):
        r"""
        append_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, ActiveForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::ActiveForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_ActiveForceLengthCurve(self, value)

    def constructProperty_ActiveForceLengthCurve(self, initValue):
        r"""
        constructProperty_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, ActiveForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::ActiveForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_ActiveForceLengthCurve(self, initValue)

    def get_ActiveForceLengthCurve(self, *args):
        r"""
        get_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> ActiveForceLengthCurve

        Parameters
        ----------
        i: int

        get_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self) -> ActiveForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_get_ActiveForceLengthCurve(self, *args)

    def upd_ActiveForceLengthCurve(self, *args):
        r"""
        upd_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> ActiveForceLengthCurve

        Parameters
        ----------
        i: int

        upd_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self) -> ActiveForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_ActiveForceLengthCurve(self, *args)

    def set_ActiveForceLengthCurve(self, *args):
        r"""
        set_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, int i, ActiveForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::ActiveForceLengthCurve const &

        set_ActiveForceLengthCurve(Millard2012EquilibriumMuscle self, ActiveForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::ActiveForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_ActiveForceLengthCurve(self, *args)

    def copyProperty_ForceVelocityCurve(self, source):
        r"""
        copyProperty_ForceVelocityCurve(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_ForceVelocityCurve(self, source)

    def append_ForceVelocityCurve(self, value):
        r"""
        append_ForceVelocityCurve(Millard2012EquilibriumMuscle self, ForceVelocityCurve value) -> int

        Parameters
        ----------
        value: OpenSim::ForceVelocityCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_ForceVelocityCurve(self, value)

    def constructProperty_ForceVelocityCurve(self, initValue):
        r"""
        constructProperty_ForceVelocityCurve(Millard2012EquilibriumMuscle self, ForceVelocityCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::ForceVelocityCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_ForceVelocityCurve(self, initValue)

    def get_ForceVelocityCurve(self, *args):
        r"""
        get_ForceVelocityCurve(Millard2012EquilibriumMuscle self, int i) -> ForceVelocityCurve

        Parameters
        ----------
        i: int

        get_ForceVelocityCurve(Millard2012EquilibriumMuscle self) -> ForceVelocityCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_get_ForceVelocityCurve(self, *args)

    def upd_ForceVelocityCurve(self, *args):
        r"""
        upd_ForceVelocityCurve(Millard2012EquilibriumMuscle self, int i) -> ForceVelocityCurve

        Parameters
        ----------
        i: int

        upd_ForceVelocityCurve(Millard2012EquilibriumMuscle self) -> ForceVelocityCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_ForceVelocityCurve(self, *args)

    def set_ForceVelocityCurve(self, *args):
        r"""
        set_ForceVelocityCurve(Millard2012EquilibriumMuscle self, int i, ForceVelocityCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::ForceVelocityCurve const &

        set_ForceVelocityCurve(Millard2012EquilibriumMuscle self, ForceVelocityCurve value)

        Parameters
        ----------
        value: OpenSim::ForceVelocityCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_ForceVelocityCurve(self, *args)

    def copyProperty_FiberForceLengthCurve(self, source):
        r"""
        copyProperty_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_FiberForceLengthCurve(self, source)

    def append_FiberForceLengthCurve(self, value):
        r"""
        append_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, FiberForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::FiberForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_FiberForceLengthCurve(self, value)

    def constructProperty_FiberForceLengthCurve(self, initValue):
        r"""
        constructProperty_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, FiberForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::FiberForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_FiberForceLengthCurve(self, initValue)

    def get_FiberForceLengthCurve(self, *args):
        r"""
        get_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> FiberForceLengthCurve

        Parameters
        ----------
        i: int

        get_FiberForceLengthCurve(Millard2012EquilibriumMuscle self) -> FiberForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_get_FiberForceLengthCurve(self, *args)

    def upd_FiberForceLengthCurve(self, *args):
        r"""
        upd_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> FiberForceLengthCurve

        Parameters
        ----------
        i: int

        upd_FiberForceLengthCurve(Millard2012EquilibriumMuscle self) -> FiberForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_FiberForceLengthCurve(self, *args)

    def set_FiberForceLengthCurve(self, *args):
        r"""
        set_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, int i, FiberForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::FiberForceLengthCurve const &

        set_FiberForceLengthCurve(Millard2012EquilibriumMuscle self, FiberForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::FiberForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_FiberForceLengthCurve(self, *args)

    def copyProperty_TendonForceLengthCurve(self, source):
        r"""
        copyProperty_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, Millard2012EquilibriumMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012EquilibriumMuscle::Self const &

        """
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_TendonForceLengthCurve(self, source)

    def append_TendonForceLengthCurve(self, value):
        r"""
        append_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, TendonForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::TendonForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_append_TendonForceLengthCurve(self, value)

    def constructProperty_TendonForceLengthCurve(self, initValue):
        r"""
        constructProperty_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, TendonForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::TendonForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_TendonForceLengthCurve(self, initValue)

    def get_TendonForceLengthCurve(self, *args):
        r"""
        get_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> TendonForceLengthCurve

        Parameters
        ----------
        i: int

        get_TendonForceLengthCurve(Millard2012EquilibriumMuscle self) -> TendonForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_get_TendonForceLengthCurve(self, *args)

    def upd_TendonForceLengthCurve(self, *args):
        r"""
        upd_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, int i) -> TendonForceLengthCurve

        Parameters
        ----------
        i: int

        upd_TendonForceLengthCurve(Millard2012EquilibriumMuscle self) -> TendonForceLengthCurve
        """
        return _simulation.Millard2012EquilibriumMuscle_upd_TendonForceLengthCurve(self, *args)

    def set_TendonForceLengthCurve(self, *args):
        r"""
        set_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, int i, TendonForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::TendonForceLengthCurve const &

        set_TendonForceLengthCurve(Millard2012EquilibriumMuscle self, TendonForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::TendonForceLengthCurve const &

        """
        return _simulation.Millard2012EquilibriumMuscle_set_TendonForceLengthCurve(self, *args)
    _has_output_passive_fiber_elastic_force = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_set, doc=r"""_has_output_passive_fiber_elastic_force : bool""")
    _has_output_passive_fiber_elastic_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_set, doc=r"""_has_output_passive_fiber_elastic_force_along_tendon : bool""")
    _has_output_passive_fiber_damping_force = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_set, doc=r"""_has_output_passive_fiber_damping_force : bool""")
    _has_output_passive_fiber_damping_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_set, doc=r"""_has_output_passive_fiber_damping_force_along_tendon : bool""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. Produces a non-functional empty muscle.

        |

        *Overload 2:*
        Constructs a functional muscle using default curves and activation model
           parameters. The tendon is assumed to be elastic, full fiber dynamics are
           solved, and activation dynamics are included.
               :type aName: string
               :param aName: The name of the muscle.
               :type aMaxIsometricForce: float
               :param aMaxIsometricForce: The force generated by the muscle when fully
               activated at its optimal resting length with a contraction velocity of zero.
               :type aOptimalFiberLength: float
               :param aOptimalFiberLength: The optimal length of the muscle fiber.
               :type aTendonSlackLength: float
               :param aTendonSlackLength: The resting length of the tendon.
               :type aPennationAngle: float
               :param aPennationAngle: The angle of the fiber (in radians) relative to
               the tendon when the fiber is at its optimal resting length.
        """
        _simulation.Millard2012EquilibriumMuscle_swiginit(self, _simulation.new_Millard2012EquilibriumMuscle(*args))

    def getUseFiberDamping(self):
        r"""
        :rtype: boolean
        :return: A boolean indicating whether fiber damping is being used.
        """
        return _simulation.Millard2012EquilibriumMuscle_getUseFiberDamping(self)

    def getFiberDamping(self):
        r"""
        :rtype: float
        :return: The fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberDamping(self)

    def getDefaultActivation(self):
        r"""
        :rtype: float
        :return: The default activation level that is used as an initial
               condition if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscle_getDefaultActivation(self)

    def getDefaultFiberLength(self):
        r"""
        :rtype: float
        :return: The default fiber length that is used as an initial condition
               if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscle_getDefaultFiberLength(self)

    def getActivationTimeConstant(self):
        r"""
        :rtype: float
        :return: The activation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self):
        r"""
        :rtype: float
        :return: The deactivation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_getDeactivationTimeConstant(self)

    def getMinimumActivation(self):
        r"""
        :rtype: float
        :return: The minimum activation level permitted by the muscle model.
               Note that this equilibrium model, like all equilibrium models, has a
               singularity when activation approaches 0, which means that a non-zero lower
               bound is required.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumActivation(self)

    def getActiveForceLengthCurve(self):
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: The ActiveForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self):
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: The ForceVelocityCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self):
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: The FiberForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self):
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: The TendonForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getTendonForceLengthCurve(self)

    def getPennationModel(self):
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: The MuscleFixedWidthPennationModel owned by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getPennationModel(self)

    def getActivationModel(self):
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: The MuscleFirstOrderActivationDynamicModel owned by this
               model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationModel(self)

    def getMinimumFiberLength(self):
        r"""
        :rtype: float
        :return: The minimum fiber length, which is the maximum of two values:
               the smallest fiber length allowed by the pennation model, and the minimum
               fiber length on the active-force-length curve. When the fiber reaches this
               length, it is constrained to this value until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self):
        r"""
        :rtype: float
        :return: The minimum fiber length along the tendon, which is the maximum
               of two values: the smallest fiber length along the tendon permitted by the
               pennation model, and the minimum fiber length along the tendon on the
               active-force-length curve. When the fiber length reaches this value, it is
               constrained to this length along the tendon until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumFiberLengthAlongTendon(self)

    def getTendonForceMultiplier(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :rtype: float
               :return: The normalized force term associated with the tendon element,
               :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation.
        """
        return _simulation.Millard2012EquilibriumMuscle_getTendonForceMultiplier(self, s)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        :rtype: float
        :return: The stiffness of the muscle fibers along the tendon (N/m).
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberStiffnessAlongTendon(self, s)

    def getFiberVelocity(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The velocity of the fiber (m/s).
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberVelocity(self, s)

    def getActivationDerivative(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The time derivative of activation.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationDerivative(self, s)

    def getPassiveFiberElasticForce(self, s):
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s):
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s):
        r"""
        get the portion of the passive fiber force generated by the damping
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s):
        r"""
        get the portion of the passive fiber force generated by the damping
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberDampingForceAlongTendon(self, s)

    def setMuscleConfiguration(self, ignoreTendonCompliance, ignoreActivationDynamics, dampingCoefficient):
        r"""
        :type ignoreTendonCompliance: boolean
        :param ignoreTendonCompliance: Use a rigid (true) or elastic tendon.
               :type ignoreActivationDynamics: boolean
               :param ignoreActivationDynamics: Treat the excitation input as the
               activation signal (true) or use a first-order activation dynamic model.
               :type dampingCoefficient: float
               :param dampingCoefficient: Specify the amount of damping to include in
               the model (must be either 0 or greater than 0.001).
        """
        return _simulation.Millard2012EquilibriumMuscle_setMuscleConfiguration(self, ignoreTendonCompliance, ignoreActivationDynamics, dampingCoefficient)

    def setFiberDamping(self, dampingCoefficient):
        r"""
        :type dampingCoefficient: float
        :param dampingCoefficient: Define the fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberDamping(self, dampingCoefficient)

    def setDefaultActivation(self, activation):
        r"""
        :type activation: float
        :param activation: The default activation level that is used to
               initialize the muscle.
        """
        return _simulation.Millard2012EquilibriumMuscle_setDefaultActivation(self, activation)

    def setActivation(self, s, activation):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :type activation: float
               :param activation: The desired activation level.
        """
        return _simulation.Millard2012EquilibriumMuscle_setActivation(self, s, activation)

    def setDefaultFiberLength(self, fiberLength):
        r"""
        :type fiberLength: float
        :param fiberLength: The default fiber length that is used to initialize
               the muscle.
        """
        return _simulation.Millard2012EquilibriumMuscle_setDefaultFiberLength(self, fiberLength)

    def setActivationTimeConstant(self, activationTimeConstant):
        r"""
        :type activationTimeConstant: float
        :param activationTimeConstant: The activation time constant (in
               seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_setActivationTimeConstant(self, activationTimeConstant)

    def setDeactivationTimeConstant(self, deactivationTimeConstant):
        r"""
        :type deactivationTimeConstant: float
        :param deactivationTimeConstant: The deactivation time constant (in
               seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_setDeactivationTimeConstant(self, deactivationTimeConstant)

    def setMinimumActivation(self, minimumActivation):
        r"""
        :type minimumActivation: float
        :param minimumActivation: The minimum permissible activation level.
        """
        return _simulation.Millard2012EquilibriumMuscle_setMinimumActivation(self, minimumActivation)

    def setActiveForceLengthCurve(self, aActiveForceLengthCurve):
        r"""
        :type aActiveForceLengthCurve: :py:class:`ActiveForceLengthCurve`
        :param aActiveForceLengthCurve: The ActiveForceLengthCurve used by the
               muscle model to scale active fiber force as a function of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setActiveForceLengthCurve(self, aActiveForceLengthCurve)

    def setForceVelocityCurve(self, aForceVelocityCurve):
        r"""
        :type aForceVelocityCurve: :py:class:`ForceVelocityCurve`
        :param aForceVelocityCurve: The ForceVelocityCurve used by the muscle
               model to calculate the derivative of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setForceVelocityCurve(self, aForceVelocityCurve)

    def setFiberForceLengthCurve(self, aFiberForceLengthCurve):
        r"""
        :type aFiberForceLengthCurve: :py:class:`FiberForceLengthCurve`
        :param aFiberForceLengthCurve: The FiberForceLengthCurve used by the
               muscle model to calculate the passive force the muscle fiber generates as a
               function of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberForceLengthCurve(self, aFiberForceLengthCurve)

    def setTendonForceLengthCurve(self, aTendonForceLengthCurve):
        r"""
        :type aTendonForceLengthCurve: :py:class:`TendonForceLengthCurve`
        :param aTendonForceLengthCurve: The TendonForceLengthCurve used by the
               muscle model to calculate the force exerted by the tendon as a function of
               tendon length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setTendonForceLengthCurve(self, aTendonForceLengthCurve)

    def setFiberLength(self, s, fiberLength):
        r"""
        :type s: :py:class:`State`, out
        :param s: The state of the system.
               :type fiberLength: float
               :param fiberLength: The desired fiber length (m).
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberLength(self, s, fiberLength)

    def computeActuation(self, s):
        r"""
        :type s: :py:class:`State`, in
        :param s: The state of the system.
               :rtype: float
               :return: The tensile force the muscle is generating (N).
        """
        return _simulation.Millard2012EquilibriumMuscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        Computes the fiber length such that the fiber and tendon are developing
           the same force, distributing the velocity of the entire musculotendon
           actuator between the fiber and tendon according to their relative
           stiffnesses.
               :type s: :py:class:`State`, in/out
               :param s: The state of the system.
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscle_computeInitialFiberEquilibrium(self, s)

    def computeFiberEquilibrium(self, s, solveForVelocity=False):
        r"""
        Computes the fiber length such that the fiber and tendon are developing
               the same force, either assuming muscle-tendon velocity as provided
               by the state or zero as designated by the useZeroVelocity flag.
               :type s: :py:class:`State`, in/out
               :param s:         The state of the system.
               :type solveForVelocity: boolean, optional
               :param solveForVelocity:  Flag indicating to solve for fiber velocity,
                                            which by default is false (zero fiber-velocity)
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscle_computeFiberEquilibrium(self, s, solveForVelocity)

    def calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity):
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Millard2012EquilibriumMuscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT):
        r"""
        calcFiberStateGivenBoundaryCond(Millard2012EquilibriumMuscle self, double lengthMT, double velocityMT, double tendonForce, double dTendonForceDT) -> Vec4

        Parameters
        ----------
        lengthMT: double
        velocityMT: double
        tendonForce: double
        dTendonForceDT: double

        """
        return _simulation.Millard2012EquilibriumMuscle_calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""
        calcInextensibleTendonActiveFiberForce(Millard2012EquilibriumMuscle self, State s, double aActivation) -> double

        Parameters
        ----------
        s: SimTK::State &
        aActivation: double

        """
        return _simulation.Millard2012EquilibriumMuscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def extendPostScale(self, s, scaleSet):
        r"""
        End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The
                optimal fiber length and tendon slack length are each multiplied by the
                ratio of the current path length and the path length before scaling.
        """
        return _simulation.Millard2012EquilibriumMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscle

# Register Millard2012EquilibriumMuscle in _simulation:
_simulation.Millard2012EquilibriumMuscle_swigregister(Millard2012EquilibriumMuscle)

