
<!-- %W  o8p2s3_o8p5s3.xml GAP 4 package CTblLib            Thomas Breuer -->

<Chapter Label="chap:o8p2s3_o8p5s3">
<Heading>&GAP; Computations with <M>O_8^+(5).S_3</M> and <M>O_8^+(2).S_3</M></Heading>

Date: October 08th, 2006

<P/>

This chapter shows how to construct a representation of the automorphic
extension <M>G</M> of the simple group <M>S = O_8^+(5)</M>
by a symmetric group on three points,
together with an embedding of the normalizer <M>H</M> of an <M>O_8^+(2)</M>
type subgroup of <M>O_8^+(5)</M>.

<P/>

As an application, it is shown that the permutation representation of <M>G</M>
on the cosets of <M>H</M> has a base of length two.
This question arose in&nbsp;<Cite Key="BGS11"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:overview_o8p2s3">
<Heading>Overview</Heading>

Let <M>S</M> denote the simple group
<M>O_8^+(5) \cong </M> P<M>\Omega^+(8,5)</M>,
that is, the nonabelian simple group that occurs as a composition factor
of the general orthogonal group GO<M>{}^+(8,5)</M> of <M>8 \times 8</M>
matrices over the field with five elements.

<P/>

The outer automorphism group of <M>S</M> is isomorphic to the symmetric group
on four points.
Let <M>G</M> be an automorphic extension of <M>S</M> by the symmetric group
on three points.
By&nbsp;<Cite Key="Kle87"/>,
the group <M>S</M> contains a maximal subgroup <M>M</M> of the type
<M>O_8^+(2)</M> such that the normalizer <M>H</M>, say,
of <M>M</M> in <M>G</M> is an automorphic extension of <M>M</M> by
a symmetric group on three points.
(In fact, <M>H</M> is isomorphic to the full automorphism group of
<M>O_8^+(2)</M>.)

<P/>

Let <M>S.2</M> and <M>S.3</M> denote intermediate subgroups between
<M>S</M> and <M>G</M>,
in which <M>S</M> has the indices <M>2</M> and <M>3</M>, respectively.
Analogously, let <M>M.2 = H \cap S.2</M> and <M>M.3 = H \cap S.3</M>.

<P/>

In Section&nbsp;<Ref Subsect="sect:sect2"/>,
we use the following approach to construct representations of <M>M.2</M> and
<M>S.2</M>.
By&nbsp;<Cite Key="CCN85" Where="p. 85"/>,
the Weyl group <M>W</M> of type <M>E_8</M> is a double cover of <M>M.2</M>,
and the reduction of its rational <M>8</M>-dimensional representation modulo
<M>5</M> embeds into the general orthogonal group GO<M>{}^+(8,5)</M>,
which has the structure <M>2.O_8^+(5).2^2</M>.
Then the actions of GO<M>{}^+(8,5)</M> and of an isomorphic image of <M>W</M>
in GO<M>{}^+(8,5)</M> on <M>1</M>-spaces in the
natural module of GO<M>{}^+(8,5)</M> yield <M>M.2</M> as a subgroup of
(a supergroup of) <M>S.2</M>,
where both groups are represented as permutation groups on <M>N = 19\,656</M>
points.

<P/>

In Section&nbsp;<Ref Sect="sect:sect3"/>,
first we use &GAP; to compute the automorphism group of <M>M</M>.
Then we take an outer automorphism <M>\alpha</M> of <M>M</M>, of order three,
and extend <M>\alpha</M> to an automorphism of <M>S</M>.
Concretely, we compute the images of generating sets of <M>S</M> and <M>M</M>
under <M>\alpha</M> and <M>\alpha^2</M>.
This yields permutation representations of <M>S.3</M> and its subgroup
<M>M.3</M> on <M>3 N = 58\,968</M> points.

<P/>

In Section&nbsp;<Ref Sect="sect:sect4"/>,
we put the above information together,
in order to construct permutation representations of <M>G</M> and <M>M</M>,
on <M>3 N</M> points.

<P/>

As an application, it is shown in Section&nbsp;<Ref Sect="sect:appl"/>
that the permutation representation of <M>G</M> on the cosets of <M>H</M>
has a base of length two;
this question arose in&nbsp;<Cite Key="BGS11"/>.

<P/>

In two appendices, it is discussed how to derive a part of this result
from the permutation character <M>(1_H^G)_H</M>
(see Section&nbsp;<Ref Subsect="sect:appendix_permchar"/>),
and a file containing the data used in the earlier sections is described
(see Section&nbsp;<Ref Subsect="sect:appendix_data"/>).

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:sect2">
<Heading>Constructing Representations of <M>M.2</M> and <M>S.2</M></Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:repres_W_E8">
<Heading>A Matrix Representation of the Weyl Group of Type <M>E_8</M></Heading>

Following the recipe listed
in&nbsp;<Cite Key="CCN85" Where="p. 85, Section Weyl"/>,
we can generate the Weyl group <M>W</M> of type <M>E_8</M> as a group of
rational <M>8 \times 8</M> matrices generated by the reflections in the
vectors

<Display Mode="M">
   \left(\pm 1/2, \pm 1/2, 0, 0, 0, 0, 0, 0\right)
</Display>

plus the vectors obtained from these by permuting the coordinates,
plus those those vectors of the form

<Display Mode="M">
   \left( \pm 1/2, \pm 1/2, \pm 1/2, \pm 1/2,
          \pm 1/2, \pm 1/2, \pm 1/2, \pm 1/2 \right)
</Display>

that have an even number of negative signs.
(Clearly it is sufficient to consider only one vector form a pair
<M>\pm v</M>.)

<P/>

<Example><![CDATA[
gap> rootvectors:= [];;
gap> for i in Combinations( [ 1 .. 8 ], 2 ) do
>      v:= 0 * [ 1 .. 8 ];
>      v{i}:= [ 1, 1 ];
>      Add( rootvectors, v );
>      v:= 0 * [ 1 .. 8 ];
>      v{i}:= [ 1, -1 ];
>      Add( rootvectors, v );
>    od;
gap> Append( rootvectors,
>      1/2 * Filtered( Tuples( [ -1, 1 ], 8 ),
>              x -> x[1] = 1 and Number( x, y -> y = 1 ) mod 2 = 0 ) );
gap> we8:= Group( List( rootvectors, ReflectionMat ) );
<matrix group with 120 generators>
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:embedding_W_E8">
<Heading>Embedding the Weyl group of Type <M>E_8</M> into GO<M>{}^+(8,5)</M></Heading>

The elements in the group constructed above respect the symmetric bilinear
form that is given by the identity matrix.

<P/>

<Example><![CDATA[
gap> I:= IdentityMat( 8 );;
gap> ForAll( GeneratorsOfGroup( we8 ), x -> x * TransposedMat(x) = I );
true
]]></Example>

<P/>

So the reduction of the matrices modulo <M>5</M> yields a group <M>W^{\ast}</M>
of orthogonal matrices w.&nbsp;r.&nbsp;t.&nbsp;the identity matrix.
The group GO<M>{}^+(8,5)</M> returned by the &GAP; function
<Ref Func="GO" BookName="ref"/> leaves
a different bilinear form invariant.

<P/>

<Example><![CDATA[
gap> largegroup:= GO(1,8,5);;
gap> Display( InvariantBilinearForm( largegroup ).matrix );
 . 1 . . . . . .
 1 . . . . . . .
 . . 2 . . . . .
 . . . 2 . . . .
 . . . . 2 . . .
 . . . . . 2 . .
 . . . . . . 2 .
 . . . . . . . 2
]]></Example>

<P/>

In order to conjugate <M>W^{\ast}</M> into this group,
we need a <M>2 \times 2</M> matrix <M>T</M> over the field with five elements
with the property that <M>T T^{tr}</M>
is half of the upper left <M>2 \times 2</M> matrix in the above matrix.

<P/>

<Example><![CDATA[
gap> T:= [ [ 1, 2 ], [ 4, 2 ] ] * One( GF(5) );;
gap> Display( 2 * T * TransposedMat( T ) );
 . 1
 1 .
gap> I:= IdentityMat( 8, GF(5) );;
gap> I{ [ 1, 2 ] }{ [ 1, 2 ] }:= T;;
gap> conj:= List( GeneratorsOfGroup( we8 ), x -> I * x * I^-1 );;
gap> IsSubset( largegroup, conj );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:120pt">
<Heading>Compatible Generators of <M>M</M>, <M>M.2</M>, <M>S</M>, and <M>S.2</M></Heading>

For the next computations,
we switch from the natural matrix representation of GO<M>{}^+(8,5)</M>
to a permutation representation of PGO<M>{}^+(8,5)</M>,
of degree <M>N = 19\,656</M>,
which is given by the action of GO<M>{}^+(8,5)</M> on the smallest orbit
of <M>1</M>-spaces in its natural module.

<P/>

<Example><![CDATA[
gap> orbs:= OrbitsDomain( largegroup, NormedRowVectors( GF(5)^8 ),
>                         OnLines );;
gap> List( orbs, Length );
[ 39000, 39000, 19656 ]
gap> N:= Length( orbs[3] );
19656
gap> orbN:= SortedList( orbs[3] );;
gap> largepermgroup:= Action( largegroup, orbN, OnLines );;
]]></Example>

<P/>

In the same way,
permutation representations of the subgroup <M>M.2 \cong </M>SO<M>{}^+(8,2)</M>
and of its derived subgroup <M>M</M> are obtained.
But first we compute a smaller generating set of the simple group <M>M</M>,
using a permutation representation on <M>120</M> points.

<P/>

<Example><![CDATA[
gap> orbwe8:= SortedList( Orbit( we8, rootvectors[1], OnLines ) );;
gap> Length( orbwe8 );
120
gap> we8_to_m2:= ActionHomomorphism( we8, orbwe8, OnLines );;
gap> m2_120:= Image( we8_to_m2 );;
gap> m_120:= DerivedSubgroup( m2_120 );;
gap> sml:= SmallGeneratingSet( m_120 );;  Length( sml );
2
gap> gens_m:= List( sml, x -> PreImagesRepresentative( we8_to_m2, x ) );;
]]></Example>

<P/>

Now we compute the actions of <M>M</M> and <M>M.2</M>
on the above orbit of length <M>N</M>.
For generating <M>M.2</M>, we choose an element <M>b_N \in M.2 \setminus M</M>,
which is obtained from the action of a matrix <M>b \in 2.M.2 \setminus 2.M</M>.

<P/>

<Example><![CDATA[
gap> gens_m_N:= List( gens_m,
>      x -> Permutation( I * x * I^-1, orbN, OnLines ) );;
gap> m_N:= Group( gens_m_N );;
gap> b:= I * we8.1 * I^-1;;
gap> DeterminantMat( b );
Z(5)^2
gap> b_N:= Permutation( b, orbN, OnLines );;
gap> m2_N:= ClosureGroup( m_N, b_N );;
]]></Example>

<P/>

(Note that <M>M.2</M> is not contained in PSO<M>{}^+(8,5)</M>,
since the determinant of <M>b</M> is <M>-1</M> in the field with five elements.)

<P/>

The group <M>S</M> is the derived subgroup of PSO<M>{}^+(8,5)</M>,
and <M>S.2</M> is generated by <M>S</M> together with <M>b_N</M>.

<P/>

<Example><![CDATA[
gap> s_N:= DerivedSubgroup( largepermgroup );;
gap> s2_N:= ClosureGroup( s_N, b_N );;
]]></Example>

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:sect3">
<Heading>Constructing Representations of <M>M.3</M> and <M>S.3</M></Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:action_M.3_M">
<Heading>The Action of <M>M.3</M> on <M>M</M></Heading>

Let <M>\alpha</M> be an automorphism of <M>M</M>, of order three.
Then a representation of the semidirect product <M>M.3</M> of <M>M</M> by
<M>\langle \alpha \rangle</M> can be constructed as follows.

<P/>

If <M>M</M> is given by a matrix representation then we map <M>g \in M</M>
to the block diagonal matrix

<Alt Only="LaTeX">
\[
   \left[ \begin{array}{ccc}
             g &amp;          &amp; \\
               &amp; g^\alpha &amp; \\
               &amp; &amp;    g^{(\alpha^2)}
          \end{array} \right] ,
\]
</Alt>

<Alt Only="Text">
<Verb>
                          ⌈ g             ⌉
                          |   g^α         |
                          ⌊       g^(α^2) ⌋,
</Verb>
</Alt>

<Alt Only="HTML"><![CDATA[
<div class="pcenter">
  <table class="GAPDocTable">
    <tr>
      <td class="tdright"><span class="SimpleMath">g</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">g^α</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">g^(α^2)</span></td>
    </tr>
  </table>
</div>
]]></Alt>

and we represent <M>\alpha</M> by the block permutation matrix

<Alt Only="LaTeX">
\[
   \left[ \begin{array}{ccc}
            &amp; &amp; I \\
            I     &amp; &amp; \\
            &amp; I     &amp;
          \end{array} \right] ,
\]
</Alt>

<Alt Only="Text">
<Verb>
                          ⌈     I ⌉
                          | I     |
                          ⌊   I   ⌋,
</Verb>
</Alt>

<Alt Only="HTML"><![CDATA[
<div class="pcenter">
  <table class="GAPDocTable">
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">I</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">I</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">I</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
  </table>
</div>
]]></Alt>

where <M>I</M> is the identity element in <M>M</M>.

<P/>

We need the action of <M>\alpha</M> on <M>M</M>.
More precisely, we need images of the chosen generators of <M>M</M>
under <M>\alpha</M> and <M>\alpha^2</M>.

<P/>

The group <M>M</M> is small enough for asking &GAP; to compute
its automorphism group, which is isomorphic with <M>O^+_8(2).S_3</M>;
for that, we use the degree <M>120</M> permutation representation
constructed in Section&nbsp;<Ref Subsect="subsect:120pt"/>.

<P/>

<Example><![CDATA[
gap> aut_m:= AutomorphismGroup( m_120 );;
]]></Example>

<P/>

We pick an outer automorphism <M>\alpha</M> of order three.

<P/>

<Example><![CDATA[
gap> nice_aut_m:= NiceMonomorphism( aut_m );;
gap> der:= DerivedSubgroup( Image( nice_aut_m ) );;
gap> der2:= DerivedSubgroup( der );;
gap> repeat x:= Random( der );
>      ord:= Order( x );
>    until ord mod 3 = 0 and ord mod 9 <> 0 and not x in der2;
gap> x:= x^( ord / 3 );;
gap> alpha_120:= PreImagesRepresentative( nice_aut_m, x );;
]]></Example>

<P/>

Next we compute the images of the generators <C>sml</C> under <M>\alpha</M>
and <M>\alpha^2</M>,
and the corresponding elements in the action of <M>M</M> on <M>N</M> points.

<P/>

<Example><![CDATA[
gap> sml_alpha:= List( sml, x -> Image( alpha_120, x ) );;
gap> sml_alpha_2:= List( sml_alpha, x -> Image( alpha_120, x ) );;
gap> gens_m_alpha:= List( sml_alpha,
>                     x -> PreImagesRepresentative( we8_to_m2, x ) );;
gap> gens_m_alpha_2:= List( sml_alpha_2,
>                       x -> PreImagesRepresentative( we8_to_m2, x ) );;
gap> gens_m_N_alpha:= List( gens_m_alpha,
>      x -> Permutation( I * x * I^-1, orbN, OnLines ) );;
gap> gens_m_N_alpha_2:= List( gens_m_alpha_2,
>      x -> Permutation( I * x * I^-1, orbN, OnLines ) );;
]]></Example>

<P/>

Finally, we use the construction descibed in the beginning of this section,
and obtain a permutation representation of <M>M.3</M> on <M>3 N = 58\,968</M>
points.

<P/>

<Example><![CDATA[
gap> alpha_3N:= PermList( Concatenation( [ [ 1 .. N ] + 2*N,
>                                          [ 1 .. N ],
>                                          [ 1 .. N ] + N ] ) );;
gap> gens_m_3N:= List( [ 1 .. Length( gens_m_N ) ],
>      i -> gens_m_N[i] *
>           ( gens_m_N_alpha[i]^alpha_3N ) *
>           ( gens_m_N_alpha_2[i]^(alpha_3N^2) ) );;
gap> m_3N:= Group( gens_m_3N );;
gap> m3_3N:= ClosureGroup( m_3N, alpha_3N );;
]]></Example>

<!-- gap> shift:= Product( List( [ 1 .. N ], i -> (i,i+N,i+2N) ) );;
     # exceeds the memory! -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:M.3andS.3">
<Heading>The Action of <M>S.3</M> on <M>S</M></Heading>

Our approach is to extend the automorphism <M>\alpha</M> of <M>M</M> to
<M>S</M>;
we can do this because in the full automorphism group of <M>S</M>,
<E>any</E> <M>O^+_8(2)</M> type subgroup extends
to a group of the type <M>O^+_8(2).3</M>, and this extension lies in a
subgroup of the type <M>O^+_8(5).3</M> (see&nbsp;<Cite Key="Kle87"/>).

<P/>

The group <M>M</M> is maximal in <M>S</M>,
so <M>S</M> is generated by <M>M</M> together with any element
<M>s \in S \setminus M</M>.
Having fixed such an element <M>s</M>, what we have to is to find the images
of <M>s</M> under the automorphisms that extend <M>\alpha</M> and
<M>\alpha^2</M>.

<P/>

For that, we first choose <M>x \in M</M> such that <M>C_S(x)</M> is a
small group that is not contained in <M>M</M>.
Then we choose <M>s \in C_S(x) \setminus M</M>,
and using that <M>s^\alpha</M> must lie in <M>C_S(C_M(s)^\alpha)</M>,
we then check which elements of this small subgroup can be the desired
image.

<P/>

Each element <M>x</M> of order nine in <M>M</M> has a root <M>s</M> of order
<M>63</M> in <M>S</M>,
and <M>C_S(x)</M> has order <M>189</M>.
For suitable such <M>x</M>,
exactly one element <M>y \in C_S(C_M(s)^\alpha)</M> has order <M>63</M> and
satisfies the necessary conditions
that the orders of the products of <M>s</M> and the generators of <M>M</M>
are equal to the orders of the product of <M>y</M> and the images of these
generators under <M>\alpha</M>.
In other words, we have <M>s^\alpha = y</M>.

<P/>

<Example><![CDATA[
gap> alpha:= GroupHomomorphismByImagesNC( m_N, m_N,
>                gens_m_N, gens_m_N_alpha );;
gap> CheapTestForHomomorphism:= function( gens, genimages, x, cand )
>        return Order( x ) = Order( cand ) and
>               ForAll( [ 1 .. Length( gens ) ],
>            i -> Order( gens[i] * x ) = Order( genimages[i] * cand ) );
> end;;
gap> repeat
>      repeat
>        x:= Random( m_N );
>      until Order( x ) = 9;
>      c_s:= Centralizer( s_N, x );
>      repeat
>        s:= Random( c_s );
>      until Order( s ) = 63;
>      c_m_alpha:= Images( alpha, Centralizer( m_N, s ) );
>      good:= Filtered( Elements( Centralizer( s_N, c_m_alpha ) ),
>               x -> CheapTestForHomomorphism( gens_m_N,
>                      gens_m_N_alpha, s, x ) );
>    until Length( good ) = 1;
gap> s_alpha:= good[1];;
gap> c_m_alpha_2:= Images( alpha, c_m_alpha );;
gap> good:= Filtered( Elements( Centralizer( s_N, c_m_alpha_2 ) ),
>      x -> CheapTestForHomomorphism( gens_m_N_alpha, gens_m_N_alpha_2,
>                                     s_alpha, x ) );;
gap> s_alpha_2:= good[1];;
]]></Example>

<P/>

Using the notation of the previous section,
this means that the permutation representation of <M>M.3</M> on <M>3 N</M>
points can be extended to <M>S.3</M> by choosing the permutation corresponding
to the block diagonal matrix
<Alt Only="LaTeX">
\[
   \left[ \begin{array}{ccc}
            s     &amp;    &amp; \\
            &amp; s^\alpha &amp; \\
            &amp; &amp;    s^{(\alpha^2)}
          \end{array} \right] ,
\]
</Alt>

<Alt Only="Text">
<Verb>
                          ⌈ s             ⌉
                          |   s^α         |
                          ⌊       s^(α^2) ⌋,
</Verb>
</Alt>

<Alt Only="HTML"><![CDATA[
<div class="pcenter">
  <table class="GAPDocTable">
    <tr>
      <td class="tdright"><span class="SimpleMath">s</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">s^α</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">s^(α^2)</span></td>
    </tr>
  </table>
</div>
]]></Alt>

as an additional generator.

<P/>

<Example><![CDATA[
gap> outer:= s * ( s_alpha^alpha_3N ) * ( s_alpha_2^(alpha_3N^2) );;
gap> s3_3N:= ClosureGroup( m3_3N, outer );;
]]></Example>

<P/>

(And of course we have <M>S = \langle M, s \rangle</M>,
which yields generators for <M>S</M> that are compatible with those of
<M>M</M>.)

<P/>

<Example><![CDATA[
gap> s_3N:= ClosureGroup( m_3N, outer );;
]]></Example>

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:sect4">
<Heading>Constructing Compatible Generators of <M>H</M> and <M>G</M></Heading>

After having constructed compatible representations of <M>M.2</M> and
<M>G.2</M> on <M>N</M> points
(see Section&nbsp;<Ref Subsect="subsect:120pt"/>)
and of <M>M.3</M> and <M>S.3</M> on <M>3 N</M> points
(see Section&nbsp;<Ref Subsect="subsect:M.3andS.3"/>),
the last construction step is to find a permutation on <M>3 N</M> points
with the following properties:

<List>
<Item>
    The induced automorphism <M>\beta</M> of <M>M</M> extends to <M>M.3</M>
    such that the automorphism <M>\alpha</M> of <M>M</M> is inverted,
    modulo inner automorphisms of <M>M</M>.
</Item>
<Item>
    The action on the first <M>N</M> points coincides with that of the element
    <M>b_N \in M.2 \setminus M</M> that was constructed in
    Section&nbsp;<Ref Subsect="subsect:120pt"/>.
</Item>
</List>

<P/>

Using the notation of the previous sections,
we represent <M>\beta</M> by a block matrix

<Alt Only="LaTeX">
\[
   \left[ \begin{array}{ccc}
            b     &amp; &amp; \\
            &amp; &amp;   b d \\
            &amp;   b g &amp;
          \end{array} \right] ,
\]
</Alt>

<Alt Only="Text">
<Verb>
                          ⌈ b         ⌉
                          |       b d |
                          ⌊   b g     ⌋,
</Verb>
</Alt>

<Alt Only="HTML"><![CDATA[
<div class="pcenter">
  <table class="GAPDocTable">
    <tr>
      <td class="tdright"><span class="SimpleMath">b</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">b d</span></td>
    </tr>
    <tr>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
      <td class="tdright"><span class="SimpleMath">b g</span></td>
      <td class="tdright"><span class="SimpleMath">&nbsp;</span></td>
    </tr>
  </table>
</div>
]]></Alt>

where <M>b</M> describes the action of <M>\beta</M> on <M>M</M>
(on <M>N</M> points),
<M>g</M> describes the inner automorphism <M>\gamma</M> of <M>M</M>
that is defined by the condition <M>\beta \alpha = \alpha^2 \beta \gamma</M>,
and <M>d</M> describes <M>\gamma \gamma^\alpha</M>.

<P/>

So we compute an element in <M>M</M> that induces the conjugation automorphism
<M>\gamma</M>, and its image under <M>\alpha</M>.
We do this in the representation of <M>M</M> on <M>120</M> points,
and carry over the result to the representation on <M>N</M> points,
via the rational matrix representation;
this approach had been used already in
Section&nbsp;<Ref Subsect="subsect:120pt"/>.

<P/>

<Example><![CDATA[
gap> b_120:= Permutation( we8.1, orbwe8, OnLines );;
gap> g_120:= RepresentativeAction( m_120,
>                List( sml_alpha_2, x -> x^b_120 ),
>                List( sml, x -> (x^b_120)^alpha_120 ), OnTuples );;
gap> g_120_alpha:= g_120^alpha_120;;
gap> g_N:= Permutation( I * PreImagesRepresentative( we8_to_m2, g_120 )
>                         * I^-1, orbN, OnLines );;
gap> g_N_alpha:= Permutation( I * PreImagesRepresentative( we8_to_m2,
>                  g_120_alpha ) * I^-1, orbN, OnLines );;
gap> inv:= PermList( Concatenation(
>                      ListPerm( b_N ),
>                      ListPerm( b_N * g_N ) + 2*N,
>                      ListPerm( b_N * g_N * g_N_alpha ) + N ) );;
]]></Example>

<P/>

So we have constructed compatible generators for <M>H</M> and <M>G</M>.

<P/>

<Example><![CDATA[
gap> h:= ClosureGroup( m3_3N, inv );;
gap> g:= ClosureGroup( s3_3N, inv );;
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:appl">
<Heading>Application: Regular Orbits of <M>H</M> on <M>G/H</M></Heading>

We want to show that <M>H</M> has regular orbits on the right cosets
<M>G/H</M>.
The stabilizer in <M>H</M> of the coset <M>H g</M> is <M>H \cap H^g</M>,
so we compute that there are elements <M>s \in S</M> with the property
<M>|H \cap H^s| = 1</M>.

<P/>

(Of course this implies that also in the permutation representations of
the subgroups <M>S</M>, <M>S.2</M>, and <M>S.3</M> of <M>G</M> on the
cosets of the intersection with <M>H</M>,
the point stabilizers have regular orbits.)

<P/>

<Example><![CDATA[
gap> repeat
>      conj:= Random( s_3N );
>      inter:= Intersection( h, h^conj );
>    until Size( inter ) = 1;
]]></Example>

<P/>

Eventually &GAP; will return from this loop,
so there are elements <M>s</M> with the required property.

<P/>

(Computing one such intersection takes about six minutes
on a 2.5 GHz Pentium 4,
so one may have to be a bit patient.)

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:appendix_permchar">
<Heading>Appendix: The Permutation Character <M>(1_H^G)_H</M></Heading>

<P/>

As an alternative to the computation of <M>|H \cap H^s|</M> for suitable
<M>s \in S</M>, we can try to derive information from the
permutation character <M>(1_H^G)_H</M>.
Unfortunately, there seems to be no easy way to prove the existence of
regular <M>H</M>-orbits on <M>G/H</M>
(cf.&nbsp;Section&nbsp;<Ref Sect="sect:appl"/>)
only by means of this character.

<P/>

However, it is not difficult to show that regular orbits
of <M>M</M>, <M>M.2</M>, and <M>M.3</M> exist.
For that, we compute <M>(1_H^G)_H</M>,
by computing class representatives of <M>H</M>,
their centralizer orders in <M>G</M>,
and the class fusion of <M>H</M>-classes in <M>G</M>.

<P/>

We want to compute the class representatives in a small permutation
representation of <M>H</M>;
this could be done using the degree <M>360</M> representation that was
implicitly constructed above,

<!-- (Each class representative can be written in the form
     <M>h \alpha^i</M> with <M>h \in M.2</M>.) -->

but it is technically easier to use a degree <M>405</M> representation
that is obtained from the degree <M>58\,968</M> representation
by the action of <M>H</M> on blocks in an orbit of length <M>22\,680</M>.
(One could get this also using the &GAP; function
<Ref Func="SmallerDegreePermutationRepresentation" BookName="ref"/>.)

<P/>

<Example><![CDATA[
gap> orbs:= Orbits( h, MovedPoints( h ) );;
gap> List( orbs, Length );
[ 22680, 36288 ]
gap> orb:= orbs[1];;
gap> bl:= Blocks( h, orb );;  Length( bl[1] );
2
gap> actbl:= Action( h, bl, OnSets );;
gap> bll:= Blocks( actbl, MovedPoints( actbl ) );;  Length( bll );  
405
gap> oneblock:= Union( bl{ bll[1] } );;
gap> orb:= SortedList( Orbit( h, oneblock, OnSets ) );;
gap> acthom:= ActionHomomorphism( h, orb, OnSets );;
gap> ccl:= ConjugacyClasses( Image( acthom ) );;
gap> reps:= List( ccl, x -> PreImagesRepresentative( acthom,
>                               Representative( x ) ) );;
]]></Example>

<P/>

Then we carry back class representatives to the degree <M>58\,968</M>
representation, and compute the class fusion and the centralizer orders
in <M>G</M>.

<P/>

<Example><![CDATA[
gap> reps:= List( ccl, x -> PreImagesRepresentative( acthom,
>                               Representative( x ) ) );;
gap> fusion:= [];;
gap> centralizers:= [];;
gap> fusreps:= [];;
gap> for i in [ 1 .. Length( reps ) ] do
>      found:= false;
>      cen:= Size( Centralizer( g, reps[i] ) );
>      for j in [ 1 .. Length( fusreps ) ] do
>        if cen = centralizers[j] and
>           IsConjugate( g, fusreps[j], reps[i] ) then
>          fusion[i]:= j;
>          found:= true;
>          break;
>        fi;
>      od;
>      if not found then
>        Add( fusreps, reps[i] );
>        Add( fusion, Length( fusreps ) );
>        Add( centralizers, cen );
>      fi;
>    od;
]]></Example>

<P/>

Next we compute the permutation character values,
using the formula

<Display Mode="M">
   (1_H)^G(g) = (|C_G(g)| \sum_{h} |h^H|) /|H| ,
</Display>

where the summation runs over class representatives <M>h \in H</M>
that are <M>G</M>-conjugate to <M>g</M>.

<P/>

<Example><![CDATA[
gap> pi:= 0 * [ 1 .. Length( fusreps ) ];;
gap> for i in [ 1 .. Length( ccl ) ] do
>      pi[ fusion[i] ]:= pi[ fusion[i] ] + centralizers[ fusion[i] ] *
>                                              Size( ccl[i] );
>    od;
gap> pi:= pi{ fusion } / Size( h );;
]]></Example>

<P/>

In order to write the permutation character w.r.t.&nbsp;the ordering of
classes in the &GAP; character table, we use the &GAP; function
<Ref Func="CompatibleConjugacyClasses" BookName="ref"/>.

<P/>

<Example><![CDATA[
gap> tblh:= CharacterTable( "O8+(2).S3" );;
gap> map:= CompatibleConjugacyClasses( Image( acthom ), ccl, tblh );;
gap> pi:= pi{ map }; 
[ 51162109375, 69375, 1259375, 69375, 568750, 1750, 4000, 375, 135, 
  975, 135, 625, 150, 650, 30, 72, 80, 72, 27, 27, 3, 7, 25, 30, 6, 
  12, 25, 484375, 1750, 375, 375, 30, 40, 15, 15, 15, 6, 6, 3, 3, 3, 
  157421875, 121875, 4875, 475, 75, 3875, 475, 13000, 1750, 300, 400, 
  30, 60, 15, 15, 15, 125, 10, 30, 4, 8, 6, 9, 7, 5, 6, 5 ]
]]></Example>

<!-- This would not work for <M>O^+_8(2)</M>, <M>O^+_8(2).2</M>,
     <M>O^+_8(2).3</M>;
     in these cases, we would have to consider invariants:
     element orders, centralizer orders,
     centralizer orders of second and third power,
     containment in the derived subgroup. -->

<P/>

Now we consider the restrictions of this permutation character to
<M>M</M>, <M>M.2</M>, and <M>M.3</M>.
Note that
<M>(1_H^G)_M = (1_M^S)_M</M>,
<M>(1_H^G)_{M.2} = (1_{M.2}^{S.2})_{M.2}</M>, and
<M>(1_H^G)_{M.3} = (1_{M.3}^{S.3})_{M.3}</M>.

<P/>

<Example><![CDATA[
gap> tblm2:= CharacterTable( "O8+(2).2" );;
gap> tblm3:= CharacterTable( "O8+(2).3" );;
gap> tblm:= CharacterTable( "O8+(2)" );;
gap> pi_m2:= pi{ GetFusionMap( tblm2, tblh ) };;
gap> pi_m3:= pi{ GetFusionMap( tblm3, tblh ) };;
gap> pi_m:= pi_m3{ GetFusionMap( tblm, tblm3 ) };;
]]></Example>

<P/>

The permutation character <M>(1_M^S)_M</M> decomposes
into <M>483</M> transitive permutation characters,
and regular <M>M</M>-orbits on <M>S/M</M> correspond to regular constituents
in this decomposition.
If there is no regular transitive constituent in <M>(1_M^S)_M</M> then
the largest degree of a transitive constituent is <M>|M|/2</M>;
but then the degree of <M>1_M^S</M> is less than <M>483 |M|/2</M>,
which is smaller than <M>[S:M]</M>.

<P/>

<Example><![CDATA[
gap> n:= ScalarProduct( tblm, pi_m, TrivialCharacter( tblm ) );
483
gap> n * Size( tblm ) / 2;
42065049600
gap> pi[1];
51162109375
]]></Example>

<P/>

For the case of <M>M.2 &lt; S.2</M>, this argument turns out to be not
sufficient.
So we first compute a lower bound on the number of regular <M>M</M>-orbits
on <M>S/M</M>.
For involutions <M>g \in M</M>, the number of transitive constituents
<M>1_{\langle g \rangle}^M</M> in <M>(1_M^S)_M</M> is at most the integral
part of
<M>1_M^S(g) / 1_{\langle g \rangle}^M(g) = 2 \cdot 1_M^S(g) / |C_M(g)|</M>;
from this we compute that there are at most <M>208</M> such constituents.

<P/>

<Example><![CDATA[
gap> inv:= Filtered( [ 1 .. NrConjugacyClasses( tblm ) ],
>              i -> OrdersClassRepresentatives( tblm )[i] = 2 );
[ 2, 3, 4, 5, 6 ]
gap> n2:= List( inv,
>           i -> Int( 2 * pi_m[i] / SizesCentralizers( tblm )[i] ) );
[ 1, 54, 54, 54, 45 ]
gap> Sum( n2 );
208
]]></Example>

<P/>

As a consequence, <M>M</M> has at least <M>148</M> regular orbits on
<M>S/M</M>.

<P/>

<Example><![CDATA[
gap> First( [ 1 .. 483 ],                                           
>      i -> i * Size( tblm ) + 208 * Size( tblm ) / 2
>           + ( 483 - i - 208 - 1 ) * Size( tblm ) / 3 + 1 >= pi[1] );
148
]]></Example>

<P/>

Now we consider the action of <M>M.2</M> on <M>S.2/M.2</M>.
If <M>M.2</M> has no regular orbit then the <M>148</M> regular orbits of
<M>M</M> must arise from the restriction of transitive constituents
<M>1_U^{M.2}</M> to <M>M</M> with <M>|U| = 2</M>
and such that <M>U</M> is not contained in <M>M</M>.
(This follows from the fact that the restriction of a transitive constituent
of <M>(1_{M.2}^{S.2})_{M.2}</M> to <M>M</M> is either itself a transitive
constituent of <M>(1_M^S)_M</M> or the sum of two such constituents;
the latter case occurs if and only if the point stabilizer is contained
in <M>M</M>.)
However, the number of these constituents is at most <M>134</M>.

<P/>

<Example><![CDATA[
gap> inv:= Filtered( [ 1 .. NrConjugacyClasses( tblm2 ) ],
>              i -> OrdersClassRepresentatives( tblm2 )[i] = 2 and
>                   not i in ClassPositionsOfDerivedSubgroup( tblm2 ) );
[ 41, 42 ]
gap> n2:= List( inv,
>           i -> Int( 2 * pi_m2[i] / SizesCentralizers( tblm2 )[i] ) );
[ 108, 26 ]
gap> Sum( n2 );
134
]]></Example>

<!-- The number of <M>M.2-S.2-M.2</M> double cosets is <M>331</M>. -->

<P/>

Finally, we consider the action of <M>M.3</M> on <M>S.3/M.3</M>.
We compute that <M>(1_{M.3}^{S.3})_{M.3}</M> has <M>205</M>
transitive constituents,
and at most <M>69</M> of them can be induced from subgroups of order two.
This is already sufficient to show that there must be regular constituents.

<P/>

<Example><![CDATA[
gap> n:= ScalarProduct( tblm3, pi_m3, TrivialCharacter( tblm3 ) );
205
gap> inv:= Filtered( [ 1 .. NrConjugacyClasses( tblm3 ) ],
>              i -> OrdersClassRepresentatives( tblm3 )[i] = 2 );
[ 2, 3, 4 ]
gap> n2:= List( inv,
>           i -> Int( 2 * pi_m3[i] / SizesCentralizers( tblm3 )[i] ) );
[ 0, 54, 15 ]
gap> Sum( n2 );
69
gap> 69 * Size( tblm3 ) / 2 + ( n - 69 - 1 ) * Size( tblm3 ) / 3 + 1;
41542502401
gap> pi[1];
51162109375
]]></Example>

<!-- at least <M>28</M> regular constituents -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:appendix_data">
<Heading>Appendix: The Data File</Heading>

The file <F>o8p2s3_o8p5s3.g</F> that can be found at

<P/>

<URL>http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/data/o8p2s3_o8p5s3.g</URL>

<P/>

contains the relevant data used in the above computations.
This covers the representations for the groups
and the permutation character of <M>O^+_8(2).S_3</M>
computed in Section&nbsp;<Ref Subsect="sect:appendix_permchar"/>.

<P/>

Reading the file into &GAP; will define a global variable
<C>o8p2s3_o8p5s3_data</C>, a record with the following components.

<P/>

<List>
<Mark><C>pi</C></Mark>
<Item>
    the list of values of the permutation character of <M>G = O^+_8(5).S_3</M>
    on the cosets of its subgroup <M>H = O^+_8(2).S_3</M>,
    restricted to <M>H</M>,
    corresponding to the ordering of classes in the character table of <M>H</M>
    in the &GAP; Character Table Library
    (this table has the
    <Ref Func="Identifier" BookName="ref"/>
    value <C>"O8+(2).3.2"</C>),
</Item>
<Mark><C>dim8Q</C></Mark>
<Item>
    a record with generators for <M>2.M</M> and <M>2.M.2</M>,
    matrices of dimension eight over the Rationals,
</Item>
<Mark><C>deg120</C></Mark>
<Item>
    a record with generators for <M>M</M> and <M>M.2</M>,
    permutations of degree <M>120</M>,
</Item>
<Mark><C>deg360</C></Mark>
<Item>
    a record with generators for
    <M>M</M>, <M>M.2</M>, <M>M.3</M>, and <M>H</M>,
    permutations of degree <M>360</M>,
</Item>
<Mark><C>dim8f5</C></Mark>
<Item>
    a record with generators for
    <M>2.M</M>, <M>2.M.2</M>, <M>2.S</M>, and <M>2.S.2</M>,
    matrices of dimension eight over the field with five elements,
</Item>
<Mark><C>deg19656</C></Mark>
<Item>
    a record with generators for
    <M>M</M>, <M>M.2</M>, <M>S</M>, and <M>S.2</M>,
    permutations of degree <M>19\,656</M>,
</Item>
<Mark><C>deg58968</C></Mark>
<Item>
    a record with generators for
    <M>M</M>, <M>M.2</M>, <M>M.3</M>, <M>H</M>,
    <M>S</M>, <M>S.2</M>, <M>S.3</M>, and <M>G</M>,
    permutations of degree <M>58\,968</M>,
</Item>
<Mark><C>seed405</C></Mark>
<Item>
    a block whose <M>H</M>-orbit in the representation on
    <M>58\,968</M> points, w.r.t.&nbsp;the action
    <Ref Func="OnSets" BookName="ref"/>,
    yields a representation of <M>H</M> on <M>405</M> points.
</Item>
</List>

<P/>

For each of the permutation representations, we have (where applicable)

<Table Align="lcl">
<Row>
<Item><M>M</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2 \rangle</M>,</Item>
</Row>
<Row>
<Item><M>M.2</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, b \rangle</M>,</Item>
</Row>
<Row>
<Item><M>M.3</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, t \rangle</M>,</Item>
</Row>
<Row>
<Item><M>H</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, t, b \rangle</M>,</Item>
</Row>
<Row>
<Item><M>S</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c \rangle</M>,</Item>
</Row>
<Row>
<Item><M>S.2</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c, b \rangle</M>,</Item>
</Row>
<Row>
<Item><M>S.3</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c, t \rangle</M>,</Item>
</Row>
<Row>
<Item><M>G</M></Item>
<Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c, t, b \rangle</M>,</Item>
</Row>
</Table>

where <M>a_1, a_2, b, t, c</M> are the values of the record components
<C>a1</C>, <C>a2</C>, <C>b</C>, <C>t</C>, and <C>c</C>.

<P/>

Analogously,
for the matrix representations, we have (where applicable)

<P/>

<Table Align="lcl">
<Row>
<Item><M>2.M</M></Item><Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2 \rangle</M>,</Item>
</Row>
<Row>
<Item><M>2.M.2</M></Item><Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, b \rangle</M>,</Item>
</Row>
<Row>
<Item><M>2.S</M></Item><Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c \rangle</M>,</Item>
</Row>
<Row>
<Item><M>2.S.2</M></Item><Item><M>\cong</M></Item>
<Item><M>\langle a_1, a_2, c, b \rangle</M>,</Item>
</Row>
</Table>

<P/>

Additional components are used for deriving the representations from
initial data, as in the constructions in the previous sections.

<P/>

For example, most of the permutations needed arise as the induced actions
of matrices on orbits of vectors;
these orbits are computed when the file is read,
and are then stored in the components <C>orb120</C> and <C>orb19656</C>.

<P/>

The file <F>o8p2s3_o8p5s3.g</F> does not contain the generators
explicitly,
but it is self-contained in the sense that only a few &GAP; functions
are actually needed to produce the data;
for example, it should not be difficult to translate the contents of
the file into the language of other computer algebra systems.

<P/>

Advantages of this way to store the data are that the relations between
the representations become explicit,
and also that only very little space is needed to describe
the representations &ndash;the size of the file is less than <M>10</M> kB,
whereas storing (explicitly) one of the permutations on <M>58\,968</M> points
requires already about <M>350</M> kB.

</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

