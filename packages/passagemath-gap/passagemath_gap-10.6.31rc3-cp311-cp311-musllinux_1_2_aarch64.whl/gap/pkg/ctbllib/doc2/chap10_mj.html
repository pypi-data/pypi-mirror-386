<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (CTblLibXpls) - Chapter 10: GAP computations needed in the proof of
[DNT13, Theorem 6.1 (ii)]</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap10"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap9_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap10.html">[MathJax off]</a></p>
<p><a id="X831E9D0A7A2DBC72" name="X831E9D0A7A2DBC72"></a></p>
<div class="ChapSects"><a href="chap10_mj.html#X831E9D0A7A2DBC72">10 <span class="Heading"><strong class="pkg">GAP</strong> computations needed in the proof of
<a href="chapBib_mj.html#biBDNT">[DNT13, Theorem 6.1 (ii)]</a></span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X82BDD020860C6E95">10.1 <span class="Heading"><span class="SimpleMath">\(G/N \cong Sz(8)\)</span> and <span class="SimpleMath">\(|N| = 2^{12}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X7C01350E8217B0B1">10.2 <span class="Heading"><span class="SimpleMath">\(G/N \cong M_{22}\)</span> and <span class="SimpleMath">\(|N| = 2^{10}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X7E356703856DF22E">10.3 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 2^{12}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X797E2EDB78F05F6E">10.4 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 5^{14}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X828AECAE82B0CEB6">10.5 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 2^{28}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X81AB173981E3EED7">10.6 <span class="Heading"><span class="SimpleMath">\(G/N \cong {}^3D_4(2)\)</span> and <span class="SimpleMath">\(|N| = 2^{26}\)</span></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10_mj.html#X83B044547B96B7A5">10.7 <span class="Heading"><span class="SimpleMath">\(G/N \cong {}^3D_4(2)\)</span> and <span class="SimpleMath">\(|N| = 3^{25}\)</span></span></a>
</span>
</div>
</div>

<h3>10 <span class="Heading"><strong class="pkg">GAP</strong> computations needed in the proof of
<a href="chapBib_mj.html#biBDNT">[DNT13, Theorem 6.1 (ii)]</a></span></h3>

<p>Date: September 19th, 2011</p>

<p>(This is joint work with Klaus Lux.)</p>

<p>This is a collection of example computations that are cited in the Appendix of <a href="chapBib_mj.html#biBDNT">[DNT13]</a>. In each case, the aim is to show that the extension of a given finite simple group by an elementary abelian group of given rank has the property that not all complex irreducible characters of the same degree are Galois conjugate.</p>

<p>The purpose of this writeup is twofold. On the one hand, the details of the computations are documented this way. On the other hand, the <strong class="pkg">GAP</strong> code shown for the examples can be used as test input for automatic checking of the data and the functions used.} For the computations, we need some Brauer character tables from <a href="chapBib_mj.html#biBJLPW95">[JLPW95]</a>, some generating matrices from <a href="chapBib_mj.html#biBAGRv3">[WWT+]</a>, and some functions from the <strong class="pkg">GAP</strong> system <a href="chapBib_mj.html#biBGAP">[GAP24]</a> and its packages <code class="code">AtlasRep</code> <a href="chapBib_mj.html#biBAtlasRep">[WPN+22]</a>, <code class="code">cohomolo</code> <a href="chapBib_mj.html#biBcohomolo">[Hol08]</a>, <code class="code">CTblLib</code> <a href="chapBib_mj.html#biBCTblLib">[Bre25]</a>, and <code class="code">TomLib</code> <a href="chapBib_mj.html#biBTomLib">[MNP19]</a>.</p>

<p>First we load the necessary <strong class="pkg">GAP</strong> packages.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "AtlasRep", "1.5", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "cohomolo", "1.6", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CTblLib", "1.2", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "TomLib", "1.2.1", false );</span>
true
</pre></div>

<p><a id="X82BDD020860C6E95" name="X82BDD020860C6E95"></a></p>

<h4>10.1 <span class="Heading"><span class="SimpleMath">\(G/N \cong Sz(8)\)</span> and <span class="SimpleMath">\(|N| = 2^{12}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = Sz(8)\)</span> has exactly one irreducible <span class="SimpleMath">\(12\)</span>-dimensional module over the field with two elements, up to isomorphism. This module can be obtained from any of the three absolutely irreducible <span class="SimpleMath">\(4\)</span>-dimensional <span class="SimpleMath">\(S\)</span>-modules in characteristic two, by regarding it as a module over the prime field <span class="SimpleMath">\(GF(2)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 2;;  d:= 12;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "Sz(8)" ) mod p;</span>
BrauerTable( "Sz(8)", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
Sz(8)mod2

       1a 5a 7a 7b 7c 13a 13b 13c

Y.1     1  1  1  1  1   1   1   1
Y.2     4 -1  A  C  B   D   F   E
Y.3     4 -1  B  A  C   E   D   F
Y.4     4 -1  C  B  A   F   E   D

A = E(7)^2+E(7)^3+E(7)^4+E(7)^5
B = E(7)+E(7)^2+E(7)^5+E(7)^6
C = E(7)+E(7)^3+E(7)^4+E(7)^6
D = E(13)+E(13)^5+E(13)^8+E(13)^12
E = E(13)^4+E(13)^6+E(13)^7+E(13)^9
F = E(13)^2+E(13)^3+E(13)^10+E(13)^11
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irr, x -&gt; SizeOfFieldOfDefinition( x, p ) );</span>
[ 2, 8, 8, 8 ]
</pre></div>

<p>First we construct the <span class="SimpleMath">\(12\)</span>-dimensional irreducible representation of <span class="SimpleMath">\(S\)</span> over <span class="SimpleMath">\(GF(2)\)</span>, using that the <strong class="pkg">Atlas</strong> of Group Representations provides matrix generators for <span class="SimpleMath">\(S\)</span> in the <span class="SimpleMath">\(4\)</span>-dimensional representation over <span class="SimpleMath">\(GF(8)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "Sz(8)", Dimension, 4,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Characteristic, p );</span>
rec( charactername := "4a", constituents := [ 2 ], contents := "core",
  dim := 4, groupname := "Sz(8)", id := "a", 
  identifier := [ "Sz(8)", [ "Sz8G1-f8r4aB0.m1", "Sz8G1-f8r4aB0.m2" ],
      1, 8 ], repname := "Sz8G1-f8r4aB0", repnr := 17, 
  ring := GF(2^3), size := 29120, standardization := 1, 
  type := "matff" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_dim4:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis( GF(8) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_dim12:= List( gens_dim4, x -&gt; BlownUpMatrix( b, x ) );;</span>
</pre></div>

<p>We claim that any extension of <span class="SimpleMath">\(S\)</span> with the given module splits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= AtlasGroup( "Sz(8)", IsPermGroup, true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chr:= CHR( s, p, 0, gens_dim12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 100 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SecondCohomologyDimension( chr );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 72 ] );;</span>
</pre></div>

<p>(The function <code class="code">CHR</code> takes as its arguments a permutation group, the characteristic of the module, a finitely presented group (or zero), and a list of matrices that define the module in the sense that they correspond to the generators of the given permutation group. Note that this condition is satisfied because the generators provided by the <strong class="pkg">Atlas</strong> of Group Representations are compatible.) So it is enough to consider the semidirect product <span class="SimpleMath">\(G = 2^{12}\!:\!Sz(8)\)</span>. If we would like then we could represent this group as a group of <span class="SimpleMath">\(13 \times 13\)</span> matrices over <span class="SimpleMath">\(GF(2)\)</span>, as follows. For each element of <span class="SimpleMath">\(G\)</span>, the submatrix consisting of the first <span class="SimpleMath">\(12\)</span> rows and columns describes the part from the complement <span class="SimpleMath">\(Sz(8)\)</span>, in its action on the module in question, and the last row describes the part from the elementary abelian normal group <span class="SimpleMath">\(N\)</span>; the last column is zero, except for an identity entry in the last row. In order to write down generators of this group, it suffices to take the two generators of the complement plus one nonidentity element from <span class="SimpleMath">\(N\)</span>. (Note that <span class="SimpleMath">\(N\)</span> is irreducible.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= List( [1 .. 3 ], x -&gt; IdentityMat( d+1, GF(p) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= mats[1][ d+1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[1]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_dim12[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[2]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_dim12[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[3][ d+1 ][1]:= Z(p)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp:= Group( mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( IsomorphismPermGroup( grp ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
119275520
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrConjugacyClasses( g );</span>
41
</pre></div>

<p>The <strong class="pkg">GAP</strong> Character Table Library contains the ordinary character table of <span class="SimpleMath">\(G\)</span>. We check this as follows. By the above cohomology result, the group <span class="SimpleMath">\(G\)</span> is uniquely determined, up to isomorphism, by the group order and the property that <span class="SimpleMath">\(G\)</span> has a minimal normal subgroup <span class="SimpleMath">\(N\)</span> such that <span class="SimpleMath">\(G/N\)</span> is a simple group isomorphic with <span class="SimpleMath">\(S\)</span>.</p>

<p>(Since <span class="SimpleMath">\(|G|/|S|\)</span> is a power of two, <span class="SimpleMath">\(N\)</span> is a <span class="SimpleMath">\(2\)</span>-group. By the minimality condition, <span class="SimpleMath">\(N\)</span> is elementary abelian and the action of <span class="SimpleMath">\(S\)</span> on <span class="SimpleMath">\(N\)</span> affords the desired <span class="SimpleMath">\(S\)</span>-module. Note that the isomorphism type of a finite simple group is determined by its character table.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= IsomorphismTypeInfoFiniteSimpleGroup( s );</span>
rec( name := "2B(2,8) = 2C(2,8) = Sz(8)", parameter := 8, 
  series := "2B", shortname := "Sz(8)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= AllCharacterTableNames( Size, 2^12 * Size( s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( names, CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= Filtered( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t -&gt; ForAny( ClassPositionsOfMinimalNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            n -&gt; IsomorphismTypeInfoFiniteSimpleGroup( t / n ) = iso ) );</span>
[ CharacterTable( "2^12:Sz(8)" ) ]
</pre></div>

<p>So we can easily check that <span class="SimpleMath">\(G\)</span> has eight rational valued irreducibles of the degree <span class="SimpleMath">\(455\)</span> (or of the degree <span class="SimpleMath">\(3\,640\)</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= cand[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rationals:= Filtered( Irr( t ), x -&gt; IsSubset( Integers, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( rationals, x -&gt; x[1] ) );</span>
[ [ 1, 1 ], [ 64, 1 ], [ 91, 1 ], [ 455, 8 ], [ 3640, 8 ] ]
</pre></div>

<p><a id="X7C01350E8217B0B1" name="X7C01350E8217B0B1"></a></p>

<h4>10.2 <span class="Heading"><span class="SimpleMath">\(G/N \cong M_{22}\)</span> and <span class="SimpleMath">\(|N| = 2^{10}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = M_{22}\)</span> has exactly two irreducible <span class="SimpleMath">\(10\)</span>-dimensional modules over the field with two elements, up to isomorphism. These modules are in fact absolutely irreducible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 2;;  d:= 10;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "M22" ) mod p;</span>
BrauerTable( "M22", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
M22mod2

       1a 3a 5a 7a 7b 11a 11b

Y.1     1  1  1  1  1   1   1
Y.2    10  1  .  A /A  -1  -1
Y.3    10  1  . /A  A  -1  -1

A = E(7)+E(7)^2+E(7)^4
  = (-1+Sqrt(-7))/2 = b7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irr, x -&gt; SizeOfFieldOfDefinition( x, p ) );</span>
[ 2, 2, 2 ]
</pre></div>

<p>First we construct the two irreducible <span class="SimpleMath">\(10\)</span>-dimensional representations of <span class="SimpleMath">\(S\)</span> over <span class="SimpleMath">\(GF(2)\)</span>, again using that the <strong class="pkg">Atlas</strong> of Group Representations provides the matrix generators in question.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= AllAtlasGeneratingSetInfos( "M22", Dimension, d,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Characteristic, p );</span>
[ rec( charactername := "10a", constituents := [ 2 ], 
      contents := "core", dim := 10, groupname := "M22", id := "a", 
      identifier := 
        [ "M22", [ "M22G1-f2r10aB0.m1", "M22G1-f2r10aB0.m2" ], 1, 2 ],
      repname := "M22G1-f2r10aB0", repnr := 13, ring := GF(2), 
      size := 443520, standardization := 1, type := "matff" ), 
  rec( charactername := "10b", constituents := [ 3 ], 
      contents := "core", dim := 10, groupname := "M22", id := "b", 
      identifier := 
        [ "M22", [ "M22G1-f2r10bB0.m1", "M22G1-f2r10bB0.m2" ], 1, 2 ],
      repname := "M22G1-f2r10bB0", repnr := 14, ring := GF(2), 
      size := 443520, standardization := 1, type := "matff" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= List( info, r -&gt; AtlasGenerators( r ).generators );;</span>
</pre></div>

<p>We claim that any extension of <span class="SimpleMath">\(S\)</span> with any of the two given modules splits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= AtlasGroup( "M22", IsPermGroup, true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chr:= CHR( s, p, 0, gens[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 100 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SecondCohomologyDimension( chr );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chr:= CHR( s, p, 0, gens[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SecondCohomologyDimension( chr );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 72 ] );;</span>
</pre></div>

<p>Again we see that it is enough to consider semidirect products <span class="SimpleMath">\(G = 2^{10}\!:\!M_{22}\)</span>, but this time for the two nonisomorphic modules.</p>

<p>We could use the same method as in the first case for constructing the two groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_1:= gens[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= List( [1 .. 3 ], x -&gt; IdentityMat( d+1, GF(p) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= mats[1][ d+1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[1]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_1[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[2]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_1[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[3][ d+1 ][1]:= Z(p)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp_1:= Group( mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( grp_1 );</span>
454164480
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_2:= gens[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= List( [1 .. 3 ], x -&gt; IdentityMat( d+1, GF(p) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= mats[1][ d+1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[1]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[2]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_2[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[3][ d+1 ][1]:= Z(p)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp_2:= Group( mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( grp_2 );</span>
454164480
</pre></div>

<p>The <strong class="pkg">GAP</strong> Character Table Library contains the ordinary character tables of the two groups in question. We check this with the same approach as in the previous examples.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= IsomorphismTypeInfoFiniteSimpleGroup( s );</span>
rec( name := "M(22)", series := "Spor", shortname := "M22" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= AllCharacterTableNames( Size, 2^10 * Size( s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( names, CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= Filtered( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t -&gt; ForAny( ClassPositionsOfMinimalNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            n -&gt; IsomorphismTypeInfoFiniteSimpleGroup( t / n ) = iso ) );</span>
[ CharacterTable( "2^10:M22'" ), CharacterTable( "2^10:m22" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cand, NrConjugacyClasses );</span>
[ 47, 43 ]
</pre></div>

<p>So we can easily check that in both cases, <span class="SimpleMath">\(G\)</span> has two rational valued irreducibles of the degree <span class="SimpleMath">\(1\,155\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= cand[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rationals:= Filtered( Irr( t ), x -&gt; IsSubset( Integers, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( rationals, x -&gt; x[1] ) );</span>
[ [ 1, 1 ], [ 21, 1 ], [ 22, 1 ], [ 55, 1 ], [ 99, 1 ], [ 154, 1 ], 
  [ 210, 1 ], [ 231, 3 ], [ 385, 1 ], [ 440, 1 ], [ 770, 5 ], 
  [ 924, 2 ], [ 1155, 2 ], [ 1386, 1 ], [ 1408, 1 ], [ 3080, 2 ], 
  [ 3465, 4 ], [ 4620, 2 ], [ 6930, 3 ], [ 9240, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= cand[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rationals:= Filtered( Irr( t ), x -&gt; IsSubset( Integers, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( rationals, x -&gt; x[1] ) );</span>
[ [ 1, 1 ], [ 21, 1 ], [ 55, 1 ], [ 77, 1 ], [ 99, 1 ], [ 154, 1 ], 
  [ 210, 1 ], [ 231, 1 ], [ 330, 1 ], [ 385, 3 ], [ 616, 2 ], 
  [ 693, 1 ], [ 770, 1 ], [ 1155, 2 ], [ 1980, 1 ], [ 2310, 4 ], 
  [ 2640, 1 ], [ 3465, 2 ], [ 4620, 1 ], [ 5544, 2 ], [ 6160, 1 ], 
  [ 6930, 2 ], [ 9856, 1 ] ]
</pre></div>

<p><a id="X7E356703856DF22E" name="X7E356703856DF22E"></a></p>

<h4>10.3 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 2^{12}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = J_2\)</span> has exactly one irreducible <span class="SimpleMath">\(12\)</span>-dimensional module over the field with two elements, up to isomorphism. This module can be obtained from any of the two absolutely irreducible <span class="SimpleMath">\(6\)</span>-dimensional <span class="SimpleMath">\(S\)</span>-modules in characteristic two, by regarding it as a module over the prime field <span class="SimpleMath">\(GF(2)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 2;;  d:= 12;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "J2" ) mod p;</span>
BrauerTable( "J2", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
J2mod2

       1a 3a 3b 5a 5b 5c 5d 7a 15a 15b

Y.1     1  1  1  1  1  1  1  1   1   1
Y.2     6 -3  .  A *A  B *B -1   C  *C
Y.3     6 -3  . *A  A *B  B -1  *C   C

A = -2*E(5)-2*E(5)^4
  = 1-Sqrt(5) = 1-r5
B = E(5)+2*E(5)^2+2*E(5)^3+E(5)^4
  = (-3-Sqrt(5))/2 = -2-b5
C = E(5)+E(5)^4
  = (-1+Sqrt(5))/2 = b5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irr, x -&gt; SizeOfFieldOfDefinition( x, p ) );</span>
[ 2, 4, 4 ]
</pre></div>

<p>First we construct the irreducible <span class="SimpleMath">\(12\)</span>-dimensional representation of <span class="SimpleMath">\(S\)</span> over <span class="SimpleMath">\(GF(2)\)</span>, using that the <strong class="pkg">Atlas</strong> of Group Representations provides matrix generators for <span class="SimpleMath">\(S\)</span> in the <span class="SimpleMath">\(6\)</span>-dimensional representation over <span class="SimpleMath">\(GF(4)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "J2", Dimension, 6,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Characteristic, p );</span>
rec( charactername := "6a", constituents := [ 2 ], contents := "core",
  dim := 6, groupname := "J2", id := "a", 
  identifier := [ "J2", [ "J2G1-f4r6aB0.m1", "J2G1-f4r6aB0.m2" ], 1, 
      4 ], repname := "J2G1-f4r6aB0", repnr := 16, ring := GF(2^2), 
  size := 604800, standardization := 1, type := "matff" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_dim6:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis( GF(4) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens_dim12:= List( gens_dim6, x -&gt; BlownUpMatrix( b, x ) );;</span>
</pre></div>

<p>We claim that any extension of <span class="SimpleMath">\(S\)</span> with the given module splits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= AtlasGroup( "J2", IsPermGroup, true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chr:= CHR( s, p, 0, gens_dim12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 100 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SecondCohomologyDimension( chr );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 72 ] );;</span>
</pre></div>

<p>Again we see that it is enough to consider a semidirect product <span class="SimpleMath">\(G = 2^{12}\!:\!J_2\)</span>.</p>

<p>Here is a description how we could construct the group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= List( [ 1 .. 3 ], x -&gt; IdentityMat( d+1, GF(p) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= mats[1][ d+1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[1]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_dim12[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[2]{ [ 1 .. d ] }{ [ 1 .. d ] }:= gens_dim12[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats[3][ d+1 ][1]:= Z(p)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp:= Group( mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( IsomorphismPermGroup( grp ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
2477260800
</pre></div>

<p>The <strong class="pkg">GAP</strong> Character Table Library contains the ordinary character table of <span class="SimpleMath">\(G\)</span>. We check this with the same approach as in the previous examples.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= IsomorphismTypeInfoFiniteSimpleGroup( s );</span>
rec( name := "HJ = J(2) = F(5-)", series := "Spor", shortname := "J2" 
 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= AllCharacterTableNames( Size, 2^12 * Size( s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( names, CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= Filtered( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t -&gt; ForAny( ClassPositionsOfMinimalNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            n -&gt; IsomorphismTypeInfoFiniteSimpleGroup( t / n ) = iso ) );</span>
[ CharacterTable( "2^12:J2" ) ]
</pre></div>

<p>So we can easily check that <span class="SimpleMath">\(G\)</span> has two rational valued irreducibles of the degree <span class="SimpleMath">\(1\,575\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= cand[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rationals:= Filtered( Irr( t ), x -&gt; IsSubset( Integers, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( rationals, x -&gt; x[1] ) );</span>
[ [ 1, 1 ], [ 36, 1 ], [ 63, 1 ], [ 90, 1 ], [ 126, 1 ], [ 160, 1 ], 
  [ 175, 1 ], [ 225, 1 ], [ 288, 1 ], [ 300, 1 ], [ 336, 1 ], 
  [ 1575, 2 ], [ 2520, 4 ], [ 3150, 1 ], [ 4725, 6 ], [ 9450, 1 ], 
  [ 10080, 4 ], [ 12600, 4 ], [ 18900, 2 ] ]
</pre></div>

<p><a id="X797E2EDB78F05F6E" name="X797E2EDB78F05F6E"></a></p>

<h4>10.4 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 5^{14}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = J_2\)</span> has exactly one irreducible <span class="SimpleMath">\(14\)</span>-dimensional module over the field with <span class="SimpleMath">\(5\)</span> elements, up to isomorphism. This module is in fact absolutely irreducible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 5;;  d:= 14;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "J2" ) mod p;</span>
BrauerTable( "J2", 5 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
J2mod5

       1a 2a 2b 3a 3b 4a 6a 6b 7a 8a 12a

Y.1     1  1  1  1  1  1  1  1  1  1   1
Y.2    14 -2  2  5 -1  2  1 -1  .  .  -1
</pre></div>

<p>In this case, we do not attempt to compute the complete character table of <span class="SimpleMath">\(G\)</span>. Instead, we show that <span class="SimpleMath">\(G/N\)</span> has at least five regular orbits on the dual space of <span class="SimpleMath">\(N\)</span>, and apply \cite[Lemma 5.1 (i)]{DNT}. (Note that <span class="SimpleMath">\(N\)</span> is in fact self-dual.)</p>

<p>For that, we use <strong class="pkg">GAP</strong>'s table of marks of <span class="SimpleMath">\(S\)</span>. The information stored for this table of marks allows us to compute, for each class of subgroups <span class="SimpleMath">\(U\)</span> of <span class="SimpleMath">\(S\)</span>, the numbers of orbits in the dual space of <span class="SimpleMath">\(N\)</span> for which contain the point stabilizers in <span class="SimpleMath">\(S\)</span> are exactly the conjugates of <span class="SimpleMath">\(U\)</span>. The following <strong class="pkg">GAP</strong> function takes the table of marks <code class="code">tom</code> of <span class="SimpleMath">\(S\)</span>, a list <code class="code">matgens</code> of matrices that describe the action of the generators of <span class="SimpleMath">\(S\)</span> on the vector space in question, and the size <code class="code">q</code> of its field of scalars. The return value is a record with the components <code class="code">fixed</code> (the vector of numbers of fixed points of the subgroups of <span class="SimpleMath">\(S\)</span> on the dual of <span class="SimpleMath">\(N\)</span>), <code class="code">decomp</code> (the numbers of orbits with the corresponding point stabilizers), <code class="code">nonzeropos</code> (the positions of subgroups that occur as point stabilizers), and <code class="code">staborders</code> (the list of orders of the subgroups that occur as point stabilizers).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbits_from_tom:= function( tom, matgens, q )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local slp, fixed, idmat, i, rest, decomp, nonzeropos;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    slp:= StraightLineProgramsTom( tom );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fixed:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    idmat:= matgens[1]^0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 1 .. Length( slp ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if IsList( slp[i] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # Each subgroup generator has a program of its own.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        rest:= List( slp[i],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     prg -&gt; ResultOfStraightLineProgram( prg, gens ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # The subgroup generators are computed with one common program.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        rest:= ResultOfStraightLineProgram( slp[i], gens );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if IsEmpty( rest ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # The subgroup is trivial.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fixed[i]:= q^Length( idmat );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # Compute the intersection of fixed spaces of the transposed</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # matrices, since we act on Irr(N) not on N.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fixed[i]:= q^Length( NullspaceMat( TransposedMat( Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       List( rest, x -&gt; x - idmat ) ) ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    decomp:= DecomposedFixedPointVector( tom, fixed );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nonzeropos:= Filtered( [ 1 .. Length( decomp ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           i -&gt; decomp[i] &lt;&gt; 0 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return rec( fixed:= fixed,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                decomp:= decomp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                nonzeropos:= nonzeropos,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                staborders:= OrdersTom( tom ){ nonzeropos },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>Note that this function assumes that the generators of <span class="SimpleMath">\(S\)</span> obtained from the <strong class="pkg">Atlas</strong> of Group Representations are compatible with the generators from <strong class="pkg">GAP</strong>'s table of marks of <span class="SimpleMath">\(S\)</span>. This fact can be read off from the <code class="keyw">true</code> value of the <code class="code">ATLAS</code> component in the <code class="func">StandardGeneratorsInfo</code> (<a href="../../../pkg/tomlib/doc/chap1_mj.html#X7984E27078B20557"><span class="RefLink">TomLib: StandardGeneratorsInfo for groups</span></a>) value of the table of marks.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "J2" );</span>
TableOfMarks( "J2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StandardGeneratorsInfo( tom );</span>
[ rec( ATLAS := true, 
      description := "|z|=10, z^5=a, |b|=3, |C(b)|=36, |ab|=7", 
      generators := "a, b", 
      script := 
        [ [ 1, 10, 5 ], [ 2, 3 ], [ [ 2, 1 ], [ "|C(",, ")|" ], 36 ], 
          [ 1, 1, 2, 1, 7 ] ], standardization := 1 ) ]
</pre></div>

<p>Alternatively, we can compute whether the generators are compatible, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "J2", Dimension, d, Ring, GF(p) );</span>
rec( charactername := "14a", constituents := [ 2 ], 
  contents := "core", dim := 14, givenRing := GF(5), 
  groupname := "J2", id := "", 
  identifier := [ "J2", [ "J2G1-f5r14B0.m1", "J2G1-f5r14B0.m2" ], 1, 
      5 ], repname := "J2G1-f5r14B0", repnr := 19, ring := GF(5), 
  size := 604800, standardization := 1, type := "matff" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:= GroupGeneralMappingByImages( UnderlyingGroup( tom ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Group( gens ), GeneratorsOfGroup( UnderlyingGroup( tom ) ), gens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupHomomorphism( map );</span>
true
</pre></div>

<p>Now we are sure that we may apply the function <code class="code">orbits_from_tom</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbits_from_tom( tom, gens, p );</span>
rec( 
  decomp := [ 8600, 0, 2512, 359, 10, 0, 0, 212, 5, 0, 0, 4, 0, 240, 
      16, 10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 2, 0, 0, 36, 0, 0, 0, 26, 
      0, 0, 0, 0, 0, 0, 0, 20, 0, 10, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 10, 0, 0, 5, 0, 0, 0, 26, 0, 10, 0, 0, 0, 0, 10, 0, 
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 2, 0, 
      0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 4, 0, 0, 0, 4, 0, 0, 1 ], 
  fixed := [ 6103515625, 15625, 390625, 390625, 625, 25, 3125, 3125, 
      625, 625, 625, 625, 5, 3125, 125, 625, 25, 25, 125, 5, 125, 25, 
      125, 25, 25, 25, 5, 125, 125, 125, 25, 25, 3125, 1, 1, 5, 5, 
      25, 5, 25, 125, 5, 25, 25, 25, 25, 25, 25, 5, 25, 25, 5, 25, 5, 
      5, 5, 5, 25, 25, 1, 125, 1, 5, 5, 125, 1, 25, 5, 25, 1, 5, 25, 
      5, 5, 25, 25, 5, 5, 5, 1, 5, 5, 1, 1, 1, 5, 1, 25, 25, 25, 1, 
      5, 25, 5, 5, 1, 1, 125, 5, 5, 5, 25, 5, 5, 5, 1, 1, 5, 5, 1, 5, 
      1, 5, 1, 1, 25, 5, 5, 1, 1, 1, 1, 5, 1, 1, 25, 1, 1, 5, 1, 1, 
      5, 1, 5, 1, 1, 5, 1, 5, 1, 1, 1, 5, 1, 1, 1 ], 
  nonzeropos := [ 1, 3, 4, 5, 8, 9, 12, 14, 15, 16, 21, 26, 29, 33, 
      41, 43, 44, 58, 61, 65, 67, 72, 89, 93, 98, 99, 105, 116, 126, 
      139, 143, 146 ], 
  staborders := [ 1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 8, 9, 10, 12, 12, 12, 
      14, 20, 24, 24, 24, 30, 48, 50, 60, 60, 72, 120, 192, 600, 
      1920, 604800 ] )
</pre></div>

<p>We see that <span class="SimpleMath">\(S\)</span> has <span class="SimpleMath">\(8\,600\)</span> regular orbits on (the dual space of) <span class="SimpleMath">\(N\)</span>.</p>

<p><a id="X828AECAE82B0CEB6" name="X828AECAE82B0CEB6"></a></p>

<h4>10.5 <span class="Heading"><span class="SimpleMath">\(G/N \cong J_2\)</span> and <span class="SimpleMath">\(|N| = 2^{28}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = J_2\)</span> has exactly one irreducible <span class="SimpleMath">\(28\)</span>-dimensional module over the field with two elements, up to isomorphism. This module can be obtained from any of the two absolutely irreducible <span class="SimpleMath">\(14\)</span>-dimensional <span class="SimpleMath">\(S\)</span>-modules in characteristic two, by regarding it as a module over the prime field <span class="SimpleMath">\(GF(2)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 2;;  d:= 28;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "J2" ) mod p;</span>
BrauerTable( "J2", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
J2mod2

       1a 3a 3b 5a 5b  5c  5d 7a 15a 15b

Y.1     1  1  1  1  1   1   1  1   1   1
Y.2     6 -3  .  A *A   C  *C -1   D  *D
Y.3     6 -3  . *A  A  *C   C -1  *D   D
Y.4    14  5 -1  B *B  -C -*C  .   .   .
Y.5    14  5 -1 *B  B -*C  -C  .   .   .

A = -2*E(5)-2*E(5)^4
  = 1-Sqrt(5) = 1-r5
B = -3*E(5)-3*E(5)^4
  = (3-3*Sqrt(5))/2 = -3b5
C = E(5)+2*E(5)^2+2*E(5)^3+E(5)^4
  = (-3-Sqrt(5))/2 = -2-b5
D = E(5)+E(5)^4
  = (-1+Sqrt(5))/2 = b5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irr, x -&gt; SizeOfFieldOfDefinition( x, p ) );</span>
[ 2, 4, 4, 4, 4 ]
</pre></div>

<p>We use the same approach as in the previous example.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "J2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "J2", Dimension, 14, Ring, GF(4) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= List( AtlasGenerators( info ).generators,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                x -&gt; BlownUpMat( Basis(GF(4)), x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbits_from_tom( tom, gens, p );</span>
rec( 
  decomp := [ 235, 33, 282, 38, 0, 0, 6, 31, 36, 0, 0, 0, 3, 66, 9, 
      0, 0, 0, 0, 0, 0, 2, 18, 0, 0, 1, 0, 0, 15, 0, 0, 0, 6, 0, 0, 
      0, 0, 0, 0, 0, 12, 0, 0, 5, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 3, 1, 3, 0, 9, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 
      3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 
      0, 0, 3, 0, 0, 1 ], 
  fixed := [ 268435456, 65536, 65536, 65536, 256, 1024, 4096, 1024, 
      1024, 256, 256, 256, 64, 1024, 64, 256, 16, 16, 64, 64, 64, 
      256, 256, 64, 16, 16, 64, 64, 64, 64, 16, 16, 1024, 4, 4, 4, 4, 
      16, 16, 16, 64, 16, 16, 16, 16, 64, 16, 16, 16, 64, 16, 16, 16, 
      16, 4, 16, 16, 16, 16, 1, 64, 4, 16, 4, 64, 4, 16, 4, 16, 1, 4, 
      16, 4, 4, 16, 16, 4, 4, 16, 1, 4, 16, 1, 1, 1, 16, 4, 16, 16, 
      16, 1, 4, 16, 4, 4, 1, 4, 64, 4, 4, 4, 16, 4, 4, 4, 1, 1, 4, 
      16, 1, 4, 1, 4, 1, 4, 16, 4, 4, 1, 1, 1, 1, 4, 1, 1, 16, 1, 1, 
      4, 1, 4, 4, 1, 4, 1, 1, 4, 1, 4, 1, 1, 1, 4, 1, 1, 1 ], 
  nonzeropos := [ 1, 2, 3, 4, 7, 8, 9, 13, 14, 15, 22, 23, 26, 29, 
      33, 41, 44, 46, 50, 61, 62, 63, 65, 72, 82, 93, 99, 105, 109, 
      116, 126, 131, 139, 143, 146 ], 
  staborders := [ 1, 2, 2, 3, 4, 4, 4, 6, 6, 6, 8, 8, 9, 10, 12, 12, 
      14, 16, 16, 24, 24, 24, 24, 30, 40, 50, 60, 72, 96, 120, 192, 
      240, 600, 1920, 604800 ] )
</pre></div>

<p>We see that <span class="SimpleMath">\(S\)</span> has <span class="SimpleMath">\(235\)</span> regular orbits on (the dual space of) <span class="SimpleMath">\(N\)</span>.</p>

<p><a id="X81AB173981E3EED7" name="X81AB173981E3EED7"></a></p>

<h4>10.6 <span class="Heading"><span class="SimpleMath">\(G/N \cong {}^3D_4(2)\)</span> and <span class="SimpleMath">\(|N| = 2^{26}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = {}^3D_4(2)\)</span> has exactly one irreducible <span class="SimpleMath">\(26\)</span>-dimensional module over the field with two elements, up to isomorphism. This module is in fact absolutely irreducible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 2;;  d:= 26;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "3D4(2)" ) mod p;</span>
BrauerTable( "3D4(2)", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
3D4(2)mod2

       1a 3a 3b 7a 7b 7c 7d 9a 9b 9c 13a 13b 13c 21a 21b 21c

Y.1     1  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1
Y.2     8  2 -1  A  C  B  1  D  F  E   G   I   H   J   L   K
Y.3     8  2 -1  B  A  C  1  E  D  F   H   G   I   K   J   L
Y.4     8  2 -1  C  B  A  1  F  E  D   I   H   G   L   K   J
Y.5    26 -1 -1  5  5  5 -2  2  2  2   .   .   .  -1  -1  -1

A = 3*E(7)^2+E(7)^3+E(7)^4+3*E(7)^5
B = 3*E(7)+E(7)^2+E(7)^5+3*E(7)^6
C = E(7)+3*E(7)^3+3*E(7)^4+E(7)^6
D = -E(9)^2+E(9)^3-2*E(9)^4-2*E(9)^5+E(9)^6-E(9)^7
E = -E(9)^2+E(9)^3+E(9)^4+E(9)^5+E(9)^6-E(9)^7
F = 2*E(9)^2+E(9)^3+E(9)^4+E(9)^5+E(9)^6+2*E(9)^7
G = E(13)+E(13)^2+E(13)^3+E(13)^5+E(13)^8+E(13)^10+E(13)^11+E(13)^12
H = E(13)+E(13)^4+E(13)^5+E(13)^6+E(13)^7+E(13)^8+E(13)^9+E(13)^12
I = E(13)^2+E(13)^3+E(13)^4+E(13)^6+E(13)^7+E(13)^9+E(13)^10+E(13)^11
J = E(7)^3+E(7)^4
K = E(7)^2+E(7)^5
L = E(7)+E(7)^6
</pre></div>

<p>We try the same approach as in the examples about the group <span class="SimpleMath">\(J_2\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "3D4(2)" );</span>
TableOfMarks( "3D4(2)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StandardGeneratorsInfo( tom );</span>
[ rec( ATLAS := true, 
      description := "|z|=8, z^4=a, |b|=9, |ab|=13, |abb|=8", 
      generators := "a, b", 
      script := [ [ 1, 8, 4 ], [ 2, 9 ], [ 1, 1, 2, 1, 13 ], 
          [ 1, 1, 2, 1, 2, 1, 8 ] ], standardization := 1 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "3D4(2)", Dimension, 26, Ring, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:= GroupGeneralMappingByImages( UnderlyingGroup( tom ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Group( gens ), GeneratorsOfGroup( UnderlyingGroup( tom ) ), gens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupHomomorphism( map );</span>
true
</pre></div>

<p>Now we apply the function <code class="code">orbits_from_tom</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo:= orbits_from_tom( tom, gens, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.fixed[1];</span>
67108864
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.decomp[1];</span>
0
</pre></div>

<p>Unfortunately, <span class="SimpleMath">\(S\)</span> has no regular orbit on (the dual of) <span class="SimpleMath">\(N\)</span>. However, there is one orbit whose point stabilizer in <span class="SimpleMath">\(S\)</span> is a dihedral group <span class="SimpleMath">\(D_{18}\)</span> of order <span class="SimpleMath">\(18\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.staborders;</span>
[ 16, 16, 18, 42, 48, 52, 64, 72, 392, 1008, 1536, 3024, 3072, 3584, 
  258048, 211341312 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.nonzeropos[3];</span>
446
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.decomp[446];</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= RepresentativeTom( tom, 446 );</span>
&lt;permutation group of size 18 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDihedralGroup( u );</span>
true
</pre></div>

<p>Thus there ia a linear character <span class="SimpleMath">\(\lambda\)</span> of <span class="SimpleMath">\(N\)</span> whose inertia subgroup <span class="SimpleMath">\(T = I_G(\lambda)\)</span> has the structure <span class="SimpleMath">\(N.D_{18}\)</span>. Now <span class="SimpleMath">\(Irr( T | \lambda )\)</span> can be identified with those irreducibles of <span class="SimpleMath">\(T/\ker(\lambda)\)</span> that restrict nontrivially to <span class="SimpleMath">\(N/\ker(\lambda)\)</span>, and there are only two groups, up to isomorphism, that can occur as <span class="SimpleMath">\(T/\ker(\lambda)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= Filtered( AllSmallGroups( 36 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            x -&gt; Size( Centre( x ) ) = 2 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 IsDihedralGroup( x / Centre( x ) ) );</span>
[ &lt;pc group of size 36 with 4 generators&gt;, 
  &lt;pc group of size 36 with 4 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cand, StructureDescription );</span>
[ "C9 : C4", "D36" ]
</pre></div>

<p>These two groups are a split and a nonsplit extension of the cyclic group of order <span class="SimpleMath">\(18\)</span> with a group of order two that acts by inverting. In other words, these two groups are the direct product of <span class="SimpleMath">\(D_{18}\)</span> with a cyclic group of order two and the subdirect product of <span class="SimpleMath">\(D_{18}\)</span> with a cyclic group of order four.</p>

<p>Both groups possess irreducible characters of degree two, one rational valued and the other not, which restrict nontrivially to the centre.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CharacterTable( "Dihedral", 18 ) );</span>
Dihedral(18)

     2  1  .  .  .  .  1
     3  2  2  2  2  2  .

       1a 9a 9b 3a 9c 2a
    2P 1a 9b 9c 3a 9a 1a
    3P 1a 3a 3a 1a 3a 2a

X.1     1  1  1  1  1  1
X.2     1  1  1  1  1 -1
X.3     2  A  B -1  C  .
X.4     2  B  C -1  A  .
X.5     2 -1 -1  2 -1  .
X.6     2  C  A -1  B  .

A = -E(9)^2-E(9)^4-E(9)^5-E(9)^7
B = E(9)^2+E(9)^7
C = E(9)^4+E(9)^5
</pre></div>

<p>By \cite[Lemma 5.1 (ii)]{DNT}, we are done.</p>

<p><a id="X83B044547B96B7A5" name="X83B044547B96B7A5"></a></p>

<h4>10.7 <span class="Heading"><span class="SimpleMath">\(G/N \cong {}^3D_4(2)\)</span> and <span class="SimpleMath">\(|N| = 3^{25}\)</span></span></h4>

<p>The group <span class="SimpleMath">\(S = {}^3D_4(2)\)</span> has exactly one irreducible <span class="SimpleMath">\(25\)</span>-dimensional module over the field with three elements, up to isomorphism. This module is in fact absolutely irreducible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= 3;;  d:= 25;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "3D4(2)" ) mod p;</span>
BrauerTable( "3D4(2)", 3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Filtered( Irr( t ), x -&gt; x[1] &lt;= d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, rec( chars:= irr, powermap:= false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    centralizers:= false ) );</span>
3D4(2)mod3

       1a 2a 2b 4a 4b 4c 7a 7b 7c 7d 8a 8b 13a 13b 13c 14a 14b 14c 28a

Y.1     1  1  1  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   1
Y.2    25 -7  1  5 -3  1  4  4  4 -3 -1 -1  -1  -1  -1   .   .   .  -2

       28b 28c

Y.1      1   1
Y.2     -2  -2
</pre></div>

<p>We use the same approach as in the examples about the group <span class="SimpleMath">\(J_2\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "3D4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "3D4(2)", Dimension, d, Ring, GF(p) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo:= orbits_from_tom( tom, gens, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.fixed[1];</span>
847288609443
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbsinfo.decomp[1];</span>
3551
</pre></div>

<p>We see that <span class="SimpleMath">\(S\)</span> has <span class="SimpleMath">\(3\,551\)</span> regular orbits on (the dual space of) <span class="SimpleMath">\(N\)</span>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap9_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
