
<!-- %W  ambigfus.xml    GAP 4 package CTblLib              Thomas Breuer -->

<!-- add example for ambiguous fusion LyN5 -> LyM5 (known via construction -->

<Chapter Label="chap:ambigfus">
<Heading>Ambiguous Class Fusions in the &GAP; Character Table Library</Heading>

Date: January 11th, 2004

<P/>

This is a collection of examples showing how class fusions between character
tables can be determined using the &GAP; system&nbsp;<Cite Key="GAP"/>.
In each of these examples, the fusion is <E>ambiguous</E> in the sense that
the character tables do not determine it up to table automorphisms.
Our strategy is to compute first all possibilities with the &GAP; function
<Ref Func="PossibleClassFusions" BookName="ref"/>,
and then to use either other character tables or
information about the groups for excluding some of these candidates until
only one (orbit under table automorphisms) remains.

<P/>

The purpose of this writeup is twofold.
On the one hand, the computations are documented this way.
On the other hand, the &GAP; code shown for the examples can be used as
test input for automatic checking of the data and the functions used;
therefore, each example ends with a comparison of the result with the
fusion that is actually stored in
the &GAP; Character Table Library&nbsp;<Cite Key="CTblLib"/>.

<P/>

The examples use the &GAP; Character Table Library,
so we first load this package.

<P/>

<Example><![CDATA[
gap> LoadPackage( "ctbllib", false );
true
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:GAP_Utilities">
<Heading>Some &GAP; Utilities</Heading>

The function <C>SetOfComposedClassFusions</C> takes two list of class fusions,
where the first list consists of fusions between the character tables of
the groups <M>H</M> and <M>G</M>, say,
and the second list consists of class fusions between the character tables
of the groups <M>U</M> and <M>H</M>, say;
the return value is the set of compositions of each map in the first list
with each map in the second list (via
<Ref Func="CompositionMaps" BookName="ref"/>).

<P/>

Note that the returned list may be a proper subset of the set of
all possible class fusions between <M>U</M> and <M>G</M>,
which can be computed with
<Ref Func="PossibleClassFusions" BookName="ref"/>.

<P/>

<Example><![CDATA[
gap> SetOfComposedClassFusions:= function( hfusg, ufush )
>     local result, map1, map2;
>     result:= [];;
>     for map2 in hfusg do
>       for map1 in ufush do
>         AddSet( result, CompositionMaps( map2, map1 ) );
>       od;
>     od;
>     return result;
> end;;
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Fusions_Determined_by_Intermediate_Subgroups">
<Heading>Fusions Determined by Factorization through Intermediate Subgroups</Heading>

<P/>

This situation clearly occurs only for nonmaximal subgroups.
Interesting examples are Sylow normalizers.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Co_3N5_in_Co_3">
<Heading><M>Co_3N5 \rightarrow Co_3</M> (September 2002)</Heading>

Let <M>H</M> be the Sylow <M>5</M> normalizer in the sporadic simple group
<M>Co_3</M>.
The class fusion of <M>H</M> into <M>Co_3</M> is not uniquely determined by the
character tables of the two groups.

<P/>

<Example><![CDATA[
gap> co3:= CharacterTable( "Co3" );
CharacterTable( "Co3" )
gap> h:= CharacterTable( "Co3N5" );
CharacterTable( "5^(1+2):(24:2)" )
gap> hfusco3:= PossibleClassFusions( h, co3 );;
gap> Length( RepresentativesFusions( h, hfusco3, co3 ) );
2
]]></Example>

<P/>

As <M>H</M> is not maximal in <M>Co_3</M>,
we look at those maximal subgroups of <M>Co_3</M>
whose order is divisible by that of <M>H</M>.

<P/>

<Example><![CDATA[
gap> mx:= Maxes( co3 );
[ "McL.2", "HS", "U4(3).(2^2)_{133}", "M23", "3^5:(2xm11)", 
  "2.S6(2)", "U3(5).3.2", "3^1+4:4s6", "2^4.a8", "L3(4).D12", 
  "2xm12", "2^2.[2^7*3^2].S3", "s3xpsl(2,8).3", "a4xs5" ]
gap> maxes:= List( mx, CharacterTable );;
gap> filt:= Filtered( maxes, x -> Size( x ) mod Size( h ) = 0 );
[ CharacterTable( "McL.2" ), CharacterTable( "HS" ), 
  CharacterTable( "U3(5).3.2" ) ]
]]></Example>

<P/>

According to the &ATLAS;
(see&nbsp;<Cite Key="CCN85" Where="pp. 34 and 100"/>),
<M>H</M> occurs as the Sylow <M>5</M> normalizer in <M>U_3(5).3.2</M>
and in <M>McL.2</M>;
however, <M>H</M> is not a subgroup of <M>HS</M>,
since otherwise <M>H</M> would be contained in subgroups of type
<M>U_3(5).2</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 80"/>),
but the only possible subgroups in these groups are too small
(see&nbsp;<Cite Key="CCN85" Where="p. 34"/>).

<P/>

We compute the possible class fusions from <M>H</M> into <M>McL.2</M>
and from <M>McL.2</M> to <M>Co_3</M>,
and then form the compositions of these maps.

<P/>

<Example><![CDATA[
gap> max:= filt[1];;
gap> hfusmax:= PossibleClassFusions( h, max );;
gap> maxfusco3:= PossibleClassFusions( max, co3 );;
gap> comp:= SetOfComposedClassFusions( maxfusco3, hfusmax );;
gap> Length( comp );
2
gap> reps:= RepresentativesFusions( h, comp, co3 );
[ [ 1, 2, 3, 4, 8, 8, 7, 9, 10, 11, 17, 17, 19, 19, 22, 23, 27, 27, 
      30, 33, 34, 40, 40, 40, 40, 42 ] ]
]]></Example>

<P/>

So factoring through a maximal subgroup of type <M>McL.2</M>
determines the fusion from <M>H</M> to <M>Co_3</M>
uniquely up to table automorphisms.

<P/>

Alternatively, we can use the group <M>U_3(5).3.2</M> as intermediate
subgroup, which leads to the same result.

<P/>

<Example><![CDATA[
gap> max:= filt[3];;
gap> hfusmax:= PossibleClassFusions( h, max );;
gap> maxfusco3:= PossibleClassFusions( max, co3 );;
gap> comp:= SetOfComposedClassFusions( maxfusco3, hfusmax );;
gap> reps2:= RepresentativesFusions( h, comp, co3 );;
gap> reps2 = reps;
true
]]></Example>

<P/>

Finally, we compare the result with the map that is stored on the library
table of <M>H</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( h, co3 ) in reps;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:31:15_in_B">
<Heading><M>31:15 \rightarrow B</M> (March 2003)</Heading>

The Sylow <M>31</M> normalizer <M>H</M> in the sporadic simple group <M>B</M>
has the structure <M>31:15</M>.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> h:= CharacterTable( "31:15" );;
gap> hfusb:= PossibleClassFusions( h, b );;
gap> Length( RepresentativesFusions( h, hfusb, b ) );
2
]]></Example>

<P/>

We determine the correct fusion using the fact that
<M>H</M> is contained in a (maximal) subgroup of type <M>Th</M> in <M>B</M>.

<P/>

<Example><![CDATA[
gap> th:= CharacterTable( "Th" );;
gap> hfusth:= PossibleClassFusions( h, th );;
gap> thfusb:= PossibleClassFusions( th, b );;
gap> comp:= SetOfComposedClassFusions( thfusb, hfusth );;
gap> Length( comp );
2
gap> reps:= RepresentativesFusions( h, comp, b );
[ [ 1, 145, 146, 82, 82, 19, 82, 7, 19, 82, 82, 19, 7, 82, 19, 82, 82 
     ] ]
gap> GetFusionMap( h, b ) in reps;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:SuzN3_in_Suz">
<Heading><M>SuzN3 \rightarrow Suz</M> (September 2002)</Heading>

The class fusion from the Sylow <M>3</M> normalizer into the
sporadic simple group <M>Suz</M> is not uniquely determined
by the character tables of these groups.

<P/>

<Example><![CDATA[
gap> h:= CharacterTable( "SuzN3" );
CharacterTable( "3^5:(3^2:SD16)" )
gap> suz:= CharacterTable( "Suz" );
CharacterTable( "Suz" )
gap> hfussuz:= PossibleClassFusions( h, suz );;
gap> Length( RepresentativesFusions( h, hfussuz, suz ) );
2
]]></Example>

<P/>

Since <M>H</M> is not maximal in <M>Suz</M>,
we try to factorize the fusion through a suitable maximal subgroup.

<P/>

<Example><![CDATA[
gap> maxes:= List( Maxes( suz ), CharacterTable );;
gap> filt:= Filtered( maxes, x -> Size( x ) mod Size( h ) = 0 );
[ CharacterTable( "3_2.U4(3).2_3'" ), CharacterTable( "3^5:M11" ), 
  CharacterTable( "3^2+4:2(2^2xa4)2" ) ]
]]></Example>

<P/>

The group <M>3_2.U_4(3).2_3^{\prime}</M> does not admit a fusion from <M>H</M>.

<P/>

<Example><![CDATA[
gap> PossibleClassFusions( h, filt[1] );
[  ]
]]></Example>

<P/>

Definitely <M>3^5:M_{11}</M> contains a group isomorphic with <M>H</M>,
because the Sylow <M>3</M> normalizer in <M>M_{11}</M> has the structure
<M>3^2:SD_{16}</M>;
using <M>3^{2+4}:2(2^2 \times A_4)2</M> would lead to the same result as
we get below.
We compute the compositions of possible class fusions.

<P/>

<Example><![CDATA[
gap> max:= filt[2];;
gap> hfusmax:= PossibleClassFusions( h, max );;
gap> maxfussuz:= PossibleClassFusions( max, suz );;
gap> comp:= SetOfComposedClassFusions( maxfussuz, hfusmax );;
gap> repr:= RepresentativesFusions( h, comp, suz );
[ [ 1, 2, 2, 4, 5, 4, 5, 5, 5, 5, 5, 6, 9, 9, 14, 15, 13, 16, 16, 14, 
      15, 13, 13, 13, 16, 15, 14, 16, 16, 16, 21, 21, 23, 22, 29, 29, 
      29, 38, 39 ] ]
]]></Example>

<P/>

So the factorization determines the fusion map up to table automorphisms.
We check that this map is equal to the stored one.

<P/>

<Example><![CDATA[
gap> GetFusionMap( h, suz ) in repr;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:F3+N5_in_F3+">
<Heading><M>F_{{3+}}N5 \rightarrow F_{{3+}}</M> (March 2002)</Heading>

The class fusion from the table of the Sylow <M>5</M> normalizer <M>H</M>
in the sporadic simple group <M>F_{{3+}}</M> into <M>F_{{3+}}</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> f3p:= CharacterTable( "F3+" );;
gap> h:= CharacterTable( "F3+N5" );;
gap> hfusf3p:= PossibleClassFusions( h, f3p );;
gap> Length( RepresentativesFusions( h, hfusf3p, f3p ) );
2
]]></Example>

<P/>

<M>H</M> is not maximal in <M>F_{{3+}}</M>,
so we look for tables of maximal subgroups that can contain <M>H</M>.

<P/>

<Example><![CDATA[
gap> maxes:= List( Maxes( f3p ), CharacterTable );;
gap> filt:= Filtered( maxes, x -> Size( x ) mod Size( h ) = 0 );
[ CharacterTable( "Fi23" ), CharacterTable( "2.Fi22.2" ), 
  CharacterTable( "(3xO8+(3):3):2" ), CharacterTable( "O10-(2)" ), 
  CharacterTable( "(A4xO8+(2).3).2" ), CharacterTable( "He.2" ), 
  CharacterTable( "F3+M14" ), CharacterTable( "(A5xA9):2" ) ]
gap> possfus:= List( filt, x -> PossibleClassFusions( h, x ) );
[ [  ], [  ], [  ], [  ], 
  [ [ 1, 69, 110, 12, 80, 121, 4, 72, 113, 11, 11, 79, 79, 120, 120, 
          3, 71, 11, 79, 23, 91, 112, 120, 132, 29, 32, 97, 100, 37, 
          37, 105, 105, 139, 140, 145, 146, 155, 155, 156, 156, 44, 
          44, 167, 167, 48, 48, 171, 171, 57, 57, 180, 180, 66, 66, 
          189, 189 ], 
      [ 1, 69, 110, 12, 80, 121, 4, 72, 113, 11, 11, 79, 79, 120, 
          120, 3, 71, 11, 79, 23, 91, 112, 120, 132, 29, 32, 97, 100, 
          37, 37, 105, 105, 140, 139, 146, 145, 156, 156, 155, 155, 
          44, 44, 167, 167, 48, 48, 171, 171, 57, 57, 180, 180, 66, 
          66, 189, 189 ] ], [  ], [  ], [  ] ]
]]></Example>

<P/>

We see that from the eight possible classes of maximal subgroups in
<M>F_{{3+}}</M> that might contain <M>H</M>,
only the group of type <M>(A_4 \times O_8^+(2).3).2</M>
admits a class fusion from <M>H</M>.
Hence we can compute the compositions of the possible fusions from <M>H</M>
into this group with the possible fusions from this group into <M>F_{{3+}}</M>.

<P/>

<Example><![CDATA[
gap> max:= filt[5];
CharacterTable( "(A4xO8+(2).3).2" )
gap> hfusmax:= possfus[5];;
gap> maxfusf3p:= PossibleClassFusions( max, f3p );;
gap> comp:= SetOfComposedClassFusions( maxfusf3p, hfusmax );;
gap> Length( comp );
2
gap> repr:= RepresentativesFusions( h, comp, f3p );
[ [ 1, 2, 4, 12, 35, 54, 3, 3, 16, 9, 9, 11, 11, 40, 40, 2, 3, 9, 11, 
      35, 36, 13, 40, 90, 7, 22, 19, 20, 43, 43, 50, 50, 8, 8, 23, 
      23, 46, 46, 47, 47, 10, 10, 9, 9, 10, 10, 11, 11, 26, 26, 28, 
      28, 67, 67, 68, 68 ] ]
]]></Example>

<P/>

Finally, we check whether the map stored in the table library is correct.

<P/>

<Example><![CDATA[
gap> GetFusionMap( h, f3p ) in repr;
true
]]></Example>

<P/>

Note that we did <E>not</E> determine the class fusion from the
maximal subgroup <M>(A_4 \times O_8^+(2).3).2</M> into <M>F_{{3+}}</M>
up to table automorphisms
(see Section&nbsp;<Ref Subsect="subsect:A4xO8p2d32fusf3p"/> for this problem),
since also the ambiguous result was enough for computing the fusion from
<M>H</M> into <M>F_{{3+}}</M>.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Fusions_Determined_Using_Commutative_Diagrams">
<Heading>Fusions Determined Using Commutative Diagrams Involving Smaller
Subgroups</Heading>

In each of the following examples, the class fusion of a (not necessarily
maximal) subgroup <M>M</M> of a group <M>G</M> into <M>G</M> is determined
by considering a proper subgroup <M>U</M> of <M>M</M>
whose class fusion into <M>G</M> can be computed, perhaps using another subgroup
<M>S</M> of <M>G</M> that also contains <M>U</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ambigfus1.png" alt="setup: some subgroups of G"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                G
                               ╱ ╲
                              ╱   ╲
                             M     S
                              ╲   ╱
                               ╲ ╱
                                .
                                │
                                U
                                │
                                │
                                1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ambigfus1 -->
<![CDATA[
\setlength{\unitlength}{3pt}
\begin{center}
\begin{picture}(40,30)(-10,0)
\put(10, 5){\circle*{1}}
\put(10,10){\circle{1}} \put(13,10){\makebox(0,0){$U$}}
\put(10,15){\circle{1}}
\put( 5,20){\circle{1}} \put(2,20){\makebox(0,0){$M$}}
\put(15,20){\circle{1}} \put(17,20){\makebox(0,0){$S$}}
\put(10,25){\circle*{1}} \put(10,28){\makebox(0,0){$G$}}
\put(10, 5){\line(0,1){10}}
\put(10,15){\line(-1,1){5}}
\put(10,15){\line(1,1){5}}
\put( 5,20){\line(1,1){5}}
\put(15,20){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:BN7">
<Heading><M>BN7 \rightarrow B</M> (March 2002)</Heading>

Let <M>H</M> be a Sylow <M>7</M> normalizer in the sporadic simple group
<M>B</M>.
The class fusion of <M>H</M> into <M>B</M> is not uniquely determined by the
character tables of the two groups.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );
CharacterTable( "B" )
gap> h:= CharacterTable( "BN7" );
CharacterTable( "BN7" )
gap> hfusb:= PossibleClassFusions( h, b );;
gap> Length( RepresentativesFusions( h, hfusb, b ) );
2
]]></Example>

<P/>

Let us consider a maximal subgroup of the type <M>Th</M> in <M>B</M>
(cf.&nbsp;<Cite Key="CCN85" Where="p. 217"/>).
By&nbsp;<Cite Key="CCN85" Where="p. 177"/>,
the Sylow <M>7</M> normalizers in <M>Th</M> are maximal subgroups of <M>Th</M>
and have the structure <M>7^2:(3 \times 2S_4)</M>.
Let <M>U</M> be such a subgroup.

<P/>

Note that the only maximal subgroups of <M>Th</M> whose order is divisible by
the order of a Sylow <M>7</M> subgroup of <M>B</M> have the types
<M>{}^3D_4(2).3</M> and <M>7^2:(3 \times 2S_4)</M>,
and the Sylow <M>7</M> normalizers in the former groups have the structure
<M>7^2:(3 \times 2A_4)</M>, cf.&nbsp;<Cite Key="CCN85" Where="p. 89"/>.

<P/>

<Example><![CDATA[
gap> Number( Factors( Size( b ) ), x -> x = 7 );
2
gap> th:= CharacterTable( "Th" );
CharacterTable( "Th" )
gap> Filtered( Maxes( th ), x -> Size( CharacterTable( x ) ) mod 7^2 = 0 );
[ "3D4(2).3", "7^2:(3x2S4)" ]
]]></Example>

<P/>

The class fusion of <M>U</M> into <M>B</M> via <M>Th</M> is
uniquely determined by the character tables of these groups.

<P/>

<Example><![CDATA[
gap> thn7:= CharacterTable( "ThN7" );
CharacterTable( "7^2:(3x2S4)" )
gap> comp:= SetOfComposedClassFusions( PossibleClassFusions( th, b ),
>               PossibleClassFusions( thn7, th ) );
[ [ 1, 31, 7, 7, 5, 28, 28, 17, 72, 72, 6, 6, 7, 28, 27, 27, 109, 
      109, 17, 45, 45, 72, 72, 127, 127, 127, 127 ] ]
]]></Example>

<P/>

The condition that the class fusion of <M>U</M> into <M>B</M> factors through <M>H</M>
determines the class fusion of <M>H</M> into <M>B</M> up to table automorphisms.

<P/>

<Example><![CDATA[
gap> thn7fush:= PossibleClassFusions( thn7, h );;
gap> filt:= Filtered( hfusb, x ->
>               ForAny( thn7fush, y -> CompositionMaps( x, y ) in comp ) );;
gap> Length( RepresentativesFusions( h, filt, b ) );
1
]]></Example>

<P/>

Finally, we compare the result with the map that is stored on the library
table of <M>H</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( h, b ) in filt;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:A4xO8p2d32fusf3p">
<Heading><M>(A_4 \times O_8^+(2).3).2 \rightarrow Fi_{24}^{\prime}</M> (November 2002)</Heading>

The class fusion of the maximal subgroup
<M>M \cong (A_4 \times O_8^+(2).3).2</M> of <M>G = Fi_{24}^{\prime}</M>
is ambiguous.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "(A4xO8+(2).3).2" );;
gap> t:= CharacterTable( "F3+" );;
gap> mfust:= PossibleClassFusions( m, t );;
gap> repr:= RepresentativesFusions( m, mfust, t );;
gap> Length( repr );
2
]]></Example>

<P/>

We first observe that the elements of order three in the normal subgroup
of type <M>A_4</M> in <M>M</M> lie in the class <C>3A</C> of <M>Fi_{24}^{\prime}</M>.

<P/>

<Example><![CDATA[
gap> a4inm:= Filtered( ClassPositionsOfNormalSubgroups( m ),
>                      n -> Sum( SizesConjugacyClasses( m ){ n } ) = 12 );
[ [ 1, 69, 110 ] ]
gap> OrdersClassRepresentatives( m ){ a4inm[1] };
[ 1, 2, 3 ]
gap> List( repr, map -> map[110] );
[ 4, 4 ]
gap> OrdersClassRepresentatives( t ){ [ 1 .. 4 ] };
[ 1, 2, 2, 3 ]
]]></Example>

<P/>

Let us take one such element <M>g</M>, say.
Its normalizer <M>S</M> in <M>G</M> has the structure <M>(3 \times O_8^+(3).3).2</M>;
this group is maximal in <M>G</M>, and its character table is available in &GAP;.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "F3+N3A" );
CharacterTable( "(3xO8+(3):3):2" )
]]></Example>

<P/>

The intersection <M>N_M(g) = S \cap M</M> contains a subgroup <M>U</M> of the type
<M>3 \times O_8^+(2).3</M>,
and in the following we compute the class fusions of <M>U</M> into <M>S</M> and <M>M</M>,
and then utilize the fact that only those class fusions from <M>M</M> into <M>G</M>
are possible whose composition with the class fusion from <M>U</M> into <M>M</M>
equals a composition of class fusions from <M>U</M> into <M>S</M>
and from <M>S</M> into <M>G</M>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "Cyclic", 3 ) * CharacterTable( "O8+(2).3" );
CharacterTable( "C3xO8+(2).3" )
gap> ufuss:= PossibleClassFusions( u, s );;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> comp:= SetOfComposedClassFusions( sfust, ufuss );;
gap> Length( comp );
6
gap> filt:= Filtered( mfust,
>     x -> ForAny( ufusm, map -> CompositionMaps( x, map ) in comp ) );;
gap> repr:= RepresentativesFusions( m, filt, t );;
gap> Length( repr );
1
gap> GetFusionMap( m, t ) in repr;
true
]]></Example>

<P/>

So the class fusion from <M>M</M> into <M>G</M> is determined up to table automorphisms
by the commutative diagram.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:A_6xL_2(8).3_in_Fi24">
<Heading><M>A_6 \times L_2(8).3 \rightarrow Fi_{24}^{\prime}</M> (November 2002)</Heading>

The class fusion of the maximal subgroup <M>M \cong A_6 \times L_2(8).3</M>
of <M>G = Fi_{24}^{\prime}</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "A6xL2(8):3" );;
gap> t:= CharacterTable( "F3+" );;
gap> mfust:= PossibleClassFusions( m, t );;
gap> Length( RepresentativesFusions( m, mfust, t ) );
2
]]></Example>

<P/>

We will use the fact that the direct factor of the type <M>A_6</M> in <M>M</M>
contains elements in the class <C>3A</C> of <M>G</M>.
This fact can be shown as follows.

<P/>

<Example><![CDATA[
gap> dppos:= ClassPositionsOfDirectProductDecompositions( m );
[ [ [ 1, 12 .. 67 ], [ 1 .. 11 ] ] ]
gap> List( dppos[1], l -> Sum( SizesConjugacyClasses( t ){ l } ) );
[ 17733424133316996808705, 4545066196775803392 ]
gap> List( dppos[1], l -> Sum( SizesConjugacyClasses( m ){ l } ) );
[ 360, 1512 ]
gap> 3Apos:= Position( OrdersClassRepresentatives( t ), 3 );
4
gap> 3Ainm:= List( mfust, map -> Position( map, 3Apos ) );
[ 23, 23, 23, 23, 34, 34, 34, 34 ]
gap> ForAll( 3Ainm, x -> x in dppos[1][1] );
true
]]></Example>

<P/>

Since the normalizer of an element of order three in <M>A_6</M> has the form
<M>3^2:2</M>,
such a <C>3A</C> element in <M>M</M> contains a subgroup <M>U</M> of the structure
<M>3^2:2 \times L_2(8).3</M> which is contained in the <C>3A</C> normalizer <M>S</M> in <M>G</M>,
which has the structure <M>(3 \times O_8^+(3).3).2</M>.

<P/>

(Note that all classes in the <M>3^2:2</M> type group are rational,
and its character table is available in the &GAP; Character Table Library
with the identifier <C>"3^2:2"</C>.)

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "3^2:2" ) * CharacterTable( "L2(8).3" );
CharacterTable( "3^2:2xL2(8).3" )
gap> s:= CharacterTable( "F3+N3A" );
CharacterTable( "(3xO8+(3):3):2" )
gap> ufuss:= PossibleClassFusions( u, s );;
gap> comp:= SetOfComposedClassFusions( sfust, ufuss );;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> filt:= Filtered( mfust,
>               map -> ForAny( ufusm,
>                          map2 -> CompositionMaps( map, map2 ) in comp ) );;
gap> repr:= RepresentativesFusions( m, filt, t );;
gap> Length( repr );
1
gap> GetFusionMap( m, t ) in repr;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:BM14">
<Heading><M>(3^2:D_8 \times U_4(3).2^2).2 \rightarrow B</M> (June 2007)</Heading>

Let <M>G</M> be a maximal subgroup of the type <M>(3^2:D_8 \times U_4(3).2^2).2</M>
in the sporadic simple group <M>B</M>,
cf.&nbsp;<Cite Key="CCN85" Where="p. 217"/>.
Computing the class fusion of <M>G</M> into <M>B</M> just from the character tables
of the two groups takes extremely long.
So we use additional information.

<P/>

According to&nbsp;<Cite Key="CCN85" Where="p. 217"/>,
<M>G</M> is the normalizer in <M>B</M> of an elementary abelian group
<M>\langle x, y \rangle</M> of order <M>9</M>, with <M>x, y</M> in the class <C>3A</C> of <M>B</M>,
and <M>N = N_B(\langle x \rangle)</M> has the structure <M>S_3 \times Fi_{22}.2</M>.
The intersection <M>G \cap N</M> has the structure
<M>S_3 \times S_3 \times U_4(3).2^2</M>,
which is the direct product of <M>S_3</M> and the normalizer in <M>Fi_{22}.2</M>
of a <C>3A</C> element of <M>Fi_{22}.2</M>,
see&nbsp;<Cite Key="CCN85" Where="p. 163"/>.
Thus we may use that the class fusions from <M>G \cap N</M> into <M>B</M>
through <M>G</M> or <M>N</M> coincide.

<P/>

The class fusion from <M>N</M> into <M>B</M> is uniquely determined by the
character tables.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> n:= CharacterTable( "BN3A" );
CharacterTable( "S3xFi22.2" )
gap> nfusb:= PossibleClassFusions( n, b );;
gap> Length( nfusb );
1
gap> nfusb:= nfusb[1];;
]]></Example>

<P/>

The computation of the class fusion from <M>G \cap N</M> into <M>N</M> is
sped up by computing first the class fusion modulo the direct factor
<M>S_3</M>, and then lifting these fusion maps.

<P/>

<Example><![CDATA[
gap> fi222:= CharacterTable( "Fi22.2" );;
gap> fi222n3a:= CharacterTable( "S3xU4(3).(2^2)_{122}" );;
gap> s3:= CharacterTable( "S3" );;
gap> inter:= s3 * fi222n3a;;
gap> intermods3fusnmods3:= PossibleClassFusions( fi222n3a, fi222 );;
gap> Length( intermods3fusnmods3 );
2
gap> Length( RepresentativesFusions( fi222n3a, intermods3fusnmods3, fi222 ) );
1
]]></Example>

<P/>

We get two equivalent possibilities,
and need to consider only one of them.
For lifting it to a map between <M>G \cap N</M> and <M>N</M>,
the safe way is to use the fusion map between the two factors for computing
an approximation.
(Additionally, we could interpret the known maps as fusions between two
subgroups, and use this for improving the approximation,
but in this case the speedup is not worth the effort.)

<P/>

<Example><![CDATA[
gap> interfusn:= CompositionMaps( InverseMap( GetFusionMap( n, fi222 ) ),
>        CompositionMaps( intermods3fusnmods3[1],
>            GetFusionMap( inter, fi222n3a ) ) );;
gap> interfusn:= PossibleClassFusions( inter, n,
>        rec( fusionmap:= interfusn, quick:= true ) );;
gap> Length( interfusn );
1
]]></Example>

<P/>

The lift is unique.
Since we lift a class fusion to direct products,
we could also <Q>extend</Q> the fusion directly.
But note that this would assume the ordering of classes in character tables
of direct products.
This alternative would work as follows.

<P/>

<Example><![CDATA[
gap> nccl:= NrConjugacyClasses( fi222 );;
gap> interfusn[1] = Concatenation( List( [ 0 .. 2 ],
>                       i -> intermods3fusnmods3[1] + i * nccl ) );
true
]]></Example>

<P/>

Next we compute the class fusions from <M>G \cap N</M> to <M>G</M>.
We get two equivalent solutions.

<P/>

<Example><![CDATA[
gap> tblg:= CharacterTable( "BM14" );
CharacterTable( "(3^2:D8xU4(3).2^2).2" )
gap> interfusg:= PossibleClassFusions( inter, tblg );;
gap> Length( interfusg );
2
gap> Length( RepresentativesFusions( inter, interfusg, tblg ) );
1
]]></Example>

<P/>

The approximation of the class fusion from <M>G</M> to <M>B</M> is computed
by composing the known maps.
Because we have chosen one of the two possible maps from <M>G \cap N</M> to <M>N</M>,
here we consider the two possibilities.
 From these approximations, we compute the possible class fusions.

<P/>

<Example><![CDATA[
gap> interfusb:= CompositionMaps( nfusb, interfusn[1] );;
gap> approx:= List( interfusg,
>        map -> CompositionMaps( interfusb, InverseMap( map ) ) );;
gap> gfusb:= Set( Concatenation( List( approx,
>                     map -> PossibleClassFusions( tblg, b,
>                                rec( fusionmap:= map ) ) ) ) );;
gap> Length( gfusb );
4
gap> Length( RepresentativesFusions( tblg, gfusb, b ) );
1
]]></Example>

<P/>

Finally, we compare the result with the class fusion that is stored
on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( tblg, b ) in gfusb;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:MM24">
<Heading><M>7^{1+4}:(3 \times 2.S_7) \rightarrow M</M> (May 2009)</Heading>

The class fusion of the maximal subgroup <M>U</M> of type
<M>7^{1+4}:(3 \times 2.S_7)</M> of the Monster group <M>M</M> into <M>M</M>
is ambiguous.

<P/>

<Example><![CDATA[
gap> tblu:= CharacterTable( "7^(1+4):(3x2.S7)" );;
gap> m:= CharacterTable( "M" );;
gap> ufusm:= PossibleClassFusions( tblu, m );;
gap> Length( RepresentativesFusions( tblu, ufusm, m ) );
2
]]></Example>

<P/>

The subgroup <M>U</M> contains a Sylow <M>7</M>-subgroup of <M>M</M>,
and the only maximal subgroups of <M>M</M> with this property are the class of <M>U</M>
and another class of subgroups, of the type <M>7^{2+1+2}:GL_2(7)</M>.
<!-- % show this explicitly! -->
Moreover, it turns out that the Sylow <M>7</M> normalizers in the subgroups
in both classes have the same order, hence they are the Sylow <M>7</M>
normalizers in <M>M</M>.

<P/>

For that, we use representations from the &ATLAS; of Group
Representations&nbsp;<Cite Key="AGRv3"/>, and access these representations
via the &GAP; package <Package>AtlasRep</Package> (<Cite Key="AtlasRep"/>).

<P/>

<Example><![CDATA[
gap> LoadPackage( "atlasrep", false );
true
gap> g1:= AtlasGroup( "7^(2+1+2):GL2(7)" );;
gap> s1:= SylowSubgroup( g1, 7 );;
gap> n1:= Normalizer( g1, s1 );;
gap> g2:= AtlasGroup( "7^(1+4):(3x2.S7)" );;
gap> s2:= SylowSubgroup( g2, 7 );;
gap> n2:= Normalizer( g2, s2 );;
gap> Size( n1 ) = Size( n2 );
true
gap> ( Size( m ) / Size( s1 ) ) mod 7 <> 0;
true
]]></Example>

<P/>

So let <M>N</M> be a Sylow <M>7</M> normalizer in <M>U</M>,
and choose a subgroup <M>S</M> of the type <M>7^{2+1+2}:GL_2(7)</M>
that contains <M>N</M>.

<P/>

We compute the character table of <M>N</M>.
Computing the possible class fusions of <M>N</M> into <M>M</M> directly
yields two possibilities,
but the class fusion of <M>N</M> into <M>M</M> via <M>S</M> is
uniquely determined by the character tables.

<P/>

<Example><![CDATA[
gap> tbln:= CharacterTable( Image( IsomorphismPcGroup( n1 ) ) );;
gap> tbls:= CharacterTable( "7^(2+1+2):GL2(7)" );;
gap> nfusm:= PossibleClassFusions( tbln, m );;
gap> Length( RepresentativesFusions( tbln, nfusm, m ) );
2
gap> nfuss:= PossibleClassFusions( tbln, tbls );;
gap> sfusm:= PossibleClassFusions( tbls, m );;
gap> nfusm:= SetOfComposedClassFusions( sfusm, nfuss );;
gap> Length( nfusm );
1
]]></Example>

<P/>

Now we use the condition that the class fusions from <M>N</M> into <M>M</M>
factors through <M>U</M>.
This determines the class fusion of <M>U</M> into <M>M</M>
up to table automorphisms.

<P/>

<Example><![CDATA[
gap> nfusu:= PossibleClassFusions( tbln, tblu );;
gap> ufusm:= Filtered( ufusm, map2 -> ForAny( nfusu, 
>        map1 -> CompositionMaps( map2, map1 ) in nfusm ) );;
gap> Length( RepresentativesFusions( tblu, ufusm, m ) );
1
]]></Example>

<P/>

Let <M>C</M> be the centralizer in <M>U</M> of the normal subgroup of order
<M>7</M>; note that <M>C</M> is the <C>7B</C> centralizer on <M>M</M>.
We can use the information about the class fusion of <M>U</M> into <M>M</M>
for determining the class fusion of <M>C</M> into <M>M</M>.
The class fusion of <M>C</M> into <M>M</M> is not determined by the character
tables,
but the class fusion of <M>C</M> into <M>U</M> is determined
up to table automorphisms,
so the same holds for the class fusion of <M>C</M> into <M>M</M>.

<P/>

<Example><![CDATA[
gap> tblc:= CharacterTable( "MC7B" );                             
CharacterTable( "7^1+4.2A7" )
gap> cfusm:= PossibleClassFusions( tblc, m );;             
gap> Length( RepresentativesFusions( tblc, cfusm, m ) );
2
gap> cfusu:= PossibleClassFusions( tblc, tblu );;
gap> cfusm:= SetOfComposedClassFusions( ufusm, cfusu );;
gap> Length( RepresentativesFusions( tblc, cfusm, m ) );
1
]]></Example>

<!-- Compare tables and fusions with the ones in the library! -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:3^7.O_7(3):2_in_Fi24">
<Heading><M>3^7.O_7(3):2 \rightarrow Fi_{24}</M> (November 2010)</Heading>

The class fusion of the maximal subgroup <M>M \cong 3^7.O_7(3):2</M>
of <M>G = Fi_{24} = F_{{3+}}.2</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "3^7.O7(3):2" );;
gap> t:= CharacterTable( "F3+.2" );;
gap> mfust:= PossibleClassFusions( m, t );;
gap> Length( RepresentativesFusions( m, mfust, t ) );
2
]]></Example>

<P/>

We will use the fact that the elementary abelian normal subgroup of order
<M>3^7</M> in <M>M</M> contains an element <M>x</M>, say, in the class <C>3A</C> of <M>G</M>.
This fact can be shown as follows.

<P/>

<Example><![CDATA[
gap> nsg:= ClassPositionsOfNormalSubgroups( m );
[ [ 1 ], [ 1 .. 4 ], [ 1 .. 158 ], [ 1 .. 291 ] ]
gap> Sum( SizesConjugacyClasses( m ){ nsg[2] } );
2187
gap> 3^7;
2187
gap> rest:= Set( mfust, map -> map{ nsg[2] } );
[ [ 1, 4, 5, 6 ] ]
gap> List( rest, l -> ClassNames( t, "Atlas" ){ l } );
[ [ "1A", "3A", "3B", "3C" ] ]
]]></Example>

<P/>

The normalizer <M>S</M> of <M>\langle x \rangle</M> in <M>G</M> has the form
<M>S_3 \times O_8^+(3):S_3</M>,
and the order of <M>U = S \cap M = N_M( \langle x \rangle)</M>
is <M>53059069440</M>, so <M>U</M> has index <M>3360</M> in <M>S</M>.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "F3+.2N3A" );
CharacterTable( "S3xO8+(3):S3" )
gap> PowerMap( m, 2 )[4];
4
gap> size_u:= 2 * SizesCentralizers( m )[ 2 ];
53059069440
gap> Size( s ) / size_u;
3360
]]></Example>

<P/>

Using the list of maximal subgroups of <M>O_8^+(3)</M>,
we see that only the maximal subgroups of the type <M>3^6:L_4(3)</M>
have index dividing <M>3360</M> in <M>O_8^+(3)</M>.
(There are three classes of such subgroups.)
This implies that <M>U</M> contains a subgroup of the type
<M>S_3 \times 3^6:L_4(3)</M>.

<P/>

<Example><![CDATA[
gap> o8p3:= CharacterTable( "O8+(3)" );;
gap> mx:= List( Maxes( o8p3 ), CharacterTable );;
gap> filt:= Filtered( mx, x -> 3360 mod Index( o8p3, x ) = 0 );
[ CharacterTable( "3^6:L4(3)" ), CharacterTable( "O8+(3)M8" ), 
  CharacterTable( "O8+(3)M9" ) ]
gap> List( filt, x -> Index( o8p3, x ) );
[ 1120, 1120, 1120 ]
]]></Example>

<P/>

We compute the possible class fusions from <M>U</M> into <M>M</M> and <M>S</M> in two
steps, because this is faster.
First the possible class fusions from <M>U^{\prime\prime} \cong 3^6:L_4(3)</M>
into <M>M</M> and <M>S</M> are computed, and then these fusions are used to derive
approximations for the fusions from <M>U</M> into <M>M</M> and <M>S</M>.

<P/>

<Example><![CDATA[
gap> uu:= filt[1];;
gap> u:= CharacterTable( "Symmetric", 3 ) * uu;
CharacterTable( "Sym(3)x3^6:L4(3)" )
gap> uufusm:= PossibleClassFusions( uu, m );;
gap> Length( uufusm );
8
gap> approx:= List( uufusm, map -> CompositionMaps( map,
>                   InverseMap( GetFusionMap( uu, u ) ) ) );;
gap> ufusm:= Concatenation( List( approx, map ->
>        PossibleClassFusions( u, m, rec( fusionmap:= map ) ) ) );;
gap> Length( ufusm );
8
gap> uufuss:= PossibleClassFusions( uu, s );;
gap> Length( uufuss );
8
gap> approx:= List( uufuss, map -> CompositionMaps( map,
>              InverseMap( GetFusionMap( uu, u ) ) ) );;
gap> ufuss:= Concatenation( List( approx, map ->
>   PossibleClassFusions( u, s, rec( fusionmap:= map ) ) ) );;
gap> Length( ufuss );
8
]]></Example>

<P/>

Now we compute the possible class fusions from <M>S</M> into <M>G</M>,
and the compositions of these maps with the possible class fusions
from <M>U</M> into <M>S</M>.

<P/>

<Example><![CDATA[
gap> sfust:= PossibleClassFusions( s, t );;
gap> comp:= SetOfComposedClassFusions( sfust, ufuss );;
gap> Length( comp );
8
]]></Example>

<P/>

It turns out that only one orbit of the possible class fusions from <M>M</M> to
<M>G</M> is compatible with these possible class fusions from <M>U</M> to <M>G</M>.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( mfust, map2 -> ForAny( ufusm, map1 ->
>        CompositionMaps( map2, map1 ) in comp ) );;
gap> Length( filt );
4
gap> Length( RepresentativesFusions( m, filt, t ) );
1
]]></Example>

<P/>

The class fusion stored in the &GAP; Character Table Library is one of them.

<P/>

<Example><![CDATA[
gap> GetFusionMap( m, t ) in filt;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2E62N3C_in_2E62">
<Heading><M>{}^2E_6(2)N3C \rightarrow {}^2E_6(2)</M> (January 2019)</Heading>

Let <M>G = {}^2E_6(2)</M>,
and <M>g \in G</M> in the conjugacy class <C>3C</C>.
Using a permutation representation of <M>G</M>,
Frank Lübeck has computed a representation and the character table
of the maximal subgroup <M>N = N_G(\langle g \rangle)</M> of <M>G</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "2E6(2)" );;
gap> pos3CinG:= Position( ClassNames( t ), "3c" );
7
gap> n:= CharacterTable( "2E6(2)N3C" );;
gap> nclasses:= SizesConjugacyClasses( n );;
gap> pos3CinN:= Filtered( [ 1 .. NrConjugacyClasses( n ) ],
>                         i -> nclasses[i] = 2 );
[ 2 ]
gap> nfust:= PossibleClassFusions( n, t );;
gap> ForAll( nfust, x -> x[ pos3CinN[1] ] = pos3CinG );
true
gap> Size( n ) = 2 * SizesCentralizers( t )[ pos3CinG ];
true
gap> ForAll( Irr( n ), x -> IsInt( x[ pos3CinN[1] ] ) );
true
]]></Example>

<P/>

The class fusion of <M>N</M> in <M>G</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> rep:= RepresentativesFusions( n, nfust, t );;
gap> Length( rep );
4
]]></Example>

<P/>

We use the fact that <M>g</M> is contained in a subgroup
<M>S \cong Fi_{22}</M> of <M>G</M>, <M>\ldots</M>

<Example><![CDATA[
gap> s:= CharacterTable( "Fi22" );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> ForAll( sfust, x -> x[6] = pos3CinG );
true
gap> pos3CinS:= 6;;
]]></Example>

<M>\ldots</M> and that
<M>U = N_S(\langle g \rangle) \cong 3^{1+6}:2^{3+4}:3^2:2</M>
is a maximal subgroup of <M>S</M> whose character table is available.
Thus <M>U \leq N</M>, of index four.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( Maxes( s )[11] );
CharacterTable( "3^(1+6):2^(3+4):3^2:2" )
gap> uclasses:= SizesConjugacyClasses( u );;
gap> pos3CinU:= Filtered( [ 1 .. NrConjugacyClasses( u ) ],
>                         i -> uclasses[i] = 2 );
[ 2 ]
gap> ufuss:= PossibleClassFusions( u, s );;
gap> ForAll( ufuss, x -> x[ pos3CinU[1] ] = pos3CinS );
true
gap> Size( n ) / Size( u );
4
]]></Example>

<P/>

Composing the class fusions of <M>U</M> in <M>N</M> and
<M>N</M> in <M>G</M> must be equal to the composition of the class fusions
of <M>U</M> in <M>S</M> and <M>S</M> in <M>G</M>.
This reduces the number of candidates for the fusion of <M>N</M> in <M>G</M>
from four to two.

<Example><![CDATA[
gap> ufusn:= PossibleClassFusions( u, n );;
gap> comp:= SetOfComposedClassFusions( sfust, ufuss );;
gap> good:= Filtered( nfust, map2 -> ForAny( ufusn,
>               map1 -> CompositionMaps( map2, map1 ) in comp ) );;
gap> Length( good );
1728
gap> goodrep:= RepresentativesFusions( n, good, t );;
gap> Length( goodrep );
2
]]></Example>

<P/>

Next we use the fact that <M>g</M> and thus <M>N</M> is invariant under
an outer automorphism <M>\alpha</M>, say, of order three of <M>G</M>.
Note that such an automorphism acts nontrivially on the conjugacy classes
of <M>G</M>, for example because the class fusion of <M>G</M> into
<M>G.3 = \langle G, \alpha \rangle</M> shows the existence of orbits
of length three,
and that the permutation action of <M>\alpha</M> on the classes of <M>G</M>
is given by the unique subgroup of order three
in the group of table automorphisms of <M>G</M>.

<P/>

<Example><![CDATA[
gap> tfust3:= GetFusionMap( t, CharacterTable( "2E6(2).3" ) );;
gap> Number( InverseMap( tfust3 ), IsList );
14
gap> autt:= AutomorphismsOfTable( t );;
gap> ord3:= Filtered( autt, x -> Order( x ) = 3 );;
gap> Length( ord3 );
2
gap> alpha:= ord3[1];;
gap> pos3CinG ^ alpha = pos3CinG;
true
]]></Example>

<P/>

The character table of <M>N</M> has <M>26</M> table automorphisms
of order three.
We do not know which of them (or perhaps the identity permutation)
is induced by the restriction <M>\alpha_N</M> of <M>\alpha</M> to <M>N</M>,
but the embedding <M>\iota\colon N \rightarrow G</M> satisfies
<M>\alpha \circ \iota = \iota \circ \alpha_N</M>,
and we can check each fusion candidate for the existence of a candidate
for <M>\alpha_N</M> such that this relation holds.

<P/>

<Example><![CDATA[
gap> autn:= AutomorphismsOfTable( n );;
gap> ord3:= Filtered( autn, x -> Order( x ) = 3 );;
gap> Length( ord3 );
26
gap> Add( ord3, () );
gap> filt:= Filtered( rep, map -> ForAny( ord3, beta ->
> OnTuples( map, alpha ) = Permuted( map, beta ) ) );;
gap> Length( filt );
2
]]></Example>

<P/>

Again, the number of candidates for the fusion of <M>N</M> in <M>G</M>
is reduced from four to two.
Moreover, we are lucky because only one candidate satifies also the
first criterion we have checked.

<P/>

<Example><![CDATA[
gap> inter:= Intersection( good, filt );
[ [ 1, 7, 5, 6, 7, 2, 3, 4, 27, 30, 24, 32, 25, 26, 9, 11, 12, 13, 
      10, 14, 19, 19, 19, 16, 17, 18, 21, 58, 61, 62, 67, 68, 69, 57, 
      72, 59, 75, 76, 77, 78, 79, 80, 64, 65, 66, 60, 81, 82, 5, 6, 
      7, 6, 7, 7, 7, 7, 6, 7, 6, 7, 7, 24, 25, 27, 26, 28, 30, 29, 
      31, 32, 31, 32, 32, 32, 32, 31, 32, 31, 32, 51, 52, 52, 52, 52, 
      74, 76, 77, 77, 75, 74, 76, 74, 75, 99, 100, 101, 102, 4, 20, 
      29, 31, 32, 36, 36, 42, 42, 39, 40, 41, 49, 49, 49, 49, 49, 49, 
      71, 112, 112, 114, 115, 116 ] ]
]]></Example>

<P/>

The class fusion stored in the &GAP; Character Table Library is this
candidate.

<P/>

<Example><![CDATA[
gap> GetFusionMap( n, t ) = inter[1];
true
]]></Example>

<P/>

<E>Remark:</E>

<P/>

Note that the structure of <M>N</M> is <M>3^{1+6}:2^{3+6}:3^2:2</M>,
as is stated in <Cite Key="AtlasImpII"/>.
The structure <M>3^{1+6}.2^{3+6}.(S_3 \times 3)</M> claimed in the
&ATLAS;&nbsp;<Cite Key="CCN85" Where="p. 191"/> is wrong,
as we can read off for example from the fact that <M>N</M> has exactly
two linear characters.

<P/>

<Example><![CDATA[
gap> Length( LinearCharacters( n ) );
2
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Fusions_Determined_Using_Factor_Groups">
<Heading>Fusions Determined Using Commutative Diagrams Involving Factor
Groups</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:3.A_7_in_3.Suz">
<Heading><M>3.A_7 \rightarrow 3.Suz</M> (December 2010)</Heading>

The maximal subgroups of type <M>A_7</M> in the sporadic simple Suzuki group
<M>Suz</M> lift to groups of the type <M>3.A_7</M> in <M>3.Suz</M>.
This can be seen from the fact that <M>3.Suz</M> does not admit a class fusion
from <M>A_7</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "Suz" );;
gap> 3t:= CharacterTable( "3.Suz" );;
gap> s:= CharacterTable( "A7" );;
gap> 3s:= CharacterTable( "3.A7" );;
gap> PossibleClassFusions( s, 3t );
[  ]
]]></Example>

<P/>

The class fusion of <M>3.A_7</M> into <M>3.Suz</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> 3sfus3t:= PossibleClassFusions( 3s, 3t );;
gap> Length( 3sfus3t );
6
gap> RepresentativesFusions( 3s, 3sfus3t, 3t );
[ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 
      49, 50, 48, 49, 50 ], 
  [ 1, 11, 12, 4, 36, 37, 13, 16, 23, 82, 83, 32, 100, 101, 44, 38, 
      41, 48, 112, 116, 48, 115, 113 ] ]
gap> ClassPositionsOfCentre( 3t );
[ 1, 2, 3 ]
]]></Example>

<P/>

We see that the possible fusions in the second orbit avoid the centre of
<M>3.Suz</M>.
Since the preimages in <M>3.Suz</M> of the <M>A_7</M> type subgroups of <M>Suz</M>
contain the centre of <M>3.Suz</M>, we know that the class fusion of these
preimages belong to the first orbit.
This can be formalized by checking the commutativity of the diagram
of fusions between <M>3.A_7</M>, <M>3.Suz</M>, and their factors <M>A_7</M> and <M>Suz</M>.

<P/>

<Example><![CDATA[
gap> sfust:= PossibleClassFusions( s, t );;
gap> Length( sfust );
1
gap> filt:= Filtered( 3sfus3t, map -> CompositionMaps( GetFusionMap( 3t, t ),
>                                         map )
>               = CompositionMaps( sfust[1], GetFusionMap( 3s, s ) ) );
[ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 
      49, 50, 48, 49, 50 ], 
  [ 1, 3, 2, 7, 9, 8, 16, 16, 26, 28, 27, 32, 34, 33, 47, 47, 47, 48, 
      50, 49, 48, 50, 49 ] ]
]]></Example>

<P/>

So the class fusion of maximal <M>3.A_7</M> type subgroups of <M>3.Suz</M> is
determined up to table automorphisms.
One of these fusions is stored on the table of <M>3.A_7</M>.

<P/>

<Example><![CDATA[
gap> RepresentativesFusions( 3s, filt, 3t );
[ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 
      49, 50, 48, 49, 50 ] ]
gap> GetFusionMap( 3s, 3t ) in filt;
true
]]></Example>

<P/>

Also the class fusions in the other orbit belong to subgroups of type
<M>3.A_7</M> in <M>3.Suz</M>.
Note that <M>Suz</M> contains maximal subgroups of the type
<M>3_2.U_4(3).2_3^{\prime}</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 131"/>),
and the <M>A_7</M> type subgroups of <M>U_4(3)</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 52"/>)
lift to groups of the type <M>3.A_7</M> in <M>3_2.U_4(3)</M> because
<M>3_2.U_4(3)</M> does not admit a class fusion from <M>A_7</M>.
The preimages in <M>3.Suz</M> of the <M>3.A_7</M> type subgroups of <M>Suz</M>
have the structure <M>3 \times 3.A_7</M>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "3_2.U4(3)" );;
gap> PossibleClassFusions( s, u );
[  ]
gap> Length( PossibleClassFusions( 3s, u ) );
8
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:S6_in_U4(2)">
<Heading><M>S_6 \rightarrow U_4(2)</M> (September 2011)</Heading>

The simple group <M>G = U_4(2)</M> contains a maximal subgroup <M>U</M>
of type <M>S_6</M>.
The class fusion from <M>U</M> to <M>G</M> is unique up to table automorphisms.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "S6" );
CharacterTable( "A6.2_1" )
gap> t:= CharacterTable( "U4(2)" );
CharacterTable( "U4(2)" )
gap> sfust:= PossibleClassFusions( s, t );
[ [ 1, 3, 6, 7, 9, 10, 3, 2, 9, 16, 15 ], 
  [ 1, 3, 7, 6, 9, 10, 2, 3, 9, 15, 16 ] ]
gap> Length( RepresentativesFusions( s, sfust, t ) );
1
]]></Example>

<P/>

In the double cover <M>2.G</M> of <M>G</M>, <M>U</M> lifts to the double cover <M>2.U</M> of <M>U</M>
(which is unique up to isomorphism).
Also the class fusion from <M>2.U</M> to <M>2.G</M> is unique up to table automorphisms.

<P/>

<Example><![CDATA[
gap> 2t:= CharacterTable( "2.U4(2)" );
CharacterTable( "2.U4(2)" )
gap> 2s:= CharacterTable( "2.A6.2_1" );
CharacterTable( "2.A6.2_1" )
gap> 2sfus2t:= PossibleClassFusions( 2s, 2t );
[ [ 1, 2, 4, 11, 12, 9, 10, 15, 16, 17, 3, 4, 15, 24, 25, 26, 26 ], 
  [ 1, 2, 4, 11, 12, 9, 10, 15, 16, 17, 3, 4, 15, 25, 24, 26, 26 ] ]
gap> Length( RepresentativesFusions( 2s, 2sfus2t, 2t ) );
1
]]></Example>

<P/>

However, the two possible fusions from <M>2.U</M> to <M>2.G</M> are lifts of the
same class fusion from <M>U</M> to <M>G</M>.

<P/>

<Example><![CDATA[
gap> 2sfuss:= GetFusionMap( 2s, s );
[ 1, 1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 8, 9, 10, 10, 11, 11 ]
gap> 2tfust:= GetFusionMap( 2t, t );;
gap> induced:= Set( 2sfus2t, x -> CompositionMaps( 2tfust,
>      CompositionMaps( x, InverseMap( 2sfuss ) ) ) );
[ [ 1, 3, 7, 6, 9, 10, 2, 3, 9, 15, 16 ] ]
]]></Example>

<P/>

The point is that the outer automorphism of <M>S_6</M> that makes the two
fusions from <M>U</M> to <M>G</M> equivalent does not lift to <M>2.U</M>,
and that we have silently assumed a fixed factor fusion from <M>2.U</M> to <M>U</M>.
Note that composing this factor fusion with the automorphism of <M>U</M>
would also yield a factor fusion, and w.&nbsp;r.&nbsp;t.&nbsp;the commutative diagram
involving this factor fusion, the other possible class fusion from <M>U</M> to
<M>G</M> is induced by the possible fusions from <M>2.U</M> to <M>2.G</M>.

<P/>

<Example><![CDATA[
gap> auts:= AutomorphismsOfTable( s );
Group([ (3,4)(7,8)(10,11) ])
gap> other:= OnTuples( 2sfuss, GeneratorsOfGroup( auts )[1] );
[ 1, 1, 2, 4, 4, 3, 3, 5, 6, 6, 8, 7, 9, 11, 11, 10, 10 ]
gap> Set( 2sfus2t, x -> CompositionMaps( 2tfust,
>      CompositionMaps( x, InverseMap( other ) ) ) );
[ [ 1, 3, 6, 7, 9, 10, 3, 2, 9, 16, 15 ] ]
]]></Example>

<P/>

The library table of <M>U</M> stores the class fusion to <M>G</M> that is
compatible with the stored factor fusion from <M>2.U</M> to <M>U</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) in induced;
true
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Fusions Determined Using Commutative Diagrams Involving
Automorphic Extensions">
<Heading>Fusions Determined Using Commutative Diagrams Involving
Automorphic Extensions</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:u383to2e62">
<Heading><M>U_3(8).3_1 \rightarrow {}^2E_6(2)</M> (December 2010)</Heading>

According to the &ATLAS; (see&nbsp;<Cite Key="CCN85" Where="p. 191"/>),
the group <M>G = {}^2E_6(2)</M> contains a maximal subgroup <M>U</M>
of the type <M>U_3(8).3_1</M>.
The class fusion of <M>U</M> into <M>G</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "U3(8).3_1" );;
gap> t:= CharacterTable( "2E6(2)" );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> Length( sfust );
24
gap> Length( RepresentativesFusions( s, sfust, t ) );
2
]]></Example>

<P/>

In the automorphic extension <M>G.2 = {}^2E_6(2).2</M> of <M>G</M>,
the subgroup <M>U</M> extends to a group <M>U.2</M> of the type <M>U_3(8).6</M>
(again, see &nbsp;<Cite Key="CCN85" Where="p. 191"/>).
The class fusion of <M>U.2</M> into <M>G.2</M>
is unique up to table automorphisms.

<P/>

<Example><![CDATA[
gap> s2:= CharacterTable( "U3(8).6" );;
gap> t2:= CharacterTable( "2E6(2).2" );;
gap> s2fust2:= PossibleClassFusions( s2, t2 );;
gap> Length( s2fust2 );
2
gap> Length( RepresentativesFusions( s2, s2fust2, t2 ) );
1
]]></Example>

<P/>

Only half of the possible class fusions from <M>U</M> into <M>G</M> are compatible
with the embeddings of <M>U</M> into <M>G.2</M> via <M>U.2</M> and <M>G</M>,
and the compatible maps form one orbit under table automorphisms.

<P/>

<Example><![CDATA[
gap> sfuss2:= PossibleClassFusions( s, s2 );;
gap> comp:= SetOfComposedClassFusions( s2fust2, sfuss2 );;
gap> tfust2:= PossibleClassFusions( t, t2 );;
gap> filt:= Filtered( sfust, map -> ForAny( tfust2,
>               map2 -> CompositionMaps( map2, map ) in comp ) );;
gap> Length( filt );
12
gap> Length( RepresentativesFusions( s, filt, t ) );
1
]]></Example>

<P/>

Let us see which classes of <M>U</M> and <M>G</M> are involved in the
disambiguation of the class fusion.
The <Q>good</Q> fusion candidates differ from the excluded ones on the
classes at the positions <M>31</M> to <M>36</M>:
Under all possible class fusions, two pairs of classes are mapped to
the classes <M>81</M> and <M>82</M> of <M>G</M>;
from these classes, the excluded maps fuse classes at odd positions
with classes at even positions, whereas the <Q>good</Q> class fusions
do not have this property.

<P/>

<Example><![CDATA[
gap> Set( filt, x -> x{ [ 31 .. 36 ] } );
[ [ 74, 74, 81, 82, 81, 82 ], [ 74, 74, 82, 81, 82, 81 ], 
  [ 81, 82, 74, 74, 81, 82 ], [ 81, 82, 81, 82, 74, 74 ], 
  [ 82, 81, 74, 74, 82, 81 ], [ 82, 81, 82, 81, 74, 74 ] ]
gap> Set( Difference( sfust, filt ), x -> x{ [ 31 .. 36 ] } );
[ [ 74, 74, 81, 82, 82, 81 ], [ 74, 74, 82, 81, 81, 82 ], 
  [ 81, 82, 74, 74, 82, 81 ], [ 81, 82, 82, 81, 74, 74 ], 
  [ 82, 81, 74, 74, 81, 82 ], [ 82, 81, 81, 82, 74, 74 ] ]
]]></Example>

<P/>

None of the possible class fusions from <M>U</M> to <M>U.2</M> fuses classes
at odd positions in the interval from <M>31</M> to <M>36</M> with classes at
even positions.

<P/>

<Example><![CDATA[
gap> Set( sfuss2, x -> x{ [ 31 .. 36 ] } );
[ [ 28, 29, 30, 31, 30, 31 ], [ 29, 28, 31, 30, 31, 30 ], 
  [ 30, 31, 28, 29, 30, 31 ], [ 30, 31, 30, 31, 28, 29 ], 
  [ 31, 30, 29, 28, 31, 30 ], [ 31, 30, 31, 30, 29, 28 ] ]
]]></Example>

<P/>

This suffices to exclude the <Q>bad</Q> fusion candidates
because no further fusion of the relevant classes of <M>G</M>
happens in <M>G.2</M>.

<P/>

<Example><![CDATA[
gap> List( tfust2, x -> x{ [ 74, 81, 82 ] } );
[ [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ], 
  [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ], 
  [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ] ]
]]></Example>

<P/>

(The same holds for the fusion of the relevant classes of <M>U.2</M> in
<M>G.2</M>.)

<P/>

<Example><![CDATA[
gap> List( s2fust2, x -> x{ [ 28 .. 31 ] } );
[ [ 65, 65, 70, 71 ], [ 65, 65, 71, 70 ] ]
]]></Example>

<P/>

Finally, we check that a correct map is stored on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) in filt;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L3421-in-U62">
<Heading><M>L_3(4).2_1 \rightarrow U_6(2)</M> (December 2010)</Heading>

According to the &ATLAS; (see&nbsp;<Cite Key="CCN85" Where="p. 115"/>),
the group <M>G = U_6(2)</M> contains a maximal subgroup <M>U</M> of the type
<M>L_3(4).2_1</M>.
The class fusion of <M>U</M> into <M>G</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "L3(4).2_1" );;
gap> t:= CharacterTable( "U6(2)" );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> Length( sfust );
27
gap> Length( RepresentativesFusions( s, sfust, t ) );
3
]]></Example>

<P/>

In the automorphic extension <M>G.3 = U_6(2).3</M> of <M>G</M>,
the subgroup <M>U</M> extends to a group <M>U.3</M> of the type <M>L_3(4).6</M>
(again, see &nbsp;<Cite Key="CCN85" Where="p. 115"/>).
The class fusion of <M>U.3</M> into <M>G.3</M>
is unique up to table automorphisms.

<P/>

<Example><![CDATA[
gap> s3:= CharacterTable( "L3(4).6" );;
gap> t3:= CharacterTable( "U6(2).3" );;
gap> s3fust3:= PossibleClassFusions( s3, t3 );;
gap> Length( s3fust3 );
2
gap> Length( RepresentativesFusions( s3, s3fust3, t3 ) );
1
]]></Example>

<P/>

Here the argument used in Section&nbsp;<Ref Subsect="subsect:u383to2e62"/>
does not work,
because all possible class fusions from <M>U</M> into <M>G</M> are compatible
with the embeddings of <M>U</M> into <M>G.3</M> via <M>U.3</M> and <M>G</M>.

<P/>

<Example><![CDATA[
gap> sfuss3:= PossibleClassFusions( s, s3 );;
gap> comp:= SetOfComposedClassFusions( s3fust3, sfuss3 );;
gap> tfust3:= PossibleClassFusions( t, t3 );;
gap> sfust = Filtered( sfust, map -> ForAny( tfust3,
>                map2 -> CompositionMaps( map2, map ) in comp ) );
true
]]></Example>

<P/>

Consider the elements of order four in <M>U</M>.
There are three such classes inside <M>U^{\prime} \cong L_3(4)</M>,
which fuse to one class of <M>U.3</M>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( s );
[ 1, 2, 3, 4, 4, 4, 5, 7, 2, 4, 6, 8, 8, 8 ]
gap> sfuss3;
[ [ 1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10, 10, 10 ] ]
]]></Example>

<P/>

These classes of <M>U</M> fuse into some of the classes <M>10</M> to <M>12</M> of <M>G</M>.
In <M>G.3</M>, these three classes fuse into one class.

<P/>

<Example><![CDATA[
gap> Set( sfust, map -> map{ [ 4 .. 6 ] } );
[ [ 10, 10, 10 ], [ 10, 10, 11 ], [ 10, 10, 12 ], [ 10, 11, 10 ], 
  [ 10, 11, 11 ], [ 10, 11, 12 ], [ 10, 12, 10 ], [ 10, 12, 11 ], 
  [ 10, 12, 12 ], [ 11, 10, 10 ], [ 11, 10, 11 ], [ 11, 10, 12 ], 
  [ 11, 11, 10 ], [ 11, 11, 11 ], [ 11, 11, 12 ], [ 11, 12, 10 ], 
  [ 11, 12, 11 ], [ 11, 12, 12 ], [ 12, 10, 10 ], [ 12, 10, 11 ], 
  [ 12, 10, 12 ], [ 12, 11, 10 ], [ 12, 11, 11 ], [ 12, 11, 12 ], 
  [ 12, 12, 10 ], [ 12, 12, 11 ], [ 12, 12, 12 ] ]
gap> Set( tfust3, map -> map{ [ 10 .. 12 ] } );
[ [ 10, 10, 10 ] ]
]]></Example>

<P/>

This means that the automorphism <M>\alpha</M> of <M>G</M> that is induced by
the action of <M>G.3</M> permutes the classes <M>10</M> to <M>12</M> of <M>G</M> transitively.
The fact that <M>U</M> extends to <M>U.3</M> in <M>G.3</M> means that <M>U</M> is invariant
under <M>\alpha</M>.
This implies that <M>U</M> contains either no elements from the classes
<M>10</M> to <M>12</M> or elements from all of these classes.
The possible class fusions from <M>U</M> to <M>G</M> satisfying this condition
form one orbit under table automprhisms.

<P/>

<Example><![CDATA[
gap> Filtered( sfust, map -> Intersection( map, [ 10 .. 12 ] ) = [] );
[  ]
gap> filt:= Filtered( sfust, map -> IsSubset( map, [ 10 .. 12 ] ) );
[ [ 1, 3, 7, 10, 11, 12, 15, 24, 4, 14, 23, 26, 27, 28 ], 
  [ 1, 3, 7, 10, 12, 11, 15, 24, 4, 14, 23, 26, 28, 27 ], 
  [ 1, 3, 7, 11, 10, 12, 15, 24, 4, 14, 23, 27, 26, 28 ], 
  [ 1, 3, 7, 11, 12, 10, 15, 24, 4, 14, 23, 27, 28, 26 ], 
  [ 1, 3, 7, 12, 10, 11, 15, 24, 4, 14, 23, 28, 26, 27 ], 
  [ 1, 3, 7, 12, 11, 10, 15, 24, 4, 14, 23, 28, 27, 26 ] ]
gap> Length( RepresentativesFusions( s, filt, t ) );
1
]]></Example>

<P/>

Finally, we check that a correct map is stored on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) in filt;
true
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Conditions Imposed by Brauer Tables">
<Heading>Conditions Imposed by Brauer Tables</Heading>

The examples in this section show that symmetries can be broken as soon as
the class fusions between two ordinary tables shall be compatible with
the corresponding Brauer character tables.
More precisely, we assume that the class fusion from each Brauer table
to its ordinary table is already fixed;
choosing these fusions consistently can be a nontrivial task,
solving so-called <Q>generality problems</Q> may require the construction
of certain modules, similar to the arguments used
in&nbsp;<Ref Subsect="subsect:generality"/> below.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(16).4_in_J3.2">
<Heading><M>L_2(16).4 \rightarrow J_3.2</M> (January&nbsp;2004)</Heading>

It can happen that Brauer tables decide ambiguities of class fusions between
the corresponding ordinary tables.
An easy example is the class fusion of <M>L_2(16).4</M> into <M>J_3.2</M>.
The ordinary tables admit four possible class fusions,
of which two are essentially different.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "L2(16).4" );;
gap> t:= CharacterTable( "J3.2" );;
gap> fus:= PossibleClassFusions( s, t );
[ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ], 
  [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ], 
  [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ], 
  [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]
gap> RepresentativesFusions( s, fus, t );
[ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ], 
  [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]
]]></Example>

<P/>

Using Brauer tables, we will see that just one fusion is admissible.

<P/>

We can exclude two possible fusions by the fact that their images all
lie inside the normal subgroup <M>J_3</M>, but <M>J_3</M> does not contain a subgroup
of type <M>L_2(16).4</M>; so still one orbit of length two remains.

<P/>

<Example><![CDATA[
gap> j3:= CharacterTable( "J3" );;
gap> PossibleClassFusions( s, j3 );
[  ]
gap> GetFusionMap( j3, t );
[ 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 14, 15, 16, 
  17, 17 ]
gap> filt:= Filtered( fus,
>          x -> not IsSubset( ClassPositionsOfDerivedSubgroup( t ), x ) );
[ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ], 
  [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]
]]></Example>

<P/>

Now the remaining wrong fusion is excluded by the fact that the table
automorphism of <M>J_3.2</M> that swaps the two classes of element order <M>17</M>
&ndash;which swaps two of the possible class fusions&ndash;
does not live in the <M>2</M>-modular table.

<P/>

<Example><![CDATA[
gap> smod2:= s mod 2;;
gap> tmod2:= t mod 2;;
gap> admissible:= [];;  modmap:= "dummy";;
gap> for map in filt do
>      modmap:= CompositionMaps( InverseMap( GetFusionMap( tmod2, t ) ),
>                   CompositionMaps( map, GetFusionMap( smod2, s ) ) );
>      if not fail in Decomposition( Irr( smod2 ),
>            List( Irr( tmod2 ), chi -> chi{ modmap } ), "nonnegative" ) then
>        AddSet( admissible, map );
>      fi;
>    od;
gap> admissible;
[ [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]
]]></Example>

<P/>

The test of all available Brauer tables is implemented in the function
<C>CTblLib.Test.Decompositions</C> of the &GAP; Character Table Library
(<Cite Key="CTblLib"/>).

<P/>

<Example><![CDATA[
gap> CTblLib.Test.Decompositions( s, fus, t ) = admissible;
true
]]></Example>

<P/>

We see that <M>p</M>-modular tables alone determine the class fusion uniquely;
in fact the primes <M>2</M> and <M>3</M> suffice for that.
<P/>
<Example><![CDATA[
gap> GetFusionMap( s, t ) in admissible;
true
]]></Example>

<P/>

<E>Remark:</E>

<P/>

In May&nbsp;2015,
the <M>19</M>-modular character table of <M>J_3</M> has been corrected,
by swapping the two classes of element order <M>17</M>.
Since the class fusion of <M>L_2(16).4</M> into <M>J_3.2</M>
is uniquely determined by the <M>2</M>-modular tables of <M>L_2(16).4</M>
and <M>J_3.2</M> and since this class fusion has been compatible with the
previous version of the <M>19</M>-modular table of <M>J_3</M>,
the correction does not affect the above arguments.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(17)_in_S8(2)">
<Heading><M>L_2(17) \rightarrow S_8(2)</M> (July 2004)</Heading>

The class fusion of the maximal subgroup <M>M \cong L_2(17)</M>
of <M>G = S_8(2)</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "L2(17)" );;
gap> t:= CharacterTable( "S8(2)" );;
gap> mfust:= PossibleClassFusions( m, t );;
gap> Length( RepresentativesFusions( m, mfust, t ) );
4
]]></Example>

<P/>

The Brauer tables for <M>M</M> and <M>G</M> determine the class fusion up to
table automorphisms.

<P/>

<Example><![CDATA[
gap> filt:= CTblLib.Test.Decompositions( m, mfust, t );;
gap> repr:= RepresentativesFusions( m, filt, t );;
gap> Length( repr );
1
gap> GetFusionMap( m, t ) in repr;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:generality">
<Heading><M>L_2(19) \rightarrow J_3</M> (April 2003)</Heading>

It can happen that Brauer tables impose conditions such that ambiguities
arise which are not visible if one considers only ordinary tables.

<P/>

The class fusion between the ordinary character tables of <M>L_2(19)</M>
and <M>J_3</M> is unique up to table automorphisms.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "L2(19)" );;
gap> t:= CharacterTable( "J3" );;
gap> sfust:= PossibleClassFusions( s, t );
[ [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 21, 20 ], 
  [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 21, 20 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 21, 20 ], 
  [ 1, 2, 4, 7, 6, 10, 11, 12, 14, 13, 20, 21 ], 
  [ 1, 2, 4, 7, 6, 10, 11, 12, 14, 13, 21, 20 ], 
  [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 20, 21 ], 
  [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 21, 20 ], 
  [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 20, 21 ], 
  [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 21, 20 ] ]
gap> fusreps:= RepresentativesFusions( s, sfust, t );
[ [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 20, 21 ] ]
]]></Example>

<P/>

The Galois automorphism that permutes the three classes of element order <M>9</M>
in the tables of (<M>L_2(19)</M> and) <M>J_3</M> does not live in characteristic <M>19</M>.
For example, the unique irreducible Brauer character of degree <M>110</M>
in the <M>19</M>-modular table of <M>J_3</M> is <M>\varphi_3</M>,
and the value of this character on the class <C>9A</C> is <C>-1+2y9+&amp;4</C>.

<P/>

<Example><![CDATA[
gap> tmod19:= t mod 19;
BrauerTable( "J3", 19 )
gap> deg110:= Filtered( Irr( tmod19 ), phi -> phi[1] = 110 );
[ Character( BrauerTable( "J3", 19 ),
  [ 110, -2, 5, 2, 2, 0, 0, 1, 0, 
      -2*E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6-2*E(9)^7, 
      E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6+E(9)^7, 
      E(9)^2+E(9)^3+2*E(9)^4+2*E(9)^5+E(9)^6+E(9)^7, -2, -2, -1, 0, 
      0, E(17)^3+E(17)^5+E(17)^6+E(17)^7+E(17)^10+E(17)^11+E(17)^12
         +E(17)^14, 
      E(17)+E(17)^2+E(17)^4+E(17)^8+E(17)^9+E(17)^13+E(17)^15+E(17)^16
     ] ) ]
gap> 9A:= Position( OrdersClassRepresentatives( tmod19 ), 9 );
10
gap> deg110[1][ 9A ];
-2*E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6-2*E(9)^7
gap> AtlasIrrationality( "-1+2y9+&4" ) = deg110[1][ 9A ];
true
]]></Example>

<P/>

It turns out that four of the twelve possible class fusions are not compatible
with the <M>19</M>-modular tables.

<P/>

<Example><![CDATA[
gap> smod19:= s mod 19;
BrauerTable( "L2(19)", 19 )
gap> compatible:= [];;
gap> for map in sfust do
>      comp:= CompositionMaps( InverseMap( GetFusionMap( tmod19, t ) ),
>      CompositionMaps( map, GetFusionMap( smod19, s ) ) );
>      rest:= List( Irr( tmod19 ), phi -> phi{ comp } );
>      if not fail in Decomposition( Irr( smod19 ), rest, "nonnegative" ) then
>        Add( compatible, map );
>      fi;
>    od;
gap> compatible;
[ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 21, 20 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 21, 20 ], 
  [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 20, 21 ], 
  [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 21, 20 ], 
  [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 20, 21 ], 
  [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 21, 20 ] ]
]]></Example>

<P/>

Moreover, the subgroups of those table automorphisms of the ordinary tables
that leave the set of compatible fusions invariant make two orbits on this
set.
Indeed, the two orbits belong to essentially different decompositions of the
restriction of <M>\varphi_3</M>.

<P/>

<Example><![CDATA[
gap> reps:= RepresentativesFusions( s, compatible, t );
[ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ] ]
gap> compatiblemod19:= List( reps, map -> CompositionMaps(
>        InverseMap( GetFusionMap( tmod19, t ) ),
>        CompositionMaps( map, GetFusionMap( smod19, s ) ) ) );
[ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14 ], 
  [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14 ] ]
gap> rest:= List( compatiblemod19, map -> Irr( tmod19 )[3]{ map } );;
gap> dec:= Decomposition( Irr( smod19 ), rest, "nonnegative" );
[ [ 0, 0, 1, 2, 1, 2, 2, 1, 0, 1 ], [ 0, 2, 0, 2, 0, 1, 2, 0, 2, 1 ] ]
gap> List( Irr( smod19 ), phi -> phi[1] );
[ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 ]
]]></Example>

<P/>

In order to decide which class fusion is correct,
we take the matrix representation of <M>J_3</M> that affords <M>\varphi_3</M>,
restrict it to <M>L_2(19)</M>, which is the second maximal subgroup of <M>J_3</M>,
and compute the composition factors.
For that, we use a representation from the &ATLAS; of Group
Representations&nbsp;<Cite Key="AGRv3"/>, and access it via the &GAP; package
<Package>AtlasRep</Package> (<Cite Key="AtlasRep"/>).

<P/>

<Example><![CDATA[
gap> LoadPackage( "atlasrep", false );
true
gap> prog:= AtlasProgram( "J3", "maxes", 2 );
rec( groupname := "J3", identifier := [ "J3", "J3G1-max2W1", 1 ], 
  program := <straight line program>, size := 3420, 
  standardization := 1, subgroupname := "L2(19)", version := "1" )
gap> gens:= OneAtlasGeneratingSetInfo( "J3", Characteristic, 19,
>               Dimension, 110 );;
gap> gens:= AtlasGenerators( gens );
rec( charactername := "110a", constituents := [ 3 ], 
  contents := "core", dim := 110, 
  generators := [ < immutable compressed matrix 110x110 over GF(19) >,
      < immutable compressed matrix 110x110 over GF(19) > ], 
  groupname := "J3", id := "", 
  identifier := [ "J3", [ "J3G1-f19r110B0.m1", "J3G1-f19r110B0.m2" ], 
      1, 19 ], repname := "J3G1-f19r110B0", repnr := 35, 
  ring := GF(19), size := 50232960, standardization := 1, 
  type := "matff" )
gap> restgens:= ResultOfStraightLineProgram( prog.program, gens.generators );
[ < immutable compressed matrix 110x110 over GF(19) >, 
  < immutable compressed matrix 110x110 over GF(19) > ]
gap> module:= GModuleByMats( restgens, GF( 19 ) );;
gap> facts:= SMTX.CollectedFactors( module );;
gap> Length( facts );
7
gap> List( facts, x -> x[1].dimension );
[ 5, 7, 9, 11, 13, 15, 19 ]
gap> List( facts, x -> x[2] );
[ 1, 2, 1, 2, 2, 1, 1 ]
]]></Example>

<P/>

This means that there are seven pairwise nonisomorphic composition factors,
the smallest one of dimension five.
In other words, the first of the two maps is the correct one.
Let us check whether this map equals the one that is stored on the library
table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) = reps[1];
true
]]></Example>

<P/>

<E>Remark:</E>

<P/>

In May&nbsp;2015, the <M>19</M>-modular character table of <M>J_3</M>
has been corrected, by swapping the two classes of element order <M>17</M>.
This affects the above computations only in one place,
where the values of the character <C>deg110</C> are shown.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Fusions Determined by Information about the Groups">
<Heading>Fusions Determined by Information about the Groups</Heading>

In the examples in this section, character theoretic arguments do not suffice
for determining the class fusions.
So we use computations with the groups in question or information about
these groups beyond the character table,
and perhaps additionally character theoretic arguments.

<P/>

The group representations are taken from the &ATLAS; of Group
Representations&nbsp;<Cite Key="AGRv3"/> and are accessed via the &GAP; package
<Package>AtlasRep</Package> (<Cite Key="AtlasRep"/>).

<P/>

<Example><![CDATA[
gap> LoadPackage( "atlasrep", false );
true
]]></Example>


<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- OPEN!!!
<Subsection Label="subsect:2xL2(31)_in_2.B">
<Heading><M>2 \times L_2(31) \rightarrow 2.B</M></Heading>

First we determine the fusions between the factor groups modulo the centre.

<Example><![CDATA[
gap> l:= CharacterTable( "L2(31)" );
CharacterTable( "L2(31)" )
gap> s:= CharacterTable( "31:15" );
CharacterTable( "31:15" )
gap> sfusl:= PossibleClassFusions( s, l );;
#I  RepresentativesFusions: 1 orbit(s) of length(s) [ 8 ]
#I  PossibleClassFusions: 8 solutions
gap> lfusb:= PossibleClassFusions( l, b );;
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 2, 2 ] 
#I  PossibleClassFusions: 4 solutions
gap> filt:= Filtered( lfusb, x -> ForAny( sfusl, map ->
> # comp is s -> b as determined by factorization through Th!
> CompositionMaps( x, map ) in comp ) );
[ [ 1, 5, 7, 15, 19, 19, 44, 44, 82, 82, 82, 82, 90, 90, 90, 90, 145, 146 ], 
  [ 1, 5, 7, 15, 19, 19, 44, 44, 82, 82, 82, 82, 90, 90, 90, 90, 146, 145 ] ]
gap> RepresentativesFusions( l, filt, b );
#I  RepresentativesFusions: 1 orbit(s) of length(s) [ 2 ]
[ [ 1, 5, 7, 15, 19, 19, 44, 44, 82, 82, 82, 82, 90, 90, 90, 90, 145, 146 ] ]
]]></Example>

Now we compute the fusions between the groups themselves.

Note that since ... it is clear that <M>L_2(31)</M> does not lift to the
proper covering group <M>2.L_2(31)</M>.
(Alternatively, show that no fusion is possible.)

<Example><![CDATA[
gap> 2l:= CharacterTable( "2.L2(31)" );
CharacterTable( "2.L2(31)" )
gap> PossibleClassFusions( 2l, 2b );
[  ]
gap> dp:= c2 * l;
CharacterTable( "C2xL2(31)" )
gap> 2lfus2b:= PossibleClassFusions( dp, 2b );;
#I  RepresentativesFusions: 6 orbit(s) of length(s) [ 2, 2, 2, 2, 2, 2 ]
#I  PossibleClassFusions: 12 solutions
gap> filt:= Filtered( 2lfus2b, x -> CompositionMaps( GetFusionMap( 2b, b ), x ) =
> CompositionMaps( [1,5,7,15,19,19,44,44,82,82,82,82,90,90,90,90,145,146],
> GetFusionMap( dp, l ) ) );
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
#I  GetFusionMap: Used fusion has specification 2
[ [ 1, 7, 10, 20, 25, 25, 56, 56, 107, 107, 107, 107, 116, 116, 116, 116, 
      190, 192, 2, 7, 11, 20, 26, 26, 56, 56, 108, 108, 108, 108, 117, 117, 
      117, 117, 191, 193 ], 
  [ 1, 7, 10, 20, 25, 25, 56, 56, 107, 107, 107, 107, 117, 117, 117, 117, 
      190, 192, 2, 7, 11, 20, 26, 26, 56, 56, 108, 108, 108, 108, 116, 116, 
      116, 116, 191, 193 ] ]
gap> RepresentativesFusions( dp, filt, 2b );
#I  RepresentativesFusions: Not all table automorphisms of the
#I    subgroup table act; computing the admiss. subgroup.
#I  RepresentativesFusions: Not all table automorphisms of the
#I    supergroup table act; computing the admiss. subgroup.
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 1, 1 ]
[ [ 1, 7, 10, 20, 25, 25, 56, 56, 107, 107, 107, 107, 116, 116, 116, 116, 
      190, 192, 2, 7, 11, 20, 26, 26, 56, 56, 108, 108, 108, 108, 117, 117, 
      117, 117, 191, 193 ], 
  [ 1, 7, 10, 20, 25, 25, 56, 56, 107, 107, 107, 107, 117, 117, 117, 117, 
      190, 192, 2, 7, 11, 20, 26, 26, 56, 56, 108, 108, 108, 108, 116, 116, 
      116, 116, 191, 193 ] ]
gap> List( filt, x -> ConsiderStructureConstants( dp, 2b, x ) );
[ true, true ]
]]></Example>

So we still have a problem!!

Is 116 or 117 inside L2(31) ?
(order 16, cont. in 2xD32)
 -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:U3(3).2_in_Fi24'">
<Heading><M>U_3(3).2 \rightarrow Fi_{24}^{\prime}</M> (November 2002)</Heading>
<P/>
The group <M>G = Fi_{24}^{\prime}</M> contains a maximal subgroup <M>H</M>
of type <M>U_3(3).2</M>.
From the character tables of <M>G</M> and <M>H</M>, one gets a lot of
essentially different possibilities (and additionally this takes quite some
time).
We use the description of <M>H</M> as the normalizer in <M>G</M> of a
<M>U_3(3)</M> type subgroup containing elements in the classes
<C>2B</C>, <C>3D</C>, <C>3E</C>, <C>4C</C>, <C>4C</C>,
<C>6J</C>, <C>7B</C>, <C>8C</C>, and <C>12M</C> (see&nbsp;<Cite Key="BN95"/>).

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "F3+" );
CharacterTable( "F3+" )
gap> s:= CharacterTable( "U3(3).2" );
CharacterTable( "U3(3).2" )
gap> tnames:= ClassNames( t, "ATLAS" );
[ "1A", "2A", "2B", "3A", "3B", "3C", "3D", "3E", "4A", "4B", "4C", 
  "5A", "6A", "6B", "6C", "6D", "6E", "6F", "6G", "6H", "6I", "6J", 
  "6K", "7A", "7B", "8A", "8B", "8C", "9A", "9B", "9C", "9D", "9E", 
  "9F", "10A", "10B", "11A", "12A", "12B", "12C", "12D", "12E", 
  "12F", "12G", "12H", "12I", "12J", "12K", "12L", "12M", "13A", 
  "14A", "14B", "15A", "15B", "15C", "16A", "17A", "18A", "18B", 
  "18C", "18D", "18E", "18F", "18G", "18H", "20A", "20B", "21A", 
  "21B", "21C", "21D", "22A", "23A", "23B", "24A", "24B", "24C", 
  "24D", "24E", "24F", "24G", "26A", "27A", "27B", "27C", "28A", 
  "29A", "29B", "30A", "30B", "33A", "33B", "35A", "36A", "36B", 
  "36C", "36D", "39A", "39B", "39C", "39D", "42A", "42B", "42C", 
  "45A", "45B", "60A" ]
gap> OrdersClassRepresentatives( s );
[ 1, 2, 3, 3, 4, 4, 6, 7, 8, 12, 2, 4, 6, 8, 12, 12 ]
gap> sfust:= List( [ "1A", "2B", "3D", "3E", "4C", "4C", "6J", "7B", "8C",
>                    "12M" ], x -> Position( tnames, x ) );
[ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50 ]
gap> sfust:= PossibleClassFusions( s, t, rec( fusionmap:= sfust ) );
[ [ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50, 3, 9, 23, 28, 43, 43 ], 
  [ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50, 3, 11, 23, 28, 50, 50 ] ]
gap> OrdersClassRepresentatives( s );
[ 1, 2, 3, 3, 4, 4, 6, 7, 8, 12, 2, 4, 6, 8, 12, 12 ]
]]></Example>

<P/>

So we still have two possibilities, which differ on the outer classes of
element order <M>4</M> and <M>12</M>.

<P/>

Our idea is to take a subgroup <M>U</M> of <M>H</M> that contains such elements,
and to compute the possible class fusions of <M>U</M> into <M>G</M>, via the
factorization through a suitable maximal subgroup <M>M</M> of <M>G</M>.

<P/>

We take <M>U = N_H(\langle g \rangle)</M> where <M>g</M> is an element in the first
class of order three elements of <M>H</M>;
this is a maximal subgroup of <M>H</M>, of order <M>216</M>.

<P/>

<Example><![CDATA[
gap> Maxes( s );
[ "U3(3)", "3^(1+2):SD16", "L3(2).2", "2^(1+4).S3", "4^2:D12" ]
gap> SizesCentralizers( s );
[ 12096, 192, 216, 18, 96, 32, 24, 7, 8, 12, 48, 48, 6, 8, 12, 12 ]
gap> u:= CharacterTable( Maxes( s )[2] );;
gap> ufuss:= GetFusionMap( u, s );
[ 1, 2, 11, 3, 4, 5, 12, 7, 13, 9, 9, 15, 16, 10 ]
]]></Example>

<P/>

Candidates for <M>M</M> are those subgroups of <M>G</M> that contain elements
in the class <C>3D</C> of <M>G</M> whose centralizer is the full <C>3D</C> centralizer
in <M>G</M>.

<P/>

<Example><![CDATA[
gap> 3Dcentralizer:= SizesCentralizers( t )[7];
153055008
gap> cand:= [];;                                                               
gap> for name in Maxes( t ) do
>      m:= CharacterTable( name );
>      mfust:= GetFusionMap( m, t );        
>      if ForAny( [ 1 .. Length( mfust ) ],                    
>          i -> mfust[i] = 7 and SizesCentralizers( m )[i] = 3Dcentralizer )   
>      then
>        Add( cand, m );
>      fi;
>    od;
gap> cand;
[ CharacterTable( "3^7.O7(3)" ), 
  CharacterTable( "3^2.3^4.3^8.(A5x2A4).2" ) ]
]]></Example>

<P/>

For these two groups <M>M</M>,
we show that the possible class fusions from <M>U</M>
to <M>G</M> via <M>M</M> factorize through <M>H</M>
only if the second possible class fusion from <M>H</M> to <M>G</M> is chosen.

<P/>

<Example><![CDATA[
gap> possufust:= List( sfust, x -> CompositionMaps( x, ufuss ) );
[ [ 1, 3, 3, 7, 8, 11, 9, 22, 23, 28, 28, 43, 43, 50 ], 
  [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]
gap> m:= cand[1];;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> Length( ufusm );
242
gap> comp:= List( ufusm, x -> CompositionMaps( GetFusionMap( m, t ), x ) );;
gap> Intersection( possufust, comp );
[ [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]
gap> m:= cand[2];;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> Length( ufusm );                        
256
gap> comp:= List( ufusm, x -> CompositionMaps( GetFusionMap( m, t ), x ) );;   
gap> Intersection( possufust, comp );
[ [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]
]]></Example>

<P/>

Finally, we check that the correct fusion is stored in the &GAP; Character
Table Library.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) = sfust[2];
true
]]></Example>

<!-- % challenge: -->
<!-- % How much of the information about the classes of <M>U_3(3)</M> is really needed? -->
<!-- % For example, (just) twelve possibilities satisfy the factorization of -->
<!-- % fusions from the <M>L_2(7).2</M> subgroups. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(13).2_in_Fi24'">
<Heading><M>L_2(13).2 \rightarrow Fi_{24}^{\prime}</M> (September 2002)</Heading>

The class fusion of maximal subgroups <M>U</M> of type <M>L_2(13).2</M>
in <M>G = Fi_{24}^{\prime}</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "F3+" );;
gap> u:= CharacterTable( "L2(13).2" );;
gap> fus:= PossibleClassFusions( u, t );;
gap> repr:= RepresentativesFusions( u, fus, t );;
gap> Length( repr );
3
]]></Example>

<P/>

In&nbsp;<Cite Key="LW91" Where="p. 155"/>,
it is stated that <M>U^{\prime}</M> contains elements
in the classes <C>2B</C>, <C>3D</C>, and <C>7B</C> of <M>G</M>.
(Note that the two conjugacy classes of groups isomorphic to <M>U</M> have
the same class fusion because the outer automorphism of <M>G</M> fixes
the relevant classes.)

<P/>

<Example><![CDATA[
gap> filt:= Filtered( repr, x -> t.2b in x and t.3d in x and t.7b in x );
[ [ 1, 3, 7, 22, 25, 25, 25, 51, 3, 9, 43, 43, 53, 53, 53 ], 
  [ 1, 3, 7, 22, 25, 25, 25, 51, 3, 11, 50, 50, 53, 53, 53 ] ]
gap> ClassNames( t ){ [ 43, 50 ] };
[ "12f", "12m" ]
]]></Example>

<P/>

So we have to decide whether <M>U</M> contains elements in the class <C>12F</C> or
in <C>12M</C> of <M>G</M>.

<P/>

The order <M>12</M> elements in question lie inside subgroups of type <M>13 : 12</M>
in <M>U</M>.
These subgroups are clearly contained in the Sylow <M>13</M> normalizers of <M>G</M>,
which are contained in maximal subgroups of type <M>(3^2:2 \times G_2(3)).2</M>
in <M>G</M>;
the class fusion of the latter groups is unique up to table automorphisms.
<P/>
<Example><![CDATA[
gap> pos:= Position( OrdersClassRepresentatives( t ), 13 );
51
gap> SizesCentralizers( t )[ pos ];
234
gap> ClassOrbit( t, pos );
[ 51 ]
gap> cand:= [];;                                                         
gap> for name in Maxes( t ) do
>      m:= CharacterTable( name );
>      pos:= Position( OrdersClassRepresentatives( m ), 13 );
>      if pos <> fail and                                             
>         SizesCentralizers( m )[ pos ] = 234                         
>         and ClassOrbit( m, pos ) = [ pos ] then
>        Add( cand, m );
>      fi;
>    od;
gap> cand;
[ CharacterTable( "(3^2:2xG2(3)).2" ) ]
gap> s:= cand[1];;
gap> sfust:= PossibleClassFusions( s, t );;
]]></Example>

<P/>

As no <M>13:12</M> type subgroup is contained in the derived subgroup of
<M>(3^2:2 \times G_2(3)).2</M>, we look at the elements of order <M>12</M> in the
outer half.

<P/>

<Example><![CDATA[
gap> der:= ClassPositionsOfDerivedSubgroup( s );;
gap> outer:= Difference( [ 1 .. NrConjugacyClasses( s ) ], der );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> imgs:= Set( Flat( List( sfust, x -> x{ outer } ) ) );
[ 2, 3, 10, 11, 15, 17, 18, 19, 21, 22, 26, 44, 45, 49, 50, 52, 62, 
  83, 87, 98 ]
gap> t.12f in imgs;
false
gap> t.12m in imgs;
true
]]></Example>

<P/>

So <M>L_2(13).2 \setminus L_2(13)</M> does not contain <C>12F</C> elements of <M>G</M>,
i.&nbsp;e., we have determined the class fusion of <M>U</M> in <M>G</M>.
<P/>
Finally, we check whether the correct fusion is stored in the
&GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> GetFusionMap( u, t ) = filt[2];
true
]]></Example>

</Subsection>


<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- OPEN!!!
<Subsection Label="subsect:2.HS.2_in_HN">
<Heading><M>2.HS.2 \rightarrow HN</M></Heading>


<Example><![CDATA[
- 2.HS.2 -> HN (2 possibilities)

note that HNN2A = 2.HS.2

rep:=
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 8, 8 ]
[ [ 1, 2, 2, 3, 7, 4, 14, 6, 6, 7, 10, 21, 9, 22, 13, 26, 30, 14, 15, 17, 33,
      19, 18, 21, 23, 41, 29, 45, 31, 34, 48, 39, 40, 2, 3, 6, 7, 18, 14, 14,
      15, 19, 19, 22, 27, 28, 30, 33, 33, 53, 54, 39, 39, 40, 40, 48, 48 ],
  [ 1, 2, 2, 3, 7, 4, 14, 6, 6, 7, 10, 21, 9, 22, 13, 26, 30, 14, 15, 17, 33,
      19, 18, 21, 23, 41, 29, 45, 31, 34, 48, 39, 40, 2, 3, 6, 7, 18, 14, 14,
      15, 19, 19, 22, 27, 28, 30, 33, 33, 53, 54, 40, 40, 39, 39, 48, 48 ] ]
gap> Parametrized( rep ); 
[ 1, 2, 2, 3, 7, 4, 14, 6, 6, 7, 10, 21, 9, 22, 13, 26, 30, 14, 15, 17, 33,
  19, 18, 21, 23, 41, 29, 45, 31, 34, 48, 39, 40, 2, 3, 6, 7, 18, 14, 14, 15,
  19, 19, 22, 27, 28, 30, 33, 33, 53, 54, [ 39, 40 ], [ 39, 40 ], [ 39, 40 ],
  [ 39, 40 ], 48, 48 ]
gap> ClassNames( hn ){[39,40]};
[ "20a", "20b" ]
(irrational values, and s.c. do not help!)

problem is: more than one pair of 20a/b classes!

(distinguished only by $\chi_{41,42}^{\pm}$

gap> t:= CharacterTable( "HN" );
CharacterTable( "HN" )
gap> s:= CharacterTable( "2.HS.2" );
CharacterTable( "2.HS.2" )

try the Sylow 5 normalizer in 2.HS.2:

gap> u:= CharacterTable( "2.HS.2N5" );
CharacterTable( "2.HS.2N5" )
gap> s;
CharacterTable( "2.HS.2" )
gap> GetFusionMap( u, s );
[ 1, 2, 11, 12, 13, 14, 15, 16, 4, 3, 25, 24, 10, 10, 23, 23, 23, 23, 8, 33, 
  32, 5, 5, 26, 26, 35, 45, 46, 38, 50, 51, 38, 51, 50, 52, 53, 36, 54, 55, 
  38, 38 ]
gap> SizesConjugacyClasses( u );
[ 1, 1, 4, 4, 40, 40, 80, 80, 25, 25, 100, 100, 250, 250, 500, 500, 500, 500, 
  100, 200, 200, 50, 50, 200, 200, 200, 400, 400, 100, 200, 200, 100, 200, 
  200, 200, 200, 200, 200, 200, 500, 500 ]
gap> OrdersClassRepresentatives( u );
[ 1, 2, 5, 10, 5, 10, 5, 10, 2, 2, 10, 10, 4, 4, 8, 8, 8, 8, 4, 20, 20, 4, 4, 
  20, 20, 2, 10, 10, 8, 40, 40, 8, 40, 40, 20, 20, 4, 20, 20, 8, 8 ]
gap> sfust:= GetFusionMap( s, t );
[ 1, 2, 2, 3, 7, 4, 14, 6, 6, 7, 10, 21, 9, 22, 13, 26, 30, 14, 15, 17, 33, 
  19, 18, 21, 23, 41, 29, 45, 31, 34, 48, 39, 40, 2, 3, 6, 7, 18, 14, 14, 15, 
  19, 19, 22, 27, 28, 30, 33, 33, 53, 54, 40, 40, 39, 39, 48, 48 ]
gap> sfust[11];
10
gap> ClassNames( t )[ sfust[11] ];
"5b"

so it is contained in the 5B normalizer in HN (HNN5B = HNM6, order 2*10^6)

gap> n:= CharacterTable( "HNM6" );
CharacterTable( "5^(1+4):2^(1+4).5.4" )
gap> GetFusionMap( n, t );
[ 1, 10, 9, 13, 11, 12, 10, 3, 23, 2, 6, 21, 22, 26, 39, 40, 10, 11, 12, 13, 
  13, 47, 46, 23, 24, 25, 27, 28, 3, 7, 7, 19, 27, 28, 24, 25, 23, 41, 41, 8, 
  8, 18, 18, 18, 18, 42, 43, 42, 43, 53, 53, 54, 54 ]
gap> ufusn:= PossibleClassFusions( u, n );;
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 32, 32 ]


so the same problem occurs already in these subgroups!
(NB: 2.HS.2N5 = HNN10A, order 8000)
[hence this problem can be solved if the original problem is solved;
add the corresponding fusion then!]

permutation character of degree 5775 for HS.2:
the preimage of the 2A normalizer in HS.2 contains 20AB and 20D, 20E elements

construct the group:

gap> g;  # from atlasrep!
<permutation group of size 177408000 with 2 generators>
gap> syl2:= SylowSubgroup( g, 2 );
<permutation group with 10 generators>
gap> repeat x:= Random( syl2 ); until Order( x ) = 4;
gap> c:= Centralizer( g, x );; Size( c );
512
gap> repeat x:= Random( syl2 ); until Order( x ) = 4;
gap> c:= Centralizer( g, x );; Size( c );
7680
gap> n:= Normalizer( g, Subgroup( g, [ x ] ) );;
Size( n );
gap> Size( n );
15360
gap> nn:= Normalizer( g, n );
Size( nn );
<permutation group with 7 generators>
gap> Size( nn );
30720
gap> n:= nn;;
gap> nt:= CharacterTable( n );;
gap> Irr( nt );;
gap> ntfuss:= PossibleClassFusions( nt, s );;
#I  RepresentativesFusions: 1 orbit(s) of length(s) [ 32 ]
#I  PossibleClassFusions: 32 solutions
gap> ntfust:= PossibleClassFusions( nt, t );;
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 8, 8 ]
#I  PossibleClassFusions: 16 solutions
gap> rep:= RepresentativesFusions( nt, ntfust, t );
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 8, 8 ]
[ [ 1, 3, 6, 2, 6, 3, 6, 3, 2, 2, 2, 7, 7, 19, 6, 6, 6, 6, 19, 19, 7, 3, 7, 
      6, 7, 2, 3, 6, 7, 7, 2, 3, 19, 19, 18, 18, 19, 19, 15, 14, 15, 15, 4, 
      31, 14, 14, 39, 40, 40, 39, 39, 10, 23, 21, 21, 40, 30, 14, 15, 30, 15, 
      14 ], [ 1, 3, 6, 2, 6, 3, 6, 3, 2, 2, 2, 7, 7, 19, 6, 6, 6, 6, 19, 19, 
      7, 3, 7, 6, 7, 2, 3, 6, 7, 7, 2, 3, 19, 19, 18, 18, 19, 19, 15, 14, 15, 
      15, 4, 31, 14, 14, 39, 40, 40, 39, 40, 10, 23, 21, 21, 39, 30, 14, 15, 
      30, 15, 14 ] ]
gap> Parametrized( rep );
[ 1, 3, 6, 2, 6, 3, 6, 3, 2, 2, 2, 7, 7, 19, 6, 6, 6, 6, 19, 19, 7, 3, 7, 6, 
  7, 2, 3, 6, 7, 7, 2, 3, 19, 19, 18, 18, 19, 19, 15, 14, 15, 15, 4, 31, 14, 
  14, 39, 40, 40, 39, [ 39, 40 ], 10, 23, 21, 21, [ 39, 40 ], 30, 14, 15, 30, 
  15, 14 ]
gap> SizesConjugacyClasses( nt );
[ 1, 1, 4, 30, 60, 30, 48, 40, 40, 1, 1, 240, 240, 960, 120, 120, 120, 120, 
  480, 480, 480, 480, 480, 480, 160, 80, 80, 480, 480, 160, 80, 80, 960, 960, 
  1920, 1920, 960, 960, 640, 1280, 640, 320, 320, 1280, 320, 320, 768, 768, 
  768, 768, 768, 384, 384, 384, 384, 768, 1280, 640, 640, 1280, 640, 640 ]


so nt lies in the 2B centralizer!

gap> v:= CharacterTable( "HNM4" ); 
CharacterTable( "2^(1+8).(A5xA5).2" )
gap> ntfusv:= PossibleClassFusions( nt, v );;
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 16, 16 ]
#I  PossibleClassFusions: 32 solutions
gap> rep:= RepresentativesFusions( nt, ntfusv, v );
#I  RepresentativesFusions: 2 orbit(s) of length(s) [ 16, 16 ]
[ [ 1, 2, 5, 3, 5, 4, 5, 4, 3, 3, 3, 17, 17, 18, 15, 15, 15, 15, 18, 18, 17, 
      14, 44, 43, 44, 41, 42, 43, 44, 44, 41, 42, 46, 46, 47, 47, 46, 46, 25, 
      24, 26, 23, 22, 27, 24, 24, 37, 38, 38, 37, 37, 34, 35, 36, 36, 38, 50, 
      49, 48, 50, 48, 49 ], 
  [ 1, 2, 5, 3, 5, 4, 5, 4, 3, 3, 3, 17, 17, 18, 15, 15, 15, 15, 18, 18, 17, 
      14, 44, 43, 44, 41, 42, 43, 44, 44, 41, 42, 46, 46, 47, 47, 46, 46, 25, 
      24, 26, 23, 22, 27, 24, 24, 37, 38, 38, 37, 38, 34, 35, 36, 36, 37, 50, 
      49, 48, 50, 48, 49 ] ]
gap> Parametrized( rep );
[ 1, 2, 5, 3, 5, 4, 5, 4, 3, 3, 3, 17, 17, 18, 15, 15, 15, 15, 18, 18, 17, 
  14, 44, 43, 44, 41, 42, 43, 44, 44, 41, 42, 46, 46, 47, 47, 46, 46, 25, 24, 
  26, 23, 22, 27, 24, 24, 37, 38, 38, 37, [ 37, 38 ], 34, 35, 36, 36, 
  [ 37, 38 ], 50, 49, 48, 50, 48, 49 ]

so we have the same problem again!!
[NB: the subgroup is HNN4A!]

systematically:
which maxes of 2.HS.2 can contain elements in both 20AB and 20DE?
(for that, first those maxes of HS that contain elements in 20AB!)

gap> hs;
CharacterTable( "HS" )
gap> maxes:= List( Maxes( hs ), CharacterTable );
[ CharacterTable( "M22" ), CharacterTable( "U3(5).2" ), 
  CharacterTable( "HSM3" ), CharacterTable( "L3(4).2_1" ), 
  CharacterTable( "A8.2" ), CharacterTable( "2^4.s6" ), 
  CharacterTable( "4^3:psl(3,2)" ), CharacterTable( "M11" ), 
  CharacterTable( "HSM9" ), CharacterTable( "4.2^4.S5" ), 
  CharacterTable( "2xa6.2^2" ), CharacterTable( "5:4xa5" ) ]
gap> perms:= List( maxes, x -> TrivialCharacter( x )^hs );;
gap> List( perms, x -> x[23] );
[ 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 2 ]
gap> Filtered( perms, x -> x[23] <> 0 );
[ Character( CharacterTable( "HS" ), [ 176, 16, 12, 5, 16, 0, 4, 1, 6, 1, 3, 
      1, 1, 0, 2, 2, 1, 2, 0, 0, 1, 0, 1, 1 ] ), 
  Character( CharacterTable( "HS" ), [ 176, 16, 12, 5, 16, 0, 4, 1, 6, 1, 3, 
      1, 1, 0, 2, 2, 1, 2, 0, 0, 1, 0, 1, 1 ] ), 
  Character( CharacterTable( "HS" ), [ 5775, 111, 75, 15, 31, 15, 3, 25, 0, 
      0, 3, 3, 0, 3, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1 ] ), 
  Character( CharacterTable( "HS" ), [ 36960, 32, 216, 6, 32, 0, 8, 10, 25, 
      0, 0, 2, 0, 0, 0, 0, 2, 1, 0, 0, 2, 1, 2, 2 ] ) ]

The first two do not extend to HS.2, the novelty HS.2N5 has been considered
already.
The third extends to HS.2N2A, which was considered above.
The last one:
Trying the preimage of 5:4xS5 does not help: does not contain 20DE elements


what about subgroups of HN that may contain the interesting subgroups
of 2.HS.2:

gap> maxes:= List( Maxes( t ), CharacterTable );
[ CharacterTable( "A12" ), CharacterTable( "2.HS.2" ), 
  CharacterTable( "U3(8).3_1" ), CharacterTable( "2^(1+8).(A5xA5).2" ), 
  CharacterTable( "(D10xU3(5)).2" ), CharacterTable( "5^(1+4):2^(1+4).5.4" ), 
  CharacterTable( "2^6.U4(2)" ), CharacterTable( "(A6xA6).D8" ), 
  CharacterTable( "2^3.2^2.2^6.(3xL3(2))" ), CharacterTable( "5^2.5.5^2.4A5" )
    , CharacterTable( "M12.2" ), CharacterTable( "HNM12" ), 
  CharacterTable( "3^4:2(A4xA4).4" ), CharacterTable( "3^(1+4):4A5" ) ]
gap> Position( OrdersClassRepresentatives( t ), 20 );
39
gap> filt:= Filtered( maxes, x -> 39 in GetFusionMap( x, t ) );
[ CharacterTable( "2.HS.2" ), CharacterTable( "2^(1+8).(A5xA5).2" ), 
  CharacterTable( "(D10xU3(5)).2" ), CharacterTable( "5^(1+4):2^(1+4).5.4" ) ]
gap> fus:= GetFusionMap( filt[3], t );
[ 1, 2, 4, 7, 10, 9, 13, 14, 17, 18, 21, 9, 22, 34, 41, 9, 13, 11, 12, 48, 
  51, 52, 53, 54, 22, 7, 6, 30, 18, 41, 31, 39, 40, 2, 3, 14, 7, 21, 22, 26, 
  15, 33, 18, 23, 7, 6, 30, 18, 41, 31, 40, 39 ]
gap> PositionsProperty( fus, x -> x = 6 );
[ 27, 46 ]
gap> SizesCentralizers( filt[3] ){[27,46]};
[ 480, 480 ]
gap> u;
CharacterTable( "2.HS.2N5" )
gap> PossibleClassFusions( u, filt[3] );
#I  InitFusion: no images possible for class 4
#I  PossibleClassFusions: no initialisation possible
[  ]
gap> OrdersClassRepresentatives( filt[3] );
[ 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 10, 5, 10, 15, 20, 5, 5, 5, 5, 30, 35, 35, 
  40, 40, 10, 4, 4, 12, 8, 20, 12, 20, 20, 2, 2, 6, 4, 10, 10, 10, 6, 14, 8, 
  10, 4, 4, 12, 8, 20, 12, 20, 20 ]

?????


try to compute the intersection of 2.HS.2N5 with (D10xU3(5)).2,
which is the 10A normalizer inside the second group
(note that the first group is the full 10A normalizer in HN!),
which has index 2 in the first group

gap> syl5:= SylowSubgroup( g, 5 );
<permutation group of size 125 with 3 generators>
gap> ns:= Normalizer( g, syl5 );
<permutation group of size 8000 with 6 generators>
gap> dns:= DerivedSubgroup( ns );
<permutation group of size 1000 with 5 generators>
gap> Centre( ns );
<permutation group with 1 generators>
gap> Size( g ) / 4;
44352000
gap> Centre( g );
<permutation group of size 2 with 1 generators>
gap> IsSubset( ns, Centre( g ) );
true
gap> Centre( ns );
<permutation group with 1 generators>
gap> Size( Centre( ns ) );
2
gap> cl:= ClosureGroup( ns, Centre( ns ) );
<permutation group of size 8000 with 6 generators>
gap> cl:= ClosureGroup( dns, Centre( ns ) );
<permutation group of size 1000 with 5 generators>
gap> nathom:= NaturalHomomorphismByNormalSubgroup( ns, dns );;
gap> fact:= Image( nathom );
Group([ f1, f2, f3 ])
gap> AbelianInvariants( fact );
[ 2, 4 ]

so three possibilities!

gap> pc:= Image( IsomorphismPcGroup( ns ) );
Group([ f1, f2, f3, f4, f5, f6, f7, f8, f9 ])
gap> Size( pc );
8000
gap> ccl:= ConjugacyClasses( pc );;
gap> reps:= List( ccl, Representative );;
gap> filt:= Filtered( reps, x -> Order( x ) = 10 );;
gap> Length( filt );
7
gap> List( filt, x -> Size( Normalizer( pc, Subgroup( pc, [ x ] ) ) ) );
[ 320, 320, 400, 800, 8000, 40, 40 ]
gap> dns:= DerivedSubgroup( pc );
Group([ f2*f3*f4*f7*f8^3, f4*f5*f6, f6, f7, f8, f9 ])
gap> Size( dns );
1000
gap> c1:= ClosureGroup( dns, Pcgs( pc ){ [ 4, 5 ] } );
Group([ f2*f3*f4*f7*f8^3, f4*f5*f6, f5, f6, f7, f8, f9 ])
gap> Size( c1 );
2000
gap> c1:= ClosureGroup( dns, Pcgs( pc ){ [ 3, 4, 5 ] } );
Group([ f2*f3*f4*f7*f8^3, f3, f4*f5*f6, f5, f6, f7, f8, f9 ])
gap> Size( c1 );
4000
gap> c2:= ClosureGroup( dns, Pcgs( pc ){ [ 2, 4, 5 ] } );
Group([ f2*f3*f4*f7*f8^3, f3*f4*f5*f6*f9^4, f4*f5*f6, f5, f6, f7, f8, f9 ])
gap> Size( c1 );
4000
gap> Size( c2 );
4000
gap> c1 = c2;
true
gap> c2:= ClosureGroup( dns, Pcgs( pc ){ [ 1, 4, 5 ] } );
Group([ f1, f2*f3*f4*f7*f8^3, f4, f5, f6, f7, f8, f9 ])
gap> Size( c2 );
4000
gap> c1 = c2;
false
gap> c3:= ClosureGroup( dns, Pcgs( pc ){ [ 4, 5 ] } );
Group([ f2*f3*f4*f7*f8^3, f4*f5*f6, f5, f6, f7, f8, f9 ])
gap> Size( c3 );
2000
gap> c3:= ClosureGroup( c3, Product( Pcgs( pc ){ [ 1, 2 ] } ) );
Group([ f1*f2, f2*f3*f4*f7*f8^3, f4, f5, f6, f7, f8, f9 ])
gap> Size( c3 );
4000
gap> c1 = c3;
false
gap> c2 = c3;
false
gap> tbls:= List( [ c1, c2, c3 ], CharacterTable );;
gap> List( tbls, Irr );;
gap> List( tbls, NrConjugacyClasses );
[ 34, 46, 46 ]
gap> filt:= Filtered( maxes, x -> 39 in GetFusionMap( x, t ) );
[ CharacterTable( "2.HS.2" ), CharacterTable( "2^(1+8).(A5xA5).2" ), 
  CharacterTable( "(D10xU3(5)).2" ), CharacterTable( "5^(1+4):2^(1+4).5.4" ) ]
gap> PossibleClassFusions( tbls[2], filt[3] );;
#I  PossibleClassFusions: fusion initialized
#I  TransferDiagram: inconsistency at class 23
#I  TestConsistencyMaps: inconsistency in powermap 2
#I  PossibleClassFusions: inconsistency of fusion and power maps
gap> PossibleClassFusions( tbls[3], filt[3] );;
#I  InitFusion: no images possible for class 18
#I  PossibleClassFusions: no initialisation possible
gap> myfus:= PossibleClassFusions( tbls[1], filt[3] );;
#I  RepresentativesFusions: 1 orbit(s) of length(s) [ 16 ]
#I  PossibleClassFusions: 16 solutions

so just one possibility!

gap> newfus:= PossibleClassFusions( tbls[1], u );;
#I  RepresentativesFusions: 1 orbit(s) of length(s) [ 16 ]
#I  PossibleClassFusions: 16 solutions
gap> Set( newfus, x -> CompositionMaps( GetFusionMap( u, s ), x ) );
[ [ 1, 11, 15, 13, 3, 24, 10, 10, 10, 10, 25, 4, 16, 14, 12, 2, 23, 23, 23, 
      23, 32, 8, 33, 26, 5, 26, 5, 8, 32, 33, 23, 23, 23, 23 ], 
  [ 1, 11, 15, 13, 3, 24, 10, 10, 10, 10, 25, 4, 16, 14, 12, 2, 23, 23, 23, 
      23, 33, 8, 32, 26, 5, 26, 5, 8, 33, 32, 23, 23, 23, 23 ] ]

Aha.
The intersection lies inside 2.HS, thus this does not help!!

Only idea now:
Explicitly compute HNN10A -> HNN5B from the group!


gap> g:= OneAtlasGeneratingSet( "HN", Dimension, 132 );
rec( generators := [ < immutable compressed matrix 132x132 over GF(4) >, 
      < immutable compressed matrix 132x132 over GF(4) > ], 
  standardization := 1, 
  identifier := [ "HN", [ "HNG1-f4r132aB0.m1", "HNG1-f4r132aB0.m2" ], 1, 4 ] )
gap> prg:= AtlasProgram( "HN", "maxes", 6 );
rec( program := <straight line program>, standardization := 1, 
  identifier := [ "HN", "HNG1-max6W1", 1 ] )
gap> s:= ResultOfStraightLineProgram( prg.program, g.generators );
[ < immutable compressed matrix 132x132 over GF(4) >, 
  < immutable compressed matrix 132x132 over GF(4) > ]
gap> s:= Group( s );
<matrix group with 2 generators>
gap> SetSize( s, 2*10^6 );
gap> iso:= IsomorphismPermGroup( s );;

.....
]]></Example>

-->

<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- OPEN!!!
<Subsection Label="subsect:D8xV4_in_HS">
<Heading><M>D_8 \times V_4 \rightarrow HS</M></Heading>

Let <M>G</M> denote the sporadic simple Higman-Sims group <M>HS</M>,
and choose a Sylow <M>2</M> subgroup <M>S</M> of <M>G</M>.

The subgroup <M>D_8 \times V_4</M> occurs as an intersection of the normalizer of
<M>S</M> in <M>G</M> with the normalizer of an element in the class <C>2B</C> of <M>G</M>.
(There is exactly one <M>G</M>-conjugacy class of such groups.)

<Example><![CDATA[
gap> g:= OneAtlasGeneratingSet( "HS", NrMovedPoints, 100 );;
gap> g:= Group( g.generators );;
gap> syl:= SylowSubgroup( g, 2 );;
gap> syln:= Normalizer( g, syl );;
gap> id:= IdGroup( DirectProduct( DihedralGroup( 8 ),
>                                 ElementaryAbelianGroup( 4 ) ) );
[ 32, 46 ]
gap> repeat
>      repeat
>        x:= Random( syl );
>      until Order( x ) = 2;
>      c:= Subgroup( g, [ x ] );
>      n:= Intersection( syln, Normalizer( g, c ) );
>    until IdGroup( n ) = id;
]]></Example>

The class fusion is determined uniquely by the natural character in the
faithful permutation representation of <M>G</M> of degree <M>100</M>.

<Example><![CDATA[
gap> hs:= CharacterTable( "HS" );;
gap> perms:= PermChars( hs, rec( torso:= [ 100 ] ) );
[ Character( CharacterTable( "HS" ), [ 100, 20, 0, 10, 0, 8, 4, 0, 0, 5, 0, 
      2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 ] ) ]
gap> nat:= ValuesOfClassFunction( perms[1] );;
gap> tbl:= CharacterTable( n );;
gap> libtbl:= CharacterTable( "D8xV4" );;
gap> trans:= TransformingPermutationsCharacterTables( libtbl, tbl );;
gap> pi:= List( ConjugacyClasses( tbl ),
>               x -> 100 - NrMovedPoints( Representative( x ) ) );;
gap> pi:= Permuted( pi, trans.columns^-1 );
[ 100, 20, 0, 0, 8, 0, 4, 4, 20, 20, 0, 0, 0, 0, 20, 20, 20, 20, 0, 0 ]
gap> fus:= InitFusion( libtbl, hs );;
[ 1, [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 5, 6, 7 ], [ 5, 6, 7 ], [ 5, 6, 7 ], 
  [ 5, 6, 7 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], 
  [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ] ]
gap> UpdateMap( nat, fus, pi );;
gap> fus;
[ 1, 2, 3, 3, 6, 5, 7, 7, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3 ]
]]></Example>

-->


<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- OPEN!!!
<Subsection Label="subsect:Ambiguities in the MGA case">
<Heading>Ambiguities in the MGA case</Heading>

<Example><![CDATA[
(mention possible problems in the bicyclic case:
3_2.U4(3) -> 3_2.U4(3).2_3' is ambiguous, but the MGA situation determines
the fusion)
]]></Example>

-->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:M11fusB">
<Heading><M>M_{11} \rightarrow B</M> (April 2009)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup <M>M</M>
of the type <M>M_{11}</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> m11:= CharacterTable( "M11" );;
gap> m11fusb:= PossibleClassFusions( m11, b );;
gap> Length( m11fusb );
31
gap> CompositionMaps( ClassNames( b, "ATLAS" ), Parametrized( m11fusb ) );
[ "1A", [ "2B", "2D" ], [ "3A", "3B" ], 
  [ "4B", "4E", "4G", "4H", "4J" ], [ "5A", "5B" ], 
  [ "6C", "6E", "6H", "6I", "6J" ], 
  [ "8B", "8E", "8G", "8J", "8K", "8L", "8M", "8N" ], 
  [ "8B", "8E", "8G", "8J", "8K", "8L", "8M", "8N" ], "11A", "11A" ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="Wil93a" Where="Thm. 12.1"/>,
<M>M</M> contains no <C>5A</C> elements of <M>B</M>.
By the proof of&nbsp;<Cite Key="Wil99" Where="Prop. 4.1"/>,
the involutions in any <M>S_5</M> type subgroup <M>U</M> of <M>M</M>
lie in the class <C>2C</C> or <C>2D</C> of <M>B</M>,
and since the possible class fusions of <M>M</M> computed above
admit only involutions in the class <C>2B</C> or <C>2D</C>,
all involutions of <M>U</M> lie in the class <C>2D</C>.
Again by the proof of&nbsp;<Cite Key="Wil99" Where="Prop. 4.1"/>,
<M>U</M> is contained in a maximal
subgroup of type <M>Th</M> in <M>B</M>.

<P/>

Now we use the embedding of <M>U</M> into <M>B</M> via <M>M</M> and <M>Th</M>
for determining the class fusion of <M>M</M> into <M>B</M>.
The class fusion of the embedding of <M>U</M> via <M>Th</M> is uniquely
determined.

<P/>

<Example><![CDATA[
gap> th:= CharacterTable( "Th" );;
gap> s5:= CharacterTable( "S5" );;
gap> s5fusth:= PossibleClassFusions( s5, th );
[ [ 1, 2, 4, 8, 2, 7, 11 ] ]
gap> thfusb:= PossibleClassFusions( th, b );;
gap> s5fusb:= Set( thfusb, x -> CompositionMaps( x, s5fusth[1] ) );
[ [ 1, 5, 7, 19, 5, 17, 29 ] ]
]]></Example>

<P/>

Also the class fusion of <M>U</M> into <M>M</M> is unique,
and this determines the class fusion of <M>M</M> into <M>B</M>.

<P/>

<Example><![CDATA[
gap> s5fusm11:= PossibleClassFusions( s5, m11 );
[ [ 1, 2, 3, 5, 2, 4, 6 ] ]
gap> m11fusb:= Filtered( m11fusb,
>                  map -> CompositionMaps( map, s5fusm11[1] ) = s5fusb[1] );
[ [ 1, 5, 7, 17, 19, 29, 45, 45, 54, 54 ] ]
gap> CompositionMaps( ClassNames( b, "ATLAS" ), m11fusb[1] );
[ "1A", "2D", "3B", "4J", "5B", "6J", "8N", "8N", "11A", "11A" ]
]]></Example>

<P/>

(Using the information that the <M>M_{10}</M> type subgroups of <M>M</M>
are also contained in <M>Th</M> type subgroups would not have helped us,
since these subgroups do not contain elements of order <M>6</M>,
and two possibilities would have remained.)

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(11):2_in_B">
<Heading><M>L_2(11):2 \rightarrow B</M> (April 2009)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup <M>L</M>
of the type <M>L_2(11):2</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> l:= CharacterTable( "L2(11).2" );;
gap> lfusb:= PossibleClassFusions( l, b );;
gap> Length( lfusb );
16
gap> CompositionMaps( ClassNames( b, "ATLAS" ), Parametrized( lfusb ) );
[ "1A", [ "2B", "2D" ], [ "3A", "3B" ], [ "5A", "5B" ], 
  [ "5A", "5B" ], [ "6C", "6H", "6I", "6J" ], "11A", [ "2C", "2D" ], 
  [ "4D", "4E", "4F", "4G", "4H", "4J" ], [ "10C", "10E", "10F" ], 
  [ "10C", "10E", "10F" ], 
  [ "12E", "12F", "12H", "12I", "12J", "12L", "12N", "12P", "12Q", 
      "12R", "12S" ], 
  [ "12E", "12F", "12H", "12I", "12J", "12L", "12N", "12P", "12Q", 
      "12R", "12S" ] ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="Wil93a" Where="Thm. 12.1"/>,
<M>L</M> contains no <C>5A</C> elements of <M>B</M>.
By the proof of&nbsp;<Cite Key="Wil99" Where="Prop. 4.1"/>,
<M>B</M> contains exactly one class of
<M>L_2(11)</M> type subgroups with this property.
Hence the subgroup <M>U</M> of index two in <M>L</M> is contained in a maximal subgroup
<M>M</M> of type <M>M_{11}</M> in <M>B</M>,
whose class fusion was determined in
Section&nbsp;<Ref Subsect="subsect:M11fusB"/>.

<P/>

In the same way as we proceeded in
Section&nbsp;<Ref Subsect="subsect:M11fusB"/>,
we use the embedding of <M>U</M> into <M>B</M> via <M>L</M> and <M>M</M> for
determining the class fusion of <M>L</M> into <M>B</M>.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "M11" );;
gap> u:= CharacterTable( "L2(11)" );;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> mfusb:= GetFusionMap( m, b );;
gap> ufusb:= Set( ufusm, x -> CompositionMaps( mfusb, x ) );
[ [ 1, 5, 7, 19, 19, 29, 54, 54 ] ]
gap> ufusl:= PossibleClassFusions( u, l );
[ [ 1, 2, 3, 4, 5, 6, 7, 7 ], [ 1, 2, 3, 5, 4, 6, 7, 7 ] ]
gap> lfusb:= Filtered( lfusb, 
>              map2 -> ForAny( ufusl, 
>                        map1 -> CompositionMaps( map2, map1 ) in ufusb ) );
[ [ 1, 5, 7, 19, 19, 29, 54, 5, 15, 53, 53, 73, 73 ] ]
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L3(3)_in_B">
<Heading><M>L_3(3) \rightarrow B</M> (April 2009)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup <M>T</M>
of the type <M>L_3(3)</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> t:= CharacterTable( "L3(3)" );;
gap> tfusb:= PossibleClassFusions( t, b );;
gap> Length( tfusb );
36
]]></Example>

<P/>

According to&nbsp;<Cite Key="Wil99" Where="Section 9"/>,
<M>T</M> contains a subgroup <M>U</M> of the type
<M>3^2:2S_4</M> that is contained also in a maximal subgroup <M>M</M> of the type
<M>3^2.3^3.3^6.(S_4 \times 2S_4)</M>.
So we throw away the possible fusions from <M>T</M> to <M>B</M> that are not compatible
with the compositions of the embeddings of <M>U</M> into <M>B</M> via <M>T</M> and <M>M</M>.

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "3^2.3^3.3^6.(S4x2S4)" );;
gap> g:= PSL(3,3);;
gap> mx:= MaximalSubgroupClassReps( g );;
gap> u:= First( mx, x -> Size( x ) = 432 );;
gap> u:= CharacterTable( u );;
gap> ufusm:= PossibleClassFusions( u, m );;
gap> ufust:= PossibleClassFusions( u, t );;
gap> mfusb:= GetFusionMap( m, b );;
gap> ufusb:= Set( ufusm, map -> CompositionMaps( mfusb, map ) );;
gap> tfusb:= Filtered( tfusb, map -> ForAny( ufust,
>        map2 -> CompositionMaps( map, map2 ) in ufusb ) );;
gap> tfusb;
[ [ 1, 5, 6, 7, 12, 27, 41, 41, 75, 75, 75, 75 ], 
  [ 1, 5, 7, 6, 12, 28, 41, 41, 75, 75, 75, 75 ], 
  [ 1, 5, 7, 7, 12, 28, 41, 41, 75, 75, 75, 75 ], 
  [ 1, 5, 7, 7, 12, 29, 41, 41, 75, 75, 75, 75 ], 
  [ 1, 5, 7, 7, 17, 29, 45, 45, 75, 75, 75, 75 ] ]
]]></Example>

<P/>

Now we use that <M>T</M> does not contain <C>4E</C> elements of <M>B</M>
(again see&nbsp;<Cite Key="Wil99" Where="Section 9"/>).
Thus the last of the five candidates is the correct class fusion.

<P/>

<Example><![CDATA[
gap> ClassNames( b, "ATLAS" ){ [ 12, 17 ] };
[ "4E", "4J" ]
]]></Example>

<P/>

We check that this map is stored on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( t, b ) = tfusb[5];
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(17).2_in_B">
<Heading><M>L_2(17).2 \rightarrow B</M> (March 2004)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup <M>U</M>
of the type <M>L_2(17).2</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> u:= CharacterTable( "L2(17).2" );;
gap> ufusb:= PossibleClassFusions( u, b );
[ [ 1, 5, 7, 15, 42, 42, 47, 47, 47, 91, 4, 30, 89, 89, 89, 89, 97, 
      97, 97 ], 
  [ 1, 5, 7, 15, 44, 44, 46, 46, 46, 91, 5, 29, 90, 90, 90, 90, 96, 
      96, 96 ], 
  [ 1, 5, 7, 15, 44, 44, 47, 47, 47, 91, 5, 29, 90, 90, 90, 90, 95, 
      95, 95 ] ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="Wil99" Where="Prop. 11.1"/>,
<M>U</M> contains elements in the classes
<C>8M</C> and <C>9A</C> of <M>B</M>.
This determines the fusion map.

<P/>

<Example><![CDATA[
gap> names:= ClassNames( b, "ATLAS" );;
gap> pos:= List( [ "8M", "9A" ], x -> Position( names, x ) );
[ 44, 46 ]
gap> ufusb:= Filtered( ufusb, map -> IsSubset( map, pos ) );
[ [ 1, 5, 7, 15, 44, 44, 46, 46, 46, 91, 5, 29, 90, 90, 90, 90, 96, 
      96, 96 ] ]
]]></Example>

<P/>

We check that this map is stored on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( u, b ) = ufusb[1];
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(49).2_3_in_B">
<Heading><M>L_2(49).2_3 \rightarrow B</M> (June 2006)</Heading>

The sporadic simple group <M>B</M> contains a class of maximal subgroups
of the type <M>L_2(49).2_3</M> (a non-split extension of <M>L_2(49)</M>,
see&nbsp;<Cite Key="Wilson93" Where="Theorem 2"/>).
Let <M>U</M> be such a subgroup.
The class fusion of <M>U</M> in <M>B</M> is not determined by
the character tables of <M>U</M> and <M>B</M>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "L2(49).2_3" );;
gap> b:= CharacterTable( "B" );;
gap> ufusb:= PossibleClassFusions( u, b );;
gap> Length( RepresentativesFusions( u, ufusb, b ) );
2
gap> ufusb;
[ [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 
      128, 128, 15, 71, 71, 89, 89, 89, 89 ], 
  [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 
      128, 128, 17, 72, 72, 89, 89, 89, 89 ] ]
]]></Example>

<P/>

We show that the fusion is determined by the embeddings of the Sylow <M>7</M>
normalizer <M>N</M>, say, of <M>U</M> into <M>U</M>
and into the Sylow <M>7</M> normalizer of <M>B</M>.
(Note that the fusion of the latter group into <M>B</M> has been determined
in Section&nbsp;<Ref Subsect="subsect:BN7"/>.)

<P/>

For that, we compute the character table of <M>N</M> from a representation of <M>U</M>.
Note that <M>U</M> is a non-split extension of the simple group <M>L_2(49)</M> by
the product of a diagonal automorphism and a field automorphism.
In&nbsp;<Cite Key="Wilson93"/>, the structure of <M>N</M> is described as
<M>7^2:(3 \times Q_{16})</M>.

<P/>

<Example><![CDATA[
gap> g:= SL( 2, 49 );;
gap> gens:= GeneratorsOfGroup( g );;
gap> f:= GF(49);;
gap> mats:= List( gens, x -> IdentityMat( 4, f ) );;
gap> for i in [ 1 .. Length( gens ) ] do
>      mats[i]{ [ 1, 2 ] }{ [ 1, 2 ] }:= gens[i];
>      mats[i]{ [ 3, 4 ] }{ [ 3, 4 ] }:= List( gens[i],
>                                              x -> List( x, y -> y^7 ) );
>    od;
gap> fieldaut:= PermutationMat( (1,3)(2,4), 4, f );;
gap> diagaut:= IdentityMat( 4, f );;
gap> diagaut[1][1]:= Z(49);;
gap> diagaut[3][3]:= Z(49)^7;;
gap> g:= Group( Concatenation( mats, [ fieldaut * diagaut ] ) );;
gap> v:= [ 1, 0, 0, 0 ] * Z(7)^0;;
gap> orb:= Orbit( g, v, OnLines );;
gap> act:= Action( g, orb, OnLines );;
gap> n:= Normalizer( act, SylowSubgroup( act, 7 ) );;
gap> ntbl:= CharacterTable( n );;
]]></Example>

<P/>

Now we compute the possible class fusions of <M>N</M> into <M>B</M>, via the Sylow <M>7</M>
normalizer in <M>B</M>.

<P/>

<Example><![CDATA[
gap> bn7:= CharacterTable( "BN7" );;
gap> nfusbn7:= PossibleClassFusions( ntbl, bn7 );;
gap> Length( RepresentativesFusions( ntbl, nfusbn7, bn7 ) );
3
gap> nfusb:= SetOfComposedClassFusions( PossibleClassFusions( bn7, b ),
>                                       nfusbn7 );;
gap> Length( RepresentativesFusions( ntbl, nfusb, b ) );
5
]]></Example>

<P/>

Although there are several possibilities, this information is enough to
exclude one of the possible fusions of <M>U</M> into <M>B</M>.

<P/>

<Example><![CDATA[
gap> nfusu:= PossibleClassFusions( ntbl, u );;
gap> Length( nfusu );
4
gap> filt:= Filtered( ufusb,
>              x -> ForAny( nfusu, y -> CompositionMaps( x, y ) in nfusb ) );
[ [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 
      128, 128, 17, 72, 72, 89, 89, 89, 89 ] ]
gap> ClassNames( b, "ATLAS" ){ filt[1] };
[ "1A", "2D", "3B", "4H", "5B", "6I", "7A", "8K", "8K", "12Q", "24L", 
  "24L", "25A", "25A", "25A", "25A", "25A", "4J", "12R", "12R", 
  "16G", "16G", "16G", "16G" ]
]]></Example>

<P/>

So the class fusion of <M>U</M> into <M>B</M> can be described by the property that
the elements of order four inside and outside the simple subgroup <M>L_2(49)</M>
are not conjugate in <M>B</M>.

<P/>

We check that the correct map is stored on the library table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( u, b ) in filt;
true
]]></Example>

<!-- %T Is it possible that computing L2(49).2_2 -> B is <E>faster</E> at info level 2? -->
<!-- %T There are 5 solutions (in 4 orbits) left. -->

<P/>

Let us confirm that the two groups of the types <M>L_2(49).2_1</M> and
<M>L_2(49).2_2</M> cannot occur as subgroups of <M>B</M>.
First we show that <M>L_2(49).2_1</M> is isomorphic with PGL<M>(2,49)</M>,
an extension of <M>L_2(49)</M> by a diagonal automorphism,
and <M>L_2(49).2_2</M> is an extension by a field automorphism.

<P/>

<Example><![CDATA[
gap> NrConjugacyClasses( u );  NrConjugacyClasses( act );
24
24
gap> u:= CharacterTable( "L2(49).2_1" );;
gap> g:= Group( Concatenation( mats, [ diagaut ] ) );;
gap> orb:= Orbit( g, v, OnLines );;
gap> act:= Action( g, orb, OnLines );;
gap> Size(act );
117600
gap> NrConjugacyClasses( u );  NrConjugacyClasses( act );
51
51
gap> u:= CharacterTable( "L2(49).2_2" );;
gap> g:= Group( Concatenation( mats, [ fieldaut ] ) );;
gap> orb:= Orbit( g, v, OnLines );;
gap> act:= Action( g, orb, OnLines );;
gap> NrConjugacyClasses( u );  NrConjugacyClasses( act );
27
27
]]></Example>

<P/>

The group <M>L_2(49).2_1</M> can be excluded because no class fusion into
<M>B</M> is possible.

<P/>

<Example><![CDATA[
gap> PossibleClassFusions( CharacterTable( "L2(49).2_1" ), b );
[  ]
]]></Example>

<P/>

For <M>L_2(49).2_2</M>, it is not that easy.
We would get several possible class fusions into <M>B</M>.

<!-- %T Note that computing the possible fusions of <M>L_2(49).2_2</M> into <M>B</M> -->
<!-- %T takes <E>VERY LONG</E>. -->

However, the Sylow <M>7</M> normalizer of <M>L_2(49).2_2</M> does not admit
a class fusion into the Sylow <M>7</M> normalizer of <M>B</M>.

<P/>

<Example><![CDATA[
gap> n:= Normalizer( act, SylowSubgroup( act, 7 ) );;
gap> Length( PossibleClassFusions( CharacterTable( n ), bn7 ) );
0
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2^3.L3(2)_in_G2(5)">
<Heading><M>2^3.L_3(2) \rightarrow G_2(5)</M> (January&nbsp;2004)</Heading>

The Chevalley group <M>G = G_2(5)</M> contains a maximal subgroup <M>U</M>
of the type <M>2^3.L_3(2)</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "G2(5)" );;
gap> s:= CharacterTable( "2^3.L3(2)" );;
gap> sfust:= PossibleClassFusions( s, t );;
gap> RepresentativesFusions( s, sfust, t );
[ [ 1, 2, 2, 5, 6, 4, 13, 16, 17, 15, 15 ], 
  [ 1, 2, 2, 5, 6, 4, 14, 16, 17, 15, 15 ] ]
gap> OrdersClassRepresentatives( s );
[ 1, 2, 2, 4, 4, 3, 6, 8, 8, 7, 7 ]
]]></Example>

<P/>

So the question is whether <M>U</M> contains elements in the class <C>6B</C> or <C>6C</C>
of <M>G</M> (position <M>13</M> or <M>14</M> in the &ATLAS; table).
We use a permutation representation of <M>G</M>, restrict it to <M>U</M>,
and compute the centralizer in <M>G</M> of a suitable element of order <M>6</M> in <M>U</M>.

<P/>

<Example><![CDATA[
gap> g:= AtlasGroup( "G2(5)" );;
gap> u:= AtlasSubgroup( "G2(5)", 7 );;
gap> Size( u );
1344
gap> repeat
>      x:= Random( u );
>    until Order( x ) = 6;
gap> siz:= Size( Centralizer( g, x ) );
36
gap> Filtered( [ 1 .. NrConjugacyClasses( t ) ],
>              i -> SizesCentralizers( t )[i] = siz );
[ 14 ]
]]></Example>

<P/>

So <M>U</M> contains <C>6C</C> elements in <M>G_2(5)</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) in Filtered( sfust, map -> 14 in map );  
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:5^{1+4}.2^{1+4}.A_5.4_in_B">
<Heading><M>5^{{1+4}}.2^{{1+4}}.A_5.4 \rightarrow B</M> (April 2009)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup <M>M</M>
of the type <M>5^{{1+4}}.2^{{1+4}}.A_5.4</M> whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> b:= CharacterTable( "B" );;
gap> m:= CharacterTable( "5^(1+4).2^(1+4).A5.4" );;
gap> mfusb:= PossibleClassFusions( m, b );;
gap> Length( mfusb );
4
gap> repres:= RepresentativesFusions( m, mfusb, b );; 
gap> Length( repres );
2
]]></Example>

<P/>

The restriction of the unique irreducible character of degree <M>4\,371</M>
distinguishes the two possibilities,

<P/>

<Example><![CDATA[
gap> char:= Filtered( Irr( b ), x -> x[1] = 4371 );;
gap> Length( char );
1
gap> rest:= List( repres, map -> char[1]{ map } );;
gap> scprs:= MatScalarProducts( m, Irr( m ), rest );;
gap> constit:= List( scprs,
>                x -> Filtered( [1 .. Length(x) ], i -> x[i] <> 0 ) );
[ [ 2, 27, 60, 63, 73, 74, 75, 79, 82 ], 
  [ 2, 27, 60, 63, 70, 72, 75, 79, 84 ] ]
gap> List( constit, x -> List( Irr( m ){ x }, Degree ) );
[ [ 1, 6, 384, 480, 400, 400, 500, 1000, 1200 ], 
  [ 1, 6, 384, 480, 100, 300, 500, 1000, 1600 ] ]
]]></Example>

<P/>

The database&nbsp;<Cite Key="AGRv3"/> contains the <M>3</M>-modular reduction
of the irreducible representation of degree <M>4\,371</M>
and also a straight line program for restricting this representation
to <M>M</M>.
We access these data via the &GAP; package <Package>AtlasRep</Package>
(see&nbsp;<Cite Key="AtlasRep"/>), and compute the composition factors of the
natural module of this restriction.

<P/>

<Example><![CDATA[
gap> g:= AtlasSubgroup( "B", Dimension, 4371, Ring, GF(3), 21 );;
gap> module:= GModuleByMats( GeneratorsOfGroup( g ), GF(3) );;
gap> dec:= MTX.CompositionFactors( module );;
gap> SortedList( List( dec, x -> x.dimension ) );
[ 1, 6, 100, 384, 400, 400, 400, 480, 1000, 1200 ]
]]></Example>

<P/>

<!-- The <C>AtlasSubgroup</C> call needs 5247 seconds,
     the computation of the composition factors needs 911 seconds. -->

We see that exactly one ordinary constituent does not stay irreducible
upon restriction to characteristic <M>3</M>.
Thus the first of the two possible class fusions is the correct one.

<!-- The analogous computation with the degree 4370 in characteristic two
     is much faster.
     However, it does not help us, since this decomposition is finer
     and fits to both possibilities. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:7^2:2L_2(7).2_tom">
<Heading>The fusion from the character table of <M>7^2:2L_2(7).2</M>
into the table of marks (January&nbsp;2004)</Heading>

It can happen that the class fusion from the ordinary character table of a
group <M>G</M> into the table of marks of <M>G</M> is not unique up to table
automorphisms of the character table of <M>G</M>.

<P/>

As an example, consider <M>G = 7^2:2L_2(7).2</M>, a maximal subgroup in the
sporadic simple group <M>He</M>.

<P/>

<M>G</M> contains four classes of cyclic subgroups of order <M>7</M>.
One contains the elements in the normal subgroup of type <M>7^2</M>,
and the other three are preimages of the order <M>7</M> elements in the
factor group <M>L_2(7)</M>.
The conjugacy classes of nonidentity elements in the latter three classes
split into two Galois conjugates each, which are permuted cyclicly by the
table automorphisms of the character table of <M>G</M>,
but on which the stabilizer of one class acts trivially.
This means that determining one of the three classes determines also the
other two.

<!-- % (The degree 48 representations would do the job.) -->

<P/>

<Example><![CDATA[
gap> tbl:= CharacterTable( "7^2:2psl(2,7)" );
CharacterTable( "7^2:2psl(2,7)" )
gap> tom:= TableOfMarks( tbl );
TableOfMarks( "7^2:2L2(7)" )
gap> fus:= PossibleFusionsCharTableTom( tbl, tom );
[ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 10, 9, 16, 7, 10, 9, 8, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 9, 8, 10, 16, 7, 8, 10, 9, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 10, 9, 8, 16, 7, 9, 8, 10, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 10, 8, 9, 16, 7, 8, 9, 10, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 9, 10, 8, 16, 7, 10, 8, 9, 16 ] ]
gap> reps:= RepresentativesFusions( tbl, fus, Group(()) );        
[ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ], 
  [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 10, 9, 16, 7, 10, 9, 8, 16 ] ]
gap> AutomorphismsOfTable( tbl );
Group([ (9,14)(10,17)(11,15)(12,16)(13,18), (7,8), (10,11,12)
  (15,16,17) ])
gap> OrdersClassRepresentatives( tbl );
[ 1, 7, 2, 4, 3, 6, 8, 8, 7, 7, 7, 7, 14, 7, 7, 7, 7, 14 ]
gap> perms1:= PermCharsTom( reps[1], tom );;
gap> perms2:= PermCharsTom( reps[2], tom );;
gap> perms1 = perms2;      
false
gap> Set( perms1 ) = Set( perms2 );
true
]]></Example>

<P/>

The table of marks of <M>G</M> does not distinguish the three classes
of cyclic subgroups,
there are permutations of rows and columns that act as an <M>S_3</M> on them.

<P/>

Note that an <M>S_3</M> acts on the classes in question in the <E>rational</E>
character table.
So it is due to the irrationalities in the character table that it
contains more information.

<P/>

<Example><![CDATA[
gap> Display( tbl );
7^2:2psl(2,7)

      2  4  .  4  3  1  1  3  3   1   .   .   .   1   1   .   .   .
      3  1  .  1  .  1  1  .  .   .   .   .   .   .   .   .   .   .
      7  3  3  1  .  .  .  .  .   2   2   2   2   1   2   2   2   2

        1a 7a 2a 4a 3a 6a 8a 8b  7b  7c  7d  7e 14a  7f  7g  7h  7i
     2P 1a 7a 1a 2a 3a 3a 4a 4a  7b  7c  7d  7e  7b  7f  7g  7h  7i
     3P 1a 7a 2a 4a 1a 2a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c
     5P 1a 7a 2a 4a 3a 6a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c
     7P 1a 1a 2a 4a 3a 6a 8a 8b  1a  1a  1a  1a  2a  1a  1a  1a  1a
    11P 1a 7a 2a 4a 3a 6a 8b 8a  7b  7c  7d  7e 14a  7f  7g  7h  7i
    13P 1a 7a 2a 4a 3a 6a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c

X.1      1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   1   1
X.2      3  3  3 -1  .  .  1  1   B   B   B   B   B  /B  /B  /B  /B
X.3      3  3  3 -1  .  .  1  1  /B  /B  /B  /B  /B   B   B   B   B
X.4      6  6  6  2  .  .  .  .  -1  -1  -1  -1  -1  -1  -1  -1  -1
X.5      7  7  7 -1  1  1 -1 -1   .   .   .   .   .   .   .   .   .
X.6      8  8  8  . -1 -1  .  .   1   1   1   1   1   1   1   1   1
X.7      4  4 -4  .  1 -1  .  .  -B  -B  -B  -B   B -/B -/B -/B -/B
X.8      4  4 -4  .  1 -1  .  . -/B -/B -/B -/B  /B  -B  -B  -B  -B
X.9      6  6 -6  .  .  .  A -A  -1  -1  -1  -1   1  -1  -1  -1  -1
X.10     6  6 -6  .  .  . -A  A  -1  -1  -1  -1   1  -1  -1  -1  -1
X.11     8  8 -8  . -1  1  .  .   1   1   1   1  -1   1   1   1   1
X.12    48 -1  .  .  .  .  .  .   6  -1  -1  -1   .   6  -1  -1  -1
X.13    48 -1  .  .  .  .  .  .   C  -1  /C  /D   .  /C   C   D  -1
X.14    48 -1  .  .  .  .  .  .   C  /C  /D  -1   .  /C   D  -1   C
X.15    48 -1  .  .  .  .  .  .  /C   D  -1   C   .   C  -1  /C  /D
X.16    48 -1  .  .  .  .  .  .   C  /D  -1  /C   .  /C  -1   C   D
X.17    48 -1  .  .  .  .  .  .  /C   C   D  -1   .   C  /D  -1  /C
X.18    48 -1  .  .  .  .  .  .  /C  -1   C   D   .   C  /C  /D  -1

      2   1
      3   .
      7   1

        14b
     2P  7f
     3P 14a
     5P 14a
     7P  2a
    11P 14b
    13P 14a

X.1       1
X.2      /B
X.3       B
X.4      -1
X.5       .
X.6       1
X.7      /B
X.8       B
X.9       1
X.10      1
X.11     -1
X.12      .
X.13      .
X.14      .
X.15      .
X.16      .
X.17      .
X.18      .

A = E(8)-E(8)^3
  = Sqrt(2) = r2
B = E(7)+E(7)^2+E(7)^4
  = (-1+Sqrt(-7))/2 = b7
C = 2*E(7)+2*E(7)^2+2*E(7)^4
  = -1+Sqrt(-7) = 2b7
D = -3*E(7)-3*E(7)^2-2*E(7)^3-3*E(7)^4-2*E(7)^5-2*E(7)^6
  = (5-Sqrt(-7))/2 = 2-b7
gap> mat:= MatTom( tom );;
gap> mataut:= MatrixAutomorphisms( mat );;
gap> Print( mataut, "\n" );
Group( [ (11,12)(23,24)(27,28)(46,47)(53,54)(56,57), 
  ( 9,10)(20,21)(31,32)(38,39), ( 8, 9)(20,22)(31,33)(38,40) ] )
gap> RepresentativesFusions( Group( () ), reps, mataut );
[ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ] ]
]]></Example>

<P/>

We could say that thus the fusion is unique up to table automorphisms
and automorphisms of the table of marks.
But since a group is associated with the table of marks,
we compute the character table from the group,
and decide which class fusion is correct.

<P/>

<Example><![CDATA[
gap> g:= UnderlyingGroup( tom );;
gap> tg:= CharacterTable( g );;
gap> tgfustom:= FusionCharTableTom( tg, tom );;
gap> trans:= TransformingPermutationsCharacterTables( tg, tbl );;
gap> tblfustom:= Permuted( tgfustom, trans.columns );;
gap> orbits:= List( reps, map -> OrbitFusions( AutomorphismsOfTable( tbl ),
>                                              map, Group( () ) ) );;
gap> PositionProperty( orbits, orb -> tblfustom in orb );
2
gap> PositionProperty( orbits, orb -> FusionToTom( tbl ).map in orb );
2
]]></Example>

<P/>

So we see that the second one of the possibilities above is the right one.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:3xU_4(2)_in_3_1.U_4(3)">
<Heading><M>3 \times U_4(2) \rightarrow 3_1.U_4(3)</M> (March 2010)</Heading>

According to the &ATLAS; (see&nbsp;<Cite Key="CCN85" Where="p. 52"/>),
the simple group <M>U_4(3)</M> contains two classes of maximal subgroups
of the type <M>U_4(2)</M>.
The class fusion of <M>U_4(2)</M> into <M>U_4(3)</M> is unique up to table
automorphisms.

<P/>

<Example><![CDATA[
gap> u42:= CharacterTable( "U4(2)" );;
gap> u43:= CharacterTable( "U4(3)" );;
gap> u42fusu43:= PossibleClassFusions( u42, u43 );;
gap> Length( u42fusu43 );
4
gap> Length( RepresentativesFusions( u42, u42fusu43, u43 ) );
1
]]></Example>

<P/>

More precisely, take the outer automorphism group of <M>U_4(3)</M>,
which is a dihedral group of order eight,
and consider the subgroup generated by its central involution
(this automorphism is denoted by <M>2_1</M> in the &ATLAS;)
and another involution called <M>2_3</M> in the &ATLAS;.
This subgroup is a Klein four group that induces a permutation group
on the classes of <M>U_4(3)</M> and thus acts on the four possible class
fusions of <M>U_4(2)</M> into <M>U_4(3)</M>.
In fact, this action is transitive.

<P/>

The automorphism <M>2_1</M> swaps each pair of mutually inverse classes
of order nine,
that is, <C>9A</C> is swapped with <C>9B</C> and <C>9C</C> is swapped with <C>9D</C>.
All <M>U_4(2)</M> type subgroups of <M>U_4(3)</M> are invariant under this
automorphism, they extend to subgroups of the type <M>U_4(2).2</M> in
<M>U_4(3).2_1</M>.

<P/>

<Example><![CDATA[
gap> u43_21:= CharacterTable( "U4(3).2_1" );;
gap> fus1:= GetFusionMap( u43, u43_21 );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 17, 17, 
  18 ]
gap> act1:= Filtered( InverseMap( fus1 ), IsList );
[ [ 16, 17 ], [ 18, 19 ] ]
gap> CompositionMaps( ClassNames( u43, "Atlas" ), act1 );
[ [ "9A", "9B" ], [ "9C", "9D" ] ]
]]></Example>

<P/>

The automorphism <M>2_3</M> swaps <C>6B</C> with <C>6C</C>, <C>9A</C> with <C>9C</C>,
and <C>9B</C> with <C>9D</C>.
The two classes of <M>U_4(2)</M> type subgroups of <M>U_4(3)</M> are swapped
by this automorphism.

<P/>

<Example><![CDATA[
gap> u43_23:= CharacterTable( "U4(3).2_3" );;
gap> fus3:= GetFusionMap( u43, u43_23 );
[ 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 13, 14, 13, 14, 
  15 ]
gap> act3:= Filtered( InverseMap( fus3 ), IsList );
[ [ 4, 5 ], [ 11, 12 ], [ 13, 14 ], [ 16, 18 ], [ 17, 19 ] ]
gap> CompositionMaps( ClassNames( u43, "Atlas" ), act3 );
[ [ "3B", "3C" ], [ "6B", "6C" ], [ "7A", "7B" ], [ "9A", "9C" ], 
  [ "9B", "9D" ] ]
]]></Example>

<P/>

The &ATLAS; states that the permutation character induced by the
first class of <M>U_4(2)</M> type subgroups is <C>1a+35a+90a</C>,
which means that the subgroups in this class contain <C>9A</C> and <C>9B</C> elements.
Then the permutation character induced by the second class
of <M>U_4(2)</M> type subgroups is <C>1a+35b+90a</C>,
and the subgroups in this class contain <C>9C</C> and <C>9D</C> elements.

<P/>

So we choose appropriate fusions for the two classes of maximal
<M>U_4(2)</M> type subgroups.

<P/>

<Example><![CDATA[
gap> firstfus:= First( u42fusu43, x -> IsSubset( x, [ 16, 17 ] ) );
[ 1, 2, 2, 3, 3, 5, 4, 7, 8, 9, 10, 10, 12, 12, 11, 12, 16, 17, 20, 
  20 ]
gap> secondfus:= First( u42fusu43, x -> IsSubset( x, [ 18, 19 ] ) );
[ 1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 11, 18, 19, 20, 
  20 ]
]]></Example>

<P/>

Let us now consider the central extension <M>3_1.U_4(3)</M>.
Since the Schur multiplier of <M>U_4(2)</M> has order two,
the <M>U_4(2)</M> type subgroups of <M>U_4(3)</M> lift to groups of the structure
<M>3 \times U_4(2)</M> in <M>3_1.U_4(3)</M>.
There are eight possible class fusions from <M>3 \times U_4(2)</M> to <M>3_1.U_4(3)</M>,
in two orbits of length four under the action of table automorphisms.

<P/>

<Example><![CDATA[
gap> 3u42:= CharacterTable( "Cyclic", 3 ) * u42;
CharacterTable( "C3xU4(2)" )
gap> 3u43:= CharacterTable( "3_1.U4(3)" );
CharacterTable( "3_1.U4(3)" )
gap> 3u42fus3u43:= PossibleClassFusions( 3u42, 3u43 );;
gap> Length( 3u42fus3u43 );
8
gap> Length( RepresentativesFusions( 3u42, 3u42fus3u43, 3u43 ) );
2
]]></Example>

<P/>

More precisely, each of the four fusions from <M>U_4(2)</M> to <M>U_4(3)</M> has
exactly two lifts.
The four lifts of those fusions from <M>U_4(2)</M> to <M>U_4(3)</M> with
<C>9A</C> and <C>9B</C> in their image form one orbit under the action of
table automorphisms.
The other orbit consists of the lifts of those fusions with
<C>9C</C> and <C>9D</C> in their image.

<P/>

<Example><![CDATA[
gap> inducedmaps:= List( 3u42fus3u43, map -> CompositionMaps(
>        GetFusionMap( 3u43, u43 ), CompositionMaps( map,
>        InverseMap( GetFusionMap( 3u42, u42 ) ) ) ) );;
gap> List( inducedmaps, map -> Position( u42fusu43, map ) );
[ 1, 1, 2, 2, 4, 4, 3, 3 ]
]]></Example>

<P/>

This solves the ambiguity:
Fusions from each of the two orbits occur,
and we can assign them to the two classes of subgroups
by the choice of the fusions from <M>U_4(2)</M> to <M>U_4(3)</M>.

<P/>

The reason for the asymmetry is that the automorphism <M>2_3</M> of <M>U_4(3)</M>
does not lift to <M>3_1.U_4(3)</M>.
Note that each of the classes <C>9A</C>, <C>9B</C> of <M>U_4(3)</M> has three preimages
in <M>3_1.U_4(3)</M>,
whereas each of the classes <C>9C</C>, <C>9D</C> has only one preimage.

<P/>

In fact the two classes of <M>3 \times U_4(2)</M> type subgroups of <M>3_1.U_4(3)</M>
behave differently.
For example,
inducing the irreducible characters of a <M>3 \times U_4(2)</M> type subgroup
in the first class of maximal subgroups of <M>3_1.U_4(3)</M>
yields no irreducible character, whereas the two irreducible characters
of degree <M>630</M> are obtained by inducing the irreducible characters
of a subgroup in the second class.

<P/>

<Example><![CDATA[
gap> rep:= RepresentativesFusions( 3u42, 3u42fus3u43, 3u43 );
[ [ 1, 4, 4, 7, 7, 10, 13, 15, 18, 21, 24, 24, 27, 27, 30, 27, 48, 
      49, 50, 50, 2, 5, 5, 8, 8, 11, 13, 16, 19, 22, 25, 25, 28, 28, 
      31, 28, 48, 49, 51, 51, 3, 6, 6, 9, 9, 12, 13, 17, 20, 23, 26, 
      26, 29, 29, 32, 29, 48, 49, 52, 52 ], 
  [ 1, 4, 4, 8, 9, 13, 10, 15, 18, 21, 25, 26, 31, 32, 27, 30, 46, 
      44, 51, 52, 2, 5, 5, 9, 7, 13, 11, 16, 19, 22, 26, 24, 32, 30, 
      28, 31, 47, 42, 52, 50, 3, 6, 6, 7, 8, 13, 12, 17, 20, 23, 24, 
      25, 30, 31, 29, 32, 45, 43, 50, 51 ] ]
gap> irr:= Irr( 3u42 );;
gap> ind:= InducedClassFunctionsByFusionMap( 3u42, 3u43, irr, rep[1] );;
gap> Intersection( ind, Irr( 3u43 ) );
[ Character( CharacterTable( "3_1.U4(3)" ),
  [ 630, 630*E(3)^2, 630*E(3), 6, 6*E(3)^2, 6*E(3), 9, 9*E(3)^2, 
      9*E(3), -9, -9*E(3)^2, -9*E(3), 0, 0, 2, 2*E(3)^2, 2*E(3), -2, 
      -2*E(3)^2, -2*E(3), 0, 0, 0, -3, -3*E(3)^2, -3*E(3), 3, 
      3*E(3)^2, 3*E(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, -1, -E(3)^2, -E(3) ] ), 
  Character( CharacterTable( "3_1.U4(3)" ),
  [ 630, 630*E(3), 630*E(3)^2, 6, 6*E(3), 6*E(3)^2, 9, 9*E(3), 
      9*E(3)^2, -9, -9*E(3), -9*E(3)^2, 0, 0, 2, 2*E(3), 2*E(3)^2, 
      -2, -2*E(3), -2*E(3)^2, 0, 0, 0, -3, -3*E(3), -3*E(3)^2, 3, 
      3*E(3), 3*E(3)^2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, -1, -E(3), -E(3)^2 ] ) ]
gap> ind:= InducedClassFunctionsByFusionMap( 3u42, 3u43, irr, rep[2] );;
gap> Intersection( ind, Irr( 3u43 ) );
[  ]
]]></Example>

<P/>

For <M>6_1.U_4(3)</M> and <M>12_1.U_4(3)</M>, one gets the same phenomenon:
We have two orbits of class fusions,
one corresponding to each of the two classes of subgroups
of the type <M>3 \times 4 Y 2.U_4(2)</M>.
We get <M>10</M> irreducible induced characters from
a subgroup in the second class (four faithful ones,
four with kernel of order two, and the two abovementioned
degree <M>630</M> characters with kernel of order four)
and no irreducible character from a subgroup in the first class.

<!-- %T Computing the possible class fusions from <M>3 \times 4 Y 2.U_4(2)</M> -->
<!-- %T to <M>12_1.U_4(3)</M> takes a long time ... -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2.3^4.2^3.S_4_in_2.A12">
<Heading><M>2.3^4.2^3.S_4 \rightarrow 2.A12</M> (September 2011)</Heading>

The double cover <M>G</M> of the alternating group <M>A_{12}</M> contains
a maximal subgroup <M>M</M> of the type <M>2.3^4.2^3.S_4</M>
whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> 2a12:= CharacterTable( "2.A12" );;
gap> mtbl:= CharacterTable( "2.3^4.2^3.S4" );;
gap> mtblfus2a12:= PossibleClassFusions( mtbl, 2a12 );;
gap> Length( mtblfus2a12 );
32
gap> repres:= RepresentativesFusions( mtbl, mtblfus2a12, 2a12 );; 
gap> Length( repres );
2
]]></Example>

<P/>

We decide the question which of the essentially different two
possible class fusion is the right one,
by explicitly constructing <M>M</M> as a subgroup of <M>G</M>.

<P/>

For that, let <M>\pi</M> denote the natural epimorphism from <M>G</M> to <M>A_{12}</M>,
and note that <M>\pi(M)</M> can be described as the intersection of a
<M>S_3 \wp S_4</M> type subgroup of <M>S_{12}</M> with <M>A_{12}</M>.
Further note that the generators for <M>G</M> and <M>A_{12}</M> provided by&nbsp;<Cite Key="AGRv3"/>
are compatible in the sense that <M>\pi</M> can be defined by mapping the
generators of <M>G</M> to those of <M>A_{12}</M>.

<P/>

We need <M>\pi</M> only for computing one preimage of each given element.
Therefore, we represent <M>\pi</M> implicitly by two epimorphisms from a
free group to <M>G</M> and <M>A_{12}</M>, respectively,
in order to avoid that &GAP;precomputes a lot of unnecessary information
for <M>G</M>.
This way,
computing a preimage of an element of <M>A_{12}</M> under <M>\pi</M> is cheap.
However, computing the preimage of a subgroup of <M>A_{12}</M> would be very
expensive.
So we construct the subgroup of <M>G</M> that is generated by preimages of
a set of generators of <M>\pi(M)</M>; later we see that this subgroup is in fact
equal to <M>M</M>.

<P/>

<Example><![CDATA[
gap> g:= AtlasGroup( "A12" );
Group([ (1,2,3), (2,3,4,5,6,7,8,9,10,11,12) ])
gap> 2g:= AtlasGroup( "2.A12" );
<matrix group of size 479001600 with 2 generators>
gap> f:= FreeGroup( 2 );;
gap> pi1:= GroupHomomorphismByImagesNC( f, 2g, GeneratorsOfGroup( f ),
>              GeneratorsOfGroup( 2g ) );;
gap> pi2:= GroupHomomorphismByImagesNC( f, g, GeneratorsOfGroup( f ),
>              GeneratorsOfGroup( g ) );;
gap> w:= WreathProduct( SymmetricGroup( 3 ), SymmetricGroup(4) );
<permutation group of size 31104 with 10 generators>
gap> NrMovedPoints( w );
12
gap> s:= Intersection( w, g );  Size( s );
<permutation group with 8 generators>
15552
gap> m:= SubgroupNC( 2g, List( SmallGeneratingSet( s ),
>            x -> ImagesRepresentative( pi1,
>                   PreImagesRepresentative( pi2, x ) ) ) );;
]]></Example>

<P/>

Now we compute the character table of <M>M</M>,
using a faithful permutation representation of <M>M</M>.

<P/>

<Example><![CDATA[
gap> iso:= IsomorphismPermGroup( m );;
gap> t:= CharacterTable( Image( iso ) );;
gap> Size( t );
31104
gap> trans:= TransformingPermutationsCharacterTables( mtbl, t );;
gap> IsRecord( trans );
true
]]></Example>

<P/>

Now let us see where the two fusion candidates differ.

<P/>

<Example><![CDATA[
gap> para:= Parametrized( repres );
[ 1, 2, 6, 10, 8, 12, 7, 11, 9, 13, 5, 5, 17, 17, 17, 17, 3, 4, 24, 
  22, 27, 25, 12, 10, 13, 11, 28, 29, 35, 37, 39, 36, 38, 40, 5, 23, 
  28, 29, 26, 14, 14, 16, 16, 33, 34, [ 33, 34 ], [ 33, 34 ], 49, 49, 
  48, 48 ]
gap> PositionsProperty( para, IsList );
[ 46, 47 ]
gap> List( repres, map -> map{ [ 44 .. 47 ] } );
[ [ 33, 34, 33, 34 ], [ 33, 34, 34, 33 ] ]
]]></Example>

<P/>

So the question is whether the elements in class 44 are conjugate in <M>G</M>
to the elements in class 46 or in class 47.
In order to answer this question, we compute preimages of the relevant
class representatives in the matrix group <M>M</M>.

<P/>

<Example><![CDATA[
gap> positions:= OnTuples( [ 44 .. 47 ], trans.columns );;
gap> classreps:= List( ConjugacyClasses( t ){ positions },
>        c -> PreImagesRepresentative( iso, Representative( c ) ) );;
gap> traces:= List( classreps, TraceMat );;
gap> List( traces, x -> Position( traces, x ) );
[ 1, 2, 2, 1 ]
]]></Example>

<P/>

We are lucky, already the traces of the elements allow us to decide which
pairs of elements are <M>G</M>-conjugate; there is no need for an explicit
(and expensive) conjugacy test in the matrix group <M>G</M>.

<P/>

Finally, we check whether the stored fusion is correct.

<P/>

<Example><![CDATA[
gap> good:= First( repres,
>                  map -> map{ [ 44 .. 47 ] } = [ 33, 34, 34, 33 ] );;
gap> GetFusionMap( mtbl, 2a12 ) = good;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:127:7_in_L_7(2)">
<Heading><M>127:7 \rightarrow L_7(2)</M> (January 2012)</Heading>

The simple group <M>G = L_7(2)</M> contains a maximal subgroup <M>M</M>
of the type <M>127:7</M> (the normalizer of an extension field type subgroup
GL<M>(1,2^7)</M>) whose class fusion is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "L7(2)" );;
gap> s:= CharacterTable( "127:7" );;
gap> fus:= PossibleClassFusions( s, t );;
gap> repr:= RepresentativesFusions( s, fus, t );
[ [ 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
      112, 113, 114, 115, 117, 116, 76, 76, 77, 76, 77, 77 ], 
  [ 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
      112, 113, 114, 115, 117, 116, 83, 83, 83, 83, 83, 83 ] ]
]]></Example>

<P/>

The two fusion candidates differ only for elements of order <M>7</M>.

<P/>

<Example><![CDATA[
gap> diff:= Filtered( [ 1 .. Length( repr[1] ) ],
>                     i -> repr[1][i] <> repr[2][i] );
[ 20, 21, 22, 23, 24, 25 ]
gap> OrdersClassRepresentatives( s ){ diff };
[ 7, 7, 7, 7, 7, 7 ]
gap> List( repr, l -> l{ diff } );
[ [ 76, 76, 77, 76, 77, 77 ], [ 83, 83, 83, 83, 83, 83 ] ]
gap> SizesCentralizers( t ){ [ 76, 77, 83 ] };
[ 3528, 3528, 49 ]
]]></Example>

<P/>

We can decide which candidate is the correct one if we know the centralizer
order in G of the elements of order <M>7</M> in <M>M</M>.
So we compute this centralizer order.

<P/>

<Example><![CDATA[
gap> g:= Image( IsomorphismPermGroup( GL(7,2) ) );;
gap> repeat x:= Random( g ); until Order(x) = 127;
gap> n:= Normalizer( g, SubgroupNC( g, [ x ] ) );;
gap> Size( n ) / 127;
7
gap> repeat x:= Random( n ); until Order( x ) = 7;
gap> c:= Centralizer( g, x );;
gap> Size( c );
49
]]></Example>

<P/>

We see that the second candidate is the fusion from <M>M</M> into <M>G</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( s, t ) = repr[2];
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L_2(59)_in_M">
<Heading><M>L_2(59) \rightarrow M</M> (May 2009) &ndash; Do not use this!</Heading>

It had been claimed that the sporadic simple Monster group <M>M</M>
contains a maximal subgroup <M>G</M> of the type <M>L_2(59)</M>,
see&nbsp;<Cite Key="HW04"/>.
Later it was shown that <M>M</M> does <E>not</E> contain such subgroups,
see&nbsp;<Cite Key="DLPP24"/>.

<P/>

Here we show that the character tables of <M>G</M> and <M>M</M> do not
provide enough information to determine a unique class fusion.
(In particular, the tables do not help to show that <M>G</M> is not a
subgroup of <M>M</M>.)
The class fusion of <M>G</M> into <M>M</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M" );;
gap> s:= CharacterTable( "L2(59)" );;
gap> fus:= PossibleClassFusions( s, t );;
gap> repr:= RepresentativesFusions( s, fus, t );
[ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 98, 52, 32, 52, 14, 12, 98, 52, 32, 5, 98, 12, 98, 52, 3 ], 
  [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 100, 50, 30, 50, 15, 11, 100, 50, 30, 4, 100, 11, 100, 50, 
      3 ], 
  [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 101, 51, 30, 51, 14, 11, 101, 51, 30, 5, 101, 11, 101, 51, 
      3 ], 
  [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 102, 53, 32, 53, 18, 12, 102, 53, 32, 6, 102, 12, 102, 53, 
      3 ], 
  [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 104, 52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 
      3 ] ]
]]></Example>

<P/>

The candidates differ on the classes of element order <M>30</M>.

<P/>

<Example><![CDATA[
gap> ord:= OrdersClassRepresentatives( s );;
gap> ord30:= Filtered( [ 1 .. Length( ord ) ], i -> ord[i] = 30 );
[ 18, 24, 28, 30 ]
gap> List( repr, x -> x{ ord30 } );
[ [ 98, 98, 98, 98 ], [ 100, 100, 100, 100 ], [ 101, 101, 101, 101 ], 
  [ 102, 102, 102, 102 ], [ 104, 104, 104, 104 ] ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="HW04"/>,
any subgroup <M>G</M> of <M>M</M> must contain elements in the class
<C>30G</C> of <M>M</M>.
This determines the class fusion up to Galois automorphisms.
(But note that we do not store the fusion, since <M>G</M> is not
a subgroup of <M>M</M>.)

<P/>

<Example><![CDATA[
gap> pos:= Position( ClassNames( t, "Atlas" ), "30G" );;
gap> good:= Filtered( fus, map -> pos in map );
[ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 104, 52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 
      3 ], 
  [ 1, 153, 152, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 104, 52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 
      3 ] ]
gap> repr:= RepresentativesFusions( s, good, t );
[ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 
      97, 104, 52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 
      3 ] ]
gap> GetFusionMap( s, t ) = fail;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L2(71)_in_M">
<Heading><M>L_2(71) \rightarrow M</M> (May 2009)</Heading>

The sporadic simple Monster group <M>M</M> contains a maximal subgroup <M>G</M>
of the type <M>L_2(71)</M>, see&nbsp;<Cite Key="HW08"/>.
The class fusion of <M>G</M> into <M>M</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M" );;
gap> s:= CharacterTable( "L2(71)" );;
gap> fus:= PossibleClassFusions( s, t );;
gap> repr:= RepresentativesFusions( s, fus, t );
[ [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 
      112, 112, 11, 19, 112, 112, 114, 60, 36, 27, 114, 17, 114, 27, 
      7, 60, 114, 5, 114, 60, 36, 27, 114, 3 ], 
  [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 
      112, 112, 11, 19, 112, 112, 115, 61, 36, 28, 115, 17, 115, 28, 
      7, 61, 115, 5, 115, 61, 36, 28, 115, 3 ], 
  [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 
      112, 112, 11, 19, 112, 112, 117, 61, 43, 28, 117, 17, 117, 28, 
      9, 61, 117, 5, 117, 61, 43, 28, 117, 3 ], 
  [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 114, 60, 36, 27, 114, 17, 114, 27, 
      7, 60, 114, 5, 114, 60, 36, 27, 114, 3 ], 
  [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 115, 61, 36, 28, 115, 17, 115, 28, 
      7, 61, 115, 5, 115, 61, 36, 28, 115, 3 ], 
  [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 
      9, 61, 117, 5, 117, 61, 43, 28, 117, 3 ] ]
]]></Example>

<P/>

The candidates differ on the classes of the element orders <M>7</M> and
<M>36</M>.

<P/>

<Example><![CDATA[
gap> ord:= OrdersClassRepresentatives( s );;
gap> ord36:= Filtered( [ 1 .. Length( ord ) ], i -> ord[i] = 36 );
[ 21, 25, 27, 31, 33, 37 ]
gap> List( repr, x -> x{ ord36 } );
[ [ 114, 114, 114, 114, 114, 114 ], [ 115, 115, 115, 115, 115, 115 ], 
  [ 117, 117, 117, 117, 117, 117 ], [ 114, 114, 114, 114, 114, 114 ], 
  [ 115, 115, 115, 115, 115, 115 ], [ 117, 117, 117, 117, 117, 117 ] ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="NW02" Where="Table 3"/>,
<M>G</M> contains elements in the classes <C>7B</C> and <C>36D</C> of <M>M</M>.
This determines the class fusion up to Galois automorphisms.

<P/>

<Example><![CDATA[
gap> pos1:= Position( ClassNames( t, "Atlas" ), "7B" );;
gap> pos2:= Position( ClassNames( t, "Atlas" ), "36D" );;
gap> pos:= [ pos1, pos2 ];;
gap> good:= Filtered( fus, map -> IsSubset( map, pos ) );
[ [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 
      9, 61, 117, 5, 117, 61, 43, 28, 117, 3 ], 
  [ 1, 170, 169, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 
      9, 61, 117, 5, 117, 61, 43, 28, 117, 3 ] ]
gap> repr:= RepresentativesFusions( s, good, t );
[ [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 
      113, 113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 
      9, 61, 117, 5, 117, 61, 43, 28, 117, 3 ] ]
gap> GetFusionMap( s, t ) = repr[1];
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:L_2(41)_in_M">
<Heading><M>L_2(41) \rightarrow M</M> (April 2012)</Heading>

The sporadic simple Monster group <M>M</M> contains a maximal subgroup <M>G</M>
of the type <M>L_2(41)</M>, see&nbsp;<Cite Key="NW12"/>.
The class fusion of <M>G</M> into <M>M</M> is ambiguous.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M" );;
gap> s:= CharacterTable( "L2(41)" );;
gap> fus:= PossibleClassFusions( s, t );;
gap> repr:= RepresentativesFusions( s, fus, t );
[ [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 70, 70, 19, 
      70, 70, 19, 4, 70, 19, 70 ], 
  [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 72, 72, 19, 
      72, 72, 19, 6, 72, 19, 72 ], 
  [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ], 
  [ 1, 127, 127, 66, 33, 66, 12, 7, 33, 66, 12, 66, 3, 72, 72, 19, 
      72, 72, 19, 6, 72, 19, 72 ], 
  [ 1, 127, 127, 66, 33, 66, 12, 7, 33, 66, 12, 66, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ], 
  [ 1, 127, 127, 67, 30, 67, 11, 10, 30, 67, 11, 67, 3, 72, 72, 19, 
      72, 72, 19, 6, 72, 19, 72 ], 
  [ 1, 127, 127, 67, 30, 67, 11, 10, 30, 67, 11, 67, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ], 
  [ 1, 127, 127, 68, 32, 68, 12, 10, 32, 68, 12, 68, 3, 72, 72, 19, 
      72, 72, 19, 6, 72, 19, 72 ], 
  [ 1, 127, 127, 68, 32, 68, 12, 10, 32, 68, 12, 68, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ], 
  [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 72, 72, 19, 
      72, 72, 19, 6, 72, 19, 72 ], 
  [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ] ]
]]></Example>

<P/>

The candidates differ on the classes of the element orders
<M>3</M>&ndash;<M>8</M>.

<P/>

<Example><![CDATA[
gap> ambig:= Parametrized( repr );;
gap> ambigpos:= PositionsProperty( ambig, IsList );
[ 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 
  23 ]
gap> Set( OrdersClassRepresentatives( t ){ ambigpos } );
[ 3, 4, 5, 6, 7, 8 ]
]]></Example>

<P/>

According to&nbsp;<Cite Key="NW12" Where="Theorem 3"/>,
<M>G</M> contains elements in the classes <C>3B</C> and <C>4C</C>
of <M>M</M>.
This determines the class fusion uniquely.

<P/>

<Example><![CDATA[
gap> pos1:= Position( ClassNames( t, "Atlas" ), "3B" );;
gap> pos2:= Position( ClassNames( t, "Atlas" ), "4C" );;
gap> pos:= [ pos1, pos2 ];;
gap> good:= Filtered( fus, map -> IsSubset( map, pos ) );
[ [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 73, 73, 20, 
      73, 73, 20, 5, 73, 20, 73 ] ]
gap> GetFusionMap( s, t ) = good[1];
true
]]></Example>

</Subsection>
</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

