% Here are examples of inserting in XML tags to improve the structure and readability of a prompt.
<examples>
    <example_1>
        % Here is an example_raw_prompt that needs XML tagging:
        <example_raw_prompt>
        <examples>
% Here is example_1 of how to split and generate the sub_prompt and modified_prompt:
    example_1_input_prompt: ```<./context/split/1/initial_pdd_python.prompt>```
    example_1_input_code: ```<./context/split/1/pdd.py>```
    example_1_example_code: ```<./context/split/1/split_get_extension.py>```
    example_1_sub_prompt: ```<./context/split/1/sub_pdd_python.prompt>```
    example_1_modified_prompt: ```<./context/split/1/final_pdd_python.prompt>```

% Here is example_2 of how to split and generate the sub_prompt and modified_prompt:
    example_2_input_prompt: ```<./context/split/2/initial_pdd_python.prompt>```
    example_2_input_code: ```<./context/split/2/pdd.py>```
    example_2_example_code: ```<./context/split/2/split_pdd_construct_output_path.py>```
    example_2_sub_prompt: ```<./context/split/2/sub_pdd_python.prompt>```
    example_2_modified_prompt: ```<./context/split/2/final_pdd_python.prompt>```
    
% Here is example_3 of how to split and generate the sub_prompt and modified_prompt:
    example_3_input_prompt: ```<./context/split/3/initial_postprocess_python.prompt>```
    example_3_input_code: ```<./context/split/3/postprocess.py>```
    example_3_example_code: ```<./context/split/3/split_postprocess_find_section.py>```
    example_3_sub_prompt: ```<./context/split/3/sub_postprocess_python.prompt>```
    example_3_modified_prompt: ```<./context/split/3/final_postprocess_python.prompt>```

% Here is example_4 of how to split and generate the sub_prompt and modified_prompt:
    example_4_input_prompt: ```<./context/split/4/initial_construct_paths_python.prompt>```
    example_4_input_code: ```<./context/split/4/construct_paths.py>```
    example_4_example_code: ```<./context/split/4/split_construct_paths_generate_output_filename.py>```
    example_4_sub_prompt: ```<./context/split/4/sub_construct_paths_python.prompt>```
    example_4_modified_prompt: ```<./context/split/4/final_construct_paths_python.prompt>```
</examples>

% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality. 

% Here are the inputs and outputs of this prompt:
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.

% Here is the input_prompt to split: ```{input_prompt}```
% Here is the input_code: ```{input_code}```
% Here is the example_code: ```{example_code}```

% Follow these instructions:
    1. Write out the difficulties in spliting the prompt
    2. Write out how to overcome the difficulties
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
        </example_raw_prompt>

        % Here is an example_tagged_prompt from the example_raw_prompt above:
        <example_tagged_prompt>
        <examples>
    <example_1>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name so the right code file extension (e.g. '.sh' for bash, '' for makefile, '.py' for Python) and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the command line program "pdd" as described, we will use Python's `argparse` for command line argument parsing, and the `rich` library for pretty printing. The program will handle both prompt files and code files, generating runnable code and example code as specified.

# Here's a complete implementation of the `pdd` program:

# ```python
import os
import sys
import argparse
from rich.console import Console
from rich.prompt import Confirm
from code_generator import code_generator
from context_generator import context_generator

console = Console()

def get_file_paths(input_file, output_file, example_output_file):
    # Extract basename and language from the input file
    basename, ext = os.path.splitext(os.path.basename(input_file))
    language = ext[1:]  # Remove the dot

    # Determine output file paths
    if output_file:
        runnable_file_path = output_file
    else:
        runnable_file_path = os.path.join(os.path.dirname(input_file), f"{basename}.{get_extension(language)}")

    if example_output_file:
        example_file_path = example_output_file
    else:
        example_file_path = os.path.join(os.path.dirname(input_file), f"{basename}_example.{get_example_extension(language)}")

    return runnable_file_path, example_file_path

def get_extension(language):
    extensions = {
        'python': 'py',
        'bash': 'sh',
        'makefile': 'mk',
        # Add more languages and their extensions as needed
    }
    return extensions.get(language, '')

def get_example_extension(language):
    return 'py'  # Assuming example files are always Python files for simplicity

def confirm_overwrite(file_path):
    if os.path.exists(file_path):
        return Confirm.ask(f"{file_path} already exists. Do you want to overwrite it?", default=True)
    return True

def main():
    parser = argparse.ArgumentParser(description="Compile prompts into code files or generate example code from code files.")
    parser.add_argument('input', help='Input prompt file or code file to generate example from')
    parser.add_argument('-o', '--output', help='Path or filename of the output runnable code')
    parser.add_argument('-oe', '--output-example', help='Path or filename of the output example code')
    parser.add_argument('--force', action='store_true', help='Force overwrite existing files without confirmation')

    args = parser.parse_args()

    input_file = args.input
    if not input_file.endswith('.prompt'):
        if not os.path.splitext(input_file)[1]:  # No extension, assume it's a code file
            input_file += '.prompt'
    
    # Determine if input is a prompt or code file
    is_prompt = input_file.endswith('.prompt')
    
    # Get output file paths
    runnable_file_path, example_file_path = get_file_paths(input_file, args.output, args.output_example)

    # Handle the runnable code generation
    if is_prompt:
        console.print(f"[bold green]Generating runnable code from prompt: {input_file}[/bold green]")
        runnable_code = code_generator(input_file, get_extension(os.path.splitext(input_file)[1][1:]))
        
        if not args.force and not confirm_overwrite(runnable_file_path):
            console.print("[bold red]Operation cancelled.[/bold red]")
            return
        
        with open(runnable_file_path, 'w') as f:
            f.write(runnable_code)
        console.print(f"[bold blue]Runnable code written to: {runnable_file_path}[/bold blue]")

    # Handle example code generation
    if not is_prompt or args.output_example:
        console.print(f"[bold green]Generating example code from: {runnable_file_path}[/bold green]")
        success = context_generator(runnable_file_path, example_file_path, force=args.force)

        if success:
            console.print(f"[bold blue]Example code written to: {example_file_path}[/bold blue]")
        else:
            console.print("[bold red]Example generation failed.[/bold red]")

if __name__ == "__main__":
    main()
# ```

# ### Explanation of the Code:
# 1. **Imports**: We import necessary modules including `argparse` for command line parsing, `os` for file path manipulations, and `rich` for console output.
# 2. **Functions**:
#    - `get_file_paths`: Determines the output file paths based on the input file and user-specified options.
#    - `get_extension` and `get_example_extension`: Return the appropriate file extensions based on the language.
#    - `confirm_overwrite`: Asks the user for confirmation if a file already exists.
# 3. **Main Function**:
#    - Parses command line arguments.
#    - Checks if the input file is a prompt or a code file.
#    - Generates runnable code from the prompt file and writes it to the specified output path.
#    - Generates example code from the runnable code if specified.
# 4. **Execution**: The script runs the `main` function when executed.

# ### Usage:
# - To run the program, save it as `pdd.py` and execute it from the command line:
#   ```bash
#   python pdd.py <input_prompt_file or input_code_file_to_generate_example_from> [options]
#   ```

# ### Requirements:
# - Ensure you have the `rich`, `langchain`, and `tiktoken` libraries installed, along with the `code_generator` and `context_generator` modules available in your environment.</input_code>
    <example_code>file_extension = get_extension(language)</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a python function, "get_extension", that will return the file extension associated with a given language. 

% Here are the inputs and outputs of the function:
    Input: 'language' - A string containing the language (e.g. Bash, Makefile, Python).
    Output: returns a string that is the extension for the langauge

% This program will do the following:
    Step 1. Lower case the language string to make the comparison case insensitive.
    Step 2. Look up the file extension for the given language
    Step 3. Return the file extension</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_1>

    <example_2>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the `pdd` command line program as described, we need to follow the steps outlined in the prompt. Below is the implementation of the `pdd` program in Python. This program will use the `rich` library for pretty printing and handle the various input and output scenarios as specified.

# First, ensure you have the necessary modules installed:
# ```sh
# pip install rich
# ```

# Next, create the `pdd.py` script:

# ```python
import os
import sys
import argparse
from rich.console import Console
from code_generator import code_generator
from context_generator import context_generator
from get_extension import get_extension

console = Console()

def main():
    parser = argparse.ArgumentParser(description="Compile a prompt into a code file or a code file into an example code file.")
    parser.add_argument('input_file', help="Input prompt file or input code file to generate example from")
    parser.add_argument('-o', '--output', help="Path or filename of the output of the runnable code")
    parser.add_argument('-oe', '--output_example', help="Path or filename of the output example code")
    parser.add_argument('--force', action='store_true', help="Overwrite files without asking")

    args = parser.parse_args()
    input_file = args.input_file
    output = args.output
    output_example = args.output_example
    force = args.force

    # Step 1: Read the input file name from the command line
    if not os.path.exists(input_file):
        console.print(f"[bold red]Error:[/bold red] The file '{input_file}' does not exist.")
        sys.exit(1)

    # Step 2: If file name has no extension, add '.prompt' to the file name
    if '.' not in input_file:
        input_file += '.prompt'

    # Step 3: Extract the basename and language from the file name
    basename, ext = os.path.splitext(os.path.basename(input_file))
    if ext == '.prompt':
        language = basename.split('_')[-1]
    else:
        language = ext[1:]

    file_extension = get_extension(language)

    # Step 4: Generate the appropriate file paths for the runnable and example output files
    def construct_output_path(output, default_name):
        if output is None:
            return os.path.join(os.path.dirname(input_file), default_name)
        elif os.path.isdir(output):
            return os.path.join(output, default_name)
        else:
            return output

    runnable_output_path = construct_output_path(output, f"{basename}{file_extension}")
    example_output_path = construct_output_path(output_example, f"{basename}_example{file_extension}")

    # Step 5: If a prompt input, generate code from the input prompt file name using code_generator
    if ext == '.prompt':
        console.print(f"[bold green]Generating runnable code from prompt:[/bold green] {input_file}")
        runnable_code = code_generator(input_file, language)
        write_to_file(runnable_output_path, runnable_code, force)

    # Step 6: If a code file is provided or a "-oe" option is provided, generate example code
    if ext != '.prompt' or output_example:
        console.print(f"[bold green]Generating example code from runnable code:[/bold green] {runnable_output_path}")
        success = context_generator(runnable_output_path, example_output_path, force)
        if success:
            console.print(f"[bold green]Example code generated successfully:[/bold green] {example_output_path}")
        else:
            console.print(f"[bold red]Failed to generate example code.[/bold red]")

def write_to_file(file_path, content, force):
    if os.path.exists(file_path) and not force:
        console.print(f"[bold yellow]Warning:[/bold yellow] The file '{file_path}' already exists. Overwrite? [y/N]")
        response = input().strip().lower()
        if response not in ['y', 'yes', '']:
            console.print(f"[bold red]Aborted:[/bold red] The file '{file_path}' was not overwritten.")
            return

    with open(file_path, 'w') as f:
        f.write(content)
    console.print(f"[bold green]File written successfully:[/bold green] {file_path}")

if __name__ == "__main__":
    main()
# ```

# ### Explanation:
# 1. **Argument Parsing**: The script uses `argparse` to handle command-line arguments.
# 2. **File Existence Check**: It checks if the input file exists.
# 3. **File Extension Handling**: If the input file has no extension, `.prompt` is added.
# 4. **Basename and Language Extraction**: The script extracts the basename and language from the input file name.
# 5. **Output Path Construction**: It constructs the appropriate output paths for runnable and example files.
# 6. **Code Generation**: If the input is a prompt file, it generates runnable code using `code_generator`.
# 7. **Example Code Generation**: If the input is a code file or the `-oe` option is provided, it generates example code using `context_generator`.
# 8. **File Writing**: The script writes the generated code to the specified output files, handling overwrites based on the `--force` option.

# This script should be placed in a file named `pdd.py` and can be executed from the command line as described in the prompt.</input_code>
    <example_code>runnable_output_path, example_output_path = construct_output_paths(
    basename, # the basename of the file
    file_extension, # the file extension based on the language
    argv_output_path, # string from the '-o' flag
    argv_example_output_path # string from the '-oe' flag
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function, "construct_output_paths", that will generate the appropriate file paths for the runnable and example output files that will be called by "pdd", the top-level command line program.

% Here are the inputs and outputs of the function:
    Inputs:
    - 'basename': A string containing the basename of the file
    - 'file_extension': A string containing the file extension based on the language
    - 'argv_output_path': A string from the '-o' flag (can be None)
    - 'argv_example_output_path': A string from the '-oe' flag (can be None)
    Outputs:
    - Returns a tuple containing two strings: (runnable_output_path, example_output_path)

% Consider the four possibilities for the output files as described in the main prompt:
    - File name given without path
    - File name given with path
    - Path given without file name
    - Nothing specified by user (default)

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% This function will do the following:
    Step 1: Define a helper function to construct the output path based on the given arguments and default name.
    Step 2: Use the helper function to construct the runnable_output_path using basename, file_extension, and argv_output_path.
    Step 3: Use the helper function to construct the example_output_path using basename, file_extension, and argv_example_output_path.
    Step 4: Return the tuple (runnable_output_path, example_output_path).
</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code.
    '-oe': Means program should generate example from runnable code.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example how to construct output paths: ```<./context/construct_output_paths_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. Use construct_output_paths to generate the appropriate file paths for the runnable and example output files.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_2>

    <example_3>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Find the top-level code sections via recursive function, 'find_section'. For a code section, the first backtick will always have a string right after it that determines what kind of code it is and the end of a section just has triple backticks. To properly return the list of top level-sections do the following sub-steps by iterating through lines of the string:
        Step 2a. Find the start of a code block 
        Step 2b. If another start of another code block is found, call 'find_section' recursively with a sub-section flag True. 
        Step 2c. If not, but the end of a code block is found, we should do one of the following steps depending on the sub-section flag:
            Step 2c_i: If it is a sub-section we should return with an empty list
            Step 2c_ii: If it is not a sub-section we should know the end of the code block and we should record the program type and start/end lines into the output list
        Step 2d. If all lines of the string are process, we should return the output list.
    Step 3. For the sections that are the same as file_type, we will determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure the also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</input_prompt>
    <input_code>from pdd.get_comment import get_comment
from pdd.comment_line import comment_line

def find_section(lines, start_index=0, sub_section=False):
    sections = []
    i = start_index
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('```'):
            # Start of a code block
            if len(line) > 3:
                # Extract the language from the line
                code_language = line[3:].strip()
                start_line = i
                i += 1
                # Find the end of the code block
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    i += 1
                if i < len(lines):
                    end_line = i
                    if not sub_section:
                        sections.append((code_language, start_line, end_line))
                    else:
                        return []
            else:
                # End of a code block without a language
                if sub_section:
                    return []
        i += 1
    return sections

def postprocess(llm_output, language):
    # Step 1: Get the comment character for the specified language
    comment_characters = get_comment(language)
    
    # Step 2: Find the top-level code sections
    lines = llm_output.splitlines()
    sections = find_section(lines)
    
    # Step 3: Find the largest section of the specified file_type
    largest_section = None
    max_length = 0
    for section in sections:
        code_language, start_line, end_line = section
        if code_language.lower() == language.lower():
            length = end_line - start_line
            if length > max_length:
                max_length = length
                largest_section = section
    
    # Step 4: Comment out all lines except the largest section
    if largest_section:
        _, start_line, end_line = largest_section
        processed_lines = []
        for i, line in enumerate(lines):
            if i < start_line or i > end_line:
                processed_lines.append(comment_line(line, comment_characters))
            else:
                processed_lines.append(line)
        return '\n'.join(processed_lines)
    
    # If no section matches the language, comment out everything
    return '\n'.join(comment_line(line, comment_characters) for line in lines)</input_code>
    <example_code>sections = find_section(
    lines, # splitlines of text, an array of lines of text
    start_index=0, # start index/row of the line, default is row 0
    sub_section=False # boolean to check if it is a sub-section, default is no
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function called 'find_section' that will find top-level code sections in a string output from an LLM.

% Here are the inputs and outputs of the function:
    Inputs:
        'lines' - A list of strings, where each string is a line from the LLM output.
        'start_index' - An integer representing the starting index to begin searching (default is 0).
        'sub_section' - A boolean flag indicating whether this is a recursive call for a sub-section (default is False).
    Output: returns a list of tuples, where each tuple contains (code_language, start_line, end_line) for each top-level code section found.

% Here is an example of how the function might be called:
```python
lines = llm_output.splitlines()
sections = find_section(lines)
```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% This function will do the following:
    Step 1. Initialize an empty list to store the sections found.
    Step 2. Iterate through the lines starting from start_index:
        Step 2a. Find the start of a code block (line starting with triple backticks).
        Step 2b. If another start of a code block is found, call 'find_section' recursively with sub_section flag set to True.
        Step 2c. If the end of a code block is found (line with just triple backticks), do one of the following steps depending on the sub_section flag:
            Step 2c_i: If it is a sub-section, return an empty list.
            Step 2c_ii: If it is not a sub-section, record the program type and start/end lines into the output list.
    Step 3. Return the list of sections found.</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example how to find code sections in LLM output: ```<./context/find_section_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Use the find_section function to find the top-level code sections in the llm_output.
    Step 3. For the sections that are the same as file_type, determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure to also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</modified_prompt>
    </example_3>

    <example_4>
    <input_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will will be used by pdd to do this function. All output to the console will be pretty print using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
    - 'input_file_paths' (dict) - A dictionary to the paths of the input files with the keys being those specified in the examples from the pdd program description.
    - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
    - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
    - 'command' (string) - pdd command that was run.
    - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
    - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
    - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
    - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using a separate sub-function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</input_prompt>
    <input_code>import os
import click
from rich import print
from get_extension import get_extension

def generate_output_filename(command, key, basename, language, file_extension):
    if command == 'generate':
        return f"{basename}{file_extension}"
    elif command == 'example':
        return f"{basename}_example{file_extension}"
    elif command == 'test':
        return f"test_{basename}{file_extension}"
    elif command == 'preprocess':
        return f"{basename}_{language or 'unknown'}_preprocessed.prompt"
    elif command == 'fix':
        if key == 'output-test':
            return f"test_{basename}_fixed{file_extension}"
        else:
            return f"{basename}_fixed{file_extension}"
    else:
        return f"{basename}_output{file_extension}"

def construct_paths(input_file_paths, force, quiet, command, command_options):
    input_strings = {}
    output_file_paths = {}
    language = None

    def print_if_not_quiet(message):
        if not quiet:
            print(message)

    # Step 1: Construct the input file paths
    for key, path in input_file_paths.items():
        if not os.path.splitext(path)[1]:
            if command == 'generate':
                path += '.prompt'
            input_file_paths[key] = path
        
        print_if_not_quiet(f"Input file path for {key}: {path}")

    # Step 2: Load the input files
    for key, path in input_file_paths.items():
        try:
            with open(path, 'r') as file:
                input_strings[key] = file.read()
            print_if_not_quiet(f"Loaded input file: {path}")
        except IOError as e:
            print(f"[bold red]Error loading input file {path}: {str(e)}[/bold red]")
            return None, None, None

    # Extract basename and language
    prompt_file = input_file_paths.get('PROMPT_FILE', '')
    basename, ext = os.path.splitext(os.path.basename(prompt_file))
    parts = basename.split('_')
    if len(parts) > 1:
        language = parts[-1]
        basename = '_'.join(parts[:-1])
    else:
        language = ext[1:]  # Remove the leading dot
    
    if language:
        file_extension = get_extension(language)
    else:
        file_extension = '.txt'
        print(f"[bold yellow]Warning: Could not determine language. Using .txt as default file extension.[/bold yellow]")

    print_if_not_quiet(f"Extracted basename: {basename}, language: {language}, File extension: {file_extension}")

    # Step 3: Construct the output file paths
    for key in command_options:
        if key.startswith('output'):
            output_path = command_options[key]
            if output_path:
                if os.path.isdir(output_path):
                    filename = generate_output_filename(command, key, basename, language, file_extension)
                    output_path = os.path.join(output_path, filename)
                elif not os.path.splitext(output_path)[1]:
                    output_path += file_extension
            else:
                output_path = generate_output_filename(command, key, basename, language, file_extension)
            
            output_file_paths[key] = os.path.abspath(output_path)
            print_if_not_quiet(f"Output file path for {key}: {output_file_paths[key]}")

    # Step 4: Check if output files exist and confirm overwrite if necessary
    for key, path in output_file_paths.items():
        if os.path.exists(path) and not force:
            if not click.confirm(f"Output file {path} already exists. Overwrite?"):
                print(f"[bold yellow]Operation cancelled for {key}.[/bold yellow]")
                return None, None, None

    # Step 5: Return the outputs
    return input_strings, output_file_paths, language</input_code>
    <example_code>filename = generate_output_filename(
    command, # pdd commands like 'generate', etc.
    key, # output dictionary key like 'output', 'output-test', etc.
    basename, # the basename of the file
    language, # the language of the file
    file_extension # the file extension of the file
    )</example_code>
    <sub_prompt>% You are an expert Python software engineer. Your task is to implement a function called `generate_output_filename` that creates appropriate output filenames for different commands in a Python program.

% Inputs: The function should take the following parameters:
    - `command` (string): The command being executed (e.g., 'generate', 'example', 'test', 'preprocess', 'fix')
    - `key` (string): The output dictionary key (e.g., 'output', 'output-test')
    - `basename` (string): The base name of the file
    - `language` (string): The programming language of the file
    - `file_extension` (string): The file extension to be used

% Outputs: The function should return a string representing the generated output filename.

% Follow these rules for generating the output filename:
    1. For the 'generate' command: Return `f"{basename}{file_extension}"`
    2. For the 'example' command: Return `f"{basename}_example{file_extension}"`
    3. For the 'test' command: Return `f"test_{basename}{file_extension}"`
    4. For the 'preprocess' command: Return `f"{basename}_{language or 'unknown'}_preprocessed.prompt"`
    5. For the 'fix' command:
    - If the key is 'output-test', return `f"test_{basename}_fixed{file_extension}"`
    - Otherwise, return `f"{basename}_fixed{file_extension}"`
    6. For any other command: Return `f"{basename}_output{file_extension}"`

% Implement the function to handle all these cases efficiently and return the appropriate filename as a string, accordingly.

% Ensure the function handles all cases correctly and returns the appropriate filename string, language, and file extension. The function should be robust and able to handle various edge cases, such as missing file extensions or languages.</sub_prompt>
    <modified_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will be used by pdd to perform this functionality. All output to the console will be pretty printed using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example of how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example of how to generate the appropriate output filenames based on the command, key, basename, language, and file extension using the `generate_output_filename` function: ```<./context/generate_output_filename_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
        - 'input_file_paths' (dict) - A dictionary of the paths of the input files with the keys being those specified in the examples from the pdd program description.
        - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
        - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
        - 'command' (string) - pdd command that was run.
        - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
        - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
        - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
        - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using the `generate_output_filename` function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</modified_prompt>
    </example_4>
</examples>

<context>
% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality.

% Here are the inputs and outputs of this prompt:
    <input_definitions>
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    </input_definitions>
    <output_definitions>
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.
    </output_definitions>
</context>

<inputs>
    <input_prompt>{input_prompt}</input_prompt>
    <input_code>{input_code}</input_code>
    <example_code>{example_code}</example_code>
</inputs>

<instructions>
% Follow these instructions:
    1. Write out the difficulties in spliting the prompt.
    2. Write out how to overcome the difficulties.
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
</instructions>

        </example_tagged_prompt>
    </example_1>

    <example_2>
        % Here is an example_raw_prompt that needs XML tagging:
        <example_raw_prompt>
        % You are an expert Prompt Engineer. Your goal is to enhance a given prompt by only adding XML tags where necessary to improve its structure and readability. Do not add any additional content or XML tags unless it is clearly required by the structure of the input_raw_prompt.

% Here is the input_raw_prompt that needs XML tagging to improve its organization: <input_raw_prompt>{raw_prompt}</input_raw_prompt>

<example>
    % Here is an example_raw_prompt that needs XML tagging:
    <example_raw_prompt>
    <examples>
% Here is example_1 of how to split and generate the sub_prompt and modified_prompt:
    example_1_input_prompt: ```<./context/split/1/initial_pdd_python.prompt>```
    example_1_input_code: ```<./context/split/1/pdd.py>```
    example_1_example_code: ```<./context/split/1/split_get_extension.py>```
    example_1_sub_prompt: ```<./context/split/1/sub_pdd_python.prompt>```
    example_1_modified_prompt: ```<./context/split/1/final_pdd_python.prompt>```

% Here is example_2 of how to split and generate the sub_prompt and modified_prompt:
    example_2_input_prompt: ```<./context/split/2/initial_pdd_python.prompt>```
    example_2_input_code: ```<./context/split/2/pdd.py>```
    example_2_example_code: ```<./context/split/2/split_pdd_construct_output_path.py>```
    example_2_sub_prompt: ```<./context/split/2/sub_pdd_python.prompt>```
    example_2_modified_prompt: ```<./context/split/2/final_pdd_python.prompt>```
    
% Here is example_3 of how to split and generate the sub_prompt and modified_prompt:
    example_3_input_prompt: ```<./context/split/3/initial_postprocess_python.prompt>```
    example_3_input_code: ```<./context/split/3/postprocess.py>```
    example_3_example_code: ```<./context/split/3/split_postprocess_find_section.py>```
    example_3_sub_prompt: ```<./context/split/3/sub_postprocess_python.prompt>```
    example_3_modified_prompt: ```<./context/split/3/final_postprocess_python.prompt>```

% Here is example_4 of how to split and generate the sub_prompt and modified_prompt:
    example_4_input_prompt: ```<./context/split/4/initial_construct_paths_python.prompt>```
    example_4_input_code: ```<./context/split/4/construct_paths.py>```
    example_4_example_code: ```<./context/split/4/split_construct_paths_generate_output_filename.py>```
    example_4_sub_prompt: ```<./context/split/4/sub_construct_paths_python.prompt>```
    example_4_modified_prompt: ```<./context/split/4/final_construct_paths_python.prompt>```
</examples>

% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality. 

% Here are the inputs and outputs of this prompt:
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.

% Here is the input_prompt to split: ```{input_prompt}```
% Here is the input_code: ```{input_code}```
% Here is the example_code: ```{example_code}```

% Follow these instructions:
    1. Write out the difficulties in spliting the prompt
    2. Write out how to overcome the difficulties
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
    </example_raw_prompt>

    % Here is an example_tagged_prompt from the example_raw_prompt above:
    <example_tagged_prompt>
    <examples>
    <example_1>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name so the right code file extension (e.g. '.sh' for bash, '' for makefile, '.py' for Python) and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the command line program "pdd" as described, we will use Python's `argparse` for command line argument parsing, and the `rich` library for pretty printing. The program will handle both prompt files and code files, generating runnable code and example code as specified.

# Here's a complete implementation of the `pdd` program:

# ```python
import os
import sys
import argparse
from rich.console import Console
from rich.prompt import Confirm
from code_generator import code_generator
from context_generator import context_generator

console = Console()

def get_file_paths(input_file, output_file, example_output_file):
    # Extract basename and language from the input file
    basename, ext = os.path.splitext(os.path.basename(input_file))
    language = ext[1:]  # Remove the dot

    # Determine output file paths
    if output_file:
        runnable_file_path = output_file
    else:
        runnable_file_path = os.path.join(os.path.dirname(input_file), f"{basename}.{get_extension(language)}")

    if example_output_file:
        example_file_path = example_output_file
    else:
        example_file_path = os.path.join(os.path.dirname(input_file), f"{basename}_example.{get_example_extension(language)}")

    return runnable_file_path, example_file_path

def get_extension(language):
    extensions = {
        'python': 'py',
        'bash': 'sh',
        'makefile': 'mk',
        # Add more languages and their extensions as needed
    }
    return extensions.get(language, '')

def get_example_extension(language):
    return 'py'  # Assuming example files are always Python files for simplicity

def confirm_overwrite(file_path):
    if os.path.exists(file_path):
        return Confirm.ask(f"{file_path} already exists. Do you want to overwrite it?", default=True)
    return True

def main():
    parser = argparse.ArgumentParser(description="Compile prompts into code files or generate example code from code files.")
    parser.add_argument('input', help='Input prompt file or code file to generate example from')
    parser.add_argument('-o', '--output', help='Path or filename of the output runnable code')
    parser.add_argument('-oe', '--output-example', help='Path or filename of the output example code')
    parser.add_argument('--force', action='store_true', help='Force overwrite existing files without confirmation')

    args = parser.parse_args()

    input_file = args.input
    if not input_file.endswith('.prompt'):
        if not os.path.splitext(input_file)[1]:  # No extension, assume it's a code file
            input_file += '.prompt'
    
    # Determine if input is a prompt or code file
    is_prompt = input_file.endswith('.prompt')
    
    # Get output file paths
    runnable_file_path, example_file_path = get_file_paths(input_file, args.output, args.output_example)

    # Handle the runnable code generation
    if is_prompt:
        console.print(f"[bold green]Generating runnable code from prompt: {input_file}[/bold green]")
        runnable_code = code_generator(input_file, get_extension(os.path.splitext(input_file)[1][1:]))
        
        if not args.force and not confirm_overwrite(runnable_file_path):
            console.print("[bold red]Operation cancelled.[/bold red]")
            return
        
        with open(runnable_file_path, 'w') as f:
            f.write(runnable_code)
        console.print(f"[bold blue]Runnable code written to: {runnable_file_path}[/bold blue]")

    # Handle example code generation
    if not is_prompt or args.output_example:
        console.print(f"[bold green]Generating example code from: {runnable_file_path}[/bold green]")
        success = context_generator(runnable_file_path, example_file_path, force=args.force)

        if success:
            console.print(f"[bold blue]Example code written to: {example_file_path}[/bold blue]")
        else:
            console.print("[bold red]Example generation failed.[/bold red]")

if __name__ == "__main__":
    main()
# ```

# ### Explanation of the Code:
# 1. **Imports**: We import necessary modules including `argparse` for command line parsing, `os` for file path manipulations, and `rich` for console output.
# 2. **Functions**:
#    - `get_file_paths`: Determines the output file paths based on the input file and user-specified options.
#    - `get_extension` and `get_example_extension`: Return the appropriate file extensions based on the language.
#    - `confirm_overwrite`: Asks the user for confirmation if a file already exists.
# 3. **Main Function**:
#    - Parses command line arguments.
#    - Checks if the input file is a prompt or a code file.
#    - Generates runnable code from the prompt file and writes it to the specified output path.
#    - Generates example code from the runnable code if specified.
# 4. **Execution**: The script runs the `main` function when executed.

# ### Usage:
# - To run the program, save it as `pdd.py` and execute it from the command line:
#   ```bash
#   python pdd.py <input_prompt_file or input_code_file_to_generate_example_from> [options]
#   ```

# ### Requirements:
# - Ensure you have the `rich`, `langchain`, and `tiktoken` libraries installed, along with the `code_generator` and `context_generator` modules available in your environment.</input_code>
    <example_code>file_extension = get_extension(language)</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a python function, "get_extension", that will return the file extension associated with a given language. 

% Here are the inputs and outputs of the function:
    Input: 'language' - A string containing the language (e.g. Bash, Makefile, Python).
    Output: returns a string that is the extension for the langauge

% This program will do the following:
    Step 1. Lower case the language string to make the comparison case insensitive.
    Step 2. Look up the file extension for the given language
    Step 3. Return the file extension</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_1>

    <example_2>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the `pdd` command line program as described, we need to follow the steps outlined in the prompt. Below is the implementation of the `pdd` program in Python. This program will use the `rich` library for pretty printing and handle the various input and output scenarios as specified.

# First, ensure you have the necessary modules installed:
# ```sh
# pip install rich
# ```

# Next, create the `pdd.py` script:

# ```python
import os
import sys
import argparse
from rich.console import Console
from code_generator import code_generator
from context_generator import context_generator
from get_extension import get_extension

console = Console()

def main():
    parser = argparse.ArgumentParser(description="Compile a prompt into a code file or a code file into an example code file.")
    parser.add_argument('input_file', help="Input prompt file or input code file to generate example from")
    parser.add_argument('-o', '--output', help="Path or filename of the output of the runnable code")
    parser.add_argument('-oe', '--output_example', help="Path or filename of the output example code")
    parser.add_argument('--force', action='store_true', help="Overwrite files without asking")

    args = parser.parse_args()
    input_file = args.input_file
    output = args.output
    output_example = args.output_example
    force = args.force

    # Step 1: Read the input file name from the command line
    if not os.path.exists(input_file):
        console.print(f"[bold red]Error:[/bold red] The file '{input_file}' does not exist.")
        sys.exit(1)

    # Step 2: If file name has no extension, add '.prompt' to the file name
    if '.' not in input_file:
        input_file += '.prompt'

    # Step 3: Extract the basename and language from the file name
    basename, ext = os.path.splitext(os.path.basename(input_file))
    if ext == '.prompt':
        language = basename.split('_')[-1]
    else:
        language = ext[1:]

    file_extension = get_extension(language)

    # Step 4: Generate the appropriate file paths for the runnable and example output files
    def construct_output_path(output, default_name):
        if output is None:
            return os.path.join(os.path.dirname(input_file), default_name)
        elif os.path.isdir(output):
            return os.path.join(output, default_name)
        else:
            return output

    runnable_output_path = construct_output_path(output, f"{basename}{file_extension}")
    example_output_path = construct_output_path(output_example, f"{basename}_example{file_extension}")

    # Step 5: If a prompt input, generate code from the input prompt file name using code_generator
    if ext == '.prompt':
        console.print(f"[bold green]Generating runnable code from prompt:[/bold green] {input_file}")
        runnable_code = code_generator(input_file, language)
        write_to_file(runnable_output_path, runnable_code, force)

    # Step 6: If a code file is provided or a "-oe" option is provided, generate example code
    if ext != '.prompt' or output_example:
        console.print(f"[bold green]Generating example code from runnable code:[/bold green] {runnable_output_path}")
        success = context_generator(runnable_output_path, example_output_path, force)
        if success:
            console.print(f"[bold green]Example code generated successfully:[/bold green] {example_output_path}")
        else:
            console.print(f"[bold red]Failed to generate example code.[/bold red]")

def write_to_file(file_path, content, force):
    if os.path.exists(file_path) and not force:
        console.print(f"[bold yellow]Warning:[/bold yellow] The file '{file_path}' already exists. Overwrite? [y/N]")
        response = input().strip().lower()
        if response not in ['y', 'yes', '']:
            console.print(f"[bold red]Aborted:[/bold red] The file '{file_path}' was not overwritten.")
            return

    with open(file_path, 'w') as f:
        f.write(content)
    console.print(f"[bold green]File written successfully:[/bold green] {file_path}")

if __name__ == "__main__":
    main()
# ```

# ### Explanation:
# 1. **Argument Parsing**: The script uses `argparse` to handle command-line arguments.
# 2. **File Existence Check**: It checks if the input file exists.
# 3. **File Extension Handling**: If the input file has no extension, `.prompt` is added.
# 4. **Basename and Language Extraction**: The script extracts the basename and language from the input file name.
# 5. **Output Path Construction**: It constructs the appropriate output paths for runnable and example files.
# 6. **Code Generation**: If the input is a prompt file, it generates runnable code using `code_generator`.
# 7. **Example Code Generation**: If the input is a code file or the `-oe` option is provided, it generates example code using `context_generator`.
# 8. **File Writing**: The script writes the generated code to the specified output files, handling overwrites based on the `--force` option.

# This script should be placed in a file named `pdd.py` and can be executed from the command line as described in the prompt.</input_code>
    <example_code>runnable_output_path, example_output_path = construct_output_paths(
    basename, # the basename of the file
    file_extension, # the file extension based on the language
    argv_output_path, # string from the '-o' flag
    argv_example_output_path # string from the '-oe' flag
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function, "construct_output_paths", that will generate the appropriate file paths for the runnable and example output files that will be called by "pdd", the top-level command line program.

% Here are the inputs and outputs of the function:
    Inputs:
    - 'basename': A string containing the basename of the file
    - 'file_extension': A string containing the file extension based on the language
    - 'argv_output_path': A string from the '-o' flag (can be None)
    - 'argv_example_output_path': A string from the '-oe' flag (can be None)
    Outputs:
    - Returns a tuple containing two strings: (runnable_output_path, example_output_path)

% Consider the four possibilities for the output files as described in the main prompt:
    - File name given without path
    - File name given with path
    - Path given without file name
    - Nothing specified by user (default)

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% This function will do the following:
    Step 1: Define a helper function to construct the output path based on the given arguments and default name.
    Step 2: Use the helper function to construct the runnable_output_path using basename, file_extension, and argv_output_path.
    Step 3: Use the helper function to construct the example_output_path using basename, file_extension, and argv_example_output_path.
    Step 4: Return the tuple (runnable_output_path, example_output_path).
</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code.
    '-oe': Means program should generate example from runnable code.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example how to construct output paths: ```<./context/construct_output_paths_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. Use construct_output_paths to generate the appropriate file paths for the runnable and example output files.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_2>

    <example_3>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Find the top-level code sections via recursive function, 'find_section'. For a code section, the first backtick will always have a string right after it that determines what kind of code it is and the end of a section just has triple backticks. To properly return the list of top level-sections do the following sub-steps by iterating through lines of the string:
        Step 2a. Find the start of a code block 
        Step 2b. If another start of another code block is found, call 'find_section' recursively with a sub-section flag True. 
        Step 2c. If not, but the end of a code block is found, we should do one of the following steps depending on the sub-section flag:
            Step 2c_i: If it is a sub-section we should return with an empty list
            Step 2c_ii: If it is not a sub-section we should know the end of the code block and we should record the program type and start/end lines into the output list
        Step 2d. If all lines of the string are process, we should return the output list.
    Step 3. For the sections that are the same as file_type, we will determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure the also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</input_prompt>
    <input_code>from pdd.get_comment import get_comment
from pdd.comment_line import comment_line

def find_section(lines, start_index=0, sub_section=False):
    sections = []
    i = start_index
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('```'):
            # Start of a code block
            if len(line) > 3:
                # Extract the language from the line
                code_language = line[3:].strip()
                start_line = i
                i += 1
                # Find the end of the code block
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    i += 1
                if i < len(lines):
                    end_line = i
                    if not sub_section:
                        sections.append((code_language, start_line, end_line))
                    else:
                        return []
            else:
                # End of a code block without a language
                if sub_section:
                    return []
        i += 1
    return sections

def postprocess(llm_output, language):
    # Step 1: Get the comment character for the specified language
    comment_characters = get_comment(language)
    
    # Step 2: Find the top-level code sections
    lines = llm_output.splitlines()
    sections = find_section(lines)
    
    # Step 3: Find the largest section of the specified file_type
    largest_section = None
    max_length = 0
    for section in sections:
        code_language, start_line, end_line = section
        if code_language.lower() == language.lower():
            length = end_line - start_line
            if length > max_length:
                max_length = length
                largest_section = section
    
    # Step 4: Comment out all lines except the largest section
    if largest_section:
        _, start_line, end_line = largest_section
        processed_lines = []
        for i, line in enumerate(lines):
            if i < start_line or i > end_line:
                processed_lines.append(comment_line(line, comment_characters))
            else:
                processed_lines.append(line)
        return '\n'.join(processed_lines)
    
    # If no section matches the language, comment out everything
    return '\n'.join(comment_line(line, comment_characters) for line in lines)</input_code>
    <example_code>sections = find_section(
    lines, # splitlines of text, an array of lines of text
    start_index=0, # start index/row of the line, default is row 0
    sub_section=False # boolean to check if it is a sub-section, default is no
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function called 'find_section' that will find top-level code sections in a string output from an LLM.

% Here are the inputs and outputs of the function:
    Inputs:
        'lines' - A list of strings, where each string is a line from the LLM output.
        'start_index' - An integer representing the starting index to begin searching (default is 0).
        'sub_section' - A boolean flag indicating whether this is a recursive call for a sub-section (default is False).
    Output: returns a list of tuples, where each tuple contains (code_language, start_line, end_line) for each top-level code section found.

% Here is an example of how the function might be called:
```python
lines = llm_output.splitlines()
sections = find_section(lines)
```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% This function will do the following:
    Step 1. Initialize an empty list to store the sections found.
    Step 2. Iterate through the lines starting from start_index:
        Step 2a. Find the start of a code block (line starting with triple backticks).
        Step 2b. If another start of a code block is found, call 'find_section' recursively with sub_section flag set to True.
        Step 2c. If the end of a code block is found (line with just triple backticks), do one of the following steps depending on the sub_section flag:
            Step 2c_i: If it is a sub-section, return an empty list.
            Step 2c_ii: If it is not a sub-section, record the program type and start/end lines into the output list.
    Step 3. Return the list of sections found.</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example how to find code sections in LLM output: ```<./context/find_section_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Use the find_section function to find the top-level code sections in the llm_output.
    Step 3. For the sections that are the same as file_type, determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure to also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</modified_prompt>
    </example_3>

    <example_4>
    <input_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will will be used by pdd to do this function. All output to the console will be pretty print using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
    - 'input_file_paths' (dict) - A dictionary to the paths of the input files with the keys being those specified in the examples from the pdd program description.
    - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
    - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
    - 'command' (string) - pdd command that was run.
    - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
    - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
    - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
    - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using a separate sub-function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</input_prompt>
    <input_code>import os
import click
from rich import print
from get_extension import get_extension

def generate_output_filename(command, key, basename, language, file_extension):
    if command == 'generate':
        return f"{basename}{file_extension}"
    elif command == 'example':
        return f"{basename}_example{file_extension}"
    elif command == 'test':
        return f"test_{basename}{file_extension}"
    elif command == 'preprocess':
        return f"{basename}_{language or 'unknown'}_preprocessed.prompt"
    elif command == 'fix':
        if key == 'output-test':
            return f"test_{basename}_fixed{file_extension}"
        else:
            return f"{basename}_fixed{file_extension}"
    else:
        return f"{basename}_output{file_extension}"

def construct_paths(input_file_paths, force, quiet, command, command_options):
    input_strings = {}
    output_file_paths = {}
    language = None

    def print_if_not_quiet(message):
        if not quiet:
            print(message)

    # Step 1: Construct the input file paths
    for key, path in input_file_paths.items():
        if not os.path.splitext(path)[1]:
            if command == 'generate':
                path += '.prompt'
            input_file_paths[key] = path
        
        print_if_not_quiet(f"Input file path for {key}: {path}")

    # Step 2: Load the input files
    for key, path in input_file_paths.items():
        try:
            with open(path, 'r') as file:
                input_strings[key] = file.read()
            print_if_not_quiet(f"Loaded input file: {path}")
        except IOError as e:
            print(f"[bold red]Error loading input file {path}: {str(e)}[/bold red]")
            return None, None, None

    # Extract basename and language
    prompt_file = input_file_paths.get('PROMPT_FILE', '')
    basename, ext = os.path.splitext(os.path.basename(prompt_file))
    parts = basename.split('_')
    if len(parts) > 1:
        language = parts[-1]
        basename = '_'.join(parts[:-1])
    else:
        language = ext[1:]  # Remove the leading dot
    
    if language:
        file_extension = get_extension(language)
    else:
        file_extension = '.txt'
        print(f"[bold yellow]Warning: Could not determine language. Using .txt as default file extension.[/bold yellow]")

    print_if_not_quiet(f"Extracted basename: {basename}, language: {language}, File extension: {file_extension}")

    # Step 3: Construct the output file paths
    for key in command_options:
        if key.startswith('output'):
            output_path = command_options[key]
            if output_path:
                if os.path.isdir(output_path):
                    filename = generate_output_filename(command, key, basename, language, file_extension)
                    output_path = os.path.join(output_path, filename)
                elif not os.path.splitext(output_path)[1]:
                    output_path += file_extension
            else:
                output_path = generate_output_filename(command, key, basename, language, file_extension)
            
            output_file_paths[key] = os.path.abspath(output_path)
            print_if_not_quiet(f"Output file path for {key}: {output_file_paths[key]}")

    # Step 4: Check if output files exist and confirm overwrite if necessary
    for key, path in output_file_paths.items():
        if os.path.exists(path) and not force:
            if not click.confirm(f"Output file {path} already exists. Overwrite?"):
                print(f"[bold yellow]Operation cancelled for {key}.[/bold yellow]")
                return None, None, None

    # Step 5: Return the outputs
    return input_strings, output_file_paths, language</input_code>
    <example_code>filename = generate_output_filename(
    command, # pdd commands like 'generate', etc.
    key, # output dictionary key like 'output', 'output-test', etc.
    basename, # the basename of the file
    language, # the language of the file
    file_extension # the file extension of the file
    )</example_code>
    <sub_prompt>% You are an expert Python software engineer. Your task is to implement a function called `generate_output_filename` that creates appropriate output filenames for different commands in a Python program.

% Inputs: The function should take the following parameters:
    - `command` (string): The command being executed (e.g., 'generate', 'example', 'test', 'preprocess', 'fix')
    - `key` (string): The output dictionary key (e.g., 'output', 'output-test')
    - `basename` (string): The base name of the file
    - `language` (string): The programming language of the file
    - `file_extension` (string): The file extension to be used

% Outputs: The function should return a string representing the generated output filename.

% Follow these rules for generating the output filename:
    1. For the 'generate' command: Return `f"{basename}{file_extension}"`
    2. For the 'example' command: Return `f"{basename}_example{file_extension}"`
    3. For the 'test' command: Return `f"test_{basename}{file_extension}"`
    4. For the 'preprocess' command: Return `f"{basename}_{language or 'unknown'}_preprocessed.prompt"`
    5. For the 'fix' command:
    - If the key is 'output-test', return `f"test_{basename}_fixed{file_extension}"`
    - Otherwise, return `f"{basename}_fixed{file_extension}"`
    6. For any other command: Return `f"{basename}_output{file_extension}"`

% Implement the function to handle all these cases efficiently and return the appropriate filename as a string, accordingly.

% Ensure the function handles all cases correctly and returns the appropriate filename string, language, and file extension. The function should be robust and able to handle various edge cases, such as missing file extensions or languages.</sub_prompt>
    <modified_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will be used by pdd to perform this functionality. All output to the console will be pretty printed using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example of how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example of how to generate the appropriate output filenames based on the command, key, basename, language, and file extension using the `generate_output_filename` function: ```<./context/generate_output_filename_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
        - 'input_file_paths' (dict) - A dictionary of the paths of the input files with the keys being those specified in the examples from the pdd program description.
        - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
        - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
        - 'command' (string) - pdd command that was run.
        - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
        - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
        - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
        - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using the `generate_output_filename` function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</modified_prompt>
    </example_4>
</examples>

<context>
% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality.

% Here are the inputs and outputs of this prompt:
    <input_definitions>
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    </input_definitions>
    <output_definitions>
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.
    </output_definitions>
</context>

<inputs>
    <input_prompt>{input_prompt}</input_prompt>
    <input_code>{input_code}</input_code>
    <example_code>{example_code}</example_code>
</inputs>

<instructions>
% Follow these instructions:
    1. Write out the difficulties in spliting the prompt.
    2. Write out how to overcome the difficulties.
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
</instructions>

    </example_tagged_prompt>
</example>

% Output a string with the `input_raw_prompt` properly tagged using XML as metadata and structural elements to enhance clarity and organization. The output may include, but is not limited to:
    1. `<instructions>`: Guidelines or directives for the model's output.
    2. `<context>`: Background information or relevant data for understanding the task.
    3. `<examples>`: Specific instances that guide the model's response.
    4. `<formatting>`: Special formatting instructions for the output.

% Follow these steps to tag the prompt:
    Step 1. Write out the analysis of the input_raw_prompt by identifying components like instructions, context, and examples.
    Step 2. Discuss what could be appropriate XML tags for this input_raw_prompt.
    Step 3. Insert the XML tags at the correct locations in the input_raw_prompt without introducing any new content. Only add tags to existing content. The XML tags should be enhancing the input_raw_prompt's format, structure and readability.
    
% General points:
    - With triple backtick includes and curly bracket placeholders, there could be lots of text in them after preprocessing so XML tags will help to organize the content.
    - No need to include the initial and ending triple backticks for the XML code block.  

        </example_raw_prompt>

        % Here is an example_tagged_prompt from the example_raw_prompt above:
        <example_tagged_prompt>
        <role>You are an expert Prompt Engineer.</role>

<task>Your goal is to enhance a given prompt by only adding XML tags where necessary to improve its structure and readability. Do not add any additional content or XML tags unless it is clearly required by the structure of the input_raw_prompt.</task>

<context>
Here is the input_raw_prompt that needs XML tagging to improve its organization: <input_raw_prompt>{raw_prompt}</input_raw_prompt>
</context>

<example>
    % Here is an example_raw_prompt that needs XML tagging:
    <example_raw_prompt>
    <examples>
% Here is example_1 of how to split and generate the sub_prompt and modified_prompt:
    example_1_input_prompt: ```<./context/split/1/initial_pdd_python.prompt>```
    example_1_input_code: ```<./context/split/1/pdd.py>```
    example_1_example_code: ```<./context/split/1/split_get_extension.py>```
    example_1_sub_prompt: ```<./context/split/1/sub_pdd_python.prompt>```
    example_1_modified_prompt: ```<./context/split/1/final_pdd_python.prompt>```

% Here is example_2 of how to split and generate the sub_prompt and modified_prompt:
    example_2_input_prompt: ```<./context/split/2/initial_pdd_python.prompt>```
    example_2_input_code: ```<./context/split/2/pdd.py>```
    example_2_example_code: ```<./context/split/2/split_pdd_construct_output_path.py>```
    example_2_sub_prompt: ```<./context/split/2/sub_pdd_python.prompt>```
    example_2_modified_prompt: ```<./context/split/2/final_pdd_python.prompt>```
    
% Here is example_3 of how to split and generate the sub_prompt and modified_prompt:
    example_3_input_prompt: ```<./context/split/3/initial_postprocess_python.prompt>```
    example_3_input_code: ```<./context/split/3/postprocess.py>```
    example_3_example_code: ```<./context/split/3/split_postprocess_find_section.py>```
    example_3_sub_prompt: ```<./context/split/3/sub_postprocess_python.prompt>```
    example_3_modified_prompt: ```<./context/split/3/final_postprocess_python.prompt>```

% Here is example_4 of how to split and generate the sub_prompt and modified_prompt:
    example_4_input_prompt: ```<./context/split/4/initial_construct_paths_python.prompt>```
    example_4_input_code: ```<./context/split/4/construct_paths.py>```
    example_4_example_code: ```<./context/split/4/split_construct_paths_generate_output_filename.py>```
    example_4_sub_prompt: ```<./context/split/4/sub_construct_paths_python.prompt>```
    example_4_modified_prompt: ```<./context/split/4/final_construct_paths_python.prompt>```
</examples>

% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality. 

% Here are the inputs and outputs of this prompt:
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.

% Here is the input_prompt to split: ```{input_prompt}```
% Here is the input_code: ```{input_code}```
% Here is the example_code: ```{example_code}```

% Follow these instructions:
    1. Write out the difficulties in spliting the prompt
    2. Write out how to overcome the difficulties
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
    </example_raw_prompt>

    % Here is an example_tagged_prompt from the example_raw_prompt above:
    <example_tagged_prompt>
    <examples>
    <example_1>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name so the right code file extension (e.g. '.sh' for bash, '' for makefile, '.py' for Python) and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the command line program "pdd" as described, we will use Python's `argparse` for command line argument parsing, and the `rich` library for pretty printing. The program will handle both prompt files and code files, generating runnable code and example code as specified.

# Here's a complete implementation of the `pdd` program:

# ```python
import os
import sys
import argparse
from rich.console import Console
from rich.prompt import Confirm
from code_generator import code_generator
from context_generator import context_generator

console = Console()

def get_file_paths(input_file, output_file, example_output_file):
    # Extract basename and language from the input file
    basename, ext = os.path.splitext(os.path.basename(input_file))
    language = ext[1:]  # Remove the dot

    # Determine output file paths
    if output_file:
        runnable_file_path = output_file
    else:
        runnable_file_path = os.path.join(os.path.dirname(input_file), f"{basename}.{get_extension(language)}")

    if example_output_file:
        example_file_path = example_output_file
    else:
        example_file_path = os.path.join(os.path.dirname(input_file), f"{basename}_example.{get_example_extension(language)}")

    return runnable_file_path, example_file_path

def get_extension(language):
    extensions = {
        'python': 'py',
        'bash': 'sh',
        'makefile': 'mk',
        # Add more languages and their extensions as needed
    }
    return extensions.get(language, '')

def get_example_extension(language):
    return 'py'  # Assuming example files are always Python files for simplicity

def confirm_overwrite(file_path):
    if os.path.exists(file_path):
        return Confirm.ask(f"{file_path} already exists. Do you want to overwrite it?", default=True)
    return True

def main():
    parser = argparse.ArgumentParser(description="Compile prompts into code files or generate example code from code files.")
    parser.add_argument('input', help='Input prompt file or code file to generate example from')
    parser.add_argument('-o', '--output', help='Path or filename of the output runnable code')
    parser.add_argument('-oe', '--output-example', help='Path or filename of the output example code')
    parser.add_argument('--force', action='store_true', help='Force overwrite existing files without confirmation')

    args = parser.parse_args()

    input_file = args.input
    if not input_file.endswith('.prompt'):
        if not os.path.splitext(input_file)[1]:  # No extension, assume it's a code file
            input_file += '.prompt'
    
    # Determine if input is a prompt or code file
    is_prompt = input_file.endswith('.prompt')
    
    # Get output file paths
    runnable_file_path, example_file_path = get_file_paths(input_file, args.output, args.output_example)

    # Handle the runnable code generation
    if is_prompt:
        console.print(f"[bold green]Generating runnable code from prompt: {input_file}[/bold green]")
        runnable_code = code_generator(input_file, get_extension(os.path.splitext(input_file)[1][1:]))
        
        if not args.force and not confirm_overwrite(runnable_file_path):
            console.print("[bold red]Operation cancelled.[/bold red]")
            return
        
        with open(runnable_file_path, 'w') as f:
            f.write(runnable_code)
        console.print(f"[bold blue]Runnable code written to: {runnable_file_path}[/bold blue]")

    # Handle example code generation
    if not is_prompt or args.output_example:
        console.print(f"[bold green]Generating example code from: {runnable_file_path}[/bold green]")
        success = context_generator(runnable_file_path, example_file_path, force=args.force)

        if success:
            console.print(f"[bold blue]Example code written to: {example_file_path}[/bold blue]")
        else:
            console.print("[bold red]Example generation failed.[/bold red]")

if __name__ == "__main__":
    main()
# ```

# ### Explanation of the Code:
# 1. **Imports**: We import necessary modules including `argparse` for command line parsing, `os` for file path manipulations, and `rich` for console output.
# 2. **Functions**:
#    - `get_file_paths`: Determines the output file paths based on the input file and user-specified options.
#    - `get_extension` and `get_example_extension`: Return the appropriate file extensions based on the language.
#    - `confirm_overwrite`: Asks the user for confirmation if a file already exists.
# 3. **Main Function**:
#    - Parses command line arguments.
#    - Checks if the input file is a prompt or a code file.
#    - Generates runnable code from the prompt file and writes it to the specified output path.
#    - Generates example code from the runnable code if specified.
# 4. **Execution**: The script runs the `main` function when executed.

# ### Usage:
# - To run the program, save it as `pdd.py` and execute it from the command line:
#   ```bash
#   python pdd.py <input_prompt_file or input_code_file_to_generate_example_from> [options]
#   ```

# ### Requirements:
# - Ensure you have the `rich`, `langchain`, and `tiktoken` libraries installed, along with the `code_generator` and `context_generator` modules available in your environment.</input_code>
    <example_code>file_extension = get_extension(language)</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a python function, "get_extension", that will return the file extension associated with a given language. 

% Here are the inputs and outputs of the function:
    Input: 'language' - A string containing the language (e.g. Bash, Makefile, Python).
    Output: returns a string that is the extension for the langauge

% This program will do the following:
    Step 1. Lower case the language string to make the comparison case insensitive.
    Step 2. Look up the file extension for the given language
    Step 3. Return the file extension</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_1>

    <example_2>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% There are four possibilities for the output files:
    - File name given without path (e.g. 'output.py'): This will write the 'output.py' file in the same directory as the input file.
    - File name given with path (e.g. './output.py'): This will write the 'output.py' file in the './' directory.
    - Path given without file name (e.g. './context'): This will write the file with the basename and appropriate extension (for generated runnable code and generated example code) in the './context' directory.
    - Nothing specified by user (default): This will write the file with the basename and appropriate extension in the same directory as the input file.

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code. All four of the above possibilities are possible meaning for example, the user might just have "-o" or might have "-o ./output.py".
    '-oe': Means program should generate example from runnable code. As will "-o" all four output possibilities are possible here.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. From the basename and file extension generate the appropriate file paths for the runnable and example output files considering the four possibilities. First determine which possibility for each of the outputs and then construct the proper file paths for each output.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</input_prompt>
    <input_code># To create the `pdd` command line program as described, we need to follow the steps outlined in the prompt. Below is the implementation of the `pdd` program in Python. This program will use the `rich` library for pretty printing and handle the various input and output scenarios as specified.

# First, ensure you have the necessary modules installed:
# ```sh
# pip install rich
# ```

# Next, create the `pdd.py` script:

# ```python
import os
import sys
import argparse
from rich.console import Console
from code_generator import code_generator
from context_generator import context_generator
from get_extension import get_extension

console = Console()

def main():
    parser = argparse.ArgumentParser(description="Compile a prompt into a code file or a code file into an example code file.")
    parser.add_argument('input_file', help="Input prompt file or input code file to generate example from")
    parser.add_argument('-o', '--output', help="Path or filename of the output of the runnable code")
    parser.add_argument('-oe', '--output_example', help="Path or filename of the output example code")
    parser.add_argument('--force', action='store_true', help="Overwrite files without asking")

    args = parser.parse_args()
    input_file = args.input_file
    output = args.output
    output_example = args.output_example
    force = args.force

    # Step 1: Read the input file name from the command line
    if not os.path.exists(input_file):
        console.print(f"[bold red]Error:[/bold red] The file '{input_file}' does not exist.")
        sys.exit(1)

    # Step 2: If file name has no extension, add '.prompt' to the file name
    if '.' not in input_file:
        input_file += '.prompt'

    # Step 3: Extract the basename and language from the file name
    basename, ext = os.path.splitext(os.path.basename(input_file))
    if ext == '.prompt':
        language = basename.split('_')[-1]
    else:
        language = ext[1:]

    file_extension = get_extension(language)

    # Step 4: Generate the appropriate file paths for the runnable and example output files
    def construct_output_path(output, default_name):
        if output is None:
            return os.path.join(os.path.dirname(input_file), default_name)
        elif os.path.isdir(output):
            return os.path.join(output, default_name)
        else:
            return output

    runnable_output_path = construct_output_path(output, f"{basename}{file_extension}")
    example_output_path = construct_output_path(output_example, f"{basename}_example{file_extension}")

    # Step 5: If a prompt input, generate code from the input prompt file name using code_generator
    if ext == '.prompt':
        console.print(f"[bold green]Generating runnable code from prompt:[/bold green] {input_file}")
        runnable_code = code_generator(input_file, language)
        write_to_file(runnable_output_path, runnable_code, force)

    # Step 6: If a code file is provided or a "-oe" option is provided, generate example code
    if ext != '.prompt' or output_example:
        console.print(f"[bold green]Generating example code from runnable code:[/bold green] {runnable_output_path}")
        success = context_generator(runnable_output_path, example_output_path, force)
        if success:
            console.print(f"[bold green]Example code generated successfully:[/bold green] {example_output_path}")
        else:
            console.print(f"[bold red]Failed to generate example code.[/bold red]")

def write_to_file(file_path, content, force):
    if os.path.exists(file_path) and not force:
        console.print(f"[bold yellow]Warning:[/bold yellow] The file '{file_path}' already exists. Overwrite? [y/N]")
        response = input().strip().lower()
        if response not in ['y', 'yes', '']:
            console.print(f"[bold red]Aborted:[/bold red] The file '{file_path}' was not overwritten.")
            return

    with open(file_path, 'w') as f:
        f.write(content)
    console.print(f"[bold green]File written successfully:[/bold green] {file_path}")

if __name__ == "__main__":
    main()
# ```

# ### Explanation:
# 1. **Argument Parsing**: The script uses `argparse` to handle command-line arguments.
# 2. **File Existence Check**: It checks if the input file exists.
# 3. **File Extension Handling**: If the input file has no extension, `.prompt` is added.
# 4. **Basename and Language Extraction**: The script extracts the basename and language from the input file name.
# 5. **Output Path Construction**: It constructs the appropriate output paths for runnable and example files.
# 6. **Code Generation**: If the input is a prompt file, it generates runnable code using `code_generator`.
# 7. **Example Code Generation**: If the input is a code file or the `-oe` option is provided, it generates example code using `context_generator`.
# 8. **File Writing**: The script writes the generated code to the specified output files, handling overwrites based on the `--force` option.

# This script should be placed in a file named `pdd.py` and can be executed from the command line as described in the prompt.</input_code>
    <example_code>runnable_output_path, example_output_path = construct_output_paths(
    basename, # the basename of the file
    file_extension, # the file extension based on the language
    argv_output_path, # string from the '-o' flag
    argv_example_output_path # string from the '-oe' flag
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function, "construct_output_paths", that will generate the appropriate file paths for the runnable and example output files that will be called by "pdd", the top-level command line program.

% Here are the inputs and outputs of the function:
    Inputs:
    - 'basename': A string containing the basename of the file
    - 'file_extension': A string containing the file extension based on the language
    - 'argv_output_path': A string from the '-o' flag (can be None)
    - 'argv_example_output_path': A string from the '-oe' flag (can be None)
    Outputs:
    - Returns a tuple containing two strings: (runnable_output_path, example_output_path)

% Consider the four possibilities for the output files as described in the main prompt:
    - File name given without path
    - File name given with path
    - Path given without file name
    - Nothing specified by user (default)

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% This function will do the following:
    Step 1: Define a helper function to construct the output path based on the given arguments and default name.
    Step 2: Use the helper function to construct the runnable_output_path using basename, file_extension, and argv_output_path.
    Step 3: Use the helper function to construct the example_output_path using basename, file_extension, and argv_example_output_path.
    Step 4: Return the tuple (runnable_output_path, example_output_path).
</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python command line program, "pdd", that will compile a prompt into a code file or a code file into an example code file. All output to the console will be pretty print using the Python rich library.

% Here is how the program will be used: pdd <input_prompt_file or input_code_file_to_generate_example_from>

% Prompt file names have this format: 'basename_language.prompt' (e.g. pdd_python.prompt, makefile_makefile.prompt, setup_bash.prompt)

% When given a prompt, the program will generate runnable code and example code if selected. When given a code file, an example file will be generated. Here are the options the program will support: 
    '--force': When writing the output files, if a file already exists, the program will ask before overwriting it unless a "--force" is present where it will just overwrite the file. It will default to Yes if user presses Enter.
    '-o': Path or filename of the output of the runnable code.
    '-oe': Means program should generate example from runnable code.

% Here are example command lines:
    -'pdd context_generator.py' will generate 'context_generator_example.py' in the same directory
    -'pdd context_generator.py -oe context/' will generate 'context_generator_example.py' in the './context' directory
    -'pdd context_generator_python.prompt -o pdd/ -oe context/' will generate 'context_generator.py' in the './pdd' directory and 'context_generator_example.py' in the './context' directory. 'context_generator' is the basename.
    -'pdd makefile_makefile.prompt' will generate 'makefile' in the same directory
    -'pdd pdd_python.prompt -o pdd/pdd_v1.py will generate 'pdd_v1.py' in the './pdd' directory and no example will be generated

% Here is an example how to generate code from the prompt from a file: ```<./context/code_generator_example.py>```                

% Here is an example how to generate an example from a code file: ```<./context/context_generator_example.py>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example how to construct output paths: ```<./context/construct_output_paths_example.py>```

% This program will do the following:
    Step 1. Read the input file name from the command line. 
    Step 2. If file name has no extension, add '.prompt' to the file name.
    Step 3. Extract the basename and language from the file name. Use get_extension to get the file extension for the language. The file extension and language is used for all the subsequent steps. 
    Step 4. Use construct_output_paths to generate the appropriate file paths for the runnable and example output files.
    Step 5. If a prompt input (indicated by a '.prompt' input file extension) do these steps:
        Step 5a. Generate code from the input prompt file name using code_generator.
        Step 5b. The program will write the runnable code to a runnable file path from Step 4. 
    Step 6. If a code file (indicated by a input file extension that isn't '.prompt') is provided or a "-oe" option is provided, the program will generate example code from the runnable code of Step 5 or the input code file using context_generator and write the example code to the example file path from Step 4.</modified_prompt>
    </example_2>

    <example_3>
    <input_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Find the top-level code sections via recursive function, 'find_section'. For a code section, the first backtick will always have a string right after it that determines what kind of code it is and the end of a section just has triple backticks. To properly return the list of top level-sections do the following sub-steps by iterating through lines of the string:
        Step 2a. Find the start of a code block 
        Step 2b. If another start of another code block is found, call 'find_section' recursively with a sub-section flag True. 
        Step 2c. If not, but the end of a code block is found, we should do one of the following steps depending on the sub-section flag:
            Step 2c_i: If it is a sub-section we should return with an empty list
            Step 2c_ii: If it is not a sub-section we should know the end of the code block and we should record the program type and start/end lines into the output list
        Step 2d. If all lines of the string are process, we should return the output list.
    Step 3. For the sections that are the same as file_type, we will determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure the also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</input_prompt>
    <input_code>from pdd.get_comment import get_comment
from pdd.comment_line import comment_line

def find_section(lines, start_index=0, sub_section=False):
    sections = []
    i = start_index
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('```'):
            # Start of a code block
            if len(line) > 3:
                # Extract the language from the line
                code_language = line[3:].strip()
                start_line = i
                i += 1
                # Find the end of the code block
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    i += 1
                if i < len(lines):
                    end_line = i
                    if not sub_section:
                        sections.append((code_language, start_line, end_line))
                    else:
                        return []
            else:
                # End of a code block without a language
                if sub_section:
                    return []
        i += 1
    return sections

def postprocess(llm_output, language):
    # Step 1: Get the comment character for the specified language
    comment_characters = get_comment(language)
    
    # Step 2: Find the top-level code sections
    lines = llm_output.splitlines()
    sections = find_section(lines)
    
    # Step 3: Find the largest section of the specified file_type
    largest_section = None
    max_length = 0
    for section in sections:
        code_language, start_line, end_line = section
        if code_language.lower() == language.lower():
            length = end_line - start_line
            if length > max_length:
                max_length = length
                largest_section = section
    
    # Step 4: Comment out all lines except the largest section
    if largest_section:
        _, start_line, end_line = largest_section
        processed_lines = []
        for i, line in enumerate(lines):
            if i < start_line or i > end_line:
                processed_lines.append(comment_line(line, comment_characters))
            else:
                processed_lines.append(line)
        return '\n'.join(processed_lines)
    
    # If no section matches the language, comment out everything
    return '\n'.join(comment_line(line, comment_characters) for line in lines)</input_code>
    <example_code>sections = find_section(
    lines, # splitlines of text, an array of lines of text
    start_index=0, # start index/row of the line, default is row 0
    sub_section=False # boolean to check if it is a sub-section, default is no
    )</example_code>
    <sub_prompt>% You are an expert Python engineer. Your goal is to write a Python function called 'find_section' that will find top-level code sections in a string output from an LLM.

% Here are the inputs and outputs of the function:
    Inputs:
        'lines' - A list of strings, where each string is a line from the LLM output.
        'start_index' - An integer representing the starting index to begin searching (default is 0).
        'sub_section' - A boolean flag indicating whether this is a recursive call for a sub-section (default is False).
    Output: returns a list of tuples, where each tuple contains (code_language, start_line, end_line) for each top-level code section found.

% Here is an example of how the function might be called:
```python
lines = llm_output.splitlines()
sections = find_section(lines)
```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% This function will do the following:
    Step 1. Initialize an empty list to store the sections found.
    Step 2. Iterate through the lines starting from start_index:
        Step 2a. Find the start of a code block (line starting with triple backticks).
        Step 2b. If another start of a code block is found, call 'find_section' recursively with sub_section flag set to True.
        Step 2c. If the end of a code block is found (line with just triple backticks), do one of the following steps depending on the sub_section flag:
            Step 2c_i: If it is a sub-section, return an empty list.
            Step 2c_ii: If it is not a sub-section, record the program type and start/end lines into the output list.
    Step 3. Return the list of sections found.</sub_prompt>
    <modified_prompt>% You are an expert Python engineer. Your goal is to write a python function called 'postprocess' that will post-process the string output of a LLM so that the code can be run. 

% Here are the inputs and outputs of the function:
    Input: 
        'llm_output' - A string contains a mix of text and sections of code separated by triple backticks. 
        'language' - A string that is the type (e.g. python, bash) of file that will be outputed by the LLM
    Output: returns a string that is the processed string that contains a properly commented out comments so that code can be run

% Here is an example how to get the lookup the comment line characters given a language: ```<./context/get_comment_example.py>```

% Here is an example how to comment out a line of code: ```<./context/comment_line_example.py>```

% Here is an example how to find code sections in LLM output: ```<./context/find_section_example.py>```

% Here is an example of llm_output: '''To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.

```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
```

### Explanation of the Code:
1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.

### Usage:
You can call this function by providing the necessary arguments, like so:

```python
context_generator('your_python_file.py', 'output_example.py', force=False)
```

Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
To implement the context_generator function as described, we will follow the steps outlined in   
your request. Below is the complete implementation of the function, which includes reading a     
Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
the output to a specified file.'''

% Here is an example of the Output string that would be returned: '''#To implement the `context_generator` function as described, we will follow the steps outlined in your request. Below is the complete implementation of the function, which includes reading a Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing the output to a specified file.
#
#```python
import os

def context_generator(python_filename: str, output_filename: str, force: bool = False) -> bool:
    # Step 1: Read the Python file
    try:
        with open(python_filename, 'r') as file:
            python_code = file.read()
    except FileNotFoundError:
        print(f"Error: The file {python_filename} does not exist.")
        return False


    # Step 3: Generate a prompt for GPT-4
    prompt = f"""
    You are an expert Python engineer. Based on the following Python code, generate a concise example of how to use the module properly.

    Python Code:
    ```python
    {processed_content}
    ```

    return True
#```
#
#### Explanation of the Code:
#1. **File Reading**: The function attempts to read the specified Python file. If the file does not exist, it prints an error message and returns `False`.
#2. **Preprocessing**: It calls the `preprocess` function to process the content of the Python file.
#
#### Usage:
#You can call this function by providing the necessary arguments, like so:
#
#```python
#context_generator('your_python_file.py', 'output_example.py', force=False)
#```
#
#Make sure to replace `'your_python_file.py'` and `'output_example.py'` with the actual file names you want to use.
#To implement the context_generator function as described, we will follow the steps outlined in   
#your request. Below is the complete implementation of the function, which includes reading a     
#Python file, preprocessing it, generating a prompt for the model, invoking the model, and writing
#the output to a specified file.'''

% This function will do the following:
    Step 1. For the specified file_type, associate the right comment line character with the programming language using the get_comment function.
    Step 2. Use the find_section function to find the top-level code sections in the llm_output.
    Step 3. For the sections that are the same as file_type, determine which section is the largest.
    Step 4. Now using the original llm_output string, comment out, using the comment_line function, all lines of text until the start line of the largest section of the file_type we want and then resume commenting out the lines after end line of the largest section. Be sure to also comment out the triple backticks of the largest section. This will leave the executable part of largest section of code uncommented.
    Step 5. The program will return the post processed string that contains a properly commented out program that can be run.</modified_prompt>
    </example_3>

    <example_4>
    <input_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will will be used by pdd to do this function. All output to the console will be pretty print using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
    - 'input_file_paths' (dict) - A dictionary to the paths of the input files with the keys being those specified in the examples from the pdd program description.
    - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
    - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
    - 'command' (string) - pdd command that was run.
    - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
    - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
    - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
    - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using a separate sub-function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</input_prompt>
    <input_code>import os
import click
from rich import print
from get_extension import get_extension

def generate_output_filename(command, key, basename, language, file_extension):
    if command == 'generate':
        return f"{basename}{file_extension}"
    elif command == 'example':
        return f"{basename}_example{file_extension}"
    elif command == 'test':
        return f"test_{basename}{file_extension}"
    elif command == 'preprocess':
        return f"{basename}_{language or 'unknown'}_preprocessed.prompt"
    elif command == 'fix':
        if key == 'output-test':
            return f"test_{basename}_fixed{file_extension}"
        else:
            return f"{basename}_fixed{file_extension}"
    else:
        return f"{basename}_output{file_extension}"

def construct_paths(input_file_paths, force, quiet, command, command_options):
    input_strings = {}
    output_file_paths = {}
    language = None

    def print_if_not_quiet(message):
        if not quiet:
            print(message)

    # Step 1: Construct the input file paths
    for key, path in input_file_paths.items():
        if not os.path.splitext(path)[1]:
            if command == 'generate':
                path += '.prompt'
            input_file_paths[key] = path
        
        print_if_not_quiet(f"Input file path for {key}: {path}")

    # Step 2: Load the input files
    for key, path in input_file_paths.items():
        try:
            with open(path, 'r') as file:
                input_strings[key] = file.read()
            print_if_not_quiet(f"Loaded input file: {path}")
        except IOError as e:
            print(f"[bold red]Error loading input file {path}: {str(e)}[/bold red]")
            return None, None, None

    # Extract basename and language
    prompt_file = input_file_paths.get('PROMPT_FILE', '')
    basename, ext = os.path.splitext(os.path.basename(prompt_file))
    parts = basename.split('_')
    if len(parts) > 1:
        language = parts[-1]
        basename = '_'.join(parts[:-1])
    else:
        language = ext[1:]  # Remove the leading dot
    
    if language:
        file_extension = get_extension(language)
    else:
        file_extension = '.txt'
        print(f"[bold yellow]Warning: Could not determine language. Using .txt as default file extension.[/bold yellow]")

    print_if_not_quiet(f"Extracted basename: {basename}, language: {language}, File extension: {file_extension}")

    # Step 3: Construct the output file paths
    for key in command_options:
        if key.startswith('output'):
            output_path = command_options[key]
            if output_path:
                if os.path.isdir(output_path):
                    filename = generate_output_filename(command, key, basename, language, file_extension)
                    output_path = os.path.join(output_path, filename)
                elif not os.path.splitext(output_path)[1]:
                    output_path += file_extension
            else:
                output_path = generate_output_filename(command, key, basename, language, file_extension)
            
            output_file_paths[key] = os.path.abspath(output_path)
            print_if_not_quiet(f"Output file path for {key}: {output_file_paths[key]}")

    # Step 4: Check if output files exist and confirm overwrite if necessary
    for key, path in output_file_paths.items():
        if os.path.exists(path) and not force:
            if not click.confirm(f"Output file {path} already exists. Overwrite?"):
                print(f"[bold yellow]Operation cancelled for {key}.[/bold yellow]")
                return None, None, None

    # Step 5: Return the outputs
    return input_strings, output_file_paths, language</input_code>
    <example_code>filename = generate_output_filename(
    command, # pdd commands like 'generate', etc.
    key, # output dictionary key like 'output', 'output-test', etc.
    basename, # the basename of the file
    language, # the language of the file
    file_extension # the file extension of the file
    )</example_code>
    <sub_prompt>% You are an expert Python software engineer. Your task is to implement a function called `generate_output_filename` that creates appropriate output filenames for different commands in a Python program.

% Inputs: The function should take the following parameters:
    - `command` (string): The command being executed (e.g., 'generate', 'example', 'test', 'preprocess', 'fix')
    - `key` (string): The output dictionary key (e.g., 'output', 'output-test')
    - `basename` (string): The base name of the file
    - `language` (string): The programming language of the file
    - `file_extension` (string): The file extension to be used

% Outputs: The function should return a string representing the generated output filename.

% Follow these rules for generating the output filename:
    1. For the 'generate' command: Return `f"{basename}{file_extension}"`
    2. For the 'example' command: Return `f"{basename}_example{file_extension}"`
    3. For the 'test' command: Return `f"test_{basename}{file_extension}"`
    4. For the 'preprocess' command: Return `f"{basename}_{language or 'unknown'}_preprocessed.prompt"`
    5. For the 'fix' command:
    - If the key is 'output-test', return `f"test_{basename}_fixed{file_extension}"`
    - Otherwise, return `f"{basename}_fixed{file_extension}"`
    6. For any other command: Return `f"{basename}_output{file_extension}"`

% Implement the function to handle all these cases efficiently and return the appropriate filename as a string, accordingly.

% Ensure the function handles all cases correctly and returns the appropriate filename string, language, and file extension. The function should be robust and able to handle various edge cases, such as missing file extensions or languages.</sub_prompt>
    <modified_prompt>% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths and then load the input files. This function will be used by pdd to perform this functionality. All output to the console will be pretty printed using the Python rich library. The CLI will be handled using the Python Click library.

% Here is a detailed description of the program functionality: ```<./README.md>```

% Here is an example of how to lookup a file extension given a language: ```<./context/get_extension_example.py>```

% Here is an example of how to generate the appropriate output filenames based on the command, key, basename, language, and file extension using the `generate_output_filename` function: ```<./context/generate_output_filename_example.py>```

% Here are the inputs and outputs of the function:
    Inputs:
        - 'input_file_paths' (dict) - A dictionary of the paths of the input files with the keys being those specified in the examples from the pdd program description.
        - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
        - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
        - 'command' (string) - pdd command that was run.
        - 'command_options' (dict) - A dictionary of the command options for the given command.
    Outputs:
        - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings.
        - 'output_file_paths' (dict)- A dictionary with the keys being the loaded input files and output files paths.
        - 'language' (string) - The language of the output file.

% If the file name has no extension, add the appropriate file extension (e.g '.prompt' to input file for the 'generate' command) to the file name.

% If the command is 'generate' extract the basename and language from the input_file_path. Use get_extension to get the file extension for the language. The file extension and language is used for the subsequent functionality below. Be able to handle files missing a '_' in the file name. 

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Construct the input file paths using above rules.
    Step 2. Load the input files into the input_strings dictionary with the pdd description examples as the keys. Alert the user of any errors in loading the input files.
    Step 3. Construct the output file paths using the above rules using the `generate_output_filename` function. It should construct the full file path including the output file name for the output files following the rules in the "Output Location Specification" section of the pdd program description.
    Step 4. If the output files already exist, and force isn't true, check with the user if the program should overwrite.
    Step 5. Return the outputs</modified_prompt>
    </example_4>
</examples>

<context>
% You are an expert LLM Prompt Engineer. Your goal is to split the input_prompt into a sub_prompt and modified_prompt with no loss of functionality.

% Here are the inputs and outputs of this prompt:
    <input_definitions>
    Input: 
        'input_prompt' - A string contains the prompt that will be split into a sub_prompt and modified_prompt.
        'input_code' - A string that contains the code that was generated from the input_prompt.
        'example_code' - A string that contains the code example of how the code generated from the sub_prompt would be used by the code generated from the modified_prompt.
    </input_definitions>
    <output_definitions>
    Output: 
        'sub_prompt' - A string that contains the sub_prompt that was split from the input_prompt.
        'modified_prompt' - A string that contains the modified prompt from input_prompt split from the above sub_prompt.
    </output_definitions>
</context>

<inputs>
    <input_prompt>{input_prompt}</input_prompt>
    <input_code>{input_code}</input_code>
    <example_code>{example_code}</example_code>
</inputs>

<instructions>
% Follow these instructions:
    1. Write out the difficulties in spliting the prompt.
    2. Write out how to overcome the difficulties.
    3. Generate the sub_prompt.
    4. Generate the modified_prompt.
</instructions>

    </example_tagged_prompt>
</example>

<output_instructions>
Output a string with the `input_raw_prompt` properly tagged using XML as metadata and structural elements to enhance clarity and organization. The output may include, but is not limited to:
    1. `<instructions>`: Guidelines or directives for the model's output.
    2. `<context>`: Background information or relevant data for understanding the task.
    3. `<examples>`: Specific instances that guide the model's response.
    4. `<formatting>`: Special formatting instructions for the output.
</output_instructions>

<steps>
Follow these steps to tag the prompt:
    Step 1. Write out the analysis of the input_raw_prompt by identifying components like instructions, context, and examples.
    Step 2. Discuss what could be appropriate XML tags for this input_raw_prompt.
    Step 3. Insert the XML tags at the correct locations in the input_raw_prompt without introducing any new content. Only add tags to existing content. The XML tags should be enhancing the input_raw_prompt's format, structure and readability.
</steps>
    
<general_points>
    - With triple backtick includes and curly bracket placeholders, there could be lots of text in them after preprocessing so XML tags will help to organize the content.
    - No need to include the initial and ending triple backticks for the XML code block.  
</general_points>
        </example_tagged_prompt>
    </example_2>
</examples>

<role>You are an expert Prompt Engineer.</role>

<task>Your goal is to enhance a given prompt by only adding XML tags where necessary to improve its structure and readability. Do not add any additional content or XML tags unless it is clearly required by the structure of the input_raw_prompt.</task>

<context>
Here is the input_raw_prompt that needs XML tagging to improve its organization: <input_raw_prompt>{raw_prompt}</input_raw_prompt>
</context>

<output_instructions>
Output a string with the `input_raw_prompt` properly tagged using XML as metadata and structural elements to enhance clarity and organization. The output may include, but is not limited to:
    1. `<instructions>`: Guidelines or directives for the model's output.
    2. `<context>`: Background information or relevant data for understanding the task.
    3. `<examples>`: Specific instances that guide the model's response.
    4. `<formatting>`: Special formatting instructions for the output.
</output_instructions>

<steps>
Follow these steps to tag the prompt:
    Step 1. Write out the analysis of the input_raw_prompt by identifying components like instructions, context, and examples.
    Step 2. Discuss what could be appropriate XML tags for this input_raw_prompt.
    Step 3. Insert the XML tags at the correct locations in the input_raw_prompt without introducing any new content. Only add tags to existing content. The XML tags should be enhancing the input_raw_prompt's format, structure and readability.
</steps>
    
<general_points>
    - With triple backtick includes and curly bracket placeholders, there could be lots of text in them after preprocessing so XML tags will help to organize the content.
    - No need to include the initial and ending triple backticks for the XML code block.  
</general_points>