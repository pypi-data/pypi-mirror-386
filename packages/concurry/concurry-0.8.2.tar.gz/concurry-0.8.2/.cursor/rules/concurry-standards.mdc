---
alwaysApply: true
---

# Cursor Rules for Concurry Package

## Code Quality Standards

### No Backward Compatibility
- **Never maintain backward compatibility** with deprecated patterns or old APIs
- When making breaking changes, update all code and tests immediately
- Remove deprecated code paths rather than maintaining them
- Focus on the best current design, not historical compatibility

### Type Hints
- **Always include type hints** for all function parameters and return values
- Use proper type annotations from `typing` module (e.g., `List`, `Dict`, `Optional`, `Union`)
- Include type hints for class attributes and instance variables
- Use `NoReturn` for functions that don't return (e.g., lifecycle hooks)
- Never use bare `Any` without a good reason - prefer specific types

### Explicit Checks

#### Collection Emptiness
- **Never use `not x` to check if a collection is empty**
- **Always use `len(x) == 0`** for emptiness checks
- **Use `len(x) > 0`** for non-empty checks

❌ Bad:
```python
if not my_list:
    pass
if my_dict:
    pass
```

✅ Good:
```python
if len(my_list) == 0:
    pass
if len(my_dict) > 0:
    pass
```

#### None Checks
- **Never check None using falsiness** (e.g., `not x`, `if x`)
- **Always use explicit `is None` or `is not None`**

❌ Bad:
```python
if not value:
    pass
if value:
    pass
```

✅ Good:
```python
if value is None:
    pass
if value is not None:
    pass
```

### Code Style
- Follow PEP 8 style guidelines
- Use descriptive variable names
- Keep functions focused and single-purpose
- Add comprehensive docstrings for all public APIs
- Include usage examples in docstrings for complex functionality

### Testing
- Write comprehensive test coverage for all features
- Update tests immediately when making breaking changes
- Test both success and failure cases
- Include edge cases and error conditions
- Use descriptive test names that explain what is being tested

### Documentation
- Update user guides immediately when APIs change
- Include practical examples in documentation
- Explain the "why" behind design decisions
- Keep documentation (user-guide and docstrings) in sync with code changes
- DO NOT ADD SEPARATE DEMO SCRIPTS OR DEMO MARKDOWN FILES. Add these examples to the testcases or documentation (user-guide and docstrings). Prefer to add edge-cases to testcases and typical use-case to documentation.

## Configuration System

**CRITICAL**: All default values MUST go through the global configuration system.

See [Architecture: Configuration System](docs/architecture/configuration.md) for full details.

### Public API Classes

**Rule**: Public API classes must NOT have hardcoded defaults in field declarations.

✅ **Correct Pattern**:
```python
class MyPublicClass(Typed):
    my_param: Optional[int] = None  # Default to None
    
    def post_initialize(self) -> None:
        """Apply defaults from global config."""
        from concurry.config import global_config
        local_config = global_config.clone()  # Thread-safe
        
        if self.my_param is None:
            self.my_param = local_config.defaults.my_param
```

❌ **Wrong Pattern**:
```python
class MyPublicClass(Typed):
    my_param: int = 100  # ❌ Hardcoded default!
```

**Public API classes include**:
- `Worker` (via `Worker.options()`)
- `RetryConfig`
- `RateLimit`, `Limit`
- `LimitPool`
- `PollingStrategy` classes
- `ProgressBar`

### Internal/Private Classes

**Rule**: Internal classes must NOT have ANY defaults. All values must be explicitly passed.

✅ **Correct Pattern**:
```python
class InternalWorkerProxy:
    def __init__(self, timeout: float):  # No default!
        self._timeout = timeout
```

❌ **Wrong Pattern**:
```python
class InternalWorkerProxy:
    def __init__(self, timeout: float = 5.0):  # ❌ Has default!
        self._timeout = timeout
```

**Internal classes include**:
- All `*WorkerProxy` classes
- All `*WorkerProxyPool` classes
- `RateLimiter` implementations
- `LoadBalancer` implementations
- Any class not exposed in public API

### Caller Responsibility

**Rule**: Code that instantiates internal classes must read from `global_config` and pass values explicitly.

✅ **Correct Pattern**:
```python
# In factory/builder code
from concurry.config import global_config

defaults = global_config.get_defaults(mode)
worker = InternalWorkerProxy(
    timeout=defaults.worker_timeout,  # Explicit
    max_retries=defaults.num_retries  # Explicit
)
```

### Docstrings

**Rule**: If a docstring mentions a default value, reference the config key, not a hardcoded value.

✅ **Correct**:
```python
def __init__(self, retries: Optional[int] = None):
    """
    Args:
        retries: Number of retries. 
            Defaults to global_config.defaults.num_retries.
    """
```

❌ **Wrong**:
```python
def __init__(self, retries: Optional[int] = None):
    """
    Args:
        retries: Number of retries. Defaults to 3.  # ❌ Hardcoded
    """
```

### Adding New Configuration

When adding a new configurable parameter:

1. Add to `GlobalDefaults` with concrete default value
2. Add to `ExecutionModeDefaults` as `Optional[T] = None`
3. Add `@property` to `ResolvedDefaults` with fallback logic
4. Update `temp_config()` validation to include new attributes
5. Update calling code to read from config
6. Update docstrings to reference config key
7. Add tests to `test_global_config.py`

### Thread Safety

- Use `global_config.clone()` in **public API** code (user-facing, multi-threaded)
- Direct access to `global_config` is safe in **internal, synchronous** code paths

### Verification

Before committing changes:

```bash
# Search for hardcoded numeric defaults
grep -rn "=\s*[0-9]" src/concurry/core/

# Search for hardcoded enum defaults
grep -rn "=\s*LoadBalancingAlgorithm\." src/concurry/
grep -rn "=\s*RateLimitAlgorithm\." src/concurry/
grep -rn "=\s*PollingAlgorithm\." src/concurry/

# Search for hardcoded sleep times
grep -rn "time.sleep(" src/concurry/core/
```

## Testcases

### Testcases with Ray
When writing testcases that use a Ray cluster, always use ray.init like this:
```python
import morphic
import concurry
ray.init(
    ignore_reinit_error=True,
    num_cpus=4,
    runtime_env={"py_modules": [concurry, morphic]},
)
```
If you do not have this, the test will NOT run, since the necessary dependencies are not passed to it.

### Executing testcases
Whenever you run testcases for concurry, set a timeout of 5 minutes (300 seconds).
