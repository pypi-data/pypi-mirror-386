% !! DO NOT MODIFY THIS FILE BY HAND !! Created by ht.awk.

%
%
%
%
%

%
\newcommand{\ugAppGraphicsTitle}{Programs for FriCAS Images}
\newcommand{\ugAppGraphicsNumber}{G.}
%
% =====================================================================
\begin{page}{ugAppGraphicsPage}{G. Programs for FriCAS Images}
% =====================================================================
\beginscroll
%
This appendix contains the \Language{} programs used to generate
the images in the \Gallery{} color insert of this book.
All these input files are included
with the \Language{} system.
To produce the images
on page 6 of the \Gallery{} insert, for example, issue the command:
\begin{verbatim}
)read images6
\end{verbatim}

These images were produced on an IBM RS/6000 model 530 with a
standard color graphics adapter.  The smooth shaded images
were made from X Window System screen dumps.
The remaining images were produced with \Language{}-generated
PostScript output.  The images were reproduced from slides made on an Agfa
ChromaScript PostScript interpreter with a Matrix Instruments QCR camera.

\beginmenu
    \menudownlink{{F.1. images1.input}}{ugFimagesOnePage}
    \menudownlink{{F.2. images2.input}}{ugFimagesTwoPage}
    \menudownlink{{F.3. images3.input}}{ugFimagesThreePage}
    \menudownlink{{F.4. images5.input}}{ugFimagesFivePage}
    \menudownlink{{F.5. images6.input}}{ugFimagesSixPage}
    \menudownlink{{F.6. images7.input}}{ugFimagesSevenPage}
    \menudownlink{{F.7. images8.input}}{ugFimagesEightPage}
    \menudownlink{{F.8. conformal.input}}{ugFconformalPage}
    \menudownlink{{F.9. tknot.input}}{ugFtknotPage}
    \menudownlink{{F.10. ntube.input}}{ugFntubePage}
    \menudownlink{{F.11. dhtri.input}}{ugFdhtriPage}
    \menudownlink{{F.12. tetra.input}}{ugFtetraPage}
    \menudownlink{{F.13. antoine.input}}{ugFantoinePage}
    \menudownlink{{F.14. scherk.input}}{ugFscherkPage}
\endmenu
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesOneTitle}{images1.input}
\newcommand{\ugFimagesOneNumber}{G.1.}
%
% =====================================================================
\begin{page}{ugFimagesOnePage}{G.1. images1.input}
% =====================================================================
\beginscroll

  
\noindent
{\tt 1.\ \ \ )read\ tknot}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ torusKnot(15,17,\ 0.1,\ 6,\ 700)}\newline
%-% \HDindex{torus knot}{ugFimagesOnePage}{G.1.}{images1.input}

\newpage
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesTwoTitle}{images2.input}
\newcommand{\ugFimagesTwoNumber}{G.2.}
%
% =====================================================================
\begin{page}{ugFimagesTwoPage}{G.2. images2.input}
% =====================================================================
\beginscroll

These images illustrate how Newton's method converges when computing the
%-% \HDindex{Newton iteration}{ugFimagesTwoPage}{G.2.}{images2.input}
complex cube roots of 2.   Each point in the \smath{(x,y)}-plane represents the
complex number \smath{x + iy,} which is given as a starting point for Newton's
method.  The poles in these images represent bad starting values.
The flat areas are the regions of convergence to the three roots.

  
\noindent
{\tt 1.\ \ \ )read\ newton}\newline
{\tt 2.\ \ \ )read\ vectors}\newline
{\tt 3.\ \ \ f\ :=\ newtonStep(x^3\ -\ 2)}\newline
{\tt 4.\ \ \ }\newline

The function f^n computes $n$ steps of Newton's method.

  
\noindent
{\tt 5.\ \ \ clipValue\ :=\ 4}\newline
{\tt 6.\ \ \ drawComplexVectorField(f^3,\ -3..3,\ -3..3)}\newline
{\tt 7.\ \ \ drawComplex(f^3,\ -3..3,\ -3..3)}\newline
{\tt 8.\ \ \ drawComplex(f^4,\ -3..3,\ -3..3)}\newline
  
\noindent

\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesThreeTitle}{images3.input}
\newcommand{\ugFimagesThreeNumber}{G.3.}
%
% =====================================================================
\begin{page}{ugFimagesThreePage}{G.3. images3.input}
% =====================================================================
\beginscroll

  
\noindent
{\tt 1.\ \ \ )r\ tknot}\newline
{\tt 2.\ \ \ for\ i\ in\ 0..4\ repeat\ torusKnot(2,\ 2\ +\ i/4,\ 0.5,\ 25,\ 250)}\newline

\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesFiveTitle}{images5.input}
\newcommand{\ugFimagesFiveNumber}{G.4.}
%
% =====================================================================
\begin{page}{ugFimagesFivePage}{G.4. images5.input}
% =====================================================================
\beginscroll

The parameterization of the Etruscan Venus is due to George Frances.
%-% \HDindex{Etruscan Venus}{ugFimagesFivePage}{G.4.}{images5.input}

  
\noindent
{\tt 1.\ \ \ venus(a,r,steps)\ ==}\newline
{\tt 2.\ \ \ \ \ surf\ :=\ (u:DFLOAT,\ v:DFLOAT):\ Point\ DFLOAT\ +->}\newline
{\tt 3.\ \ \ \ \ \ \ cv\ :=\ cos(v)}\newline
{\tt 4.\ \ \ \ \ \ \ sv\ :=\ sin(v)}\newline
{\tt 5.\ \ \ \ \ \ \ cu\ :=\ cos(u)}\newline
{\tt 6.\ \ \ \ \ \ \ su\ :=\ sin(u)}\newline
{\tt 7.\ \ \ \ \ \ \ x\ :=\ r\ *\ cos(2*u)\ *\ cv\ +\ sv\ *\ cu}\newline
{\tt 8.\ \ \ \ \ \ \ y\ :=\ r\ *\ sin(2*u)\ *\ cv\ -\ sv\ *\ su}\newline
{\tt 9.\ \ \ \ \ \ \ z\ :=\ a\ *\ cv}\newline
{\tt 10.\ \ \ \ \ \ point\ [x,y,z]}\newline
{\tt 11.\ \ \ \ draw(surf,\ 0..\%pi,\ -\%pi..\%pi,\ var1Steps==steps,}\newline
{\tt 12.\ \ \ \ \ \ \ \ \ var2Steps==steps,\ title\ ==\ "Etruscan\ Venus")}\newline
{\tt 13.\ \ }\newline
{\tt 14.\ \ venus(5/2,\ 13/10,\ 50)}\newline

The Figure-8 Klein Bottle
%-% \HDindex{Klein bottle}{ugFimagesFivePage}{G.4.}{images5.input}
parameterization is from
``Differential Geometry and Computer Graphics'' by Thomas Banchoff,
in {\it Perspectives in Mathematics,} Anniversary of Oberwolfasch 1984,
Birkh\"{a}user-Verlag, Basel, pp. 43-60.

  
\noindent
{\tt 15.\ \ klein(x,y)\ ==}\newline
{\tt 16.\ \ \ \ cx\ :=\ cos(x)}\newline
{\tt 17.\ \ \ \ cy\ :=\ cos(y)}\newline
{\tt 18.\ \ \ \ sx\ :=\ sin(x)}\newline
{\tt 19.\ \ \ \ sy\ :=\ sin(y)}\newline
{\tt 20.\ \ \ \ sx2\ :=\ sin(x/2)}\newline
{\tt 21.\ \ \ \ cx2\ :=\ cos(x/2)}\newline
{\tt 22.\ \ \ \ sq2\ :=\ sqrt(2.0@DFLOAT)}\newline
{\tt 23.\ \ \ \ point\ [cx\ *\ (cx2\ *\ (sq2\ +\ cy)\ +\ (sx2\ *\ sy\ *\ cy)),\ \_}\newline
{\tt 24.\ \ \ \ \ \ \ \ \ \ \ sx\ *\ (cx2\ *\ (sq2\ +\ cy)\ +\ (sx2\ *\ sy\ *\ cy)),\ \_}\newline
{\tt 25.\ \ \ \ \ \ \ \ \ \ \ -sx2\ *\ (sq2\ +\ cy)\ +\ cx2\ *\ sy\ *\ cy]}\newline
{\tt 26.\ \ }\newline
{\tt 27.\ \ draw(klein,\ 0..4*\%pi,\ 0..2*\%pi,\ var1Steps==50,}\newline
{\tt 28.\ \ \ \ \ \ \ var2Steps==50,title=="Figure\ Eight\ Klein\ Bottle")}\newline
  
\noindent

The next two images are examples of generalized tubes.

  
\noindent
{\tt 29.\ \ )read\ ntube}\newline
{\tt 30.\ \ rotateBy(p,\ theta)\ ==}\newline
{\tt 31.\ \ \ \ c\ :=\ cos(theta)}\newline
{\tt 32.\ \ \ \ s\ :=\ sin(theta)}\newline
{\tt 33.\ \ \ \ point\ [p.1*c\ -\ p.2*s,\ p.1*s\ +\ p.2*c]}\newline
{\tt 34.\ \ }\newline
{\tt 35.\ \ bcircle\ t\ ==}\newline
{\tt 36.\ \ \ \ point\ [3*cos\ t,\ 3*sin\ t,\ 0]}\newline
{\tt 37.\ \ }\newline
{\tt 38.\ \ twist(u,\ t)\ ==}\newline
{\tt 39.\ \ \ \ theta\ :=\ 4*t}\newline
{\tt 40.\ \ \ \ p\ :=\ point\ [sin\ u,\ cos(u)/2]}\newline
{\tt 41.\ \ \ \ rotateBy(p,\ theta)}\newline
{\tt 42.\ \ }\newline
{\tt 43.\ \ ntubeDrawOpt(bcircle,\ twist,\ 0..2*\%pi,\ 0..2*\%pi,}\newline
{\tt 44.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ 70,\ var2Steps\ ==\ 250)}\newline
{\tt 45.\ \ }\newline
{\tt 46.\ \ twist2(u,\ t)\ ==}\newline
{\tt 47.\ \ \ \ theta\ :=\ t}\newline
{\tt 48.\ \ \ \ p\ :=\ point\ [sin\ u,\ cos(u)]}\newline
{\tt 49.\ \ \ \ rotateBy(p,\ theta)}\newline
{\tt 50.\ \ }\newline
{\tt 51.\ \ cf(u,v)\ ==\ sin(21*u)}\newline
{\tt 52.\ \ }\newline
{\tt 53.\ \ ntubeDrawOpt(bcircle,\ twist2,\ 0..2*\%pi,\ 0..2*\%pi,}\newline
{\tt 54.\ \ \ \ colorFunction\ ==\ cf,\ var1Steps\ ==\ 168,}\newline
{\tt 55.\ \ \ \ var2Steps\ ==\ 126)}\newline
  
\noindent

\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesSixTitle}{images6.input}
\newcommand{\ugFimagesSixNumber}{G.5.}
%
% =====================================================================
\begin{page}{ugFimagesSixPage}{G.5. images6.input}
% =====================================================================
\beginscroll

  
\noindent
{\tt 1.\ \ \ gam(x,y)\ ==}\newline
{\tt 2.\ \ \ \ \ g\ :=\ Gamma\ complex(x,y)}\newline
{\tt 3.\ \ \ \ \ point\ [x,y,max(min(real\ g,\ 4),\ -4),\ argument\ g]}\newline
{\tt 4.\ \ \ }\newline
{\tt 5.\ \ \ }\newline
{\tt 6.\ \ \ draw(gam,\ -\%pi..\%pi,\ -\%pi..\%pi,}\newline
{\tt 7.\ \ \ \ \ \ \ \ title\ ==\ "Gamma(x\ +\ \%i*y)",\ \_}\newline
{\tt 8.\ \ \ \ \ \ \ \ var1Steps\ ==\ 100,\ var2Steps\ ==\ 100)}\newline
{\tt 9.\ \ \ }\newline
{\tt 10.\ \ b(x,y)\ ==\ Beta(x,y)}\newline
{\tt 11.\ \ }\newline
{\tt 12.\ \ draw(b,\ -3.1..3,\ -3.1\ ..\ 3,\ title\ ==\ "Beta(x,y)")}\newline
{\tt 13.\ \ }\newline
{\tt 14.\ \ atf(x,y)\ ==}\newline
{\tt 15.\ \ \ \ a\ :=\ atan\ complex(x,y)}\newline
{\tt 16.\ \ \ \ point\ [x,y,real\ a,\ argument\ a]}\newline
{\tt 17.\ \ }\newline
{\tt 18.\ \ draw(atf,\ -3.0..\%pi,\ -3.0..\%pi)}\newline
%-% \HDindex{function!Gamma}{ugFimagesSixPage}{G.5.}{images6.input}
%-% \HDindex{function!Euler Beta}{ugFimagesSixPage}{G.5.}{images6.input}
%-% \HDindex{Euler!Beta function}{ugFimagesSixPage}{G.5.}{images6.input}


\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesSevenTitle}{images7.input}
\newcommand{\ugFimagesSevenNumber}{G.6.}
%
% =====================================================================
\begin{page}{ugFimagesSevenPage}{G.6. images7.input}
% =====================================================================
\beginscroll

First we look at the conformal
%-% \HDindex{conformal map}{ugFimagesSevenPage}{G.6.}{images7.input}
map z +-> z + 1/z.

  
\noindent
{\tt 1.\ \ \ )read\ conformal}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ }\newline
{\tt 4.\ \ \ f\ z\ ==\ z}\newline
{\tt 5.\ \ \ }\newline
{\tt 6.\ \ \ conformalDraw(f,\ -2..2,\ -2..2,\ 9,\ 9,\ "cartesian")}\newline
{\tt 7.\ \ \ }\newline
{\tt 8.\ \ \ f\ z\ ==\ z\ +\ 1/z}\newline
{\tt 9.\ \ \ }\newline
{\tt 10.\ \ conformalDraw(f,\ -2..2,\ -2..2,\ 9,\ 9,\ "cartesian")}\newline

The map z +-> -(z+1)/(z-1) maps
the unit disk to the right half-plane, as shown
%-% \HDindex{Riemann!sphere}{ugFimagesSevenPage}{G.6.}{images7.input}
on the Riemann sphere.

  
\noindent
{\tt 11.\ \ f\ z\ ==\ z}\newline
{\tt 12.\ \ }\newline
{\tt 13.\ \ riemannConformalDraw(f,0.1..0.99,0..2*\%pi,7,11,"polar")}\newline
{\tt 14.\ \ }\newline
{\tt 15.\ \ f\ z\ ==\ -(z+1)/(z-1)}\newline
{\tt 16.\ \ riemannConformalDraw(f,0.1..0.99,0..2*\%pi,7,11,"polar")}\newline
{\tt 17.\ \ }\newline
{\tt 18.\ \ riemannSphereDraw(-4..4,\ -4..4,\ 7,\ 7,\ "cartesian")}\newline
  
\noindent

\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFimagesEightTitle}{images8.input}
\newcommand{\ugFimagesEightNumber}{G.7.}
%
% =====================================================================
\begin{page}{ugFimagesEightPage}{G.7. images8.input}
% =====================================================================
\beginscroll

  
\noindent
{\tt 1.\ \ \ )read\ dhtri}\newline
{\tt 2.\ \ \ )read\ tetra}\newline
{\tt 3.\ \ \ drawPyramid\ 4}\newline
{\tt 4.\ \ \ }\newline
%-% \HDindex{Sierpinsky's Tetrahedron}{ugFimagesEightPage}{G.7.}{images8.input}
{\tt 5.\ \ \ )read\ antoine}\newline
{\tt 6.\ \ \ drawRings\ 2}\newline
{\tt 7.\ \ \ }\newline
%-% \HDindex{Antoine's Necklace}{ugFimagesEightPage}{G.7.}{images8.input}
{\tt 8.\ \ \ )read\ scherk}\newline
{\tt 9.\ \ \ drawScherk(3,3)}\newline
{\tt 10.\ \ }\newline
%-% \HDindex{Scherk's minimal surface}{ugFimagesEightPage}{G.7.}{images8.input}
{\tt 11.\ \ )read\ ribbonsNew}\newline
{\tt 12.\ \ drawRibbons([x^i\ for\ i\ in\ 1..5],\ x=-1..1,\ y=0..2)}\newline


%\input{gallery/conformal.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFconformalTitle}{conformal.input}
\newcommand{\ugFconformalNumber}{G.8.}
%
% =====================================================================
\begin{page}{ugFconformalPage}{G.8. conformal.input}
% =====================================================================
\beginscroll
%
The functions in this section draw conformal maps both on the
%-% \HDindex{conformal map}{ugFconformalPage}{G.8.}{conformal.input}
plane and on the Riemann sphere.
%-% \HDindex{Riemann!sphere}{ugFconformalPage}{G.8.}{conformal.input}

%\xmpLine{)set fun comp on}{}
  
\noindent
{\tt 1.\ \ \ C\ :=\ Complex\ DoubleFloat}\newline
{\tt 2.\ \ \ S\ :=\ Segment\ DoubleFloat}\newline
{\tt 3.\ \ \ R3\ :=\ Point\ DFLOAT}\newline
{\tt 4.\ \ \ }\newline

\userfun{conformalDraw}{\it (f, rRange, tRange, rSteps, tSteps, coord)}
draws the image of the coordinate grid under {\it f} in the complex plane.
The grid may be given in either polar or Cartesian coordinates.
Argument {\it f} is the function to draw;
{\it rRange} is the range of the radius (in polar) or real (in Cartesian);
{\it tRange} is the range of \theta (in polar) or imaginary (in Cartesian);
{\it tSteps, rSteps}, are the number of intervals in the {\it r} and
\theta directions; and
{\it coord} is the coordinate system to use (either {\tt "polar"} or
{\tt "cartesian"}).

  
\noindent
{\tt 5.\ \ \ conformalDraw:\ (C\ ->\ C,\ S,\ S,\ PI,\ PI,\ String)\ ->\ VIEW3D}\newline
{\tt 6.\ \ \ conformalDraw(f,rRange,tRange,rSteps,tSteps,coord)\ ==}\newline
{\tt 7.\ \ \ \ \ transformC\ :=}\newline
{\tt 8.\ \ \ \ \ \ \ coord\ =\ "polar"\ =>\ polar2Complex}\newline
{\tt 9.\ \ \ \ \ \ \ cartesian2Complex}\newline
{\tt 10.\ \ \ \ cm\ :=\ makeConformalMap(f,\ transformC)}\newline
{\tt 11.\ \ \ \ sp\ :=\ createThreeSpace()}\newline
{\tt 12.\ \ \ \ adaptGrid(sp,\ cm,\ rRange,\ tRange,\ rSteps,\ tSteps)}\newline
{\tt 13.\ \ \ \ makeViewport3D(sp,\ "Conformal\ Map")}\newline
  
\noindent

\userfun{riemannConformalDraw}{\it (f, rRange, tRange, rSteps, tSteps, coord)}
draws the image of the coordinate grid under {\it f} on the Riemann sphere.
The grid may be given in either polar or Cartesian coordinates.
Its arguments are the same as those for \userfun{conformalDraw}.
  
\noindent
{\tt 14.\ \ riemannConformalDraw:(C->C,S,S,PI,PI,String)->VIEW3D}\newline
{\tt 15.\ \ riemannConformalDraw(f,\ rRange,\ tRange,}\newline
{\tt 16.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rSteps,\ tSteps,\ coord)\ ==}\newline
{\tt 17.\ \ \ \ transformC\ :=}\newline
{\tt 18.\ \ \ \ \ \ coord\ =\ "polar"\ =>\ polar2Complex}\newline
{\tt 19.\ \ \ \ \ \ cartesian2Complex}\newline
{\tt 20.\ \ \ \ sp\ :=\ createThreeSpace()}\newline
{\tt 21.\ \ \ \ cm\ :=\ makeRiemannConformalMap(f,\ transformC)}\newline
{\tt 22.\ \ \ \ adaptGrid(sp,\ cm,\ rRange,\ tRange,\ rSteps,\ tSteps)}\newline
{\tt 23.\ \ \ \ curve(sp,[point\ [0,0,2.0@DFLOAT,0],point\ [0,0,2.0@DFLOAT,0]])}\newline
{\tt 24.\ \ \ \ makeViewport3D(sp,"Map\ on\ the\ Riemann\ Sphere")}\newline
{\tt 25.\ \ }\newline
{\tt 26.\ \ adaptGrid(sp,\ f,\ uRange,\ vRange,\ \ uSteps,\ vSteps)\ ==}\newline
{\tt 27.\ \ \ \ delU\ :=\ (high(uRange)\ -\ low(uRange))/uSteps}\newline
{\tt 28.\ \ \ \ delV\ :=\ (high(vRange)\ -\ low(vRange))/vSteps}\newline
{\tt 29.\ \ \ \ uSteps\ :=\ uSteps\ +\ 1;\ vSteps\ :=\ vSteps\ +\ 1}\newline
{\tt 30.\ \ \ \ u\ :=\ low\ uRange}\newline
{\tt 31.\ \ \ \ for\ i\ in\ 1..uSteps\ repeat}\newline
{\tt 32.\ \ \ \ \ \ c\ :=\ curryLeft(f,u)}\newline
{\tt 33.\ \ \ \ \ \ cf\ :=\ (t:DFLOAT):DFLOAT\ +->\ 0}\newline
{\tt 34.\ \ \ \ \ \ makeObject(c,vRange::SEG\ Float,colorFunction==cf,}\newline
{\tt 35.\ \ \ \ \ \ \ \ space\ ==\ sp,\ tubeRadius\ ==\ .02,\ tubePoints\ ==\ 6)}\newline
{\tt 36.\ \ \ \ \ \ u\ :=\ u\ +\ delU}\newline
{\tt 37.\ \ \ \ v\ :=\ low\ vRange}\newline
{\tt 38.\ \ \ \ for\ i\ in\ 1..vSteps\ repeat}\newline
{\tt 39.\ \ \ \ \ \ c\ :=\ curryRight(f,v)}\newline
{\tt 40.\ \ \ \ \ \ cf\ :=\ (t:DFLOAT):DFLOAT\ +->\ 1}\newline
{\tt 41.\ \ \ \ \ \ makeObject(c,uRange::SEG\ Float,colorFunction==cf,}\newline
{\tt 42.\ \ \ \ \ \ \ \ space\ ==\ sp,\ tubeRadius\ ==\ .02,\ tubePoints\ ==\ 6)}\newline
{\tt 43.\ \ \ \ \ \ v\ :=\ v\ +\ delV}\newline
{\tt 44.\ \ \ \ void()}\newline
{\tt 45.\ \ }\newline
{\tt 46.\ \ riemannTransform(z)\ ==}\newline
{\tt 47.\ \ \ \ r\ :=\ sqrt\ norm\ z}\newline
{\tt 48.\ \ \ \ cosTheta\ :=\ (real\ z)/r}\newline
{\tt 49.\ \ \ \ sinTheta\ :=\ (imag\ z)/r}\newline
{\tt 50.\ \ \ \ cp\ :=\ 4*r/(4+r^2)}\newline
{\tt 51.\ \ \ \ sp\ :=\ sqrt(1-cp*cp)}\newline
{\tt 52.\ \ \ \ if\ r>2\ then\ sp\ :=\ -sp}\newline
{\tt 53.\ \ \ \ point\ [cosTheta*cp,\ sinTheta*cp,\ -sp\ +\ 1]}\newline
{\tt 54.\ \ }\newline
{\tt 55.\ \ cartesian2Complex(r:DFLOAT,\ i:DFLOAT):C\ ==}\newline
{\tt 56.\ \ \ \ complex(r,\ i)}\newline
{\tt 57.\ \ }\newline
{\tt 58.\ \ polar2Complex(r:DFLOAT,\ th:DFLOAT):C\ ==}\newline
{\tt 59.\ \ \ \ complex(r*cos(th),\ r*sin(th))}\newline
{\tt 60.\ \ }\newline
{\tt 61.\ \ makeConformalMap(f,\ transformC)\ ==}\newline
{\tt 62.\ \ \ \ (u:DFLOAT,v:DFLOAT):R3\ +->}\newline
{\tt 63.\ \ \ \ \ \ z\ :=\ f\ transformC(u,\ v)}\newline
{\tt 64.\ \ \ \ \ \ point\ [real\ z,\ imag\ z,\ 0.0@DFLOAT]}\newline
{\tt 65.\ \ }\newline
{\tt 66.\ \ makeRiemannConformalMap(f,\ transformC)\ ==}\newline
{\tt 67.\ \ \ \ (u:DFLOAT,\ v:DFLOAT):R3\ +->}\newline
{\tt 68.\ \ \ \ \ \ riemannTransform\ f\ transformC(u,\ v)}\newline
{\tt 69.\ \ }\newline
{\tt 70.\ \ riemannSphereDraw:\ (S,\ S,\ PI,\ PI,\ String)\ ->\ VIEW3D}\newline
{\tt 71.\ \ riemannSphereDraw(rRange,tRange,rSteps,tSteps,coord)\ ==}\newline
{\tt 72.\ \ \ \ transformC\ :=}\newline
{\tt 73.\ \ \ \ \ \ coord\ =\ "polar"\ =>\ polar2Complex}\newline
{\tt 74.\ \ \ \ \ \ cartesian2Complex}\newline
{\tt 75.\ \ \ \ grid\ :=\ (u:DFLOAT,\ v:DFLOAT):\ R3\ +->}\newline
{\tt 76.\ \ \ \ \ \ z1\ :=\ transformC(u,\ v)}\newline
{\tt 77.\ \ \ \ \ \ point\ [real\ z1,\ imag\ z1,\ 0]}\newline
{\tt 78.\ \ \ \ sp\ :=\ createThreeSpace()}\newline
{\tt 79.\ \ \ \ adaptGrid(sp,\ grid,\ rRange,\ tRange,\ rSteps,\ tSteps)}\newline
{\tt 80.\ \ \ \ connectingLines(sp,grid,rRange,tRange,rSteps,tSteps)}\newline
{\tt 81.\ \ \ \ makeObject(riemannSphere,0..2*\%pi,0..\%pi,space==sp)}\newline
{\tt 82.\ \ \ \ f\ :=\ (z:C):C\ +->\ z}\newline
{\tt 83.\ \ \ \ cm\ :=\ makeRiemannConformalMap(f,\ transformC)}\newline
{\tt 84.\ \ \ \ adaptGrid(sp,\ cm,\ rRange,\ tRange,\ rSteps,\ tSteps)}\newline
{\tt 85.\ \ \ \ makeViewport3D(sp,\ "Riemann\ Sphere")}\newline
{\tt 86.\ \ }\newline
{\tt 87.\ \ connectingLines(sp,f,uRange,vRange,uSteps,vSteps)\ ==}\newline
{\tt 88.\ \ \ \ delU\ :=\ (high(uRange)\ -\ low(uRange))/uSteps}\newline
{\tt 89.\ \ \ \ delV\ :=\ (high(vRange)\ -\ low(vRange))/vSteps}\newline
{\tt 90.\ \ \ \ uSteps\ :=\ uSteps\ +\ 1;\ vSteps\ :=\ vSteps\ +\ 1}\newline
{\tt 91.\ \ \ \ u\ :=\ low\ uRange}\newline
{\tt 92.\ \ \ \ for\ i\ in\ 1..uSteps\ repeat}\newline
{\tt 93.\ \ \ \ \ \ v\ :=\ low\ vRange}\newline
{\tt 94.\ \ \ \ \ \ for\ j\ in\ 1..vSteps\ repeat}\newline
{\tt 95.\ \ \ \ \ \ \ \ p1\ :=\ f(u,v)}\newline
{\tt 96.\ \ \ \ \ \ \ \ p2\ :=\ riemannTransform\ complex(p1.1,\ p1.2)}\newline
{\tt 97.\ \ \ \ \ \ \ \ fun\ :=\ lineFromTo(p1,p2)}\newline
{\tt 98.\ \ \ \ \ \ \ \ cf\ :=\ (t:DFLOAT):DFLOAT\ +->\ 3}\newline
{\tt 99.\ \ \ \ \ \ \ \ makeObject(fun,\ 0..1,space==sp,tubePoints==4,}\newline
{\tt 100.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tubeRadius==0.01,colorFunction==cf)}\newline
{\tt 101.\ \ \ \ \ \ \ v\ :=\ v\ +\ delV}\newline
{\tt 102.\ \ \ \ \ u\ :=\ u\ +\ delU}\newline
{\tt 103.\ \ \ void()}\newline
{\tt 104.\ }\newline
{\tt 105.\ riemannSphere(u,v)\ ==}\newline
{\tt 106.\ \ \ sv\ :=\ sin(v)}\newline
{\tt 107.\ \ \ 0.99@DFLOAT*(point\ [cos(u)*sv,sin(u)*sv,cos(v),0.0@DFLOAT])+}\newline
{\tt 108.\ \ \ \ \ point\ [0.0@DFLOAT,\ 0.0@DFLOAT,\ 1.0@DFLOAT,\ 4.0@DFLOAT]}\newline
{\tt 109.\ }\newline
{\tt 110.\ lineFromTo(p1,\ p2)\ ==}\newline
{\tt 111.\ \ \ d\ :=\ p2\ -\ p1}\newline
{\tt 112.\ \ \ (t:DFLOAT):Point\ DFLOAT\ +->}\newline
{\tt 113.\ \ \ \ \ p1\ +\ t*d}\newline
  
\noindent

%\input{gallery/tknot.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFtknotTitle}{tknot.input}
\newcommand{\ugFtknotNumber}{G.9.}
%
% =====================================================================
\begin{page}{ugFtknotPage}{G.9. tknot.input}
% =====================================================================
\beginscroll
%
Create a $(p,q)$ torus-knot with radius $r$ around the curve.
The formula was derived by Larry Lambe.

  
\noindent
{\tt 1.\ \ \ )read\ ntube}\newline
{\tt 2.\ \ \ torusKnot:\ (DFLOAT,\ DFLOAT,\ DFLOAT,\ PI,\ PI)\ ->\ VIEW3D}\newline
{\tt 3.\ \ \ torusKnot(p,\ q\ ,r,\ uSteps,\ tSteps)\ ==}\newline
{\tt 4.\ \ \ \ \ knot\ :=\ (t:DFLOAT):Point\ DFLOAT\ +->}\newline
{\tt 5.\ \ \ \ \ \ \ fac\ :=\ 4/(2.2@DFLOAT-sin(q*t))}\newline
{\tt 6.\ \ \ \ \ \ \ fac\ *\ point\ [cos(p*t),\ sin(p*t),\ cos(q*t)]}\newline
{\tt 7.\ \ \ \ \ circle\ :=\ (u:DFLOAT,\ t:DFLOAT):\ Point\ DFLOAT\ +->}\newline
{\tt 8.\ \ \ \ \ \ \ r\ *\ point\ [cos\ u,\ sin\ u]}\newline
{\tt 9.\ \ \ \ \ ntubeDrawOpt(knot,\ circle,\ 0..2*\%pi,\ 0..2*\%pi,}\newline
{\tt 10.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ uSteps,\ var2Steps\ ==\ tSteps)}\newline
{\tt 11.\ \ }\newline

%\input{gallery/ntube.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFntubeTitle}{ntube.input}
\newcommand{\ugFntubeNumber}{G.10.}
%
% =====================================================================
\begin{page}{ugFntubePage}{G.10. ntube.input}
% =====================================================================
\beginscroll
%
The functions in this file create generalized tubes (also known as generalized
cylinders).
These functions draw a 2-d curve in the normal
planes around a 3-d curve.

  
\noindent
{\tt 1.\ \ \ R3\ :=\ Point\ DFLOAT}\newline
{\tt 2.\ \ \ R2\ :=\ Point\ DFLOAT}\newline
{\tt 3.\ \ \ S\ :=\ Segment\ Float}\newline
{\tt 4.\ \ \ }\newline
{\tt 5.\ \ \ ThreeCurve\ :=\ DFLOAT\ ->\ R3}\newline
{\tt 6.\ \ \ TwoCurve\ :=\ (DFLOAT,\ DFLOAT)\ ->\ R2}\newline
{\tt 7.\ \ \ Surface\ :=\ (DFLOAT,\ DFLOAT)\ ->\ R3}\newline
{\tt 8.\ \ \ }\newline
{\tt 9.\ \ \ FrenetFrame\ :=}\newline
{\tt 10.\ \ \ \ \ Record(value:R3,tangent:R3,normal:R3,binormal:R3)}\newline
{\tt 11.\ \ frame:\ FrenetFrame}\newline
{\tt 12.\ \ }\newline

\userfun{ntubeDraw}{\it (spaceCurve, planeCurve,}
$u_0 .. u_1,$ $t_0 .. t_1)$
draws {\it planeCurve} in the normal planes of {\it spaceCurve.}
The parameter $u_0 .. u_1$ specifies
the parameter range for {\it planeCurve}
and $t_0 .. t_1$ specifies the parameter range for {\it spaceCurve}.
Additionally, the plane curve function takes
a second parameter: the current parameter of {\it spaceCurve}.
This allows the plane curve to change shape
as it goes around the space curve.
See \downlink{``\ugFimagesFiveTitle''}{ugFimagesFivePage} in Section \ugFimagesFiveNumber\ignore{ugFimagesFive} for an example of this.
%
  
\noindent
{\tt 13.\ \ ntubeDraw:\ (ThreeCurve,TwoCurve,S,S)\ ->\ VIEW3D}\newline
{\tt 14.\ \ ntubeDraw(spaceCurve,planeCurve,uRange,tRange)\ ==}\newline
{\tt 15.\ \ \ \ ntubeDrawOpt(spaceCurve,\ planeCurve,\ uRange,\ \_}\newline
{\tt 16.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tRange,\ []\$List\ DROPT)}\newline
{\tt 17.\ \ }\newline
{\tt 18.\ \ ntubeDrawOpt:\ (ThreeCurve,TwoCurve,S,S,List\ DROPT)}\newline
{\tt 19.\ \ \ \ \ \ ->\ VIEW3D}\newline
{\tt 20.\ \ ntubeDrawOpt(spaceCurve,planeCurve,uRange,tRange,l)\ ==}\newline
{\tt 21.\ \ }\newline
{\tt 22.\ \ \ \ delT:DFLOAT\ :=\ (high(tRange)\ -\ low(tRange))/10000}\newline
{\tt 23.\ \ \ \ oldT:DFLOAT\ :=\ low(tRange)\ -\ 1}\newline
{\tt 24.\ \ \ \ fun\ :=\ ngeneralTube(spaceCurve,planeCurve,delT,oldT)}\newline
{\tt 25.\ \ \ \ draw(fun,\ uRange,\ tRange,\ l)}\newline
{\tt 26.\ \ }\newline
  
\noindent

\userfun{nfrenetFrame}{\it (c, t, delT)}
numerically computes the Frenet frame
about the curve {\it c} at {\it t}.
Parameter {\it delT} is a small number used to
compute derivatives.
  
\noindent
{\tt 27.\ \ nfrenetFrame(c,\ t,\ delT)\ ==}\newline
{\tt 28.\ \ \ \ f0\ :=\ c(t)}\newline
{\tt 29.\ \ \ \ f1\ :=\ c(t+delT)}\newline
{\tt 30.\ \ \ \ t0\ :=\ f1\ -\ f0}\newline
{\tt 31.\ \ \ \ n0\ :=\ f1\ +\ f0}\newline
{\tt 32.\ \ \ \ b\ :=\ cross(t0,\ n0)}\newline
{\tt 33.\ \ \ \ n\ :=\ cross(b,t0)}\newline
{\tt 34.\ \ \ \ ln\ :=\ length\ n}\newline
{\tt 35.\ \ \ \ lb\ :=\ length\ b}\newline
{\tt 36.\ \ \ \ ln\ =\ 0\ or\ lb\ =\ 0\ =>}\newline
{\tt 37.\ \ \ \ \ \ \ \ error\ "Frenet\ Frame\ not\ well\ defined"}\newline
{\tt 38.\ \ \ \ n\ :=\ (1/ln)*n}\newline
{\tt 39.\ \ \ \ b\ :=\ (1/lb)*b}\newline
{\tt 40.\ \ \ \ [f0,\ t0,\ n,\ b]\$FrenetFrame}\newline
  
\noindent

\userfun{ngeneralTube}{\it (spaceCurve, planeCurve,}{\it  delT, oltT)}
creates a function that can be passed to the system \spadfun{draw} command.
The function is a parameterized surface for the general tube
around {\it spaceCurve}.  {\it delT} is a small number used to compute
derivatives. {\it oldT} is used to hold the current value of the
{\it t} parameter for {\it spaceCurve.}  This is an efficiency measure
to ensure that frames are only computed once for each value of {\it t}.
  
\noindent
{\tt 41.\ \ ngeneralTube:\ (ThreeCurve,\ TwoCurve,\ DFLOAT,\ DFLOAT)\ ->\ Surface}\newline
{\tt 42.\ \ ngeneralTube(spaceCurve,\ planeCurve,\ delT,\ oldT)\ ==}\newline
{\tt 43.\ \ \ \ free\ frame}\newline
{\tt 44.\ \ \ \ (v:DFLOAT,\ t:\ DFLOAT):\ R3\ +->}\newline
{\tt 45.\ \ \ \ \ \ if\ (t\ \notequal{}\ oldT)\ then}\newline
{\tt 46.\ \ \ \ \ \ \ \ frame\ :=\ nfrenetFrame(spaceCurve,\ t,\ delT)}\newline
{\tt 47.\ \ \ \ \ \ \ \ oldT\ :=\ t}\newline
{\tt 48.\ \ \ \ \ \ p\ :=\ planeCurve(v,\ t)}\newline
{\tt 49.\ \ \ \ \ \ frame.value\ +\ p.1*frame.normal\ +\ p.2*frame.binormal}\newline
  
\noindent

%\input{gallery/dhtri.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFdhtriTitle}{dhtri.input}
\newcommand{\ugFdhtriNumber}{G.11.}
%
% =====================================================================
\begin{page}{ugFdhtriPage}{G.11. dhtri.input}
% =====================================================================
\beginscroll
%
Create affine transformations (DH matrices) that transform
a given triangle into another.

  
\noindent
{\tt 1.\ \ \ tri2tri:\ (List\ Point\ DFLOAT,\ List\ Point\ DFLOAT)\ ->\ DHMATRIX(DFLOAT)}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ tri2tri(t1,\ t2)\ ==}\newline
{\tt 4.\ \ \ \ \ n1\ :=\ triangleNormal(t1)}\newline
{\tt 5.\ \ \ \ \ n2\ :=\ triangleNormal(t2)}\newline
{\tt 6.\ \ \ \ \ tet2tet(concat(t1,\ n1),\ concat(t2,\ n2))}\newline
{\tt 7.\ \ \ }\newline
{\tt 8.\ \ \ tet2tet:\ (List\ Point\ DFLOAT,\ List\ Point\ DFLOAT)\ ->\ DHMATRIX(DFLOAT)}\newline
{\tt 9.\ \ \ }\newline
{\tt 10.\ \ tet2tet(t1,\ t2)\ ==}\newline
{\tt 11.\ \ \ \ m1\ :=\ makeColumnMatrix\ t1}\newline
{\tt 12.\ \ \ \ m2\ :=\ makeColumnMatrix\ t2}\newline
{\tt 13.\ \ \ \ m2\ *\ inverse(m1)}\newline
{\tt 14.\ \ }\newline
{\tt 15.\ \ makeColumnMatrix(t)\ ==}\newline
{\tt 16.\ \ \ \ m\ :=\ new(4,4,0)\$DHMATRIX(DFLOAT)}\newline
{\tt 17.\ \ \ \ for\ x\ in\ t\ for\ i\ in\ 1..repeat}\newline
{\tt 18.\ \ \ \ \ \ for\ j\ in\ 1..3\ repeat}\newline
{\tt 19.\ \ \ \ \ \ \ \ m(j,i)\ :=\ x.j}\newline
{\tt 20.\ \ \ \ \ \ m(4,i)\ :=\ 1}\newline
{\tt 21.\ \ \ \ m}\newline
{\tt 22.\ \ }\newline
{\tt 23.\ \ triangleNormal(t)\ ==}\newline
{\tt 24.\ \ \ \ a\ :=\ triangleArea\ t}\newline
{\tt 25.\ \ \ \ p1\ :=\ t.2\ -\ t.1}\newline
{\tt 26.\ \ \ \ p2\ :=\ t.3\ -\ t.2}\newline
{\tt 27.\ \ \ \ c\ :=\ cross(p1,\ p2)}\newline
{\tt 28.\ \ \ \ len\ :=\ length(c)}\newline
{\tt 29.\ \ \ \ len\ =\ 0\ =>\ error\ "degenerate\ triangle!"}\newline
{\tt 30.\ \ \ \ c\ :=\ (1/len)*c}\newline
{\tt 31.\ \ \ \ t.1\ +\ sqrt(a)\ *\ c}\newline
{\tt 32.\ \ }\newline
{\tt 33.\ \ triangleArea\ t\ ==}\newline
{\tt 34.\ \ \ \ a\ :=\ length(t.2\ -\ t.1)}\newline
{\tt 35.\ \ \ \ b\ :=\ length(t.3\ -\ t.2)}\newline
{\tt 36.\ \ \ \ c\ :=\ length(t.1\ -\ t.3)}\newline
{\tt 37.\ \ \ \ s\ :=\ (a+b+c)/2}\newline
{\tt 38.\ \ \ \ sqrt(s*(s-a)*(s-b)*(s-c))}\newline
%$

\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFtetraTitle}{tetra.input}
\newcommand{\ugFtetraNumber}{G.12.}
%
% =====================================================================
\begin{page}{ugFtetraPage}{G.12. tetra.input}
% =====================================================================
\beginscroll
%
%\input{gallery/tetra.htex}
%\outdent{Sierpinsky's Tetrahedron}

  
\noindent
{\tt 1.\ \ \ )set\ expose\ add\ con\ DenavitHartenbergMatrix}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ x1:DFLOAT\ :=\ sqrt(2.0@DFLOAT/3.0@DFLOAT)}\newline
{\tt 4.\ \ \ x2:DFLOAT\ :=\ sqrt(3.0@DFLOAT)/6}\newline
{\tt 5.\ \ \ }\newline
{\tt 6.\ \ \ z\ :=\ 0.0@DFLOAT}\newline
{\tt 7.\ \ \ h\ :=\ 0.5@DFLOAT}\newline
{\tt 8.\ \ \ }\newline
{\tt 9.\ \ \ p1\ :=\ point\ [-h,\ -x2,\ z]}\newline
{\tt 10.\ \ p2\ :=\ point\ [h,\ -x2,\ z]}\newline
{\tt 11.\ \ p3\ :=\ point\ [z,\ 2*x2,\ z]}\newline
{\tt 12.\ \ p4\ :=\ point\ [z,\ z,\ x1]}\newline
{\tt 13.\ \ }\newline
{\tt 14.\ \ baseTriangle\ \ :=\ [p2,\ p1,\ p3]}\newline
{\tt 15.\ \ }\newline
{\tt 16.\ \ mt\ :=\ [h*(p2+p1),\ h*(p1+p3),\ h*(p3+p2)]}\newline
{\tt 17.\ \ }\newline
{\tt 18.\ \ bt1\ :=\ [mt.1,\ p1,\ mt.2]}\newline
{\tt 19.\ \ bt2\ :=\ [p2,\ mt.1,\ mt.3]}\newline
{\tt 20.\ \ bt3\ :=\ [mt.2,\ p3,\ mt.3]}\newline
{\tt 21.\ \ bt4\ :=\ [h*(p2+p4),\ h*(p1+p4),\ h*(p3+p4)]}\newline
{\tt 22.\ \ }\newline
{\tt 23.\ \ tt1\ :=\ tri2tri(baseTriangle,\ bt1)}\newline
{\tt 24.\ \ tt2\ :=\ tri2tri(baseTriangle,\ bt2)}\newline
{\tt 25.\ \ tt3\ :=\ tri2tri(baseTriangle,\ bt3)}\newline
{\tt 26.\ \ tt4\ :=\ tri2tri(baseTriangle,\ bt4)}\newline
{\tt 27.\ \ }\newline
{\tt 28.\ \ drawPyramid(n)\ ==}\newline
{\tt 29.\ \ \ \ s\ :=\ createThreeSpace()}\newline
{\tt 30.\ \ \ \ dh\ :=\ rotatex(0.0@DFLOAT)}\newline
{\tt 31.\ \ \ \ drawPyramidInner(s,\ n,\ dh)}\newline
{\tt 32.\ \ \ \ makeViewport3D(s,\ "Sierpinsky\ Tetrahedron")}\newline
{\tt 33.\ \ }\newline
{\tt 34.\ \ drawPyramidInner(s,\ n,\ dh)\ ==}\newline
{\tt 35.\ \ \ \ n\ =\ 0\ =>\ makeTetrahedron(s,\ dh,\ n)}\newline
{\tt 36.\ \ \ \ drawPyramidInner(s,\ n-1,\ dh\ *\ tt1)}\newline
{\tt 37.\ \ \ \ drawPyramidInner(s,\ n-1,\ dh\ *\ tt2)}\newline
{\tt 38.\ \ \ \ drawPyramidInner(s,\ n-1,\ dh\ *\ tt3)}\newline
{\tt 39.\ \ \ \ drawPyramidInner(s,\ n-1,\ dh\ *\ tt4)}\newline
{\tt 40.\ \ }\newline
{\tt 41.\ \ makeTetrahedron(sp,\ dh,\ color)\ ==}\newline
{\tt 42.\ \ \ \ w1\ :=\ dh*p1}\newline
{\tt 43.\ \ \ \ w2\ :=\ dh*p2}\newline
{\tt 44.\ \ \ \ w3\ :=\ dh*p3}\newline
{\tt 45.\ \ \ \ w4\ :=\ dh*p4}\newline
{\tt 46.\ \ \ \ polygon(sp,\ [w1,\ w2,\ w4])}\newline
{\tt 47.\ \ \ \ polygon(sp,\ [w1,\ w3,\ w4])}\newline
{\tt 48.\ \ \ \ polygon(sp,\ [w2,\ w3,\ w4])}\newline
{\tt 49.\ \ \ \ void()}\newline
%-% \HDindex{Sierpinsky's Tetrahedron}{ugFtetraPage}{G.12.}{tetra.input}


%\input{gallery/antoine.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFantoineTitle}{antoine.input}
\newcommand{\ugFantoineNumber}{G.13.}
%
% =====================================================================
\begin{page}{ugFantoinePage}{G.13. antoine.input}
% =====================================================================
\beginscroll
%
Draw Antoine's Necklace.
%-% \HDindex{Antoine's Necklace}{ugFantoinePage}{G.13.}{antoine.input}
Thank you to Matthew Grayson at IBM's T.J Watson Research Center for the idea.

  
\noindent
{\tt 1.\ \ \ )set\ expose\ add\ con\ DenavitHartenbergMatrix}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ torusRot:\ DHMATRIX(DFLOAT)}\newline
{\tt 4.\ \ \ }\newline
{\tt 5.\ \ \ }\newline
{\tt 6.\ \ \ drawRings(n)\ ==}\newline
{\tt 7.\ \ \ \ \ s\ :=\ createThreeSpace()}\newline
{\tt 8.\ \ \ \ \ dh:DHMATRIX(DFLOAT)\ :=\ identity()}\newline
{\tt 9.\ \ \ \ \ drawRingsInner(s,\ n,\ dh)}\newline
{\tt 10.\ \ \ \ makeViewport3D(s,\ "Antoine's\ Necklace")}\newline
{\tt 11.\ \ }\newline

In order to draw Antoine rings, we take one ring, scale it down to
a smaller size, rotate it around its central axis, translate it
to the edge of the larger ring and rotate it around the edge to
a point corresponding to its count (there are 10 positions around
the edge of the larger ring). For each of these new rings we
recursively perform the operations, each ring becoming 10 smaller
rings. Notice how the \spadtype{DHMATRIX} operations are used to build up
the proper matrix composing all these transformations.

  
\noindent
{\tt 12.\ \ F\ ==>\ DFLOAT}\newline
{\tt 13.\ \ drawRingsInner(s,\ n,\ dh)\ ==}\newline
{\tt 14.\ \ \ \ n\ =\ 0\ =>}\newline
{\tt 15.\ \ \ \ \ \ drawRing(s,\ dh)}\newline
{\tt 16.\ \ \ \ \ \ void()}\newline
{\tt 17.\ \ \ \ t\ :=\ 0.0@F}\newline
{\tt 18.\ \ \ \ p\ :=\ 0.0@F}\newline
{\tt 19.\ \ \ \ tr\ :=\ 1.0@F}\newline
{\tt 20.\ \ \ \ inc\ :=\ 0.1@F}\newline
{\tt 21.\ \ \ \ for\ i\ in\ 1..10\ repeat}\newline
{\tt 22.\ \ \ \ \ \ tr\ :=\ tr\ +\ inc}\newline
{\tt 23.\ \ \ \ \ \ inc\ :=\ -inc}\newline
{\tt 24.\ \ \ \ \ \ dh'\ :=\ dh*rotatez(t)*translate(tr,0.0@F,0.0@F)*}\newline
{\tt 25.\ \ \ \ \ \ \ \ \ \ \ \ \ rotatey(p)*scale(0.35@F,\ 0.48@F,\ 0.4@F)}\newline
{\tt 26.\ \ \ \ \ \ drawRingsInner(s,\ n-1,\ dh')}\newline
{\tt 27.\ \ \ \ \ \ t\ :=\ t\ +\ 36.0@F}\newline
{\tt 28.\ \ \ \ \ \ p\ :=\ p\ +\ 90.0@F}\newline
{\tt 29.\ \ \ \ void()}\newline
{\tt 30.\ \ }\newline
{\tt 31.\ \ drawRing(s,\ dh)\ ==}\newline
{\tt 32.\ \ \ \ free\ torusRot}\newline
{\tt 33.\ \ \ \ torusRot\ :=\ dh}\newline
{\tt 34.\ \ \ \ makeObject(torus,\ 0..2*\%pi,\ 0..2*\%pi,\ var1Steps\ ==\ 6,}\newline
{\tt 35.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ space\ ==\ s,\ var2Steps\ ==\ 15)}\newline
{\tt 36.\ \ }\newline
{\tt 37.\ \ torus(u\ ,v)\ ==}\newline
{\tt 38.\ \ \ \ cu\ :=\ cos(u)/6}\newline
{\tt 39.\ \ \ \ torusRot*point\ [(1+cu)*cos(v),(1+cu)*sin(v),(sin\ u)/6]}\newline
  
\noindent

%\input{gallery/scherk.htex}
\endscroll
\autobuttons
\end{page}
%
%
\newcommand{\ugFscherkTitle}{scherk.input}
\newcommand{\ugFscherkNumber}{G.14.}
%
% =====================================================================
\begin{page}{ugFscherkPage}{G.14. scherk.input}
% =====================================================================
\beginscroll
%

Scherk's minimal surface, defined by:
%-% \HDindex{Scherk's minimal surface}{ugFscherkPage}{G.14.}{scherk.input}
\spad{exp(z) * cos(x) = cos(y)}.
See: {\it A Comprehensive Introduction to Differential Geometry,} Vol. 3,
by Michael Spivak, Publish Or Perish, Berkeley, 1979, pp. 249-252.

  
\noindent
{\tt 1.\ \ \ (xOffset,\ yOffset):DFLOAT}\newline
{\tt 2.\ \ \ }\newline
{\tt 3.\ \ \ }\newline
{\tt 4.\ \ \ drawScherk(m,n)\ ==}\newline
{\tt 5.\ \ \ \ \ free\ xOffset,\ yOffset}\newline
{\tt 6.\ \ \ \ \ space\ :=\ createThreeSpace()}\newline
{\tt 7.\ \ \ \ \ for\ i\ in\ 0..m-1\ repeat}\newline
{\tt 8.\ \ \ \ \ \ \ xOffset\ :=\ i*\%pi}\newline
{\tt 9.\ \ \ \ \ \ \ for\ j\ in\ 0\ ..\ n-1\ repeat}\newline
{\tt 10.\ \ \ \ \ \ \ \ rem(i+j,\ 2)\ =\ 0\ =>\ 'iter}\newline
{\tt 11.\ \ \ \ \ \ \ \ yOffset\ :=\ j*\%pi}\newline
{\tt 12.\ \ \ \ \ \ \ \ drawOneScherk(space)}\newline
{\tt 13.\ \ \ \ makeViewport3D(space,\ "Scherk's\ Minimal\ Surface")}\newline
{\tt 14.\ \ }\newline
{\tt 15.\ \ scherk1(u,v)\ ==}\newline
{\tt 16.\ \ \ \ x\ :=\ cos(u)/exp(v)}\newline
{\tt 17.\ \ \ \ point\ [xOffset\ +\ acos(x),\ yOffset\ +\ u,\ v,\ abs(v)]}\newline
{\tt 18.\ \ }\newline
{\tt 19.\ \ scherk2(u,v)\ ==}\newline
{\tt 20.\ \ \ \ x\ :=\ cos(u)/exp(v)}\newline
{\tt 21.\ \ \ \ point\ [xOffset\ -\ acos(x),\ yOffset\ +\ u,\ v,\ abs(v)]}\newline
{\tt 22.\ \ }\newline
{\tt 23.\ \ scherk3(u,v)\ ==}\newline
{\tt 24.\ \ \ \ x\ :=\ exp(v)\ *\ cos(u)}\newline
{\tt 25.\ \ \ \ point\ [xOffset\ +\ u,\ yOffset\ +\ acos(x),\ v,\ abs(v)]}\newline
{\tt 26.\ \ }\newline
{\tt 27.\ \ scherk4(u,v)\ ==}\newline
{\tt 28.\ \ \ \ x\ :=\ exp(v)\ *\ cos(u)}\newline
{\tt 29.\ \ \ \ point\ [xOffset\ +\ u,\ yOffset\ -\ acos(x),\ v,\ abs(v)]}\newline
{\tt 30.\ \ }\newline
{\tt 31.\ \ drawOneScherk(s)\ ==}\newline
{\tt 32.\ \ \ \ makeObject(scherk1,-\%pi/2..\%pi/2,0..\%pi/2,space==s,}\newline
{\tt 33.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ 28,\ var2Steps\ ==\ 28)}\newline
{\tt 34.\ \ \ \ makeObject(scherk2,-\%pi/2..\%pi/2,0..\%pi/2,space==s,}\newline
{\tt 35.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ 28,\ var2Steps\ ==\ 28)}\newline
{\tt 36.\ \ \ \ makeObject(scherk3,-\%pi/2..\%pi/2,-\%pi/2..0,space==s,}\newline
{\tt 37.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ 28,\ var2Steps\ ==\ 28)}\newline
{\tt 38.\ \ \ \ makeObject(scherk4,-\%pi/2..\%pi/2,-\%pi/2..0,space==s,}\newline
{\tt 39.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var1Steps\ ==\ 28,\ var2Steps\ ==\ 28)}\newline
{\tt 40.\ \ \ \ void()}\newline
\endscroll
\autobuttons
\end{page}
%
