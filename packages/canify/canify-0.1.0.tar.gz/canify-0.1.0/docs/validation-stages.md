# Canify 验证策略

## 1. 概述

Canify 采用分层验证策略，将软件工程的质量保证思想融入到"文档即代码"的工作流中。通过在不同开发阶段设立三级质量门，在开发效率和文档质量之间取得最佳平衡。

## 2. 三级质量门

Canify 提供三个核心命令，分别对应开发工作流中的三个关键阶段：

| 命令              | 开发阶段          | 核心目标                                           | 建议触发方式               |
| :---------------- | :---------------- | :------------------------------------------------- | :------------------------- |
| `canify lint`     | **编辑 (Edit)**   | 提供关于格式和基本语法的即时反馈。                 | 编辑器保存时 (On-Save)     |
| `canify verify`   | **提交 (Commit)** | 保证提交入库的结构化文档在结构和形式上是完整的。   | Git `pre-commit` 钩子      |
| `canify validate` | **合并 (Merge)**  | 确保合入主干的内容在业务逻辑和语义上是完全正确的。 | CI/CD 流水线 (On-PR/Merge) |

## 3. 验证深度演进

### 3.1 `canify lint` (基础语法检查)

-   **目标**: 对单个文件提供瞬时的语法健康检查。
-   **执行者**: **本地 CLI**
-   **数据源**: 单个文件的内容，不依赖缓存。
-   **检查内容**:
    -   检查 `entity` 代码块的 YAML 语法是否正确。
    -   检查实体声明是否包含 `id`, `type`, `name` 等最基本的必需字段。

### 3.2 `canify verify` (本地快速验证)

-   **目标**: 在保证极快响应速度的前提下，对项目的结构完整性和本地业务规则进行检查。
-   **执行者**: **本地 CLI**
-   **数据源**: 从**本地符号缓存 (SQLite)** 中加载的视图。
-   **检查内容**:
    -   所有 `lint` 级别的检查。
    -   **引用有效性**: 检查是否存在悬空引用（Dangling Reference）。
    -   **Schema 校验**: 检查实体数据是否符合其 Pydantic 模型定义的类型和约束。
    -   **本地业务规则**: 执行所有在 `spec` 文件中被标记为 `env: local` 的业务规则。
    -   **占位符**: 识别并**警告**占位符的存在（如 `TBD`, `?`）。

### 3.3 `canify validate` (权威深度验证)

此命令旨在提供最严格、最完整的验证，确保合入主干的内容在业务上完全正确。它包含两种模式：

#### a) 本地模式 (`canify validate`)

-   **目标**: 作为 `verify` 的严格版本，在本地执行更严格的检查。
-   **执行者**: **本地 CLI**
-   **数据源**: **本地符号缓存 (SQLite)**
-   **检查内容**: 与 `verify` 的检查范围完全相同，但有一个关键区别：
    -   **占位符**: 禁止任何占位符的存在，并将其视为**错误**。

#### b) 远程模式 (`canify validate --remote`)

-   **目标**: 执行终极、权威的验证，通常用于 CI/CD 的合并前卡点。
-   **执行者**: **远程 Server**
-   **数据源**: 由 CLI 发送的、代表项目完整状态的 `View` 对象。
-   **检查内容**: **执行所有可能的验证**。
    -   包含所有本地 `validate` 的检查项。
    -   额外执行所有被标记为 `env: remote` 的、需要访问外部设施（如内部数据库、私有 API）的重量级业务规则。
