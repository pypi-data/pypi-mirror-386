# 术语与验证框架

本文档定义了 Canify 的核心术语，并提出了一个双层框架来解释其验证机制：一个理论框架（类比编译器）和一个实用框架（CLI 命令）。

## 1. 核心术语

- **实体 (Entity)**: 项目中的核心对象，如 `service`, `team`, `user`。在 `.md` 文件中以 YAML Front Matter 的形式声明。
- **引用 (Reference)**: 实体间的链接，用于构建知识图谱。例如，一个 `service` 实体可以引用它的 `owner` (一个 `team` 实体)。
- **模式 (Schema)**: 定义实体数据结构的 Pydantic 模型，存在于 `.py` 文件中。它约束了实体的字段、类型和基本格式。
- **规约 (Spec)**: 在 `spec_*.yaml` 文件中定义的业务规则。它通过 `fixture` 和 `test_case` 关联到具体的 Python 代码，用于执行超越简单模式的复杂验证。
- **守护进程 (Daemon)**: Canify 的核心后台服务。它监控文件变化，解析符号，维护一个持久化的知识图谱（符号表），并执行所有验证。
- **命令行工具 (CLI)**: 用户与 Canify 系统交互的“瘦客户端”，负责将命令发送给 Daemon 并展示结果。

---

## 2. 理论框架：Canify 的验证阶段

Canify 的验证过程可以类比现代编译器的分析流程，分为三个主要阶段。

### 2.1 词法与语法分析 (Lexical & Syntactic Analysis)

此阶段是验证的基础，专注于将源文件转换为结构化的、但尚未关联的符号信息。

- **目标**: 从各类源文件中解析出独立的、结构化的符号单元。
- **过程**:
    - **Markdown (`.md`)**: 解析文件中的 YAML Front Matter，识别出**实体声明**；解析 `[text](entity://id)` 格式的链接，识别出**实体引用**。
    - **Python (`.py`)**: 使用抽象语法树 (AST) 解析代码，识别出继承自 Pydantic `BaseModel` 的**模式定义**及其字段和验证器。
    - **YAML (`spec_*.yaml`)**: 解析文件内容，识别出**规约 (Spec)** 的定义，包括其 ID, fixture, test_case 等。
- **输出**: 一个包含所有已声明但未链接的实体、引用、模式和规约的集合。这些信息被存入 Daemon 的持久化数据库中。
- **关联命令**: `canify lint` 主要工作在这一层面。

### 2.2 语义分析 (Semantic Analysis)

在获得结构化的符号后，此阶段开始构建它们之间的联系（知识图谱），并检查这些联系的有效性。

- **目标**: 验证知识图谱的内部一致性和类型正确性。
- **过程与细节**:
    1.  **校验实体引用存在性**:
        - **方式**: `ReferenceValidator` 检查每个**实体引用**的 `target_entity_id` 是否能在符号表（数据库）中找到一个与之对应的**实体声明**。
        - **结果**: 如果找不到，该引用被标记为“悬空引用 (Dangling Reference)”，并产生一个错误。

    2.  **校验实体字段类型 (Schema 验证)**:
        - **方式**: `SchemaValidator` 找到实体类型对应的**模式 (Schema)**，然后使用这个 Pydantic 模型来验证**实体声明**中的 `raw_data`。
        - **结果**: Pydantic 会自动检查字段是否齐全、类型是否正确（如 `string` vs `int`）、格式是否合规（如 `email` 格式）。任何不匹配都会导致验证错误。

    3.  **校验实体引用类型**:
        - **方式**: 这是对语义的深层检查。例如，一个 `service` 实体的 `owner` 字段被其 Schema 注解为 `TeamRef` (即引用一个 `team` 类型的实体)。验证器会：
            a. 确认 `owner` 字段引用的实体 ID 确实存在。
            b. 确认该 ID 对应的实体类型确实是 `team`。
        - **结果**: 如果引用的实体类型不是 `team`，则会报告类型不匹配的错误。

    4.  **处理 Pydantic `@validator` 装饰器**:
        - **方式**: 在**词法/语法分析**阶段，Canify 的 `EntitySchemaParser` 会通过 AST 识别出这些装饰器方法。在**语义分析**阶段，当 `SchemaValidator` 动态创建 Pydantic 模型用于验证时，这些验证器逻辑会被包含进去。当实体数据被加载到模型实例中时，Pydantic 会自动触发并执行这些自定义验证函数。
        - **结果**: 开发者自定义的、更复杂的字段级别验证逻辑（如检查某个数值是否在特定范围内）得以执行。

- **关联命令**: `canify verify` 完整地覆盖了此阶段的所有检查。

### 2.3 业务规约验证 (Business Spec Validation)

这是最高层次的验证，用于执行跨实体、跨领域的复杂业务规则。

- **目标**: 验证项目是否符合在 `spec` 文件中定义的、宏观的业务逻辑和约束。
- **过程与细节**:
    1.  **本地规约执行**:
        - **方式**: `SpecExecutor` 负责此过程。对于每个被选中的 `spec`：
            a. 它动态导入并执行 `fixture` 函数，该函数负责从知识图谱中查询和准备验证所需的数据（例如，获取所有 `service` 实体和它们引用的 `team` 实体）。
            b. 它将 `fixture` 返回的数据传递给 `test_case` 函数。
            c. `test_case` 函数执行核心验证逻辑，并返回一个布尔值或 `ValidationResult` 对象来表明成功或失败。
        - **结果**: `test_case` 的失败将直接转化为 `validate` 命令的验证错误。

    2.  **远程规约执行 (未来设计)**:
        - **方式**: 对于标记为 `env: remote` 的 `spec`，其验证逻辑需要在另一个环境（如预发布或生产环境）中执行。
        - **设计**:
            a. `Daemon` 识别出这是一个 `remote spec`。
            b. `Daemon` 不会本地执行它，而是将该 `spec` 的定义、上下文信息（可能包括 `fixture` 的部分数据或引用）序列化，并通过网络发送给一个远端的 `Canify Server`。
            c. 远端的 `Server` 在其环境中执行 `test_case`，并将结果返回给本地的 `Daemon`。
- **关联命令**: `canify validate` 专门用于执行此阶段的验证。

---

## 3. 实用框架：CLI 命令详解

Canify 的 CLI 命令与上述理论框架的三个阶段精确对应。

- **`canify lint`**
    - **对应阶段**: 词法与语法分析。
    - **检查内容**: 检查文件是否能被成功解析。例如，YAML 格式是否正确，实体声明是否包含 `id`, `type`, `name` 等基本字段。
    - **特点**: 速度最快，提供最基础的格式和结构保证。

- **`canify verify`**
    - **对应阶段**: 语义分析。
    - **检查内容**: 执行所有 `lint` 的检查。此外，还进行 Schema 验证、引用完整性检查和类型约束检查。
    - **特点**: 确保了项目内部知识图谱的一致性和正确性，是保证“单一事实来源”可靠性的关键步骤。

- **`canify validate`**
    - **对应阶段**: 业务规约验证。
    - **检查内容**: 执行所有 `verify` 的检查。此外，还执行所有（或通过 `--tags` 过滤出的）在 `spec_*.yaml` 文件中定义的业务规则。
    - **特点**: 最全面、最深入的验证，确保项目不仅结构正确，还符合所有已定义的业务逻辑。

```entity
type: Example
id: id
name: 示例实体
description: 用于演示实体引用语法的示例实体
```