# 产品计划：canify v0.2

## 1. 愿景

成为下一代知识密集型项目的协作基石，将“文档即代码”的理念推广到所有行业，实现真正意义上的、可验证的“单一事实来源”。

## 2. 核心概念

Canify 构建于几个简单而强大的概念之上：

- **实体 (entity)**: 项目中的任何核心概念，例如 `service`、`team`、`project` 或 `database`。实体在 Markdown 文件中声明。
- **引用 (reference)**: 实体之间的链接。引用创建了一个知识图谱，让您能够导航和理解项目内部的关系。它们可以在 Markdown 文本中创建，也可以作为实体数据中的字段。
- **模式 (schema)**: 在 Python 文件中定义的 Pydantic 模型，用于指定实体类型的数据结构和类型。这确保了所有实体数据都格式良好且一致。
- **规约 (spec / specification)**: 在 `spec_*.yaml` 文件中定义的业务规则或约束。每个规约将一个 `fixture` (数据准备函数) 与一个 `test_case` (验证逻辑函数) 相关联，从而实现对项目规则的复杂自动化验证。

## 3. 架构 (v0.2)

v0.2 架构围绕客户端-守护进程模型构建，旨在实现高响应性、一致性和可靠性。

- **Canify 守护进程 (daemon)**: 系统的“大脑”。它是一个持久化的后台进程，负责：

  - 监控项目工作区的文件变更。
  - 解析实体、引用、模式和规约。
  - 使用嵌入式数据库 (SQLite) 将项目的整个知识图谱维持在一个持久化状态。
  - 实时运行所有验证逻辑（模式检查、引用验证、规约执行）。
  - 提供一个 IPC (进程间通信) 端点供客户端连接。

- **Canify 命令行工具 (cli)**: 用户的主要交互界面。它是一个“瘦客户端”，负责：
  - 将用户命令 (`lint`, `verify`, `validate`) 发送给守护进程。
  - 从守护进程接收验证结果并呈现给用户。
  - 自身不执行任何解析或验证，确保了快速、轻量级的用户体验。

该架构确保了项目状态始终保持最新，并且验证可以即时、一致地执行，无需在每次命令时重新解析整个项目，避免了性能开销。

## 4. 关键特性 (v0.2.0)

v0.2.0 版本专注于建立这一核心架构，并提供强大的本地验证体验。

- **基于守护进程的架构**: 一个稳定的后台服务，用于实时项目监控和验证。
- **持久化状态**: 利用本地 SQLite 数据库 (`~/.canify/canify.db`) 存储符号表，实现了快速的增量更新。
- **多阶段验证**:
  - `lint`: 快速、轻量级的解析和符号提取。
  - `verify`: 核心验证，包括模式检查和引用完整性（例如，检查悬空引用）。
  - `validate`: 执行在 `spec_*.yaml` 文件中定义的业务规则。
- **规约执行**: 支持基于 Python 的 `fixture` 和 `test_case` 函数，以实现复杂的业务逻辑。
- **基于标签的过滤**: 允许用户使用布尔表达式（例如 `--tags "core and not slow"`）选择性地运行规约。
- **IPC 通信**: 用于 CLI 和守护进程之间通信的、稳定的 JSON-RPC 协议。

## 5. 未来展望 (v0.2 之后)

v0.2 为项目奠定了坚实的基础，未来的版本将在此之上进行扩展。

- **远程验证**: 引入一个 `server` 组件，用于执行标记为 `remote` 的规约，从而在不同环境（如预发布、生产环境）中进行验证。
- **Git 集成**: 与 Git 进行更深度的集成，以支持检查点、基于分支的分析以及跨时间比较知识状态。
- **更丰富的 IDE 支持**: 增强语言服务器协议 (LSP) 功能，以实现更好的 IDE 集成（例如，跨文档的自动补全、跳转到定义）。
- **可插拔架构**: 允许第三方扩展，以支持自定义的解析器、验证器和报告生成器。
