# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class Reshare:
    project_name: 'str'
    data_types: 'Optional[List[ReshDataType]]'
    project_version: 'Optional[str]'
    symbols: 'Optional[List[ReshSymbol]]'
    target_md5: 'Optional[str]'
    target_name: 'Optional[str]'
    target_sha256: 'Optional[str]'
    target_version: 'Optional[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Reshare':
        return cls(
            _from_json_data(str, data.get("project-name")),
            _from_json_data(Optional[List[ReshDataType]], data.get("data-types")),
            _from_json_data(Optional[str], data.get("project-version")),
            _from_json_data(Optional[List[ReshSymbol]], data.get("symbols")),
            _from_json_data(Optional[str], data.get("target-md5")),
            _from_json_data(Optional[str], data.get("target-name")),
            _from_json_data(Optional[str], data.get("target-sha256")),
            _from_json_data(Optional[str], data.get("target-version")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["project-name"] = _to_json_data(self.project_name)
        if self.data_types is not None:
             data["data-types"] = _to_json_data(self.data_types)
        if self.project_version is not None:
             data["project-version"] = _to_json_data(self.project_version)
        if self.symbols is not None:
             data["symbols"] = _to_json_data(self.symbols)
        if self.target_md5 is not None:
             data["target-md5"] = _to_json_data(self.target_md5)
        if self.target_name is not None:
             data["target-name"] = _to_json_data(self.target_name)
        if self.target_sha256 is not None:
             data["target-sha256"] = _to_json_data(self.target_sha256)
        if self.target_version is not None:
             data["target-version"] = _to_json_data(self.target_version)
        return data

@dataclass
class ReshAddress:
    bytes: 'List[int]'
    space: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshAddress':
        return cls(
            _from_json_data(List[int], data.get("bytes")),
            _from_json_data(str, data.get("space")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["bytes"] = _to_json_data(self.bytes)
        data["space"] = _to_json_data(self.space)
        return data

@dataclass
class ReshDataType:
    content: 'ReshDataTypeContent'
    name: 'str'
    size: 'int'
    modifiers: 'Optional[List[str]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataType':
        return cls(
            _from_json_data(ReshDataTypeContent, data.get("content")),
            _from_json_data(str, data.get("name")),
            _from_json_data(int, data.get("size")),
            _from_json_data(Optional[List[str]], data.get("modifiers")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["content"] = _to_json_data(self.content)
        data["name"] = _to_json_data(self.name)
        data["size"] = _to_json_data(self.size)
        if self.modifiers is not None:
             data["modifiers"] = _to_json_data(self.modifiers)
        return data

@dataclass
class ReshDataTypeContent:
    type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContent':
        variants: Dict[str, Type[ReshDataTypeContent]] = {
            "ARRAY": ReshDataTypeContentArray,
            "ENUM": ReshDataTypeContentEnum,
            "FUNCTION": ReshDataTypeContentFunction,
            "POINTER": ReshDataTypeContentPointer,
            "PRIMITIVE": ReshDataTypeContentPrimitive,
            "STRUCTURE": ReshDataTypeContentStructure,
            "UNION": ReshDataTypeContentUnion,
        }

        return variants[data["type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ReshDataTypeContentArray(ReshDataTypeContent):
    base_type: 'ReshTypeSpec'
    length: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentArray':
        return cls(
            "ARRAY",
            _from_json_data(ReshTypeSpec, data.get("base-type")),
            _from_json_data(int, data.get("length")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "ARRAY" }
        data["base-type"] = _to_json_data(self.base_type)
        data["length"] = _to_json_data(self.length)
        return data

@dataclass
class ReshDataTypeContentEnum(ReshDataTypeContent):
    base_type: 'ReshTypeSpec'
    members: 'List[ReshEnumMember]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentEnum':
        return cls(
            "ENUM",
            _from_json_data(ReshTypeSpec, data.get("base-type")),
            _from_json_data(List[ReshEnumMember], data.get("members")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "ENUM" }
        data["base-type"] = _to_json_data(self.base_type)
        data["members"] = _to_json_data(self.members)
        return data

@dataclass
class ReshDataTypeContentFunction(ReshDataTypeContent):
    arguments: 'Optional[List[ReshFunctionArgument]]'
    calling_convention: 'Optional[str]'
    return_type: 'Optional[ReshTypeSpec]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentFunction':
        return cls(
            "FUNCTION",
            _from_json_data(Optional[List[ReshFunctionArgument]], data.get("arguments")),
            _from_json_data(Optional[str], data.get("calling-convention")),
            _from_json_data(Optional[ReshTypeSpec], data.get("return-type")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "FUNCTION" }
        if self.arguments is not None:
             data["arguments"] = _to_json_data(self.arguments)
        if self.calling_convention is not None:
             data["calling-convention"] = _to_json_data(self.calling_convention)
        if self.return_type is not None:
             data["return-type"] = _to_json_data(self.return_type)
        return data

@dataclass
class ReshDataTypeContentPointer(ReshDataTypeContent):
    target_type: 'ReshTypeSpec'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentPointer':
        return cls(
            "POINTER",
            _from_json_data(ReshTypeSpec, data.get("target-type")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "POINTER" }
        data["target-type"] = _to_json_data(self.target_type)
        return data

@dataclass
class ReshDataTypeContentPrimitive(ReshDataTypeContent):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentPrimitive':
        return cls(
            "PRIMITIVE",
        )

    def to_json_data(self) -> Any:
        data = { "type": "PRIMITIVE" }
        return data

@dataclass
class ReshDataTypeContentStructure(ReshDataTypeContent):
    members: 'List[ReshStructureMember]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentStructure':
        return cls(
            "STRUCTURE",
            _from_json_data(List[ReshStructureMember], data.get("members")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "STRUCTURE" }
        data["members"] = _to_json_data(self.members)
        return data

@dataclass
class ReshDataTypeContentUnion(ReshDataTypeContent):
    members: 'List[ReshStructureMember]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshDataTypeContentUnion':
        return cls(
            "UNION",
            _from_json_data(List[ReshStructureMember], data.get("members")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "UNION" }
        data["members"] = _to_json_data(self.members)
        return data

@dataclass
class ReshEnumMember:
    name: 'str'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshEnumMember':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ReshFunctionArgument:
    name: 'Optional[str]'
    type: 'Optional[ReshTypeSpec]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshFunctionArgument':
        return cls(
            _from_json_data(Optional[str], data.get("name")),
            _from_json_data(Optional[ReshTypeSpec], data.get("type")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.type is not None:
             data["type"] = _to_json_data(self.type)
        return data

@dataclass
class ReshLabel:
    address: 'ReshAddress'
    length: 'int'
    text: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshLabel':
        return cls(
            _from_json_data(ReshAddress, data.get("address")),
            _from_json_data(int, data.get("length")),
            _from_json_data(str, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["address"] = _to_json_data(self.address)
        data["length"] = _to_json_data(self.length)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class ReshStructureMember:
    name: 'str'
    type: 'ReshTypeSpec'
    offset: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshStructureMember':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(ReshTypeSpec, data.get("type")),
            _from_json_data(Optional[int], data.get("offset")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["type"] = _to_json_data(self.type)
        if self.offset is not None:
             data["offset"] = _to_json_data(self.offset)
        return data

class ReshSymbolConfidence(Enum):
    FACT = "FACT"
    GUESS = "GUESS"
    PRIVATE = "PRIVATE"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshSymbolConfidence':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ReshSymbol:
    address: 'ReshAddress'
    name: 'str'
    confidence: 'Optional[ReshSymbolConfidence]'
    labels: 'Optional[List[ReshLabel]]'
    type: 'Optional[ReshTypeSpec]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshSymbol':
        return cls(
            _from_json_data(ReshAddress, data.get("address")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[ReshSymbolConfidence], data.get("confidence")),
            _from_json_data(Optional[List[ReshLabel]], data.get("labels")),
            _from_json_data(Optional[ReshTypeSpec], data.get("type")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["address"] = _to_json_data(self.address)
        data["name"] = _to_json_data(self.name)
        if self.confidence is not None:
             data["confidence"] = _to_json_data(self.confidence)
        if self.labels is not None:
             data["labels"] = _to_json_data(self.labels)
        if self.type is not None:
             data["type"] = _to_json_data(self.type)
        return data

@dataclass
class ReshTypeSpec:
    type_name: 'str'
    embedded_type: 'Optional[ReshDataType]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ReshTypeSpec':
        return cls(
            _from_json_data(str, data.get("type-name")),
            _from_json_data(Optional[ReshDataType], data.get("embedded-type")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["type-name"] = _to_json_data(self.type_name)
        if self.embedded_type is not None:
             data["embedded-type"] = _to_json_data(self.embedded_type)
        return data

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
