# Structured Prompt Visualization Widget Proposal

## Goals and Constraints
- Provide an `_repr_html_()` implementation for both structured prompts and their intermediate representations that works across Jupyter Notebook, VS Code notebooks, Marimo, MkDocs, and other static renderers.
- Keep the solution self-contained (no CDN) so it works offline and during static exports.
- Support three synchronized panes: tree navigation, code-like view, and Markdown preview (with KaTeX for LaTeX rendering).
- Allow folding/hiding sections in the code and preview panes.
- Encode the JSON representation of the prompt inside the rendered HTML so that the JavaScript runtime can hydrate it without additional network requests.
- Prefer simple, easily testable vanilla tooling. Only introduce third-party libraries when they significantly reduce maintenance cost.

The work is divided into three phases. Phase 0 focuses on minimizing duplicated assets when `_repr_html_()` is invoked repeatedly. Phase 1 delivers a minimal, mostly static renderer. Phase 2 (future) will add the rich, synchronized widget experience.

---

## Phase 0 – Asset De-duplication Strategy

### Problem Statement
Each `_repr_html_()` call must return a self-sufficient HTML string. If every instance embeds the full JavaScript and CSS payload, large notebooks become heavy. We need a strategy that minimizes duplicate assets while keeping the widget offline-friendly and compatible with static exports.

### Proposed Strategy
1. **Python-side singleton injection**
   - Maintain a module-level flag in the Python widget helper (e.g., `StructuredPromptWidgetRenderer`).
   - When `_repr_html_()` is called:
     - If the bundle has not yet been emitted in this Python process, prepend the HTML string with a `<script id="tp-widget-bundle">…</script>` and `<style>` block that registers the widget runtime on `window.__TPWidget`.
     - On subsequent calls, skip embedding the bundle and only emit the per-instance markup + bootstrap script.
   - This keeps notebooks lightweight while ensuring at least one instance injects the assets.

2. **Defensive front-end bootstrap**
   - The per-instance bootstrap script should check `if (!window.__TPWidget)` and, if missing (for example, because an output cell was copied into a different document), inject the bundle stored in a `data-bundle` attribute.
   - That attribute can hold the (possibly minified) JavaScript bundle as plain text or Base64. This adds a small per-instance cost but guarantees resilience when cells are copied individually.

3. **Lazy initialization per output**
   - The bootstrap script attaches an initialization handler that runs once the DOM node is connected. Use `new MutationObserver` or `queueMicrotask` to defer initialization until the container is in the document.

4. **CSS handling**
   - Pack CSS alongside JS. The bootstrap script can inject a `<style id="tp-widget-style">` element when missing. CSS can be generated by the build step and inlined as a string.

5. **Bundling approach**
   - Use Rollup or esbuild to produce a single ES module string (minified, ~10–20 KB expected initially).
   - Export the bundle as a Python string literal (possibly compressed with `textwrap.dedent` and `minify_html`) stored in `src/t_prompts/widget_assets.py`.
   - Tests ensure the embedded bundle matches the built file (to avoid drift).

### Deliverables for Phase 0
- `widget_assets.py` exposing `JS_BUNDLE` and `CSS_BUNDLE` strings (or a combined `HTML_BUNDLE`).
- Helper functions that assemble `_repr_html_()` output with once-per-process injection.
- Tests confirming:
  - First call includes the bundle and sets the "already emitted" flag.
  - Subsequent calls omit the bundle but still produce valid HTML.
  - Bootstrap backfills the bundle if `window.__TPWidget` is missing at runtime.

---

## Phase 1 – Minimal Static Renderer

### Objectives
Deliver a simple, non-interactive visualization to unblock documentation and quick inspection scenarios. The focus is readability rather than synchronized interactivity.

### Rendering Pipeline
1. **Generate intermediate representation (IR)**
   - Leverage the existing JSON export utilities described in `docs/reference.md` (structured prompt provenance).
   - Store the IR inside the HTML as `<script type="application/json" data-role="tp-widget-ir">…</script>`.

2. **HTML structure**
   - Render a three-column layout using CSS Grid/Flexbox.
   - Each pane initially static:
     - **Tree Pane**: simple nested `<ul>` generated from the IR. No expand/collapse yet, but indent for hierarchy.
     - **Code Pane**: render Markdown-like text using `<pre><code>` with minimal styling. Highlight interpolation boundaries with spans.
     - **Preview Pane**: convert Markdown to HTML via a lightweight parser.

3. **JavaScript behavior**
   - Only responsibility is to find the JSON IR, convert Markdown to HTML, and enhance KaTeX blocks.
   - No synchronization or folding yet.

4. **Library choices**
   - **Markdown**: bundle `markdown-it` (flexible, plugin ecosystem) with the CommonMark + HTML + code fences options enabled. Alternative: `marked`. We'll prototype with `markdown-it` for KaTeX plugin support.
   - **KaTeX**: bundle the KaTeX JS + CSS (from npm) and expose a utility that finds `$...$` / `$$...$$` sequences via `markdown-it-katex`.
   - **Tree Rendering**: plain vanilla JS since the tree is static in Phase 1.

5. **Styling**
   - Define CSS variables for colors and spacing to support future theming.
   - Provide a light theme initially, with structure for dark-mode adjustments later.

### Deliverables for Phase 1
- `_repr_html_()` returning:
  - (Once) inlined JS/CSS bundles.
  - Widget container HTML with static panes.
  - Embedded JSON IR.
- JavaScript runtime that:
  - Reads IR, fills panes, and renders Markdown with KaTeX.
  - Handles errors gracefully (e.g., missing IR yields fallback text).
- Documentation page (`docs/widget-proposal.md`) updated with instructions on using the minimal renderer.
- Tests (likely snapshot-based) confirming HTML structure and verifying Markdown conversion via a headless DOM environment (e.g., `pytest` with `beautifulsoup4` or `jsdom` in Node tests).

---

## Phase 2 – Full Interactive Widget (High-Level Preview)

> Detailed planning deferred, but outline included for context.

### Features
- **Tree Pane**: interactive expand/collapse, search/filter, selection highlighting.
- **Code Pane**: folding sections, synchronized scrolling with preview, clickable spans that highlight corresponding nodes in the tree and preview.
- **Preview Pane**: live Markdown rendering with folding, tooltips for metadata, and KaTeX rendering.
- **State management**: centralized store (e.g., simple observable or Redux-like pattern) to keep panes synchronized.
- **Accessibility**: keyboard navigation, ARIA roles for tree, high-contrast theme.

### Technical Direction
- Consider using a lightweight component library (e.g., `lit` or `preact`) to manage DOM complexity.
- Keep bundler setup from Phase 0/1; expand entry point to include UI state modules.
- Expand CSS to modular structure, possibly using CSS modules compiled to strings for inlining.
- Additional tests:
  - Interaction tests via Playwright (executed in CI in headless mode) stored under `tests/widget/`.
  - Visual regression tests optional (screenshot diffs) once layout stabilizes.

---

## File & Module Organization (Projected)
- `src/t_prompts/widget/__init__.py`: public APIs for rendering and `_repr_html_()` helpers.
- `src/t_prompts/widget/assets.py`: embedded JS/CSS bundles + helpers for once-per-process injection.
- `widgets/src/` (TypeScript/JavaScript source):
  - `index.ts`: entry point exporting `initWidget(container: HTMLElement)`.
  - `renderers/` for tree, code, preview.
  - `markdown/` for Markdown + KaTeX integration.
  - `state/` for synchronization logic (Phase 2).
- `widgets/rollup.config.mjs` (or `esbuild.config.mjs`): bundler config generating a single string asset.
- Tests under `tests/widget/` (Python) and `widgets/tests/` (JS, if needed).

---

## Open Questions & Risks
- **Bundle size**: KaTeX is sizable (~250 KB unminified). Consider deferred loading or subsetting macros if the bundle becomes too large.
- **Copy/paste resilience**: Ensure that copying a single widget output still works (thanks to bootstrap self-healing). Needs manual QA with nbconvert, VS Code exports, MkDocs builds.
- **Theming**: Need to detect surrounding theme (light/dark). Could expose CSS variables and allow host page to override.
- **Security**: Markdown rendering should sanitize HTML or operate in `trusted` mode only. Evaluate if we need DOMPurify or rely on markdown-it's default rules.
- **Testing offline**: Provide a script to render sample output to static HTML for manual verification.

---

## Next Steps
1. Implement Phase 0 assets helper and associated tests.
2. Scaffold bundler configuration and embed the generated bundle into `widget_assets.py`.
3. Build the minimal Phase 1 renderer using markdown-it and KaTeX.
4. Document usage in the docs site and gather feedback before tackling Phase 2.
