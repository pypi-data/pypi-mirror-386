# Better TypeScript Library Support (Implementation Plan v2)

## Summary

This plan restructures `@t-prompts/widgets` into a conventional TypeScript component
library that ships an ESM-first bundle with straightforward re-exports while the Python
package continues to ship a self-contained IIFE bundle. The goal is to let JavaScript
consumers import just the pieces they need (plus `styles.css`) without any auto-init or
hash plumbing, while the Python build keeps its runtime bootstrap with inline assets.

## Goals and Non-Negotiables

- Deliver a standard ESM entry point (`dist/index.mjs`) with side-effect-free imports.
- Keep the Python experience unchanged: the wheel installs an IIFE bundle with inlined
  CSS and cache-busting IDs.
- Support multiple widget container entry points without breaking the current auto-init
  workflow.
- Maintain deterministic cache-busting across JavaScript and Python assets.
- Avoid regressions in existing tests, Playwright flows, and packaging workflows.

## Proposed Outputs and Entry Points

| Output                | Format | Purpose                                             | Trigger                                  |
|-----------------------|--------|-----------------------------------------------------|------------------------------------------|
| `dist/index.mjs`      | ESM    | Component/library entry (pure exports, no side effects) | `pnpm --filter @t-prompts/widgets build` |
| `dist/index.cjs`      | CJS    | Compatibility for Node tooling that still expects CJS | `pnpm --filter @t-prompts/widgets build` |
| `dist/index.d.ts`     | DTS    | Type declarations generated by `tsc`                | `pnpm --filter @t-prompts/widgets build` |
| `dist/styles.css`     | CSS    | Sidecar styles for bundler usage (ESM consumers only) | `pnpm --filter @t-prompts/widgets build` |
| `dist/iife/index.js`  | IIFE   | Python distribution bundle (single self-contained file) | `pnpm --filter @t-prompts/widgets buildPython` |

## Build Pipeline Structure

### Base Library Build (`build`)

1. **Clean** `dist/` (excluding `dist/iife/` so `buildPython` can reuse it when run later).
2. **Transpile** `src/index.ts` via esbuild for both ESM and CJS outputs, externalising peer dependencies.
3. **Run `tsc --emitDeclarationOnly`** to produce `dist/*.d.ts`.
4. **Emit styles** as separate sidecar assets (`dist/styles.css`) for bundler users; this asset never ships to Python.
5. **Mark `sideEffects: false`** in package.json so bundlers tree-shake unused component exports automatically.

### Python Bundle Build (`buildPython`)

1. **Precondition**: requires `build` artifacts to exist; fails fast if `dist/index.mjs`
   is missing.
2. **Collect CSS**: concatenate KaTeX CSS + component styles, run minifier, inline fonts.
3. **Prepare generated source for bundling**:
   - Inject style constants at build time instead of producing an intermediate `generated.ts`.
   - Wire an esbuild plugin that, after bundling, computes `asset_hash = sha256(output)[:8]`
     over the entire JavaScript payload (which already embeds the CSS).
   - Inject both `BUNDLE_HASH` (new descriptive name) and `STYLES_HASH` (backward-compatible alias)
     into the output so runtime cache IDs stay in sync with the full bundle.
4. **Bundle IIFE**: invoke esbuild in IIFE mode using the auto-init entry. Inline all CSS
   sources and keep peer dependencies (markdown-it, KaTeX) bundled so the output is
   completely self-contained.
5. **Emit final artifact**:
   - Write the bundle as `dist/iife/index.js`.
   - Copy that single file into `src/t_prompts/widgets/index.js`, leaving Python imports untouched and keeping the file name stable.
6. **Validate**: run smoke script that imports the built wheel assets and exercises
   auto-init in jsdom to ensure the bundle is self-consistent.

## Package.json Updates

- `exports` map distinguishing ESM, CJS, auto-init, and CSS:
  ```json
  {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    },
    "./auto-init": {
      "import": "./dist/auto-init.mjs"
    },
    "./styles.css": "./dist/styles.css"
  }
  ```
- Set `"type": "module"`, `"sideEffects": ["./dist/auto-init.mjs"]`.
- Move KaTeX, markdown-it, and `@mdit/plugin-katex` to `peerDependencies` with mirrored
  `devDependencies` for local tests.
- Add `"files"` allowlist for `dist/**`, `package.json`, `README.md`, `LICENSE`.
- Add scripts:
  ```json
  {
    "scripts": {
      "build": "pnpm run clean && node scripts/build-lib.mjs",
      "buildPython": "pnpm run build && node scripts/build-python.mjs",
      "test": "vitest run",
      "lint": "eslint .",
      "prepublishOnly": "pnpm run lint && pnpm run test && pnpm run build"
    }
  }
  ```

## Cache-Busting Strategy

- **IIFE only**: the `BUNDLE_HASH` constant (with `STYLES_HASH` alias) is embedded solely in the auto-initialising IIFE output.
- **Algorithm**:
  - Hash the entire bundled output (JavaScript + inlined CSS) to produce `asset_hash`.
  - Inject the hash into the bundle so runtime DOM IDs, injected `<style>` tags, and any Python
    cache headers continue to use the same value without additional metadata files.
- **Fallback**:
  - If the Python copy step detects a mismatch between the embedded hash and the value it surfaces
    to Python (via existing mechanisms), it fails CI rather than guessing.
  - Bundler users import `styles.css` where their toolchain handles cache busting; Python users
    always rely on the bundled CSS baked into `index.js`.

## Testing and CI Additions

- **Unit**: Extend Vitest suite with matrix tests that import `dist/index.mjs` and require
  `dist/index.cjs` to ensure the component exports are side-effect free.
- **Integration**:
  - jsdom smoke test that loads the IIFE bundle and asserts widgets render.
  - Python smoke test (invoked via `uv run pytest -k widgets_iife_smoke`) that exercises
    the cache-busting injection using the embedded `BUNDLE_HASH`.
- **CI jobs**:
  - `pnpm --filter @t-prompts/widgets build && pnpm --filter @t-prompts/widgets test`.
  - `pnpm --filter @t-prompts/widgets buildPython` followed by Python smoke tests.
  - Artifact verification step to ensure the `BUNDLE_HASH` surfaced to Python matches the hash computed during bundling.

## Migration Plan

1. **Scaffold new build scripts** (`scripts/build-lib.mjs`, `scripts/build-python.mjs`)
   alongside legacy `build.js`.
2. **Refactor source layout**:
   - Keep `src/index.ts` as the public component aggregator (no runtime auto-init).
   - Move runtime-only helpers under `src/runtime/` so the IIFE build can consume them.
3. **Introduce new dist outputs** while keeping the existing IIFE flow operational.
4. **Update Python copy mechanism** to persist the embedded `BUNDLE_HASH` (without changing file names) so cache headers stay accurate.
5. **Deprecate legacy build path** once CI ensures `build` + `buildPython` cover all prior
   artifacts.
6. **Publish alpha package internally** to validate npm consumption.
7. **Document new workflows** in developer docs, highlighting when to run `buildPython`.

## Open Questions

- Do we need additional entry points for per-component imports (`@t-prompts/widgets/chrome`)?
- Should the CSS hash also incorporate asset filenames (e.g., icon SVGs) if we start
  emitting them as separate files?
- What is the long-term plan for Playwright visual diffs against both ESM and IIFE builds?
