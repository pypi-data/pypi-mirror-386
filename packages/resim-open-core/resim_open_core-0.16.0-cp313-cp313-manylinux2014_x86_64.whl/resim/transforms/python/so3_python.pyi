from __future__ import annotations
import numpy
import resim.transforms.python.quaternion
import typing
__all__ = ['SO3']
class SO3:
    DIMS: typing.ClassVar[int] = 3
    DOF: typing.ClassVar[int] = 3
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    def exp(alg: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> SO3:
        ...
    @staticmethod
    def identity() -> SO3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, quaternion: resim.transforms.python.quaternion.Quaternion) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SO3) -> SO3:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def interp(self, fraction: float) -> SO3:
        ...
    def inverse(self) -> SO3:
        ...
    def is_approx(self, other: SO3, precision: float = 1e-12) -> bool:
        ...
    def log(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def quaternion(self) -> resim.transforms.python.quaternion.Quaternion:
        ...
    def rotate(self, source_vector: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def rotation_matrix(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
