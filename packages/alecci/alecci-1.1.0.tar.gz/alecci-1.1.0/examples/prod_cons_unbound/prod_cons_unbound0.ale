procedure main(argc, argv as array)
  if argc = 8 then
    shared const unit_count := int(argv[1])
    shared const producer_count := int(argv[2])
    shared const consumer_count := int(argv[3])
    shared const producer_min_delay := int(argv[4])
    shared const producer_max_delay := int(argv[5])
    shared const consumer_min_delay := int(argv[6])
    shared const consumer_max_delay := int(argv[7])

    shared mutable queue := create_integer_queue()
    shared mutable can_access_queue := create_mutex()

    shared mutable next_unit := 0
    shared mutable can_access_next_unit := create_mutex()

    shared mutable consumed_count := 0
    shared mutable can_access_consumed_count := create_mutex()

    shared mutable can_consume := create_semaphore(0)

    shared mutable producers := create_threads(producer_count, produce0)
    shared mutable  consumers := create_threads(consumer_count, consume_busywait)

    join_threads(producers)
    join_threads(consumers)
  end if
end procedure

procedure produce0()
  mutable my_unit := 0
  lock(can_access_next_unit)
    const is_there_pending_work := next_unit < unit_count
    if is_there_pending_work then
      next_unit := next_unit + 1
      my_unit := next_unit
    end if
  unlock(can_access_next_unit)

  while is_there_pending_work do
    delay(random_between(producer_min_delay, producer_max_delay))
    lock(can_access_queue)
      enqueue(queue, my_unit)
    unlock(can_access_queue)
    print `Produced  {my_unit]`

    lock(can_access_next_unit)
      is_there_pending_work := next_unit < unit_count
      if is_there_pending_work then
        next_unit := next_unit + 1
        my_unit := next_unit
      end if
    unlock(can_access_next_unit)
  end while
end procedure

procedure consume_busywait()
  while true do
    lock(can_access_consumed_count)
      if consumed_count < unit_count then
        consumed_count := consumed_count + 1
      else
        break while
      end if
    unlock(can_access_consumed_count)

    lock(can_access_queue)
      if is_empty(queue) then
        lock(can_access_consumed_count)
          consumed_count := consumed_count - 1
        unlock(can_access_consumed_count)
      else
        const my_unit := dequeue(queue)
        print `\tConsuming  {my_unit}`
        delay(random_between(consumer_min_delay, consumer_max_delay))
      end if
    unlock(can_access_queue)
  end while
end procedure

function random_between(min, max)
  return min + rand() / (max - min) 
end function
