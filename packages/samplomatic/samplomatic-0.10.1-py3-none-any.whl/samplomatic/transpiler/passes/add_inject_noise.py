# This code is a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""AddInjectNoise"""

import itertools
from collections import defaultdict
from typing import Callable, Literal

from qiskit.circuit import CircuitInstruction
from qiskit.dagcircuit import DAGCircuit, DAGOpNode
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.exceptions import TranspilerError

from ...annotations import InjectNoise, Twirl
from ...utils import BoxKey, get_annotation, undress_box
from ..noise_injection_strategies import NoiseInjectionStrategy, NoiseInjectionStrategyLiteral


class AddInjectNoise(TransformationPass):
    """Inserts :class:`~.InjectNoise` annotations to all the unique boxes with twirling annotation.

    This pass finds all the twirl-annotated boxes in the given circuit and adds inject noise
    annotations to all the boxes that contain entanglers and/or own classical registers.

    Args:
        strategy: The noise injection strategy.
        overwrite: Whether to overwrite the ``ref`` of inject noise annotations that are already
            present in the circuit.
        prefix_ref: A prefix to all the ``ref`` generated by this class.
        prefix_modifier_ref: A prefix to all the ``modifier_refs`` generated by this class.
        targets: The class of annotated boxes to target. The supported values are:

                * ``'none'`` to avoid annotating boxes of any kind.
                * ``'gates'`` to target only the twirl-annotated boxes that contain entanglers.
                * ``'measures'`` to target only the twirl-annotated boxes that own classical
                    registers.
                * ``'all'`` to target all the twirl-annotated boxes that contain entanglers
                    and/or own classical registers.

    .. note::
        Every ``ref`` is generated by appending a counter to ``prefix_ref``. The counter is shared
        across all the instances of this class. In order to avoid collisions, it is incremented
        every time that a new ``ref`` is created. The same mechanism (with a different counter)
        is used to generate the ``modifier_refs``.
    """

    _REF_COUNTER = itertools.count()
    _MODIFIER_REF_COUNTER = itertools.count()

    def __init__(
        self,
        strategy: NoiseInjectionStrategyLiteral = "no_modification",
        overwrite: bool = False,
        prefix_ref: str = "r",
        prefix_modifier_ref: str = "m",
        targets: Literal["none", "gates", "measures", "all"] = "none",
    ):
        TransformationPass.__init__(self)
        self.strategy = NoiseInjectionStrategy(strategy)
        self.overwrite = overwrite
        self.prefix_ref = prefix_ref
        self.prefix_modifier_ref = prefix_modifier_ref
        self.targets = targets

    def _skip_undressed_box(self) -> Callable[[DAGOpNode], bool]:
        if self.targets == "none":
            return True
        if self.targets == "all":
            # Skip boxes that do not contain entanglers or measurements
            return (
                lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
                and not undressed_box.body.clbits
            )
        if self.targets == "gates":
            return lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
        if self.targets == "measures":
            return lambda undressed_box: not undressed_box.body.clbits

        raise TranspilerError(
            f"Targets '{self.targets}' is invalid, choose one of 'none', 'all', 'gates',"
            " and 'measures'."
        )

    def run(self, dag: DAGCircuit) -> DAGCircuit:
        if self.targets == "none":
            return dag

        # A dictionary to map unique boxes to their ``ref``
        box_to_ref: dict[BoxKey, int] = defaultdict(
            lambda: f"{self.prefix_ref}{next(self._REF_COUNTER)}"
        )

        skip_undressed_box: Callable[[DAGOpNode], bool] = self._skip_undressed_box()

        for node in dag.op_nodes():
            if node.op.name == "box" and (twirl := get_annotation(node.op, Twirl)):
                undressed_box = undress_box(node.op)
                undressed_box.annotations = [twirl]

                if skip_undressed_box(undressed_box):
                    continue

                instr_qubits = undressed_box.body.qubits
                instr_clbits = undressed_box.body.clbits
                instr = CircuitInstruction(undressed_box, instr_qubits, instr_clbits)
                box_key = BoxKey(instr)

                if inject_noise_annotation := get_annotation(node.op, InjectNoise):
                    if box_key not in box_to_ref:
                        # The box already has a noise injection annotation, but it is the first box
                        # to be found for this hash. Its `ref` will be reused for all future boxes
                        # that produce the same hash.
                        box_to_ref[box_key] = inject_noise_annotation.ref
                    else:
                        # The box already has a noise injection annotation, and another box with the
                        # same hash has previously been found.
                        if self.overwrite is True:
                            annotation_idx = node.op.annotations.index(inject_noise_annotation)
                            node.op.annotations[annotation_idx] = InjectNoise(
                                box_to_ref[box_key],
                                inject_noise_annotation.modifier_ref,
                            )
                else:
                    # The box does not have a noise injection annotation.
                    ref = box_to_ref[box_key]

                    if self.strategy == NoiseInjectionStrategy.NO_MODIFICATION:
                        modifier_ref = ""
                    elif self.strategy == NoiseInjectionStrategy.UNIFORM_MODIFICATION:
                        modifier_ref = ref
                    else:
                        # individual modification
                        modifier_ref = (
                            f"{self.prefix_modifier_ref}{next(self._MODIFIER_REF_COUNTER)}"
                        )

                    node.op.annotations += [InjectNoise(ref, modifier_ref)]
        return dag
