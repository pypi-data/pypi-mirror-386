// Code generated by django-cfg/django_client - DO NOT EDIT.
// Generated at: {{ generated_at }}

package {{ package_name }}

import (
	"fmt"
	"regexp"
	"strings"
)

// ValidationError represents a validation error.
type ValidationError struct {
	Field   string
	Message string
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// ValidationErrors represents multiple validation errors.
type ValidationErrors []ValidationError

// Error implements the error interface.
func (e ValidationErrors) Error() string {
	if len(e) == 0 {
		return "validation errors"
	}

	var messages []string
	for _, err := range e {
		messages = append(messages, err.Error())
	}
	return strings.Join(messages, "; ")
}

// Add adds a validation error.
func (e *ValidationErrors) Add(field, message string) {
	*e = append(*e, ValidationError{
		Field:   field,
		Message: message,
	})
}

// HasErrors returns true if there are any errors.
func (e ValidationErrors) HasErrors() bool {
	return len(e) > 0
}

// Validator provides validation utilities.
type Validator struct {
	errors ValidationErrors
}

// NewValidator creates a new validator.
func NewValidator() *Validator {
	return &Validator{
		errors: make(ValidationErrors, 0),
	}
}

// Required validates that a string field is not empty.
func (v *Validator) Required(field, value string) *Validator {
	if strings.TrimSpace(value) == "" {
		v.errors.Add(field, "this field is required")
	}
	return v
}

// RequiredInt validates that an int field is set (non-zero).
func (v *Validator) RequiredInt(field string, value int64) *Validator {
	if value == 0 {
		v.errors.Add(field, "this field is required")
	}
	return v
}

// RequiredPtr validates that a pointer field is not nil.
func (v *Validator) RequiredPtr(field string, value interface{}) *Validator {
	if value == nil {
		v.errors.Add(field, "this field is required")
	}
	return v
}

// MinLength validates minimum string length.
func (v *Validator) MinLength(field, value string, min int) *Validator {
	if len(value) > 0 && len(value) < min {
		v.errors.Add(field, fmt.Sprintf("must be at least %d characters", min))
	}
	return v
}

// MaxLength validates maximum string length.
func (v *Validator) MaxLength(field, value string, max int) *Validator {
	if len(value) > max {
		v.errors.Add(field, fmt.Sprintf("must be at most %d characters", max))
	}
	return v
}

// MinValue validates minimum numeric value.
func (v *Validator) MinValue(field string, value, min int64) *Validator {
	if value < min {
		v.errors.Add(field, fmt.Sprintf("must be at least %d", min))
	}
	return v
}

// MaxValue validates maximum numeric value.
func (v *Validator) MaxValue(field string, value, max int64) *Validator {
	if value > max {
		v.errors.Add(field, fmt.Sprintf("must be at most %d", max))
	}
	return v
}

// Pattern validates string against regex pattern.
func (v *Validator) Pattern(field, value, pattern, message string) *Validator {
	if value == "" {
		return v
	}

	matched, err := regexp.MatchString(pattern, value)
	if err != nil {
		v.errors.Add(field, fmt.Sprintf("invalid pattern: %v", err))
		return v
	}

	if !matched {
		if message == "" {
			message = fmt.Sprintf("must match pattern: %s", pattern)
		}
		v.errors.Add(field, message)
	}

	return v
}

// Email validates email format.
func (v *Validator) Email(field, value string) *Validator {
	if value == "" {
		return v
	}

	// Simple email validation
	pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
	return v.Pattern(field, value, pattern, "must be a valid email address")
}

// URL validates URL format.
func (v *Validator) URL(field, value string) *Validator {
	if value == "" {
		return v
	}

	if !strings.HasPrefix(value, "http://") && !strings.HasPrefix(value, "https://") {
		v.errors.Add(field, "must be a valid URL starting with http:// or https://")
	}

	return v
}

// OneOf validates that value is one of allowed values.
func (v *Validator) OneOf(field, value string, allowed []string) *Validator {
	if value == "" {
		return v
	}

	for _, a := range allowed {
		if value == a {
			return v
		}
	}

	v.errors.Add(field, fmt.Sprintf("must be one of: %s", strings.Join(allowed, ", ")))
	return v
}

// Custom adds a custom validation error.
func (v *Validator) Custom(field, message string) *Validator {
	v.errors.Add(field, message)
	return v
}

// CustomIf adds a custom validation error if condition is true.
func (v *Validator) CustomIf(condition bool, field, message string) *Validator {
	if condition {
		v.errors.Add(field, message)
	}
	return v
}

// Errors returns all validation errors.
func (v *Validator) Errors() ValidationErrors {
	return v.errors
}

// Valid returns true if there are no validation errors.
func (v *Validator) Valid() bool {
	return !v.errors.HasErrors()
}

// Error returns validation errors as an error, or nil if valid.
func (v *Validator) Error() error {
	if v.Valid() {
		return nil
	}
	return v.errors
}

// Validate is a convenience function to create and return a validator.
func Validate() *Validator {
	return NewValidator()
}
