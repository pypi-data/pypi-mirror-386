// Code generated by django-cfg centrifugo codegen. DO NOT EDIT.

package {{ package_name }}

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// generateUUID creates a random UUID v4 using crypto/rand
func generateUUID() (string, error) {
	uuid := make([]byte, 16)
	if _, err := rand.Read(uuid); err != nil {
		return "", err
	}

	// Set version (4) and variant bits
	uuid[6] = (uuid[6] & 0x0f) | 0x40 // Version 4
	uuid[8] = (uuid[8] & 0x3f) | 0x80 // Variant is 10

	return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:]), nil
}

// CentrifugoRPCClient handles WebSocket connection and RPC call correlation.
type CentrifugoRPCClient struct {
	url             string
	token           string
	userID          string
	timeout         time.Duration
	conn            *websocket.Conn
	pendingMutex    sync.RWMutex
	pendingRequests map[string]chan RPCResponse
	replyChannel    string
	closeChan       chan struct{}
	readMutex       sync.Mutex
}

// RPCRequest represents an RPC request message.
type RPCRequest struct {
	Method        string      `json:"method"`
	Params        interface{} `json:"params"`
	CorrelationID string      `json:"correlation_id"`
	ReplyTo       string      `json:"reply_to"`
}

// RPCResponse represents an RPC response message.
type RPCResponse struct {
	CorrelationID string          `json:"correlation_id"`
	Result        json.RawMessage `json:"result,omitempty"`
	Error         *RPCError       `json:"error,omitempty"`
}

// RPCError represents an RPC error.
type RPCError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

func (e *RPCError) Error() string {
	return fmt.Sprintf("RPC error %d: %s", e.Code, e.Message)
}

// NewCentrifugoRPCClient creates a new RPC client.
//
// Args:
//   - url: Centrifugo WebSocket URL (e.g., "ws://localhost:8000/connection/websocket")
//   - token: JWT token for authentication
//   - userID: User ID for reply channel
//   - timeout: RPC call timeout
func NewCentrifugoRPCClient(url, token, userID string, timeout time.Duration) *CentrifugoRPCClient {
	return &CentrifugoRPCClient{
		url:             url,
		token:           token,
		userID:          userID,
		timeout:         timeout,
		pendingRequests: make(map[string]chan RPCResponse),
		replyChannel:    fmt.Sprintf("user#%s", userID),
	}
}

// Connect establishes WebSocket connection to Centrifugo.
func (c *CentrifugoRPCClient) Connect(ctx context.Context) error {
	client := centrifuge.NewJsonClient(
		c.url,
		centrifuge.Config{
			Token: c.token,
		},
	)

	client.OnConnected(func(e centrifuge.ConnectedEvent) {
		fmt.Printf("‚úÖ Connected to Centrifugo: client_id=%s\n", e.ClientID)
	})

	client.OnDisconnected(func(e centrifuge.DisconnectedEvent) {
		fmt.Printf("‚ö†Ô∏è  Disconnected from Centrifugo: code=%d, reason=%s\n", e.Code, e.Reason)
		c.rejectAllPending(fmt.Errorf("disconnected from Centrifugo"))
	})

	c.client = client

	// Connect to server
	if err := client.Connect(); err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}

	// Subscribe to reply channel
	sub, err := client.NewSubscription(c.replyChannel)
	if err != nil {
		return fmt.Errorf("failed to create subscription: %w", err)
	}

	sub.OnPublication(func(e centrifuge.PublicationEvent) {
		c.handleResponse(e.Data)
	})

	if err := sub.Subscribe(); err != nil {
		return fmt.Errorf("failed to subscribe to reply channel: %w", err)
	}

	return nil
}

// Disconnect closes the WebSocket connection.
func (c *CentrifugoRPCClient) Disconnect() error {
	if c.client != nil {
		if err := c.client.Disconnect(); err != nil {
			return err
		}
		c.client = nil
	}
	return nil
}

// Call makes an RPC call and waits for the response.
//
// Args:
//   - ctx: Context for cancellation
//   - method: RPC method name (e.g., "tasks.get_stats")
//   - params: Method parameters
//   - result: Pointer to result struct
//
// Returns error if RPC call fails or times out.
func (c *CentrifugoRPCClient) Call(ctx context.Context, method string, params interface{}, result interface{}) error {
	if c.client == nil {
		return fmt.Errorf("not connected to Centrifugo")
	}

	// Generate correlation ID
	correlationID := uuid.New().String()

	// Create request
	request := RPCRequest{
		Method:        method,
		Params:        params,
		CorrelationID: correlationID,
		ReplyTo:       c.replyChannel,
	}

	requestData, err := json.Marshal(request)
	if err != nil {
		return fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create response channel
	responseChan := make(chan RPCResponse, 1)
	c.pendingMutex.Lock()
	c.pendingRequests[correlationID] = responseChan
	c.pendingMutex.Unlock()

	// Publish request
	_, err = c.client.Publish(ctx, "rpc.requests", requestData)
	if err != nil {
		c.pendingMutex.Lock()
		delete(c.pendingRequests, correlationID)
		c.pendingMutex.Unlock()
		return fmt.Errorf("failed to publish request: %w", err)
	}

	fmt.Printf("üì§ RPC call: %s (correlation_id: %s)\n", method, correlationID)

	// Wait for response with timeout
	select {
	case response := <-responseChan:
		fmt.Printf("üì• RPC response: %s (correlation_id: %s)\n", method, correlationID)

		if response.Error != nil {
			return response.Error
		}

		if result != nil {
			if err := json.Unmarshal(response.Result, result); err != nil {
				return fmt.Errorf("failed to unmarshal result: %w", err)
			}
		}

		return nil

	case <-time.After(c.timeout):
		c.pendingMutex.Lock()
		delete(c.pendingRequests, correlationID)
		c.pendingMutex.Unlock()
		return fmt.Errorf("RPC timeout: %s (correlation_id: %s)", method, correlationID)

	case <-ctx.Done():
		c.pendingMutex.Lock()
		delete(c.pendingRequests, correlationID)
		c.pendingMutex.Unlock()
		return ctx.Err()
	}
}

// handleResponse processes incoming RPC responses.
func (c *CentrifugoRPCClient) handleResponse(data []byte) {
	var response RPCResponse
	if err := json.Unmarshal(data, &response); err != nil {
		fmt.Printf("‚ö†Ô∏è  Failed to unmarshal response: %v\n", err)
		return
	}

	correlationID := response.CorrelationID
	if correlationID == "" {
		fmt.Println("‚ö†Ô∏è  Received response without correlation_id")
		return
	}

	c.pendingMutex.RLock()
	responseChan, exists := c.pendingRequests[correlationID]
	c.pendingMutex.RUnlock()

	if !exists {
		fmt.Printf("‚ö†Ô∏è  Received response for unknown correlation_id: %s\n", correlationID)
		return
	}

	// Send response to waiting goroutine
	responseChan <- response

	// Clean up
	c.pendingMutex.Lock()
	delete(c.pendingRequests, correlationID)
	c.pendingMutex.Unlock()
}

// rejectAllPending rejects all pending requests with an error.
func (c *CentrifugoRPCClient) rejectAllPending(err error) {
	c.pendingMutex.Lock()
	defer c.pendingMutex.Unlock()

	for correlationID, responseChan := range c.pendingRequests {
		responseChan <- RPCResponse{
			CorrelationID: correlationID,
			Error: &RPCError{
				Code:    -1,
				Message: err.Error(),
			},
		}
		delete(c.pendingRequests, correlationID)
	}
}
