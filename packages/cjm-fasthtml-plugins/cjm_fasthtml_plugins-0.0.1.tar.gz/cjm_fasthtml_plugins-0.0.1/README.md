# cjm-fasthtml-plugins


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Install

``` bash
pip install cjm_fasthtml_plugins
```

## Project Structure

    nbs/
    ├── core/ (3)
    │   ├── execution_mode.ipynb  # Enum definitions for plugin execution modes (in-process, subprocess, Docker, cloud, etc.)
    │   ├── metadata.ipynb        # Plugin metadata structures for tracking plugin information and resources
    │   └── registry.ipynb        # Unified plugin registry for managing multiple domain-specific plugin systems with configuration persistence
    ├── protocols/ (2)
    │   ├── cloud_aware.ipynb  # Protocol for plugins that use cloud or remote computing resources
    │   └── lifecycle.ipynb    # Protocol for plugins that manage child processes, containers, or other external resources
    └── utils/ (1)
        └── helpers.ipynb  # Utility functions for plugin registry operations

Total: 6 notebooks across 4 directories

## Module Dependencies

``` mermaid
graph LR
    core_execution_mode[core.execution_mode<br/>Execution Mode]
    core_metadata[core.metadata<br/>Metadata]
    core_registry[core.registry<br/>Registry]
    protocols_cloud_aware[protocols.cloud_aware<br/>Cloud-Aware Protocol]
    protocols_lifecycle[protocols.lifecycle<br/>Lifecycle Protocol]
    utils_helpers[utils.helpers<br/>Helpers]

    core_metadata --> core_execution_mode
    core_registry --> core_metadata
    core_registry --> core_execution_mode
    protocols_cloud_aware --> core_metadata
    protocols_cloud_aware --> core_execution_mode
    protocols_lifecycle --> core_execution_mode
    utils_helpers --> core_metadata
    utils_helpers --> core_execution_mode
```

*8 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Cloud-Aware Protocol (`cloud_aware.ipynb`)

> Protocol for plugins that use cloud or remote computing resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.cloud_aware import (
    CloudAwarePlugin,
    is_cloud_aware,
    has_active_cloud_resources,
    get_total_estimated_cost
)
```

#### Functions

``` python
def is_cloud_aware(plugin: Any) -> bool:
    """Check if a plugin implements the CloudAwarePlugin protocol.
    
    Args:
        plugin: Plugin instance to check
    
    Returns:
        True if plugin implements the protocol
    """
    return isinstance(plugin, CloudAwarePlugin)

def has_active_cloud_resources(plugin: Any) -> bool
    """
    Check if a plugin implements the CloudAwarePlugin protocol.
    
    Args:
        plugin: Plugin instance to check
    
    Returns:
        True if plugin implements the protocol
    """
```

``` python
def has_active_cloud_resources(plugin: Any) -> bool:
    """Check if plugin has active cloud resources.
    
    Args:
        plugin: Plugin instance
    
    Returns:
        True if plugin has running cloud resources
    """
    if not is_cloud_aware(plugin)
    """
    Check if plugin has active cloud resources.
    
    Args:
        plugin: Plugin instance
    
    Returns:
        True if plugin has running cloud resources
    """
```

``` python
def get_total_estimated_cost(plugins: List[Any], duration_hours: float = 1.0) -> float:
    """Get total estimated cost for multiple plugins.
    
    Args:
        plugins: List of plugin instances
        duration_hours: Duration to estimate for
    
    Returns:
        Total estimated cost in USD
    """
    total = 0.0
    for plugin in plugins
    """
    Get total estimated cost for multiple plugins.
    
    Args:
        plugins: List of plugin instances
        duration_hours: Duration to estimate for
    
    Returns:
        Total estimated cost in USD
    """
```

#### Classes

```` python
@runtime_checkable
class CloudAwarePlugin(Protocol):
    """
    Protocol for plugins that use cloud/remote resources.
    
    Plugins implementing this protocol provide information about
    cloud resources they use, enabling cost tracking, resource
    management, and emergency shutdown.
    
    Example:
        ```python
        class CloudFinetunePlugin(FinetuningPlugin, CloudAwarePlugin):
            def get_remote_resource_info(self) -> Optional[RemoteResourceInfo]:
                if not self.remote_instance:
                    return None
                return RemoteResourceInfo(
                    provider=CloudProviderType.AWS,
                    instance_id=self.instance_id,
                    status="running",
                    gpu_count=8,
                    estimated_cost_per_hour=24.50
                )
            
            def provision_remote_resource(self, **config) -> RemoteResourceInfo:
                # Launch EC2 instance
                return self.remote_resource_info
            
            def terminate_remote_resource(self) -> bool:
                # Terminate EC2 instance
                return True
            
            def estimate_cost(self, duration_hours: float) -> float:
                return duration_hours * 24.50
        ```
    """
    
    def get_remote_resource_info(self) -> Optional[RemoteResourceInfo]:
            """Get information about remote/cloud resources.
            
            Returns:
                RemoteResourceInfo if resources are provisioned, None otherwise
            """
            ...
        
        def provision_remote_resource(self, **config) -> RemoteResourceInfo
        "Get information about remote/cloud resources.

Returns:
    RemoteResourceInfo if resources are provisioned, None otherwise"
    
    def provision_remote_resource(self, **config) -> RemoteResourceInfo:
            """Provision cloud resources (VM, container, etc.).
            
            Args:
                **config: Provider-specific configuration
            
            Returns:
                RemoteResourceInfo with details about provisioned resource
            """
            ...
        
        def check_remote_resource_status(self) -> str
        "Provision cloud resources (VM, container, etc.).

Args:
    **config: Provider-specific configuration

Returns:
    RemoteResourceInfo with details about provisioned resource"
    
    def check_remote_resource_status(self) -> str:
            """Check status of remote resource.
            
            Returns:
                Status string (e.g., 'running', 'stopped', 'provisioning')
            """
            ...
        
        def terminate_remote_resource(self) -> bool
        "Check status of remote resource.

Returns:
    Status string (e.g., 'running', 'stopped', 'provisioning')"
    
    def terminate_remote_resource(self) -> bool:
            """Terminate/stop cloud resources to avoid costs.
            
            Returns:
                True if termination succeeded
            """
            ...
        
        def estimate_cost(self, duration_hours: float) -> float
        "Terminate/stop cloud resources to avoid costs.

Returns:
    True if termination succeeded"
    
    def estimate_cost(self, duration_hours: float) -> float
        "Estimate cost for running this duration.

Args:
    duration_hours: Estimated runtime in hours

Returns:
    Estimated cost in USD"
````

### Execution Mode (`execution_mode.ipynb`)

> Enum definitions for plugin execution modes (in-process, subprocess,
> Docker, cloud, etc.)

#### Import

``` python
from cjm_fasthtml_plugins.core.execution_mode import (
    PluginExecutionMode,
    CloudProviderType
)
```

#### Classes

``` python
class PluginExecutionMode(Enum):
    """
    How a plugin executes.
    
    This enum categorizes plugins by their execution environment,
    from simple in-process execution to complex cloud deployments.
    
    Examples:
        >>> # Simple in-process plugin
        >>> mode = PluginExecutionMode.IN_PROCESS
        >>> 
        >>> # Plugin that spawns subprocesses (like vLLM server)
        >>> mode = PluginExecutionMode.SUBPROCESS
        >>> 
        >>> # Plugin running on cloud GPU
        >>> mode = PluginExecutionMode.CLOUD_GPU
    """
```

``` python
class CloudProviderType(Enum):
    """
    Supported cloud providers.
    
    Identifies which cloud provider or GPU rental service is being used
    for remote execution.
    
    Examples:
        >>> # Major cloud providers
        >>> provider = CloudProviderType.AWS
        >>> provider = CloudProviderType.GCP
        >>> 
        >>> # GPU rental services
        >>> provider = CloudProviderType.LAMBDA_LABS
        >>> provider = CloudProviderType.RUNPOD
    """
```

### Helpers (`helpers.ipynb`)

> Utility functions for plugin registry operations

#### Import

``` python
from cjm_fasthtml_plugins.utils.helpers import (
    filter_plugins_by_execution_mode,
    get_cloud_plugins,
    get_local_plugins,
    get_configured_plugins,
    get_unconfigured_plugins,
    get_plugin_stats
)
```

#### Functions

``` python
def filter_plugins_by_execution_mode(
    plugins: List[PluginMetadata],  # List of plugin metadata
    mode: PluginExecutionMode  # Execution mode to filter by
) -> List[PluginMetadata]:  # Filtered list
    """
    Filter plugins by execution mode.
    
    Args:
        plugins: List of plugin metadata
        mode: Execution mode to filter by
    
    Returns:
        List of plugins matching the execution mode
    """
```

``` python
def get_cloud_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]:
    """Get all cloud/remote execution plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of cloud/remote plugins
    """
    return [p for p in plugins if p.is_cloud_execution()]

def get_local_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]
    """
    Get all cloud/remote execution plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of cloud/remote plugins
    """
```

``` python
def get_local_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]:
    """Get all local execution plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of local plugins
    """
    return [p for p in plugins if p.is_local_execution()]

def get_configured_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]
    """
    Get all local execution plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of local plugins
    """
```

``` python
def get_configured_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]:
    """Get plugins that have saved configuration.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of configured plugins
    """
    return [p for p in plugins if p.is_configured]

def get_unconfigured_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]
    """
    Get plugins that have saved configuration.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of configured plugins
    """
```

``` python
def get_unconfigured_plugins(plugins: List[PluginMetadata]) -> List[PluginMetadata]
    """
    Get plugins that need configuration.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        List of unconfigured plugins
    """
```

``` python
def get_plugin_stats(plugins: List[PluginMetadata]) -> Dict[str, Any]:
    """Get statistics about a list of plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        Dictionary with plugin statistics
    """
    return {
        "total": len(plugins),
    """
    Get statistics about a list of plugins.
    
    Args:
        plugins: List of plugin metadata
    
    Returns:
        Dictionary with plugin statistics
    """
```

### Lifecycle Protocol (`lifecycle.ipynb`)

> Protocol for plugins that manage child processes, containers, or other
> external resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.lifecycle import (
    LifecycleAwarePlugin,
    is_lifecycle_aware,
    get_all_managed_pids
)
```

#### Functions

``` python
def is_lifecycle_aware(plugin: Any) -> bool:
    """Check if a plugin implements the LifecycleAwarePlugin protocol.
    
    Args:
        plugin: Plugin instance to check
    
    Returns:
        True if plugin implements the protocol
    """
    return isinstance(plugin, LifecycleAwarePlugin)

def get_all_managed_pids(plugin: Any) -> List[int]
    """
    Check if a plugin implements the LifecycleAwarePlugin protocol.
    
    Args:
        plugin: Plugin instance to check
    
    Returns:
        True if plugin implements the protocol
    """
```

``` python
def get_all_managed_pids(plugin: Any) -> List[int]:
    """Get all PIDs managed by a plugin (including children).
    
    Args:
        plugin: Plugin instance
    
    Returns:
        List of all PIDs (empty if plugin not lifecycle-aware)
    """
    if not is_lifecycle_aware(plugin)
    """
    Get all PIDs managed by a plugin (including children).
    
    Args:
        plugin: Plugin instance
    
    Returns:
        List of all PIDs (empty if plugin not lifecycle-aware)
    """
```

#### Classes

```` python
@runtime_checkable
class LifecycleAwarePlugin(Protocol):
    """
    Protocol for plugins that manage external resources.
    
    Plugins implementing this protocol provide information about
    child processes, containers, or other resources they manage.
    
    This enables:
    - Resource tracking across the application
    - Proper cleanup when stopping plugins
    - Conflict detection for GPU/memory usage
    - Cost tracking for cloud resources
    
    Example:
        ```python
        class VoxtralVLLMPlugin(TranscriptionPlugin, LifecycleAwarePlugin):
            def get_execution_mode(self) -> PluginExecutionMode:
                return PluginExecutionMode.SUBPROCESS
            
            def get_child_pids(self) -> List[int]:
                if not self.server or not self.server.process:
                    return []
                return [self.server.process.pid]
            
            def get_managed_resources(self) -> Dict[str, Any]:
                return {
                    'server_url': self.server.base_url,
                    'is_running': self.server.is_running()
                }
            
            def force_cleanup(self) -> None:
                if self.server:
                    self.server.stop()
        ```
    """
    
    def get_execution_mode(self) -> PluginExecutionMode:
            """Get the execution mode of this plugin.
            
            Returns:
                PluginExecutionMode indicating how this plugin executes
            """
            ...
        
        def get_child_pids(self) -> List[int]
        "Get the execution mode of this plugin.

Returns:
    PluginExecutionMode indicating how this plugin executes"
    
    def get_child_pids(self) -> List[int]:
            """Get PIDs of any child processes managed by this plugin.
            
            For plugins that spawn subprocesses (e.g., vLLM servers), this
            should return all child process PIDs for resource tracking.
            
            Returns:
                List of process IDs (empty list if no child processes)
            """
            ...
        
        def get_managed_resources(self) -> Dict[str, Any]
        "Get PIDs of any child processes managed by this plugin.

For plugins that spawn subprocesses (e.g., vLLM servers), this
should return all child process PIDs for resource tracking.

Returns:
    List of process IDs (empty list if no child processes)"
    
    def get_managed_resources(self) -> Dict[str, Any]:
            """Get information about managed resources.
            
            This can include:
            - Server URLs and ports
            - Container IDs
            - Conda environment names
            - Status information
            - Any other plugin-specific resource info
            
            Returns:
                Dictionary with resource information
            """
            ...
        
        def force_cleanup(self) -> None
        "Get information about managed resources.

This can include:
- Server URLs and ports
- Container IDs
- Conda environment names
- Status information
- Any other plugin-specific resource info

Returns:
    Dictionary with resource information"
    
    def force_cleanup(self) -> None
        "Force cleanup of all managed resources.

This should be more aggressive than regular cleanup(),
killing processes, stopping containers, etc. Used for
emergency shutdown scenarios."
````

### Metadata (`metadata.ipynb`)

> Plugin metadata structures for tracking plugin information and
> resources

#### Import

``` python
from cjm_fasthtml_plugins.core.metadata import (
    RemoteResourceInfo,
    PluginMetadata
)
```

#### Classes

``` python
@dataclass
class RemoteResourceInfo:
    """
    Information about a remote/cloud resource.
    
    Tracks details about cloud VMs, containers, or other remote resources
    that a plugin is using for execution.
    
    Attributes:
        provider: Cloud provider or service
        region: Cloud region/zone
        instance_id: VM/instance identifier
        job_id: Job/task identifier on remote system
        endpoint_url: HTTP endpoint for API access
        ssh_host: SSH host for remote access
        ssh_port: SSH port number
        status: Current status (provisioning, running, stopping, stopped)
        resource_type: Instance type (e.g., 'p3.2xlarge', 'n1-standard-8')
        gpu_count: Number of GPUs
        gpu_type: GPU model (e.g., 'V100', 'A100', 'H100')
        estimated_cost_per_hour: Estimated hourly cost in USD
        metadata: Additional provider-specific metadata
    """
    
    provider: CloudProviderType
    region: Optional[str]
    instance_id: Optional[str]
    job_id: Optional[str]
    endpoint_url: Optional[str]
    ssh_host: Optional[str]
    ssh_port: int = 22
    status: str = 'unknown'  # provisioning, running, stopping, stopped
    resource_type: Optional[str]
    gpu_count: int = 0
    gpu_type: Optional[str]
    estimated_cost_per_hour: Optional[float]
    metadata: Dict[str, Any] = field(...)
```

```` python
@dataclass
class PluginMetadata:
    """
    Metadata describing a plugin.
    
    This dataclass holds information about a plugin that can be displayed
    in settings UI and used for resource management without loading the
    actual plugin instance.
    
    Categories are simple strings - applications choose their own category names
    based on their needs (e.g., 'transcription', 'llm', 'image_generation', etc.).
    
    Attributes:
        name: Internal plugin identifier
        category: Plugin category string (application-defined)
        title: Display title for the plugin
        config_schema: JSON Schema for plugin configuration
        description: Optional plugin description
        version: Optional plugin version
        is_configured: Whether the plugin has saved configuration
        
        # Lifecycle metadata
        execution_mode: How the plugin executes (in-process, subprocess, cloud, etc.)
        manages_child_processes: Whether plugin spawns child processes
        manages_external_resources: Whether plugin manages Docker/servers/etc.
        
        # Local resource tracking
        spawned_pids: List of child process PIDs
        container_id: Docker container ID if applicable
        conda_env_name: Conda environment name if applicable
        
        # Cloud/Remote resource tracking
        remote_resource: Remote resource information if applicable
    
    Example:
        ```python
        # Simple in-process plugin
        metadata = PluginMetadata(
            name="whisper_base",
            category="transcription",
            title="Whisper Base Model",
            config_schema={...},
            execution_mode=PluginExecutionMode.IN_PROCESS
        )
        
        # Plugin with vLLM server (subprocess)
        metadata = PluginMetadata(
            name="voxtral_vllm",
            category="transcription",
            title="Voxtral via vLLM",
            config_schema={...},
            execution_mode=PluginExecutionMode.SUBPROCESS,
            manages_child_processes=True,
            spawned_pids=[12345, 12346, 12347]
        )
        
        # Cloud-based plugin
        metadata = PluginMetadata(
            name="llm_finetune_cloud",
            category="finetuning",
            title="Cloud LLM Finetuning",
            config_schema={...},
            execution_mode=PluginExecutionMode.CLOUD_GPU,
            manages_external_resources=True,
            remote_resource=RemoteResourceInfo(...)
        )
        ```
    """
    
    name: str
    category: str
    title: str
    config_schema: Dict[str, Any]
    description: Optional[str]
    version: Optional[str]
    is_configured: bool = False
    execution_mode: PluginExecutionMode = PluginExecutionMode.IN_PROCESS
    manages_child_processes: bool = False
    manages_external_resources: bool = False
    spawned_pids: List[int] = field(...)
    container_id: Optional[str]
    conda_env_name: Optional[str]
    remote_resource: Optional[RemoteResourceInfo]
    
    def get_unique_id(self) -> str:
            """Generate unique ID for this plugin.
            
            Returns:
                String in format 'category_name'
            """
            return f"{self.category}_{self.name}"
        
        def is_local_execution(self) -> bool
        "Generate unique ID for this plugin.

Returns:
    String in format 'category_name'"
    
    def is_local_execution(self) -> bool:
            """Check if plugin executes locally (not cloud/remote).
            
            Returns:
                True if execution is local
            """
            local_modes = {
                PluginExecutionMode.IN_PROCESS,
                PluginExecutionMode.SUBPROCESS,
                PluginExecutionMode.DOCKER,
                PluginExecutionMode.CONDA_ENV,
                PluginExecutionMode.EXTERNAL_SERVICE
            }
            return self.execution_mode in local_modes
        
        def is_cloud_execution(self) -> bool
        "Check if plugin executes locally (not cloud/remote).

Returns:
    True if execution is local"
    
    def is_cloud_execution(self) -> bool:
            """Check if plugin executes on cloud/remote resources.
            
            Returns:
                True if execution is cloud/remote
            """
            return not self.is_local_execution()
        
        def has_active_resources(self) -> bool
        "Check if plugin executes on cloud/remote resources.

Returns:
    True if execution is cloud/remote"
    
    def has_active_resources(self) -> bool
        "Check if plugin has active managed resources.

Returns:
    True if plugin has child processes, containers, or cloud resources"
````

### Registry (`registry.ipynb`)

> Unified plugin registry for managing multiple domain-specific plugin
> systems with configuration persistence

#### Import

``` python
from cjm_fasthtml_plugins.core.registry import (
    T,
    UnifiedPluginRegistry
)
```

#### Classes

```` python
class UnifiedPluginRegistry:
    def __init__(self, config_dir: Optional[Path] = None):
        """Initialize the unified plugin registry.
        
        Args:
            config_dir: Directory for plugin configuration files (default: 'configs')
        """
        self._managers: Dict[str, Any] = {}  # category -> manager
    """
    Unified registry for multiple domain-specific plugin systems.
    
    Manages plugin managers from different domains (transcription, LLM, etc.)
    and provides a single interface for plugin discovery, configuration,
    and resource management.
    
    Example:
        ```python
        from cjm_plugin_system.core.manager import PluginManager
        from cjm_transcription_plugin_system.plugin_interface import TranscriptionPlugin
        
        # Create registry
        registry = UnifiedPluginRegistry()
        
        # Register transcription plugins
        transcription_mgr = PluginManager(plugin_interface=TranscriptionPlugin)
        registry.register_plugin_manager(
            category="transcription",
            manager=transcription_mgr,
            display_name="Transcription"
        )
        
        # Get all plugins
        all_plugins = registry.get_all_plugins()
        
        # Get plugins by category
        transcription_plugins = registry.get_plugins_by_category("transcription")
        
        # Get manager for specific operations
        mgr = registry.get_manager("transcription")
        ```
    """
    
    def __init__(self, config_dir: Optional[Path] = None):
            """Initialize the unified plugin registry.
            
            Args:
                config_dir: Directory for plugin configuration files (default: 'configs')
            """
            self._managers: Dict[str, Any] = {}  # category -> manager
        "Initialize the unified plugin registry.

Args:
    config_dir: Directory for plugin configuration files (default: 'configs')"
    
    def register_plugin_manager(
            self,
            category: str,  # Category name (e.g., "transcription", "llm")
            manager: Any,  # Domain-specific plugin manager
            display_name: Optional[str] = None,  # Display name for UI
            auto_discover: bool = True  # Automatically discover plugins?
        ) -> List[PluginMetadata]:  # List of discovered plugin metadata
        "Register a domain-specific plugin manager.

Args:
    category: String category (e.g., 'transcription')
    manager: The domain-specific plugin manager instance
    display_name: Optional display name for UI
    auto_discover: Automatically discover and register plugins

Returns:
    List of discovered plugin metadata"
    
    def get_manager(
            self,
            category: str,  # Category name
            manager_type: Optional[Type[T]] = None  # Optional type hint
        ) -> Optional[T]:  # Plugin manager instance
        "Get plugin manager for a specific category.

Args:
    category: Category name (e.g., 'transcription')
    manager_type: Optional type hint for IDE autocomplete

Returns:
    Plugin manager instance if found, None otherwise"
    
    def get_categories(self) -> List[str]:
            """Get all registered categories.
            
            Returns:
                Sorted list of category names
            """
            return sorted(self._categories.keys())
        
        def get_category_display_name(self, category: str) -> str
        "Get all registered categories.

Returns:
    Sorted list of category names"
    
    def get_category_display_name(self, category: str) -> str:
            """Get display name for a category.
            
            Args:
                category: Category name
            
            Returns:
                Display name or category name if not set
            """
            return self._categories.get(category, category.title())
        
        def get_plugin(self, unique_id: str) -> Optional[PluginMetadata]
        "Get display name for a category.

Args:
    category: Category name

Returns:
    Display name or category name if not set"
    
    def get_plugin(self, unique_id: str) -> Optional[PluginMetadata]:
            """Get plugin metadata by unique ID.
            
            Args:
                unique_id: Plugin unique identifier (format: 'category_name')
            
            Returns:
                Plugin metadata if found, None otherwise
            """
            return self._plugins.get(unique_id)
        
        def get_plugins_by_category(self, category: str) -> List[PluginMetadata]
        "Get plugin metadata by unique ID.

Args:
    unique_id: Plugin unique identifier (format: 'category_name')

Returns:
    Plugin metadata if found, None otherwise"
    
    def get_plugins_by_category(self, category: str) -> List[PluginMetadata]:
            """Get all plugins in a category.
            
            Args:
                category: Category name
            
            Returns:
                List of plugin metadata for the category
            """
            return [p for p in self._plugins.values() if p.category == category]
        
        def get_all_plugins(self) -> List[PluginMetadata]
        "Get all plugins in a category.

Args:
    category: Category name

Returns:
    List of plugin metadata for the category"
    
    def get_all_plugins(self) -> List[PluginMetadata]:
            """Get all plugins across all categories.
            
            Returns:
                List of all plugin metadata
            """
            return list(self._plugins.values())
        
        def get_categories_with_plugins(self) -> List[str]
        "Get all plugins across all categories.

Returns:
    List of all plugin metadata"
    
    def get_categories_with_plugins(self) -> List[str]:
            """Get categories that have registered plugins.
            
            Returns:
                Sorted list of categories with plugins
            """
            categories = set(p.category for p in self._plugins.values())
            return sorted(categories)
        
        def load_plugin_config(self, unique_id: str) -> Dict[str, Any]
        "Get categories that have registered plugins.

Returns:
    Sorted list of categories with plugins"
    
    def load_plugin_config(self, unique_id: str) -> Dict[str, Any]:
            """Load saved configuration for a plugin.
            
            Args:
                unique_id: Plugin unique identifier
            
            Returns:
                Configuration dictionary (empty if no config exists)
            """
            config_file = self._config_dir / f"{unique_id}.json"
            if config_file.exists()
        "Load saved configuration for a plugin.

Args:
    unique_id: Plugin unique identifier

Returns:
    Configuration dictionary (empty if no config exists)"
    
    def save_plugin_config(self, unique_id: str, config: Dict[str, Any]) -> bool:
            """Save configuration for a plugin.
            
            Args:
                unique_id: Plugin unique identifier
                config: Configuration dictionary to save
            
            Returns:
                True if save succeeded, False otherwise
            """
            try
        "Save configuration for a plugin.

Args:
    unique_id: Plugin unique identifier
    config: Configuration dictionary to save

Returns:
    True if save succeeded, False otherwise"
    
    def delete_plugin_config(self, unique_id: str) -> bool:
            """Delete saved configuration for a plugin.
            
            Args:
                unique_id: Plugin unique identifier
            
            Returns:
                True if deletion succeeded, False otherwise
            """
            try
        "Delete saved configuration for a plugin.

Args:
    unique_id: Plugin unique identifier

Returns:
    True if deletion succeeded, False otherwise"
````

#### Variables

``` python
T
```
