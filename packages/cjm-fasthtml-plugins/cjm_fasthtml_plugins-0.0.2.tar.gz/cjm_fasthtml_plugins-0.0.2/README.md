# cjm-fasthtml-plugins


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Install

``` bash
pip install cjm_fasthtml_plugins
```

## Project Structure

    nbs/
    ├── core/ (3)
    │   ├── execution_mode.ipynb  # Enum definitions for plugin execution modes (in-process, subprocess, Docker, cloud, etc.)
    │   ├── metadata.ipynb        # Plugin metadata structures for tracking plugin information and resources
    │   └── registry.ipynb        # Unified plugin registry for managing multiple domain-specific plugin systems with configuration persistence
    ├── protocols/ (2)
    │   ├── cloud_aware.ipynb  # Protocol for plugins that use cloud or remote computing resources
    │   └── lifecycle.ipynb    # Protocol for plugins that manage child processes, containers, or other external resources
    └── utils/ (1)
        └── helpers.ipynb  # Utility functions for plugin registry operations

Total: 6 notebooks across 4 directories

## Module Dependencies

``` mermaid
graph LR
    core_execution_mode[core.execution_mode<br/>Execution Mode]
    core_metadata[core.metadata<br/>Metadata]
    core_registry[core.registry<br/>Registry]
    protocols_cloud_aware[protocols.cloud_aware<br/>Cloud-Aware Protocol]
    protocols_lifecycle[protocols.lifecycle<br/>Lifecycle Protocol]
    utils_helpers[utils.helpers<br/>Helpers]

    core_metadata --> core_execution_mode
    core_registry --> core_metadata
    core_registry --> core_execution_mode
    protocols_cloud_aware --> core_execution_mode
    protocols_cloud_aware --> core_metadata
    protocols_lifecycle --> core_execution_mode
    utils_helpers --> core_metadata
    utils_helpers --> core_execution_mode
```

*8 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Cloud-Aware Protocol (`cloud_aware.ipynb`)

> Protocol for plugins that use cloud or remote computing resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.cloud_aware import (
    CloudAwarePlugin,
    is_cloud_aware,
    has_active_cloud_resources,
    get_total_estimated_cost
)
```

#### Functions

``` python
def is_cloud_aware(plugin: Any  # Plugin instance to check
                  ) -> bool:  # True if plugin implements the protocol
    "Check if a plugin implements the CloudAwarePlugin protocol."
```

``` python
def has_active_cloud_resources(plugin: Any  # Plugin instance
                               ) -> bool:  # True if plugin has running cloud resources
    "Check if plugin has active cloud resources."
```

``` python
def get_total_estimated_cost(plugins: List[Any],  # List of plugin instances
                            duration_hours: float = 1.0  # Duration to estimate for
                           ) -> float:  # Total estimated cost in USD
    "Get total estimated cost for multiple plugins."
```

#### Classes

``` python
@runtime_checkable
class CloudAwarePlugin(Protocol):
    "Protocol for plugins that use cloud/remote resources."
    
    def get_remote_resource_info(self) -> Optional[RemoteResourceInfo]:  # RemoteResourceInfo if resources are provisioned, None otherwise
            """Get information about remote/cloud resources."""
            ...
        
        def provision_remote_resource(self, **config) -> RemoteResourceInfo:  # RemoteResourceInfo with details about provisioned resource
        "Get information about remote/cloud resources."
    
    def provision_remote_resource(self, **config) -> RemoteResourceInfo:  # RemoteResourceInfo with details about provisioned resource
            """Provision cloud resources (VM, container, etc.)."""
            ...
        
        def check_remote_resource_status(self) -> str:  # Status string (e.g., 'running', 'stopped', 'provisioning')
        "Provision cloud resources (VM, container, etc.)."
    
    def check_remote_resource_status(self) -> str:  # Status string (e.g., 'running', 'stopped', 'provisioning')
            """Check status of remote resource."""
            ...
        
        def terminate_remote_resource(self) -> bool:  # True if termination succeeded
        "Check status of remote resource."
    
    def terminate_remote_resource(self) -> bool:  # True if termination succeeded
            """Terminate/stop cloud resources to avoid costs."""
            ...
        
        def estimate_cost(self, 
                         duration_hours: float  # Estimated runtime in hours
                        ) -> float:  # Estimated cost in USD
        "Terminate/stop cloud resources to avoid costs."
    
    def estimate_cost(self,
                         duration_hours: float  # Estimated runtime in hours
                        ) -> float:  # Estimated cost in USD
        "Estimate cost for running this duration."
```

### Execution Mode (`execution_mode.ipynb`)

> Enum definitions for plugin execution modes (in-process, subprocess,
> Docker, cloud, etc.)

#### Import

``` python
from cjm_fasthtml_plugins.core.execution_mode import (
    PluginExecutionMode,
    CloudProviderType
)
```

#### Classes

``` python
class PluginExecutionMode(Enum):
    "Categorizes plugins by their execution environment, from in-process to cloud deployments."
```

``` python
class CloudProviderType(Enum):
    "Cloud providers and GPU rental services for remote execution."
```

### Helpers (`helpers.ipynb`)

> Utility functions for plugin registry operations

#### Import

``` python
from cjm_fasthtml_plugins.utils.helpers import (
    filter_plugins_by_execution_mode,
    get_cloud_plugins,
    get_local_plugins,
    get_configured_plugins,
    get_unconfigured_plugins,
    get_plugin_stats
)
```

#### Functions

``` python
def filter_plugins_by_execution_mode(
    plugins: List[PluginMetadata],  # List of plugin metadata
    mode: PluginExecutionMode  # Execution mode to filter by
) -> List[PluginMetadata]:  # Filtered list
    "Filter plugins by execution mode."
```

``` python
def get_cloud_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                     ) -> List[PluginMetadata]:  # List of cloud/remote plugins
    "Get all cloud/remote execution plugins."
```

``` python
def get_local_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                     ) -> List[PluginMetadata]:  # List of local plugins
    "Get all local execution plugins."
```

``` python
def get_configured_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                          ) -> List[PluginMetadata]:  # List of configured plugins
    "Get plugins that have saved configuration."
```

``` python
def get_unconfigured_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                            ) -> List[PluginMetadata]:  # List of unconfigured plugins
    "Get plugins that need configuration."
```

``` python
def get_plugin_stats(plugins: List[PluginMetadata]  # List of plugin metadata
                    ) -> Dict[str, Any]:  # Dictionary with plugin statistics
    "Get statistics about a list of plugins."
```

### Lifecycle Protocol (`lifecycle.ipynb`)

> Protocol for plugins that manage child processes, containers, or other
> external resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.lifecycle import (
    LifecycleAwarePlugin,
    is_lifecycle_aware,
    get_all_managed_pids
)
```

#### Functions

``` python
def is_lifecycle_aware(plugin: Any  # Plugin instance to check
                      ) -> bool:  # True if plugin implements the protocol
    "Check if a plugin implements the LifecycleAwarePlugin protocol."
```

``` python
def get_all_managed_pids(plugin: Any  # Plugin instance
                        ) -> List[int]:  # List of all PIDs (empty if plugin not lifecycle-aware)
    "Get all PIDs managed by a plugin (including children)."
```

#### Classes

``` python
@runtime_checkable
class LifecycleAwarePlugin(Protocol):
    "Protocol for plugins that manage external resources like child processes, containers, or cloud resources."
    
    def get_execution_mode(self) -> PluginExecutionMode:  # PluginExecutionMode indicating how this plugin executes
            """Get the execution mode of this plugin."""
            ...
        
        def get_child_pids(self) -> List[int]:  # List of process IDs (empty list if no child processes)
        "Get the execution mode of this plugin."
    
    def get_child_pids(self) -> List[int]:  # List of process IDs (empty list if no child processes)
            """Get PIDs of any child processes managed by this plugin."""
            ...
        
        def get_managed_resources(self) -> Dict[str, Any]:  # Dictionary with resource information
        "Get PIDs of any child processes managed by this plugin."
    
    def get_managed_resources(self) -> Dict[str, Any]:  # Dictionary with resource information
            """Get information about managed resources (server URLs, container IDs, conda envs, etc.)."""
            ...
        
        def force_cleanup(self) -> None
        "Get information about managed resources (server URLs, container IDs, conda envs, etc.)."
    
    def force_cleanup(self) -> None
        "Force cleanup of all managed resources (kill processes, stop containers, etc.)."
```

### Metadata (`metadata.ipynb`)

> Plugin metadata structures for tracking plugin information and
> resources

#### Import

``` python
from cjm_fasthtml_plugins.core.metadata import (
    RemoteResourceInfo,
    PluginMetadata
)
```

#### Classes

``` python
@dataclass
class RemoteResourceInfo:
    "Information about a remote/cloud resource used by a plugin."
    
    provider: CloudProviderType  # Cloud provider or service
    region: Optional[str]  # Cloud region/zone
    instance_id: Optional[str]  # VM/instance identifier
    job_id: Optional[str]  # Job/task identifier on remote system
    endpoint_url: Optional[str]  # HTTP endpoint for API access
    ssh_host: Optional[str]  # SSH host for remote access
    ssh_port: int = 22  # SSH port number
    status: str = 'unknown'  # Current status (provisioning, running, stopping, stopped)
    resource_type: Optional[str]  # Instance type (e.g., 'p3.2xlarge', 'n1-standard-8')
    gpu_count: int = 0  # Number of GPUs
    gpu_type: Optional[str]  # GPU model (e.g., 'V100', 'A100', 'H100')
    estimated_cost_per_hour: Optional[float]  # Estimated hourly cost in USD
    metadata: Dict[str, Any] = field(...)  # Additional provider-specific metadata
```

``` python
@dataclass
class PluginMetadata:
    "Metadata describing a plugin for display and resource management without loading the plugin instance."
    
    name: str  # Internal plugin identifier
    category: str  # Plugin category string (application-defined)
    title: str  # Display title for the plugin
    config_schema: Dict[str, Any]  # JSON Schema for plugin configuration
    description: Optional[str]  # Plugin description
    version: Optional[str]  # Plugin version
    is_configured: bool = False  # Whether the plugin has saved configuration
    execution_mode: PluginExecutionMode = PluginExecutionMode.IN_PROCESS  # How the plugin executes
    manages_child_processes: bool = False  # Whether plugin spawns child processes
    manages_external_resources: bool = False  # Whether plugin manages Docker/servers/etc.
    spawned_pids: List[int] = field(...)  # List of child process PIDs
    container_id: Optional[str]  # Docker container ID if applicable
    conda_env_name: Optional[str]  # Conda environment name if applicable
    remote_resource: Optional[RemoteResourceInfo]  # Remote resource information if applicable
    
    def get_unique_id(self) -> str:  # String in format 'category_name'
            """Generate unique ID for this plugin."""
            return f"{self.category}_{self.name}"
        
        def is_local_execution(self) -> bool:  # True if execution is local
        "Generate unique ID for this plugin."
    
    def is_local_execution(self) -> bool:  # True if execution is local
            """Check if plugin executes locally (not cloud/remote)."""
            local_modes = {
                PluginExecutionMode.IN_PROCESS,
                PluginExecutionMode.SUBPROCESS,
                PluginExecutionMode.DOCKER,
                PluginExecutionMode.CONDA_ENV,
                PluginExecutionMode.EXTERNAL_SERVICE
            }
            return self.execution_mode in local_modes
        
        def is_cloud_execution(self) -> bool:  # True if execution is cloud/remote
        "Check if plugin executes locally (not cloud/remote)."
    
    def is_cloud_execution(self) -> bool:  # True if execution is cloud/remote
            """Check if plugin executes on cloud/remote resources."""
            return not self.is_local_execution()
        
        def has_active_resources(self) -> bool:  # True if plugin has child processes, containers, or cloud resources
        "Check if plugin executes on cloud/remote resources."
    
    def has_active_resources(self) -> bool:  # True if plugin has child processes, containers, or cloud resources
        "Check if plugin has active managed resources."
```

### Registry (`registry.ipynb`)

> Unified plugin registry for managing multiple domain-specific plugin
> systems with configuration persistence

#### Import

``` python
from cjm_fasthtml_plugins.core.registry import (
    T,
    UnifiedPluginRegistry
)
```

#### Classes

``` python
class UnifiedPluginRegistry:
    def __init__(self, 
                 config_dir: Optional[Path] = None  # Directory for plugin configuration files (default: 'configs')
                )
    "Unified registry for multiple domain-specific plugin systems with configuration persistence."
    
    def __init__(self,
                     config_dir: Optional[Path] = None  # Directory for plugin configuration files (default: 'configs')
                    )
        "Initialize the unified plugin registry."
    
    def register_plugin_manager(
            self,
            category: str,  # Category name (e.g., "transcription", "llm")
            manager: Any,  # Domain-specific plugin manager
            display_name: Optional[str] = None,  # Display name for UI
            auto_discover: bool = True  # Automatically discover plugins?
        ) -> List[PluginMetadata]:  # List of discovered plugin metadata
        "Register a domain-specific plugin manager."
    
    def get_manager(
            self,
            category: str,  # Category name
            manager_type: Optional[Type[T]] = None  # Optional type hint for IDE autocomplete
        ) -> Optional[T]:  # Plugin manager instance
        "Get plugin manager for a specific category."
    
    def get_categories(self) -> List[str]:  # Sorted list of category names
            """Get all registered categories."""
            return sorted(self._categories.keys())
        
        def get_category_display_name(self, 
                                       category: str  # Category name
                                      ) -> str:  # Display name or category name if not set
        "Get all registered categories."
    
    def get_category_display_name(self,
                                       category: str  # Category name
                                      ) -> str:  # Display name or category name if not set
        "Get display name for a category."
    
    def get_plugin(self,
                       unique_id: str  # Plugin unique identifier (format: 'category_name')
                      ) -> Optional[PluginMetadata]:  # Plugin metadata if found, None otherwise
        "Get plugin metadata by unique ID."
    
    def get_plugins_by_category(self,
                                    category: str  # Category name
                                   ) -> List[PluginMetadata]:  # List of plugin metadata for the category
        "Get all plugins in a category."
    
    def get_all_plugins(self) -> List[PluginMetadata]:  # List of all plugin metadata
            """Get all plugins across all categories."""
            return list(self._plugins.values())
        
        def get_categories_with_plugins(self) -> List[str]:  # Sorted list of categories with plugins
        "Get all plugins across all categories."
    
    def get_categories_with_plugins(self) -> List[str]:  # Sorted list of categories with plugins
            """Get categories that have registered plugins."""
            categories = set(p.category for p in self._plugins.values())
            return sorted(categories)
        
        def load_plugin_config(self, 
                              unique_id: str  # Plugin unique identifier
                             ) -> Dict[str, Any]:  # Configuration dictionary (empty if no config exists)
        "Get categories that have registered plugins."
    
    def load_plugin_config(self,
                              unique_id: str  # Plugin unique identifier
                             ) -> Dict[str, Any]:  # Configuration dictionary (empty if no config exists)
        "Load saved configuration for a plugin."
    
    def save_plugin_config(self,
                              unique_id: str,  # Plugin unique identifier
                              config: Dict[str, Any]  # Configuration dictionary to save
                             ) -> bool:  # True if save succeeded, False otherwise
        "Save configuration for a plugin."
    
    def delete_plugin_config(self,
                                unique_id: str  # Plugin unique identifier
                               ) -> bool:  # True if deletion succeeded, False otherwise
        "Delete saved configuration for a plugin."
```

#### Variables

``` python
T
```
