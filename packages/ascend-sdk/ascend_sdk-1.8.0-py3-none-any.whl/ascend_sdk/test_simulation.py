"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from ascend_sdk import utils
from ascend_sdk._hooks import HookContext
from ascend_sdk.models import components, errors, operations
from ascend_sdk.types import OptionalNullable, UNSET
from ascend_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional, Union


class TestSimulation(BaseSDK):
    def simulate_create_check_deposit(
        self,
        *,
        account_id: str,
        simulate_create_check_deposit_request_create: Union[
            components.SimulateCreateCheckDepositRequestCreate,
            components.SimulateCreateCheckDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CheckDepositsSimulateCreateCheckDepositResponse:
        r"""Simulate Check Deposit Creation

        Creates a check deposit for a specific account FOR TESTING ONLY!

        :param account_id: The account id.
        :param simulate_create_check_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CheckDepositsSimulateCreateCheckDepositRequest(
            account_id=account_id,
            simulate_create_check_deposit_request_create=utils.get_pydantic_model(
                simulate_create_check_deposit_request_create,
                components.SimulateCreateCheckDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/checkDeposits:simulate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.simulate_create_check_deposit_request_create,
                False,
                False,
                "json",
                components.SimulateCreateCheckDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CheckDeposits_SimulateCreateCheckDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CheckDepositsSimulateCreateCheckDepositResponse(
                check_deposit=unmarshal_json_response(
                    Optional[components.CheckDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CheckDepositsSimulateCreateCheckDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def simulate_create_check_deposit_async(
        self,
        *,
        account_id: str,
        simulate_create_check_deposit_request_create: Union[
            components.SimulateCreateCheckDepositRequestCreate,
            components.SimulateCreateCheckDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CheckDepositsSimulateCreateCheckDepositResponse:
        r"""Simulate Check Deposit Creation

        Creates a check deposit for a specific account FOR TESTING ONLY!

        :param account_id: The account id.
        :param simulate_create_check_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CheckDepositsSimulateCreateCheckDepositRequest(
            account_id=account_id,
            simulate_create_check_deposit_request_create=utils.get_pydantic_model(
                simulate_create_check_deposit_request_create,
                components.SimulateCreateCheckDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/checkDeposits:simulate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.simulate_create_check_deposit_request_create,
                False,
                False,
                "json",
                components.SimulateCreateCheckDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CheckDeposits_SimulateCreateCheckDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CheckDepositsSimulateCreateCheckDepositResponse(
                check_deposit=unmarshal_json_response(
                    Optional[components.CheckDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CheckDepositsSimulateCreateCheckDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_ach_deposit(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_approve_ach_deposit_request_create: Union[
            components.ForceApproveAchDepositRequestCreate,
            components.ForceApproveAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceApproveAchDepositResponse:
        r"""ACH Deposit Approval

        Forces approval of an existing ACH deposit that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_approve_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceApproveAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_approve_ach_deposit_request_create=utils.get_pydantic_model(
                force_approve_ach_deposit_request_create,
                components.ForceApproveAchDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceApproveAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceApproveAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceApproveAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceApproveAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_ach_deposit_async(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_approve_ach_deposit_request_create: Union[
            components.ForceApproveAchDepositRequestCreate,
            components.ForceApproveAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceApproveAchDepositResponse:
        r"""ACH Deposit Approval

        Forces approval of an existing ACH deposit that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_approve_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceApproveAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_approve_ach_deposit_request_create=utils.get_pydantic_model(
                force_approve_ach_deposit_request_create,
                components.ForceApproveAchDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceApproveAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceApproveAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceApproveAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceApproveAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_noc_ach_deposit(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_noc_ach_deposit_request_create: Union[
            components.ForceNocAchDepositRequestCreate,
            components.ForceNocAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceNocAchDepositResponse:
        r"""NOC for a Deposit

        Forces a Nacha notice of change (NOC) on a completed ACH deposit. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_noc_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceNocAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_noc_ach_deposit_request_create=utils.get_pydantic_model(
                force_noc_ach_deposit_request_create,
                components.ForceNocAchDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceNoc",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_noc_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceNocAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceNocAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceNocAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceNocAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_noc_ach_deposit_async(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_noc_ach_deposit_request_create: Union[
            components.ForceNocAchDepositRequestCreate,
            components.ForceNocAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceNocAchDepositResponse:
        r"""NOC for a Deposit

        Forces a Nacha notice of change (NOC) on a completed ACH deposit. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_noc_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceNocAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_noc_ach_deposit_request_create=utils.get_pydantic_model(
                force_noc_ach_deposit_request_create,
                components.ForceNocAchDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceNoc",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_noc_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceNocAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceNocAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceNocAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceNocAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_ach_deposit(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_reject_ach_deposit_request_create: Union[
            components.ForceRejectAchDepositRequestCreate,
            components.ForceRejectAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceRejectAchDepositResponse:
        r"""ACH Deposit Rejection

        Forces rejection of an existing ACH deposit that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_reject_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceRejectAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_reject_ach_deposit_request_create=utils.get_pydantic_model(
                force_reject_ach_deposit_request_create,
                components.ForceRejectAchDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceRejectAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceRejectAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceRejectAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceRejectAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_ach_deposit_async(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_reject_ach_deposit_request_create: Union[
            components.ForceRejectAchDepositRequestCreate,
            components.ForceRejectAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceRejectAchDepositResponse:
        r"""ACH Deposit Rejection

        Forces rejection of an existing ACH deposit that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_reject_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceRejectAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_reject_ach_deposit_request_create=utils.get_pydantic_model(
                force_reject_ach_deposit_request_create,
                components.ForceRejectAchDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceRejectAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceRejectAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceRejectAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceRejectAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_return_ach_deposit(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_return_ach_deposit_request_create: Union[
            components.ForceReturnAchDepositRequestCreate,
            components.ForceReturnAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceReturnAchDepositResponse:
        r"""ACH Deposit Return

        Forces a Nacha return on a completed ACH deposit. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_return_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceReturnAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_return_ach_deposit_request_create=utils.get_pydantic_model(
                force_return_ach_deposit_request_create,
                components.ForceReturnAchDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceReturn",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_return_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceReturnAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceReturnAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceReturnAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceReturnAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_return_ach_deposit_async(
        self,
        *,
        account_id: str,
        ach_deposit_id: str,
        force_return_ach_deposit_request_create: Union[
            components.ForceReturnAchDepositRequestCreate,
            components.ForceReturnAchDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositsForceReturnAchDepositResponse:
        r"""ACH Deposit Return

        Forces a Nacha return on a completed ACH deposit. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_deposit_id: The achDeposit id.
        :param force_return_ach_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositsForceReturnAchDepositRequest(
            account_id=account_id,
            ach_deposit_id=ach_deposit_id,
            force_return_ach_deposit_request_create=utils.get_pydantic_model(
                force_return_ach_deposit_request_create,
                components.ForceReturnAchDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDeposits/{achDeposit_id}:forceReturn",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_return_ach_deposit_request_create,
                False,
                False,
                "json",
                components.ForceReturnAchDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDeposits_ForceReturnAchDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositsForceReturnAchDepositResponse(
                ach_deposit=unmarshal_json_response(
                    Optional[components.AchDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositsForceReturnAchDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_ach_withdrawal(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_approve_ach_withdrawal_request_create: Union[
            components.ForceApproveAchWithdrawalRequestCreate,
            components.ForceApproveAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceApproveAchWithdrawalResponse:
        r"""ACH Withdrawal Approval

        Forces approval of an existing ACH withdrawal that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_approve_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceApproveAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_approve_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_ach_withdrawal_request_create,
                components.ForceApproveAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceApproveAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceApproveAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceApproveAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_ach_withdrawal_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_approve_ach_withdrawal_request_create: Union[
            components.ForceApproveAchWithdrawalRequestCreate,
            components.ForceApproveAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceApproveAchWithdrawalResponse:
        r"""ACH Withdrawal Approval

        Forces approval of an existing ACH withdrawal that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_approve_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceApproveAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_approve_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_ach_withdrawal_request_create,
                components.ForceApproveAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceApproveAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceApproveAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceApproveAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_noc_ach_withdrawal(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_noc_ach_withdrawal_request_create: Union[
            components.ForceNocAchWithdrawalRequestCreate,
            components.ForceNocAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceNocAchWithdrawalResponse:
        r"""ACH Withdrawal NOC

        Forces a Nacha notice of change (NOC) on a completed ACH withdrawal. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_noc_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceNocAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_noc_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_noc_ach_withdrawal_request_create,
                components.ForceNocAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceNoc",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_noc_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceNocAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceNocAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceNocAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceNocAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_noc_ach_withdrawal_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_noc_ach_withdrawal_request_create: Union[
            components.ForceNocAchWithdrawalRequestCreate,
            components.ForceNocAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceNocAchWithdrawalResponse:
        r"""ACH Withdrawal NOC

        Forces a Nacha notice of change (NOC) on a completed ACH withdrawal. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_noc_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceNocAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_noc_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_noc_ach_withdrawal_request_create,
                components.ForceNocAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceNoc",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_noc_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceNocAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceNocAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceNocAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceNocAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_ach_withdrawal(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_reject_ach_withdrawal_request_create: Union[
            components.ForceRejectAchWithdrawalRequestCreate,
            components.ForceRejectAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceRejectAchWithdrawalResponse:
        r"""ACH Withdrawal Rejection

        Forces rejection of an existing ACH withdrawal that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_reject_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceRejectAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_reject_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_ach_withdrawal_request_create,
                components.ForceRejectAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceRejectAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceRejectAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceRejectAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_ach_withdrawal_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_reject_ach_withdrawal_request_create: Union[
            components.ForceRejectAchWithdrawalRequestCreate,
            components.ForceRejectAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceRejectAchWithdrawalResponse:
        r"""ACH Withdrawal Rejection

        Forces rejection of an existing ACH withdrawal that is pending review. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_reject_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceRejectAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_reject_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_ach_withdrawal_request_create,
                components.ForceRejectAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceRejectAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceRejectAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceRejectAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_return_ach_withdrawal(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_return_ach_withdrawal_request_create: Union[
            components.ForceReturnAchWithdrawalRequestCreate,
            components.ForceReturnAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceReturnAchWithdrawalResponse:
        r"""ACH Withdrawal Return

        Forces a Nacha return on a completed ACH withdrawal. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_return_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceReturnAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_return_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_return_ach_withdrawal_request_create,
                components.ForceReturnAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceReturn",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_return_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceReturnAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceReturnAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceReturnAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceReturnAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_return_ach_withdrawal_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_id: str,
        force_return_ach_withdrawal_request_create: Union[
            components.ForceReturnAchWithdrawalRequestCreate,
            components.ForceReturnAchWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalsForceReturnAchWithdrawalResponse:
        r"""ACH Withdrawal Return

        Forces a Nacha return on a completed ACH withdrawal. FOR TESTING ONLY!

        :param account_id: The account id.
        :param ach_withdrawal_id: The achWithdrawal id.
        :param force_return_ach_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalsForceReturnAchWithdrawalRequest(
            account_id=account_id,
            ach_withdrawal_id=ach_withdrawal_id,
            force_return_ach_withdrawal_request_create=utils.get_pydantic_model(
                force_return_ach_withdrawal_request_create,
                components.ForceReturnAchWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawals/{achWithdrawal_id}:forceReturn",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_return_ach_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceReturnAchWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawals_ForceReturnAchWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalsForceReturnAchWithdrawalResponse(
                ach_withdrawal=unmarshal_json_response(
                    Optional[components.AchWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalsForceReturnAchWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def get_micro_deposit_amounts(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsGetMicroDepositAmountsResponse:
        r"""Get Relationship Micro Deposit Verification

        Gets micro deposit amounts for bank relationships with the `MICRO_DEPOSIT` verification method. FOR TESTING ONLY!

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsGetMicroDepositAmountsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:getMicroDepositAmounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_GetMicroDepositAmounts",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsGetMicroDepositAmountsResponse(
                micro_deposit_amounts=unmarshal_json_response(
                    Optional[components.MicroDepositAmounts], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsGetMicroDepositAmountsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_micro_deposit_amounts_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsGetMicroDepositAmountsResponse:
        r"""Get Relationship Micro Deposit Verification

        Gets micro deposit amounts for bank relationships with the `MICRO_DEPOSIT` verification method. FOR TESTING ONLY!

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsGetMicroDepositAmountsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:getMicroDepositAmounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_GetMicroDepositAmounts",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsGetMicroDepositAmountsResponse(
                micro_deposit_amounts=unmarshal_json_response(
                    Optional[components.MicroDepositAmounts], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsGetMicroDepositAmountsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_ict_deposit(
        self,
        *,
        account_id: str,
        ict_deposit_id: str,
        force_approve_ict_deposit_request_create: Union[
            components.ForceApproveIctDepositRequestCreate,
            components.ForceApproveIctDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctDepositsForceApproveIctDepositResponse:
        r"""Force Approve ICT Deposit

        Forces an approval on an existing ICT deposit pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_deposit_id: The ictDeposit id.
        :param force_approve_ict_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctDepositsForceApproveIctDepositRequest(
            account_id=account_id,
            ict_deposit_id=ict_deposit_id,
            force_approve_ict_deposit_request_create=utils.get_pydantic_model(
                force_approve_ict_deposit_request_create,
                components.ForceApproveIctDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictDeposits/{ictDeposit_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ict_deposit_request_create,
                False,
                False,
                "json",
                components.ForceApproveIctDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctDeposits_ForceApproveIctDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctDepositsForceApproveIctDepositResponse(
                ict_deposit=unmarshal_json_response(
                    Optional[components.IctDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctDepositsForceApproveIctDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_ict_deposit_async(
        self,
        *,
        account_id: str,
        ict_deposit_id: str,
        force_approve_ict_deposit_request_create: Union[
            components.ForceApproveIctDepositRequestCreate,
            components.ForceApproveIctDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctDepositsForceApproveIctDepositResponse:
        r"""Force Approve ICT Deposit

        Forces an approval on an existing ICT deposit pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_deposit_id: The ictDeposit id.
        :param force_approve_ict_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctDepositsForceApproveIctDepositRequest(
            account_id=account_id,
            ict_deposit_id=ict_deposit_id,
            force_approve_ict_deposit_request_create=utils.get_pydantic_model(
                force_approve_ict_deposit_request_create,
                components.ForceApproveIctDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictDeposits/{ictDeposit_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ict_deposit_request_create,
                False,
                False,
                "json",
                components.ForceApproveIctDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctDeposits_ForceApproveIctDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctDepositsForceApproveIctDepositResponse(
                ict_deposit=unmarshal_json_response(
                    Optional[components.IctDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctDepositsForceApproveIctDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_ict_deposit(
        self,
        *,
        account_id: str,
        ict_deposit_id: str,
        force_reject_ict_deposit_request_create: Union[
            components.ForceRejectIctDepositRequestCreate,
            components.ForceRejectIctDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctDepositsForceRejectIctDepositResponse:
        r"""Force Reject ICT Deposit

        Forces a rejection on an existing ICT deposit pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_deposit_id: The ictDeposit id.
        :param force_reject_ict_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctDepositsForceRejectIctDepositRequest(
            account_id=account_id,
            ict_deposit_id=ict_deposit_id,
            force_reject_ict_deposit_request_create=utils.get_pydantic_model(
                force_reject_ict_deposit_request_create,
                components.ForceRejectIctDepositRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictDeposits/{ictDeposit_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ict_deposit_request_create,
                False,
                False,
                "json",
                components.ForceRejectIctDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctDeposits_ForceRejectIctDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctDepositsForceRejectIctDepositResponse(
                ict_deposit=unmarshal_json_response(
                    Optional[components.IctDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctDepositsForceRejectIctDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_ict_deposit_async(
        self,
        *,
        account_id: str,
        ict_deposit_id: str,
        force_reject_ict_deposit_request_create: Union[
            components.ForceRejectIctDepositRequestCreate,
            components.ForceRejectIctDepositRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctDepositsForceRejectIctDepositResponse:
        r"""Force Reject ICT Deposit

        Forces a rejection on an existing ICT deposit pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_deposit_id: The ictDeposit id.
        :param force_reject_ict_deposit_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctDepositsForceRejectIctDepositRequest(
            account_id=account_id,
            ict_deposit_id=ict_deposit_id,
            force_reject_ict_deposit_request_create=utils.get_pydantic_model(
                force_reject_ict_deposit_request_create,
                components.ForceRejectIctDepositRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictDeposits/{ictDeposit_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ict_deposit_request_create,
                False,
                False,
                "json",
                components.ForceRejectIctDepositRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctDeposits_ForceRejectIctDeposit",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctDepositsForceRejectIctDepositResponse(
                ict_deposit=unmarshal_json_response(
                    Optional[components.IctDeposit], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctDepositsForceRejectIctDepositResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_ict_withdrawal(
        self,
        *,
        account_id: str,
        ict_withdrawal_id: str,
        force_approve_ict_withdrawal_request_create: Union[
            components.ForceApproveIctWithdrawalRequestCreate,
            components.ForceApproveIctWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctWithdrawalsForceApproveIctWithdrawalResponse:
        r"""Force Approve ICT Withdrawal

        Forces an approval on an existing ICT withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_withdrawal_id: The ictWithdrawal id.
        :param force_approve_ict_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctWithdrawalsForceApproveIctWithdrawalRequest(
            account_id=account_id,
            ict_withdrawal_id=ict_withdrawal_id,
            force_approve_ict_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_ict_withdrawal_request_create,
                components.ForceApproveIctWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictWithdrawals/{ictWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ict_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveIctWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctWithdrawals_ForceApproveIctWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctWithdrawalsForceApproveIctWithdrawalResponse(
                ict_withdrawal=unmarshal_json_response(
                    Optional[components.IctWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctWithdrawalsForceApproveIctWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_ict_withdrawal_async(
        self,
        *,
        account_id: str,
        ict_withdrawal_id: str,
        force_approve_ict_withdrawal_request_create: Union[
            components.ForceApproveIctWithdrawalRequestCreate,
            components.ForceApproveIctWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctWithdrawalsForceApproveIctWithdrawalResponse:
        r"""Force Approve ICT Withdrawal

        Forces an approval on an existing ICT withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_withdrawal_id: The ictWithdrawal id.
        :param force_approve_ict_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctWithdrawalsForceApproveIctWithdrawalRequest(
            account_id=account_id,
            ict_withdrawal_id=ict_withdrawal_id,
            force_approve_ict_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_ict_withdrawal_request_create,
                components.ForceApproveIctWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictWithdrawals/{ictWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_ict_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveIctWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctWithdrawals_ForceApproveIctWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctWithdrawalsForceApproveIctWithdrawalResponse(
                ict_withdrawal=unmarshal_json_response(
                    Optional[components.IctWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctWithdrawalsForceApproveIctWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_ict_withdrawal(
        self,
        *,
        account_id: str,
        ict_withdrawal_id: str,
        force_reject_ict_withdrawal_request_create: Union[
            components.ForceRejectIctWithdrawalRequestCreate,
            components.ForceRejectIctWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctWithdrawalsForceRejectIctWithdrawalResponse:
        r"""Force Reject ICT Withdrawal

        Forces a rejection on an existing ICT withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_withdrawal_id: The ictWithdrawal id.
        :param force_reject_ict_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctWithdrawalsForceRejectIctWithdrawalRequest(
            account_id=account_id,
            ict_withdrawal_id=ict_withdrawal_id,
            force_reject_ict_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_ict_withdrawal_request_create,
                components.ForceRejectIctWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictWithdrawals/{ictWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ict_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectIctWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctWithdrawals_ForceRejectIctWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctWithdrawalsForceRejectIctWithdrawalResponse(
                ict_withdrawal=unmarshal_json_response(
                    Optional[components.IctWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctWithdrawalsForceRejectIctWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_ict_withdrawal_async(
        self,
        *,
        account_id: str,
        ict_withdrawal_id: str,
        force_reject_ict_withdrawal_request_create: Union[
            components.ForceRejectIctWithdrawalRequestCreate,
            components.ForceRejectIctWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.IctWithdrawalsForceRejectIctWithdrawalResponse:
        r"""Force Reject ICT Withdrawal

        Forces a rejection on an existing ICT withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param ict_withdrawal_id: The ictWithdrawal id.
        :param force_reject_ict_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.IctWithdrawalsForceRejectIctWithdrawalRequest(
            account_id=account_id,
            ict_withdrawal_id=ict_withdrawal_id,
            force_reject_ict_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_ict_withdrawal_request_create,
                components.ForceRejectIctWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/ictWithdrawals/{ictWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_ict_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectIctWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="IctWithdrawals_ForceRejectIctWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.IctWithdrawalsForceRejectIctWithdrawalResponse(
                ict_withdrawal=unmarshal_json_response(
                    Optional[components.IctWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.IctWithdrawalsForceRejectIctWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_wire_withdrawal(
        self,
        *,
        account_id: str,
        wire_withdrawal_id: str,
        force_approve_wire_withdrawal_request_create: Union[
            components.ForceApproveWireWithdrawalRequestCreate,
            components.ForceApproveWireWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalsForceApproveWireWithdrawalResponse:
        r"""Force Approve Wire Withdrawal

        Forces an approval on an existing wire withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param wire_withdrawal_id: The wireWithdrawal id.
        :param force_approve_wire_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalsForceApproveWireWithdrawalRequest(
            account_id=account_id,
            wire_withdrawal_id=wire_withdrawal_id,
            force_approve_wire_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_wire_withdrawal_request_create,
                components.ForceApproveWireWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawals/{wireWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_wire_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveWireWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawals_ForceApproveWireWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalsForceApproveWireWithdrawalResponse(
                wire_withdrawal=unmarshal_json_response(
                    Optional[components.WireWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalsForceApproveWireWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_wire_withdrawal_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_id: str,
        force_approve_wire_withdrawal_request_create: Union[
            components.ForceApproveWireWithdrawalRequestCreate,
            components.ForceApproveWireWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalsForceApproveWireWithdrawalResponse:
        r"""Force Approve Wire Withdrawal

        Forces an approval on an existing wire withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param wire_withdrawal_id: The wireWithdrawal id.
        :param force_approve_wire_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalsForceApproveWireWithdrawalRequest(
            account_id=account_id,
            wire_withdrawal_id=wire_withdrawal_id,
            force_approve_wire_withdrawal_request_create=utils.get_pydantic_model(
                force_approve_wire_withdrawal_request_create,
                components.ForceApproveWireWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawals/{wireWithdrawal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_wire_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceApproveWireWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawals_ForceApproveWireWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalsForceApproveWireWithdrawalResponse(
                wire_withdrawal=unmarshal_json_response(
                    Optional[components.WireWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalsForceApproveWireWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_wire_withdrawal(
        self,
        *,
        account_id: str,
        wire_withdrawal_id: str,
        force_reject_wire_withdrawal_request_create: Union[
            components.ForceRejectWireWithdrawalRequestCreate,
            components.ForceRejectWireWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalsForceRejectWireWithdrawalResponse:
        r"""Force Reject Wire Withdrawal

        Forces a rejection on an existing wire withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param wire_withdrawal_id: The wireWithdrawal id.
        :param force_reject_wire_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalsForceRejectWireWithdrawalRequest(
            account_id=account_id,
            wire_withdrawal_id=wire_withdrawal_id,
            force_reject_wire_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_wire_withdrawal_request_create,
                components.ForceRejectWireWithdrawalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawals/{wireWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_wire_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectWireWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawals_ForceRejectWireWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalsForceRejectWireWithdrawalResponse(
                wire_withdrawal=unmarshal_json_response(
                    Optional[components.WireWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalsForceRejectWireWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_wire_withdrawal_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_id: str,
        force_reject_wire_withdrawal_request_create: Union[
            components.ForceRejectWireWithdrawalRequestCreate,
            components.ForceRejectWireWithdrawalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalsForceRejectWireWithdrawalResponse:
        r"""Force Reject Wire Withdrawal

        Forces a rejection on an existing wire withdrawal pending review - FOR TESTING

        :param account_id: The account id.
        :param wire_withdrawal_id: The wireWithdrawal id.
        :param force_reject_wire_withdrawal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalsForceRejectWireWithdrawalRequest(
            account_id=account_id,
            wire_withdrawal_id=wire_withdrawal_id,
            force_reject_wire_withdrawal_request_create=utils.get_pydantic_model(
                force_reject_wire_withdrawal_request_create,
                components.ForceRejectWireWithdrawalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawals/{wireWithdrawal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_wire_withdrawal_request_create,
                False,
                False,
                "json",
                components.ForceRejectWireWithdrawalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawals_ForceRejectWireWithdrawal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalsForceRejectWireWithdrawalResponse(
                wire_withdrawal=unmarshal_json_response(
                    Optional[components.WireWithdrawal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalsForceRejectWireWithdrawalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_approve_cash_journal(
        self,
        *,
        cash_journal_id: str,
        force_approve_cash_journal_request_create: Union[
            components.ForceApproveCashJournalRequestCreate,
            components.ForceApproveCashJournalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CashJournalsForceApproveCashJournalResponse:
        r"""Force Approve Cash Journal

        Forces approval of an existing cash journal that is pending review FOR TESTING ONLY!

        :param cash_journal_id: The cashJournal id.
        :param force_approve_cash_journal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CashJournalsForceApproveCashJournalRequest(
            cash_journal_id=cash_journal_id,
            force_approve_cash_journal_request_create=utils.get_pydantic_model(
                force_approve_cash_journal_request_create,
                components.ForceApproveCashJournalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/cashJournals/{cashJournal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_cash_journal_request_create,
                False,
                False,
                "json",
                components.ForceApproveCashJournalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CashJournals_ForceApproveCashJournal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CashJournalsForceApproveCashJournalResponse(
                cash_journal=unmarshal_json_response(
                    Optional[components.CashJournal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CashJournalsForceApproveCashJournalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_approve_cash_journal_async(
        self,
        *,
        cash_journal_id: str,
        force_approve_cash_journal_request_create: Union[
            components.ForceApproveCashJournalRequestCreate,
            components.ForceApproveCashJournalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CashJournalsForceApproveCashJournalResponse:
        r"""Force Approve Cash Journal

        Forces approval of an existing cash journal that is pending review FOR TESTING ONLY!

        :param cash_journal_id: The cashJournal id.
        :param force_approve_cash_journal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CashJournalsForceApproveCashJournalRequest(
            cash_journal_id=cash_journal_id,
            force_approve_cash_journal_request_create=utils.get_pydantic_model(
                force_approve_cash_journal_request_create,
                components.ForceApproveCashJournalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/cashJournals/{cashJournal_id}:forceApprove",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_approve_cash_journal_request_create,
                False,
                False,
                "json",
                components.ForceApproveCashJournalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CashJournals_ForceApproveCashJournal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CashJournalsForceApproveCashJournalResponse(
                cash_journal=unmarshal_json_response(
                    Optional[components.CashJournal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CashJournalsForceApproveCashJournalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def force_reject_cash_journal(
        self,
        *,
        cash_journal_id: str,
        force_reject_cash_journal_request_create: Union[
            components.ForceRejectCashJournalRequestCreate,
            components.ForceRejectCashJournalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CashJournalsForceRejectCashJournalResponse:
        r"""Force Reject Cash Journal

        Forces rejection of an existing cash journal that is pending review FOR TESTING ONLY!

        :param cash_journal_id: The cashJournal id.
        :param force_reject_cash_journal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CashJournalsForceRejectCashJournalRequest(
            cash_journal_id=cash_journal_id,
            force_reject_cash_journal_request_create=utils.get_pydantic_model(
                force_reject_cash_journal_request_create,
                components.ForceRejectCashJournalRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/cashJournals/{cashJournal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_cash_journal_request_create,
                False,
                False,
                "json",
                components.ForceRejectCashJournalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CashJournals_ForceRejectCashJournal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CashJournalsForceRejectCashJournalResponse(
                cash_journal=unmarshal_json_response(
                    Optional[components.CashJournal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CashJournalsForceRejectCashJournalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def force_reject_cash_journal_async(
        self,
        *,
        cash_journal_id: str,
        force_reject_cash_journal_request_create: Union[
            components.ForceRejectCashJournalRequestCreate,
            components.ForceRejectCashJournalRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.CashJournalsForceRejectCashJournalResponse:
        r"""Force Reject Cash Journal

        Forces rejection of an existing cash journal that is pending review FOR TESTING ONLY!

        :param cash_journal_id: The cashJournal id.
        :param force_reject_cash_journal_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.CashJournalsForceRejectCashJournalRequest(
            cash_journal_id=cash_journal_id,
            force_reject_cash_journal_request_create=utils.get_pydantic_model(
                force_reject_cash_journal_request_create,
                components.ForceRejectCashJournalRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/cashJournals/{cashJournal_id}:forceReject",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.force_reject_cash_journal_request_create,
                False,
                False,
                "json",
                components.ForceRejectCashJournalRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CashJournals_ForceRejectCashJournal",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.CashJournalsForceRejectCashJournalResponse(
                cash_journal=unmarshal_json_response(
                    Optional[components.CashJournal], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.CashJournalsForceRejectCashJournalResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)
