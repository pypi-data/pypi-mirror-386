"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .bookingfee import BookingFee, BookingFeeTypedDict
from .bookinglot import BookingLot, BookingLotTypedDict
from .execution import Execution, ExecutionTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class BookingTradeAssetType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the asset being traded."""

    ASSET_TYPE_UNSPECIFIED = "ASSET_TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    FIXED_INCOME = "FIXED_INCOME"


class BookingTradeBrokerCapacity(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Broker capacity for the trade."""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class BookingTradeIdentifierType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Identifier type for the asset being traded."""

    IDENTIFIER_TYPE_UNSPECIFIED = "IDENTIFIER_TYPE_UNSPECIFIED"
    ASSET_ID = "ASSET_ID"
    SYMBOL = "SYMBOL"
    CUSIP = "CUSIP"
    ISIN = "ISIN"


class LocalMarketTradeDateTypedDict(TypedDict):
    r"""Date field to support extended trading hours."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class LocalMarketTradeDate(BaseModel):
    r"""Date field to support extended trading hours."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class BookingTradeRouteType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Route type for the trade."""

    ROUTE_TYPE_UNSPECIFIED = "ROUTE_TYPE_UNSPECIFIED"
    DMA = "DMA"
    MNGD = "MNGD"
    QUIK = "QUIK"
    ALGO = "ALGO"
    AWAY = "AWAY"
    CORR = "CORR"
    BOATS = "BOATS"


class SettlementDateTypedDict(TypedDict):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class SettlementDate(BaseModel):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class BookingTradeSide(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes if the trade is a SELL or a BUY."""

    SIDE_UNSPECIFIED = "SIDE_UNSPECIFIED"
    BUY = "BUY"
    SELL = "SELL"


class BookingTradeSideModifier(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Side modifier for the trade."""

    SIDE_MODIFIER_UNSPECIFIED = "SIDE_MODIFIER_UNSPECIFIED"
    SHORT = "SHORT"
    SHORT_EXEMPT = "SHORT_EXEMPT"
    SHORT_COVER = "SHORT_COVER"
    OPEN = "OPEN"
    CLOSE = "CLOSE"


class BookingTradeSpecialInstructions(str, Enum, metaclass=utils.OpenEnumMeta):
    SPECIAL_INSTRUCTIONS_UNSPECIFIED = "SPECIAL_INSTRUCTIONS_UNSPECIFIED"
    RULE_144 = "RULE_144"
    WITH_DIVIDEND = "WITH_DIVIDEND"
    WITH_RIGHTS = "WITH_RIGHTS"
    CLOSE_CONTRACT = "CLOSE_CONTRACT"
    COVER_SHORT = "COVER_SHORT"
    CROSS_TRADE = "CROSS_TRADE"
    OPEN_CONTRACT_COVERED = "OPEN_CONTRACT_COVERED"
    DISCRETION_EXERCISED = "DISCRETION_EXERCISED"
    DISCRETION_NOT_EXERCISED = "DISCRETION_NOT_EXERCISED"
    OPTION_ASSIGNMENT = "OPTION_ASSIGNMENT"
    EMPLOYEE_STOCK_OPTION = "EMPLOYEE_STOCK_OPTION"
    INVESTMENT_BANKING = "INVESTMENT_BANKING"
    BROKER_DEALER_ORDER = "BROKER_DEALER_ORDER"
    MAKE_MARKET_IN_SECURITY = "MAKE_MARKET_IN_SECURITY"
    MAKE_MARKET_SOLICITED = "MAKE_MARKET_SOLICITED"
    MAKE_MARKET_UNSOLICITED = "MAKE_MARKET_UNSOLICITED"
    CUSTOMER_DIRECTED = "CUSTOMER_DIRECTED"
    FULLY_REGISTERED = "FULLY_REGISTERED"
    OPEN_CONTRACT = "OPEN_CONTRACT"
    ODDLOT_DIFF_ON_REQUEST = "ODDLOT_DIFF_ON_REQUEST"
    PROSPECTUS_ENCLOSED = "PROSPECTUS_ENCLOSED"
    PROSPECTUS_SEPARATE_MAIL = "PROSPECTUS_SEPARATE_MAIL"
    SOLICITED = "SOLICITED"
    UNSOLICITED = "UNSOLICITED"
    X_DIVIDEND = "X_DIVIDEND"
    ACTING_AS_PRINCIPAL = "ACTING_AS_PRINCIPAL"
    AVERAGE_PRICE = "AVERAGE_PRICE"
    BROKER_LIQUIDATION = "BROKER_LIQUIDATION"
    COUPON_BOOKS = "COUPON_BOOKS"
    HAS_POSTAGE_FEE = "HAS_POSTAGE_FEE"
    INTERNET_ORDER = "INTERNET_ORDER"
    MARGIN_SELLOUT = "MARGIN_SELLOUT"
    MARKET_MAKERS_AS_PRINCIPAL = "MARKET_MAKERS_AS_PRINCIPAL"
    NEGATIVE_NET_PROCEED = "NEGATIVE_NET_PROCEED"
    PRE_FIG_INDICATOR = "PRE_FIG_INDICATOR"
    RISKLESS_PRINCIPAL_INSTRUCTION = "RISKLESS_PRINCIPAL_INSTRUCTION"
    SHORT_INSTRUCTION = "SHORT_INSTRUCTION"
    THIRD_MARKET = "THIRD_MARKET"
    SUPPRESS_MSRB_TRANSMISSION = "SUPPRESS_MSRB_TRANSMISSION"
    SUPPRESS_TRACE_REPORTING = "SUPPRESS_TRACE_REPORTING"
    SUPPRESS_EMAIL_NOTIFICATION = "SUPPRESS_EMAIL_NOTIFICATION"
    STOCK_REWARD = "STOCK_REWARD"
    SUPPRESS_REG_FEES = "SUPPRESS_REG_FEES"
    SUPPRESS_SEC_FEE = "SUPPRESS_SEC_FEE"
    SUPPRESS_TAF_FEE = "SUPPRESS_TAF_FEE"
    DIVIDEND_REINVESTMENT = "DIVIDEND_REINVESTMENT"


class BookingTradeVenue(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Exchange venue"""

    EXCHANGE_VENUE_UNSPECIFIED = "EXCHANGE_VENUE_UNSPECIFIED"
    AMEX = "AMEX"
    ARCA = "ARCA"
    BATS = "BATS"
    BATS_BYX = "BATS_BYX"
    BOSTON = "BOSTON"
    BOX = "BOX"
    BZX = "BZX"
    C2 = "C2"
    CBOE = "CBOE"
    CHICAGO = "CHICAGO"
    CINCINNATI = "CINCINNATI"
    EDGA = "EDGA"
    EDGX = "EDGX"
    EXCLEARING = "EXCLEARING"
    IEX = "IEX"
    ISE = "ISE"
    ISE_GEMINI = "ISE_GEMINI"
    MIAX = "MIAX"
    NASDAQ = "NASDAQ"
    NASDAQ_OMX_BX = "NASDAQ_OMX_BX"
    NYSE = "NYSE"
    PHLX = "PHLX"
    OTC = "OTC"
    QSR = "QSR"


class BookingTradeWhenIssued(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes that this trade was either when_issued or when_distributed."""

    WHEN_ISSUED_TYPE_UNSPECIFIED = "WHEN_ISSUED_TYPE_UNSPECIFIED"
    WHEN_ISSUED = "WHEN_ISSUED"
    WHEN_DISTRIBUTED = "WHEN_DISTRIBUTED"


class BookingTradeTypedDict(TypedDict):
    r"""A Trade represents an entire order made by a client. Trades can hold one or many executions representing partial fills that aggregate into a whole order."""

    account_id: NotRequired[str]
    r"""A globally unique identifier referencing a single account."""
    activity_id: NotRequired[str]
    r"""The current activity_id of this trade in the Ledger."""
    additional_instructions: NotRequired[str]
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""
    alternate_order_id: NotRequired[str]
    r"""Fractional support for market-makers' internal order ids."""
    asset_type: NotRequired[BookingTradeAssetType]
    r"""Type of the asset being traded."""
    broker_capacity: NotRequired[BookingTradeBrokerCapacity]
    r"""Broker capacity for the trade."""
    client_order_id: NotRequired[str]
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""
    executing_broker: NotRequired[str]
    r"""Executing broker of the trade."""
    executions: NotRequired[List[ExecutionTypedDict]]
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""
    fees: NotRequired[List[BookingFeeTypedDict]]
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""
    identifier: NotRequired[str]
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""
    identifier_type: NotRequired[BookingTradeIdentifierType]
    r"""Identifier type for the asset being traded."""
    issuing_region_code: NotRequired[str]
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""
    local_market_trade_date: NotRequired[Nullable[LocalMarketTradeDateTypedDict]]
    r"""Date field to support extended trading hours."""
    lot_matching_instructions: NotRequired[List[BookingLotTypedDict]]
    r"""One or many lot matching instructions for the trade."""
    mic_code: NotRequired[str]
    r"""Market Identifier Code"""
    name: NotRequired[str]
    r"""The resource name of the trade."""
    open: NotRequired[bool]
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""
    order_id: NotRequired[str]
    r"""Street-level order id, unique by day per broker."""
    route_type: NotRequired[BookingTradeRouteType]
    r"""Route type for the trade."""
    settlement_date: NotRequired[Nullable[SettlementDateTypedDict]]
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""
    side: NotRequired[BookingTradeSide]
    r"""Denotes if the trade is a SELL or a BUY."""
    side_modifier: NotRequired[BookingTradeSideModifier]
    r"""Side modifier for the trade."""
    source_application: NotRequired[str]
    r"""The source of the submission."""
    special_instructions: NotRequired[List[BookingTradeSpecialInstructions]]
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""
    trade_id: NotRequired[str]
    r"""A ULID to uniquely identify the trade globally."""
    venue: NotRequired[BookingTradeVenue]
    r"""Exchange venue"""
    when_issued: NotRequired[BookingTradeWhenIssued]
    r"""Denotes that this trade was either when_issued or when_distributed."""


class BookingTrade(BaseModel):
    r"""A Trade represents an entire order made by a client. Trades can hold one or many executions representing partial fills that aggregate into a whole order."""

    account_id: Optional[str] = None
    r"""A globally unique identifier referencing a single account."""

    activity_id: Optional[str] = None
    r"""The current activity_id of this trade in the Ledger."""

    additional_instructions: Optional[str] = None
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""

    alternate_order_id: Optional[str] = None
    r"""Fractional support for market-makers' internal order ids."""

    asset_type: Annotated[
        Optional[BookingTradeAssetType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Type of the asset being traded."""

    broker_capacity: Annotated[
        Optional[BookingTradeBrokerCapacity], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Broker capacity for the trade."""

    client_order_id: Optional[str] = None
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""

    executing_broker: Optional[str] = None
    r"""Executing broker of the trade."""

    executions: Optional[List[Execution]] = None
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""

    fees: Optional[List[BookingFee]] = None
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""

    identifier: Optional[str] = None
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""

    identifier_type: Annotated[
        Optional[BookingTradeIdentifierType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Identifier type for the asset being traded."""

    issuing_region_code: Optional[str] = None
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""

    local_market_trade_date: OptionalNullable[LocalMarketTradeDate] = UNSET
    r"""Date field to support extended trading hours."""

    lot_matching_instructions: Optional[List[BookingLot]] = None
    r"""One or many lot matching instructions for the trade."""

    mic_code: Optional[str] = None
    r"""Market Identifier Code"""

    name: Optional[str] = None
    r"""The resource name of the trade."""

    open: Optional[bool] = None
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""

    order_id: Optional[str] = None
    r"""Street-level order id, unique by day per broker."""

    route_type: Annotated[
        Optional[BookingTradeRouteType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Route type for the trade."""

    settlement_date: OptionalNullable[SettlementDate] = UNSET
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    side: Annotated[
        Optional[BookingTradeSide], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes if the trade is a SELL or a BUY."""

    side_modifier: Annotated[
        Optional[BookingTradeSideModifier], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Side modifier for the trade."""

    source_application: Optional[str] = None
    r"""The source of the submission."""

    special_instructions: Optional[
        List[
            Annotated[
                BookingTradeSpecialInstructions,
                PlainValidator(validate_open_enum(False)),
            ]
        ]
    ] = None
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""

    trade_id: Optional[str] = None
    r"""A ULID to uniquely identify the trade globally."""

    venue: Annotated[
        Optional[BookingTradeVenue], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Exchange venue"""

    when_issued: Annotated[
        Optional[BookingTradeWhenIssued], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes that this trade was either when_issued or when_distributed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "account_id",
            "activity_id",
            "additional_instructions",
            "alternate_order_id",
            "asset_type",
            "broker_capacity",
            "client_order_id",
            "executing_broker",
            "executions",
            "fees",
            "identifier",
            "identifier_type",
            "issuing_region_code",
            "local_market_trade_date",
            "lot_matching_instructions",
            "mic_code",
            "name",
            "open",
            "order_id",
            "route_type",
            "settlement_date",
            "side",
            "side_modifier",
            "source_application",
            "special_instructions",
            "trade_id",
            "venue",
            "when_issued",
        ]
        nullable_fields = ["local_market_trade_date", "settlement_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
