"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .bondyield import BondYield, BondYieldTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from datetime import datetime
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ExecutionAccruedInterestAmountTypedDict(TypedDict):
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument. Requirement of 15 or less integral number and 2 or less fractional precision. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionAccruedInterestAmount(BaseModel):
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument. Requirement of 15 or less integral number and 2 or less fractional precision. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class CommissionAmountTypedDict(TypedDict):
    r"""Commission amount of the execution. Requirement of 11 or less integral number and 2 or less fractional precision."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class CommissionAmount(BaseModel):
    r"""Commission amount of the execution. Requirement of 11 or less integral number and 2 or less fractional precision."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class GrossAmountTypedDict(TypedDict):
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Requirement of 11 or less integral number and 2 or less fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class GrossAmount(BaseModel):
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Requirement of 11 or less integral number and 2 or less fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionPrevailingMarketPriceTypedDict(TypedDict):
    r"""The price for the instrument that is prevailing in the market. Requirement of 8 or less integral number and 8 or less fractional precision. Required for FIXED_INCOME trades when the broker_capacity is PRINCIPAL."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionPrevailingMarketPrice(BaseModel):
    r"""The price for the instrument that is prevailing in the market. Requirement of 8 or less integral number and 8 or less fractional precision. Required for FIXED_INCOME trades when the broker_capacity is PRINCIPAL."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionPriceTypedDict(TypedDict):
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionPrice(BaseModel):
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class PriceAdjustmentAmountTypedDict(TypedDict):
    r"""Total monetary value of the price_adjustment"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class PriceAdjustmentAmount(BaseModel):
    r"""Total monetary value of the price_adjustment"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionPriceAdjustmentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of price adjustment being applied by the broker to the net price of the security."""

    PRICE_ADJUSTMENT_TYPE_UNSPECIFIED = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED"
    MARKUP = "MARKUP"
    MARKDOWN = "MARKDOWN"
    GROSS_CREDIT = "GROSS_CREDIT"


class PriceAdjustmentTypedDict(TypedDict):
    r"""Price adjustment that will be applied to the net price of the security."""

    price_adjustment_amount: NotRequired[Nullable[PriceAdjustmentAmountTypedDict]]
    r"""Total monetary value of the price_adjustment"""
    price_adjustment_type: NotRequired[ExecutionPriceAdjustmentType]
    r"""The type of price adjustment being applied by the broker to the net price of the security."""


class PriceAdjustment(BaseModel):
    r"""Price adjustment that will be applied to the net price of the security."""

    price_adjustment_amount: OptionalNullable[PriceAdjustmentAmount] = UNSET
    r"""Total monetary value of the price_adjustment"""

    price_adjustment_type: Annotated[
        Optional[ExecutionPriceAdjustmentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""The type of price adjustment being applied by the broker to the net price of the security."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["price_adjustment_amount", "price_adjustment_type"]
        nullable_fields = ["price_adjustment_amount"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ExecutionQuantityTypedDict(TypedDict):
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionQuantity(BaseModel):
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ExecutionState(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The state that the trade is in."""

    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    CREATING = "CREATING"
    REBOOKING = "REBOOKING"
    CANCELING = "CANCELING"
    BOOKED = "BOOKED"
    REBOOKED = "REBOOKED"
    CANCELED = "CANCELED"
    FAILED = "FAILED"


class ExecutionTypedDict(TypedDict):
    r"""An execution represents a partial-fill or a fill that is part of an order. Executions are children to a Trade, which collectively represents an entire order made by a client."""

    accrued_interest_amount: NotRequired[
        Nullable[ExecutionAccruedInterestAmountTypedDict]
    ]
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument. Requirement of 15 or less integral number and 2 or less fractional precision. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""
    activity_id: NotRequired[str]
    r"""The id of the activity in the Ledger that represents this trade."""
    bond_yield: NotRequired[List[BondYieldTypedDict]]
    r"""The yield associated with an individual fill of a fixed income trade. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""
    commission_amount: NotRequired[Nullable[CommissionAmountTypedDict]]
    r"""Commission amount of the execution. Requirement of 11 or less integral number and 2 or less fractional precision."""
    execution_id: NotRequired[str]
    r"""A ULID that uniquely identifies the execution."""
    execution_time: NotRequired[Nullable[datetime]]
    r"""Timestamp of when the execution took place. If settlement_date is not provided, this field will be converted into Eastern Time and used to calculate settlement_date."""
    external_id: NotRequired[str]
    r"""Used to generate execution_id, should be unique on the day for each source_application caller."""
    gross_amount: NotRequired[Nullable[GrossAmountTypedDict]]
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Requirement of 11 or less integral number and 2 or less fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""
    memo: NotRequired[str]
    r"""Caller provided but can be used for booking-service to note original trade details when booking into the error account or using the error asset."""
    name: NotRequired[str]
    r"""The resource name of the execution."""
    prevailing_market_price: NotRequired[
        Nullable[ExecutionPrevailingMarketPriceTypedDict]
    ]
    r"""The price for the instrument that is prevailing in the market. Requirement of 8 or less integral number and 8 or less fractional precision. Required for FIXED_INCOME trades when the broker_capacity is PRINCIPAL."""
    price: NotRequired[Nullable[ExecutionPriceTypedDict]]
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""
    price_adjustment: NotRequired[Nullable[PriceAdjustmentTypedDict]]
    r"""Price adjustment that will be applied to the net price of the security."""
    quantity: NotRequired[Nullable[ExecutionQuantityTypedDict]]
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""
    state: NotRequired[ExecutionState]
    r"""The state that the trade is in."""
    street_execution_id: NotRequired[str]
    r"""Street-level execution id, unique by day per execution venue."""
    trade_id: NotRequired[str]
    r"""The unique identifier of the trade this execution belongs to."""


class Execution(BaseModel):
    r"""An execution represents a partial-fill or a fill that is part of an order. Executions are children to a Trade, which collectively represents an entire order made by a client."""

    accrued_interest_amount: OptionalNullable[ExecutionAccruedInterestAmount] = UNSET
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument. Requirement of 15 or less integral number and 2 or less fractional precision. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""

    activity_id: Optional[str] = None
    r"""The id of the activity in the Ledger that represents this trade."""

    bond_yield: Optional[List[BondYield]] = None
    r"""The yield associated with an individual fill of a fixed income trade. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""

    commission_amount: OptionalNullable[CommissionAmount] = UNSET
    r"""Commission amount of the execution. Requirement of 11 or less integral number and 2 or less fractional precision."""

    execution_id: Optional[str] = None
    r"""A ULID that uniquely identifies the execution."""

    execution_time: OptionalNullable[datetime] = UNSET
    r"""Timestamp of when the execution took place. If settlement_date is not provided, this field will be converted into Eastern Time and used to calculate settlement_date."""

    external_id: Optional[str] = None
    r"""Used to generate execution_id, should be unique on the day for each source_application caller."""

    gross_amount: OptionalNullable[GrossAmount] = UNSET
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Requirement of 11 or less integral number and 2 or less fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    memo: Optional[str] = None
    r"""Caller provided but can be used for booking-service to note original trade details when booking into the error account or using the error asset."""

    name: Optional[str] = None
    r"""The resource name of the execution."""

    prevailing_market_price: OptionalNullable[ExecutionPrevailingMarketPrice] = UNSET
    r"""The price for the instrument that is prevailing in the market. Requirement of 8 or less integral number and 8 or less fractional precision. Required for FIXED_INCOME trades when the broker_capacity is PRINCIPAL."""

    price: OptionalNullable[ExecutionPrice] = UNSET
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    price_adjustment: OptionalNullable[PriceAdjustment] = UNSET
    r"""Price adjustment that will be applied to the net price of the security."""

    quantity: OptionalNullable[ExecutionQuantity] = UNSET
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    state: Annotated[
        Optional[ExecutionState], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The state that the trade is in."""

    street_execution_id: Optional[str] = None
    r"""Street-level execution id, unique by day per execution venue."""

    trade_id: Optional[str] = None
    r"""The unique identifier of the trade this execution belongs to."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "accrued_interest_amount",
            "activity_id",
            "bond_yield",
            "commission_amount",
            "execution_id",
            "execution_time",
            "external_id",
            "gross_amount",
            "memo",
            "name",
            "prevailing_market_price",
            "price",
            "price_adjustment",
            "quantity",
            "state",
            "street_execution_id",
            "trade_id",
        ]
        nullable_fields = [
            "accrued_interest_amount",
            "commission_amount",
            "execution_time",
            "gross_amount",
            "prevailing_market_price",
            "price",
            "price_adjustment",
            "quantity",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
