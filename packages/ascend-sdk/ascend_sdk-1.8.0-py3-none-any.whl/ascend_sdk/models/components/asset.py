"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .optiondeliverable import OptionDeliverable, OptionDeliverableTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict, deprecated


class CurrencyType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Indicates the type of currency"""

    CURRENCY_TYPE_UNSPECIFIED = "CURRENCY_TYPE_UNSPECIFIED"
    CURRENCY = "CURRENCY"
    CURRENCY_EQUIVALENT = "CURRENCY_EQUIVALENT"


class CurrencyTypedDict(TypedDict):
    r"""Currency specific asset details"""

    currency_type: NotRequired[CurrencyType]
    r"""Indicates the type of currency"""
    payment_currency: NotRequired[str]
    r"""Indicates the name of asset for the underlying payment_currency when the `currency_type` is `CURRENCY_EQUIVALENT`"""


class Currency(BaseModel):
    r"""Currency specific asset details"""

    currency_type: Annotated[
        Optional[CurrencyType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Indicates the type of currency"""

    payment_currency: Optional[str] = None
    r"""Indicates the name of asset for the underlying payment_currency when the `currency_type` is `CURRENCY_EQUIVALENT`"""


class AssetEquityType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""the code indicating the type of associated security."""

    EQUITY_TYPE_UNSPECIFIED = "EQUITY_TYPE_UNSPECIFIED"
    COMMON_STOCK = "COMMON_STOCK"
    PREFERRED_STOCK = "PREFERRED_STOCK"
    PREFERRED_ADR = "PREFERRED_ADR"
    SPECIAL_STOCK = "SPECIAL_STOCK"
    INDEX = "INDEX"
    WARRANT = "WARRANT"
    ADR = "ADR"
    RIGHTS = "RIGHTS"
    SHARES_OF_BENEFICIAL_INTEREST = "SHARES_OF_BENEFICIAL_INTEREST"
    CERTIFICATES = "CERTIFICATES"
    UNITS = "UNITS"
    DEBT_ISSUE = "DEBT_ISSUE"
    EQUITY_TYPE_OPTION = "EQUITY_TYPE_OPTION"
    ETF = "ETF"


class EquityTypedDict(TypedDict):
    r"""Equity specific asset details"""

    fractionable: NotRequired[bool]
    r"""Indicates whether the symbol is eligible for fractional or notional execution for orders at Apex"""
    liquidate: NotRequired[bool]
    r"""Indicates whether the symbol is designated as “Liquidate Only,” and, if so, the system rejects purchases"""
    type: NotRequired[AssetEquityType]
    r"""the code indicating the type of associated security."""


class Equity(BaseModel):
    r"""Equity specific asset details"""

    fractionable: Optional[bool] = None
    r"""Indicates whether the symbol is eligible for fractional or notional execution for orders at Apex"""

    liquidate: Optional[bool] = None
    r"""Indicates whether the symbol is designated as “Liquidate Only,” and, if so, the system rejects purchases"""

    type: Annotated[
        Optional[AssetEquityType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""the code indicating the type of associated security."""


class CallType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of call"""

    CALL_TYPE_UNSPECIFIED = "CALL_TYPE_UNSPECIFIED"
    ORDINARY = "ORDINARY"
    SPECIAL = "SPECIAL"
    MAKE_WHOLE = "MAKE_WHOLE"
    REGULATORY = "REGULATORY"


class CouponFrequency(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Frequency of payments"""

    COUPON_FREQUENCY_UNSPECIFIED = "COUPON_FREQUENCY_UNSPECIFIED"
    SEMI_ANNUAL = "SEMI_ANNUAL"
    MONTHLY = "MONTHLY"
    AT_MATURITY = "AT_MATURITY"
    ZERO = "ZERO"
    QUARTERLY = "QUARTERLY"
    ANNUAL = "ANNUAL"


class CouponRateTypedDict(TypedDict):
    r"""A measure of income an investor can expect to receive expressed as a percent"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class CouponRate(BaseModel):
    r"""A measure of income an investor can expect to receive expressed as a percent"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class CouponType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of coupon rate"""

    COUPON_TYPE_UNSPECIFIED = "COUPON_TYPE_UNSPECIFIED"
    COUPON_TYPE_FIXED = "COUPON_TYPE_FIXED"
    COUPON_TYPE_ZERO = "COUPON_TYPE_ZERO"


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class DurationTypedDict(TypedDict):
    r"""Weighted average time until a bond’s cash flows are received in years"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class Duration(BaseModel):
    r"""Weighted average time until a bond’s cash flows are received in years"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class FirstCouponDateTypedDict(TypedDict):
    r"""date of first coupon"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class FirstCouponDate(BaseModel):
    r"""date of first coupon"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class FixedIncomeStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The status of the fixed income"""

    FIXED_INCOME_STATUS_UNSPECIFIED = "FIXED_INCOME_STATUS_UNSPECIFIED"
    OUTSTANDING = "OUTSTANDING"
    MATURED = "MATURED"
    CALLED = "CALLED"
    UNKNOWN = "UNKNOWN"
    DEFAULTED = "DEFAULTED"
    CONVERTED = "CONVERTED"
    TENDERED = "TENDERED"
    PRE_ISSUANCE = "PRE_ISSUANCE"
    LIQUIDATED = "LIQUIDATED"
    REPURCHASED = "REPURCHASED"
    REPAID = "REPAID"
    RESTRUCTURED = "RESTRUCTURED"
    PUT = "PUT"
    FUNGED = "FUNGED"


class FixedIncomeSubtype(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of treasury"""

    FIXED_INCOME_SUBTYPE_UNSPECIFIED = "FIXED_INCOME_SUBTYPE_UNSPECIFIED"
    BOND = "BOND"
    STRIPS = "STRIPS"
    BILL = "BILL"
    NOTE = "NOTE"
    TIPS = "TIPS"


class FixedIncomeType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of fixed income security"""

    FIXED_INCOME_TYPE_UNSPECIFIED = "FIXED_INCOME_TYPE_UNSPECIFIED"
    MUNICIPAL = "MUNICIPAL"
    CORPORATE = "CORPORATE"
    CD = "CD"
    AGENCY = "AGENCY"
    TREASURY = "TREASURY"
    GOVERNMENT = "GOVERNMENT"
    FOREIGN_GOVERNMENT = "FOREIGN_GOVERNMENT"


class AssetIssueDateTypedDict(TypedDict):
    r"""The date of issuance"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class AssetIssueDate(BaseModel):
    r"""The date of issuance"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class IssueSizeTypedDict(TypedDict):
    r"""Total size of the bond issue in the issuing currency"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class IssueSize(BaseModel):
    r"""Total size of the bond issue in the issuing currency"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class LastCouponDateTypedDict(TypedDict):
    r"""date of last coupon"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class LastCouponDate(BaseModel):
    r"""date of last coupon"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class MaturityDateTypedDict(TypedDict):
    r"""The date the fixed income security matures"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class MaturityDate(BaseModel):
    r"""The date the fixed income security matures"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class NextCallDateTypedDict(TypedDict):
    r"""The date of the next call"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class NextCallDate(BaseModel):
    r"""The date of the next call"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class NextCouponDateTypedDict(TypedDict):
    r"""Date of next coupon payment"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class NextCouponDate(BaseModel):
    r"""Date of next coupon payment"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class ParValueTypedDict(TypedDict):
    r"""The amount the issuer agrees to pay the investor upon maturity"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class ParValue(BaseModel):
    r"""The amount the issuer agrees to pay the investor upon maturity"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class PriceAtIssuanceTypedDict(TypedDict):
    r"""The price at which fixed income security was issued as a percentage of par value in %"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class PriceAtIssuance(BaseModel):
    r"""The price at which fixed income security was issued as a percentage of par value in %"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class SpRating(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""

    SP_RATING_UNSPECIFIED = "SP_RATING_UNSPECIFIED"
    AAA = "AAA"
    AA_PLUS = "AA_PLUS"
    AA = "AA"
    AA_MINUS = "AA_MINUS"
    A_PLUS = "A_PLUS"
    A = "A"
    A_MINUS = "A_MINUS"
    BBB_PLUS = "BBB_PLUS"
    BBB = "BBB"
    BBB_MINUS = "BBB_MINUS"
    BB_PLUS = "BB_PLUS"
    BB = "BB"
    BB_MINUS = "BB_MINUS"
    B_PLUS = "B_PLUS"
    B = "B"
    B_MINUS = "B_MINUS"
    CCC_PLUS = "CCC_PLUS"
    CCC = "CCC"
    CCC_MINUS = "CCC_MINUS"
    CC = "CC"
    C = "C"
    D = "D"
    NR = "NR"
    SP_1_PLUS = "SP_1_PLUS"
    SP_1 = "SP_1"
    SP_1_MINUS = "SP_1_MINUS"
    A_1_PLUS = "A_1_PLUS"
    A_1 = "A_1"
    A_1_MINUS = "A_1_MINUS"


class SpRatingDateTypedDict(TypedDict):
    r"""The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class SpRatingDate(BaseModel):
    r"""The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class FixedIncomeTypedDict(TypedDict):
    r"""FixedIncome specific asset details"""

    call_type: NotRequired[CallType]
    r"""The type of call"""
    callable: NotRequired[bool]
    r"""Boolean that indicates whether an issuer may redeem the security before its maturity date"""
    convertible: NotRequired[bool]
    r"""Boolean that indicates whether an investor may convert to a number of shares of issuer common stock"""
    coupon_frequency: NotRequired[CouponFrequency]
    r"""Frequency of payments"""
    coupon_rate: NotRequired[Nullable[CouponRateTypedDict]]
    r"""A measure of income an investor can expect to receive expressed as a percent"""
    coupon_type: NotRequired[CouponType]
    r"""Type of coupon rate"""
    duration: NotRequired[Nullable[DurationTypedDict]]
    r"""Weighted average time until a bond’s cash flows are received in years"""
    first_coupon_date: NotRequired[Nullable[FirstCouponDateTypedDict]]
    r"""date of first coupon"""
    fixed_income_status: NotRequired[FixedIncomeStatus]
    r"""The status of the fixed income"""
    fixed_income_subtype: NotRequired[FixedIncomeSubtype]
    r"""The type of treasury"""
    fixed_income_type: NotRequired[FixedIncomeType]
    r"""Type of fixed income security"""
    insured: NotRequired[bool]
    r"""Boolean that indicates whether a security is backed by an insurance policy"""
    issue_date: NotRequired[Nullable[AssetIssueDateTypedDict]]
    r"""The date of issuance"""
    issue_size: NotRequired[Nullable[IssueSizeTypedDict]]
    r"""Total size of the bond issue in the issuing currency"""
    issuer: NotRequired[str]
    r"""Name of the bond issuer"""
    last_coupon_date: NotRequired[Nullable[LastCouponDateTypedDict]]
    r"""date of last coupon"""
    maturity_date: NotRequired[Nullable[MaturityDateTypedDict]]
    r"""The date the fixed income security matures"""
    next_call_date: NotRequired[Nullable[NextCallDateTypedDict]]
    r"""The date of the next call"""
    next_coupon_date: NotRequired[Nullable[NextCouponDateTypedDict]]
    r"""Date of next coupon payment"""
    par_value: NotRequired[Nullable[ParValueTypedDict]]
    r"""The amount the issuer agrees to pay the investor upon maturity"""
    perpetual: NotRequired[bool]
    r"""Indicates whether the bond is perpetual"""
    price_at_issuance: NotRequired[Nullable[PriceAtIssuanceTypedDict]]
    r"""The price at which fixed income security was issued as a percentage of par value in %"""
    sp_rating: NotRequired[SpRating]
    r"""Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""
    sp_rating_date: NotRequired[Nullable[SpRatingDateTypedDict]]
    r"""The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""
    underlying_symbol: NotRequired[str]
    r"""The symbol for the issuer’s equity"""


class FixedIncome(BaseModel):
    r"""FixedIncome specific asset details"""

    call_type: Annotated[
        Optional[CallType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The type of call"""

    callable: Optional[bool] = None
    r"""Boolean that indicates whether an issuer may redeem the security before its maturity date"""

    convertible: Optional[bool] = None
    r"""Boolean that indicates whether an investor may convert to a number of shares of issuer common stock"""

    coupon_frequency: Annotated[
        Optional[CouponFrequency], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Frequency of payments"""

    coupon_rate: OptionalNullable[CouponRate] = UNSET
    r"""A measure of income an investor can expect to receive expressed as a percent"""

    coupon_type: Annotated[
        Optional[CouponType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Type of coupon rate"""

    duration: Annotated[
        OptionalNullable[Duration],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = UNSET
    r"""Weighted average time until a bond’s cash flows are received in years"""

    first_coupon_date: OptionalNullable[FirstCouponDate] = UNSET
    r"""date of first coupon"""

    fixed_income_status: Annotated[
        Optional[FixedIncomeStatus], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The status of the fixed income"""

    fixed_income_subtype: Annotated[
        Optional[FixedIncomeSubtype], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The type of treasury"""

    fixed_income_type: Annotated[
        Optional[FixedIncomeType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Type of fixed income security"""

    insured: Optional[bool] = None
    r"""Boolean that indicates whether a security is backed by an insurance policy"""

    issue_date: OptionalNullable[AssetIssueDate] = UNSET
    r"""The date of issuance"""

    issue_size: OptionalNullable[IssueSize] = UNSET
    r"""Total size of the bond issue in the issuing currency"""

    issuer: Optional[str] = None
    r"""Name of the bond issuer"""

    last_coupon_date: OptionalNullable[LastCouponDate] = UNSET
    r"""date of last coupon"""

    maturity_date: OptionalNullable[MaturityDate] = UNSET
    r"""The date the fixed income security matures"""

    next_call_date: OptionalNullable[NextCallDate] = UNSET
    r"""The date of the next call"""

    next_coupon_date: OptionalNullable[NextCouponDate] = UNSET
    r"""Date of next coupon payment"""

    par_value: OptionalNullable[ParValue] = UNSET
    r"""The amount the issuer agrees to pay the investor upon maturity"""

    perpetual: Optional[bool] = None
    r"""Indicates whether the bond is perpetual"""

    price_at_issuance: OptionalNullable[PriceAtIssuance] = UNSET
    r"""The price at which fixed income security was issued as a percentage of par value in %"""

    sp_rating: Annotated[
        Optional[SpRating], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""

    sp_rating_date: OptionalNullable[SpRatingDate] = UNSET
    r"""The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field."""

    underlying_symbol: Optional[str] = None
    r"""The symbol for the issuer’s equity"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "call_type",
            "callable",
            "convertible",
            "coupon_frequency",
            "coupon_rate",
            "coupon_type",
            "duration",
            "first_coupon_date",
            "fixed_income_status",
            "fixed_income_subtype",
            "fixed_income_type",
            "insured",
            "issue_date",
            "issue_size",
            "issuer",
            "last_coupon_date",
            "maturity_date",
            "next_call_date",
            "next_coupon_date",
            "par_value",
            "perpetual",
            "price_at_issuance",
            "sp_rating",
            "sp_rating_date",
            "underlying_symbol",
        ]
        nullable_fields = [
            "coupon_rate",
            "duration",
            "first_coupon_date",
            "issue_date",
            "issue_size",
            "last_coupon_date",
            "maturity_date",
            "next_call_date",
            "next_coupon_date",
            "par_value",
            "price_at_issuance",
            "sp_rating_date",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class IndexTypedDict(TypedDict):
    r"""Index specific asset details"""


class Index(BaseModel):
    r"""Index specific asset details"""


class LargeOrderNotificationAmountTypedDict(TypedDict):
    r"""The threshold at which Apex would need to notify the fund family of an incoming large order."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class LargeOrderNotificationAmount(BaseModel):
    r"""The threshold at which Apex would need to notify the fund family of an incoming large order."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class MutualFundType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Identifies type of mutual fund"""

    MUTUAL_FUND_TYPE_UNSPECIFIED = "MUTUAL_FUND_TYPE_UNSPECIFIED"
    BOND = "BOND"
    MONEY_MARKET_FUND = "MONEY_MARKET_FUND"
    EQUITY = "EQUITY"


class MutualFundTypedDict(TypedDict):
    r"""MutualFund specific asset details"""

    fund_family: NotRequired[str]
    r"""Name of the fund company"""
    large_order_notification_amount: NotRequired[
        Nullable[LargeOrderNotificationAmountTypedDict]
    ]
    r"""The threshold at which Apex would need to notify the fund family of an incoming large order."""
    mutual_fund_type: NotRequired[MutualFundType]
    r"""Identifies type of mutual fund"""
    share_class: NotRequired[str]
    r"""Indicates the type and number of fees charged for the shares in a fund"""


class MutualFund(BaseModel):
    r"""MutualFund specific asset details"""

    fund_family: Optional[str] = None
    r"""Name of the fund company"""

    large_order_notification_amount: OptionalNullable[
        LargeOrderNotificationAmount
    ] = UNSET
    r"""The threshold at which Apex would need to notify the fund family of an incoming large order."""

    mutual_fund_type: Annotated[
        Optional[MutualFundType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Identifies type of mutual fund"""

    share_class: Optional[str] = None
    r"""Indicates the type and number of fees charged for the shares in a fund"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "fund_family",
            "large_order_notification_amount",
            "mutual_fund_type",
            "share_class",
        ]
        nullable_fields = ["large_order_notification_amount"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CallPut(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price."""

    CALL_PUT_UNSPECIFIED = "CALL_PUT_UNSPECIFIED"
    CALL = "CALL"
    PUT = "PUT"


class ExerciseStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration)."""

    EXERCISE_STYLE_UNSPECIFIED = "EXERCISE_STYLE_UNSPECIFIED"
    AMERICAN = "AMERICAN"
    EUROPEAN = "EUROPEAN"


class AssetExpirationDateTypedDict(TypedDict):
    r"""The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class AssetExpirationDate(BaseModel):
    r"""The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class Classification(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time."""

    CLASSIFICATION_UNSPECIFIED = "CLASSIFICATION_UNSPECIFIED"
    STANDARD = "STANDARD"
    FLEX = "FLEX"


class PennyPilotIndicator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The penny pilot indicator of the option"""

    PENNY_PILOT_INDICATOR_UNSPECIFIED = "PENNY_PILOT_INDICATOR_UNSPECIFIED"
    PENNY_PILOT = "PENNY_PILOT"
    NON_PENNY_PILOT = "NON_PENNY_PILOT"


class PositionLimitTypedDict(TypedDict):
    r"""The position Limit for a given option set at the OCC."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class PositionLimit(BaseModel):
    r"""The position Limit for a given option set at the OCC."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class SettlementStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Indicates whether the option is designated to settle at the market's opening price on the expiration date."""

    SETTLEMENT_STYLE_UNSPECIFIED = "SETTLEMENT_STYLE_UNSPECIFIED"
    SETTLE_ON_OPEN = "SETTLE_ON_OPEN"
    SETTLE_ON_CLOSE = "SETTLE_ON_CLOSE"


class StrikeMultiplierTypedDict(TypedDict):
    r"""A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.

    strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
    """

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class StrikeMultiplier(BaseModel):
    r"""A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.

    strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
    """

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class StrikePriceMultiplierTypedDict(TypedDict):
    r"""A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100
    For mini options the typical value is 10
    """

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class StrikePriceMultiplier(BaseModel):
    r"""A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100
    For mini options the typical value is 10
    """

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeValueMultiplierTypedDict(TypedDict):
    r"""A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
    the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
    Trade Value is usually the same as the Strike Value.
    For mini options the typical value is 10
    """

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeValueMultiplier(BaseModel):
    r"""A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
    the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
    Trade Value is usually the same as the Strike Value.
    For mini options the typical value is 10
    """

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class OptionRootTypedDict(TypedDict):
    r"""The full option root information"""

    classification: NotRequired[Classification]
    r"""Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time."""
    deliverables: NotRequired[List[OptionDeliverableTypedDict]]
    r"""deliverables is the deliverables of the option More than 20 deliverable assets are not supported."""
    penny_pilot_indicator: NotRequired[PennyPilotIndicator]
    r"""The penny pilot indicator of the option"""
    position_limit: NotRequired[Nullable[PositionLimitTypedDict]]
    r"""The position Limit for a given option set at the OCC."""
    root_symbol: NotRequired[str]
    r"""Unique identifier for the underlying asset and its associated option contracts, which reflects any changes to the underlying asset caused by corporate actions such as mergers, splits, or spin-offs by updating the root with a numerical value to reflect the adjusted terms or entity."""
    settlement_style: NotRequired[SettlementStyle]
    r"""Indicates whether the option is designated to settle at the market's opening price on the expiration date."""
    strike_multiplier: NotRequired[Nullable[StrikeMultiplierTypedDict]]
    r"""A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.

    strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
    """
    strike_price_multiplier: NotRequired[Nullable[StrikePriceMultiplierTypedDict]]
    r"""A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100
    For mini options the typical value is 10
    """
    trade_value_multiplier: NotRequired[Nullable[TradeValueMultiplierTypedDict]]
    r"""A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
    the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
    Trade Value is usually the same as the Strike Value.
    For mini options the typical value is 10
    """


class OptionRoot(BaseModel):
    r"""The full option root information"""

    classification: Annotated[
        Optional[Classification], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time."""

    deliverables: Optional[List[OptionDeliverable]] = None
    r"""deliverables is the deliverables of the option More than 20 deliverable assets are not supported."""

    penny_pilot_indicator: Annotated[
        Optional[PennyPilotIndicator], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The penny pilot indicator of the option"""

    position_limit: OptionalNullable[PositionLimit] = UNSET
    r"""The position Limit for a given option set at the OCC."""

    root_symbol: Optional[str] = None
    r"""Unique identifier for the underlying asset and its associated option contracts, which reflects any changes to the underlying asset caused by corporate actions such as mergers, splits, or spin-offs by updating the root with a numerical value to reflect the adjusted terms or entity."""

    settlement_style: Annotated[
        Optional[SettlementStyle], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Indicates whether the option is designated to settle at the market's opening price on the expiration date."""

    strike_multiplier: OptionalNullable[StrikeMultiplier] = UNSET
    r"""A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.

    strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
    """

    strike_price_multiplier: OptionalNullable[StrikePriceMultiplier] = UNSET
    r"""A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100
    For mini options the typical value is 10
    """

    trade_value_multiplier: OptionalNullable[TradeValueMultiplier] = UNSET
    r"""A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
    1) Number of shares for Equity Options
    2) A dollar amount for Index Options
    The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
    the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
    Trade Value is usually the same as the Strike Value.
    For mini options the typical value is 10
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "classification",
            "deliverables",
            "penny_pilot_indicator",
            "position_limit",
            "root_symbol",
            "settlement_style",
            "strike_multiplier",
            "strike_price_multiplier",
            "trade_value_multiplier",
        ]
        nullable_fields = [
            "position_limit",
            "strike_multiplier",
            "strike_price_multiplier",
            "trade_value_multiplier",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class OptionType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of deliverable asset the option is set to deliver upon expiry."""

    OPTION_TYPE_UNSPECIFIED = "OPTION_TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    INDEX = "INDEX"


class SeriesDateTypedDict(TypedDict):
    r"""The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class SeriesDate(BaseModel):
    r"""The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class SettlementMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference)."""

    SETTLEMENT_METHOD_UNSPECIFIED = "SETTLEMENT_METHOD_UNSPECIFIED"
    CASH = "CASH"
    PHYSICAL = "PHYSICAL"


class SettlementType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions."""

    SETTLEMENT_TYPE_UNSPECIFIED = "SETTLEMENT_TYPE_UNSPECIFIED"
    STANDARD = "STANDARD"
    NON_STANDARD = "NON_STANDARD"


class StrikePriceTypedDict(TypedDict):
    r"""The price at which the option holder can buy or sell the deliverable asset(s)"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class StrikePrice(BaseModel):
    r"""The price at which the option holder can buy or sell the deliverable asset(s)"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class OptionTypedDict(TypedDict):
    r"""Option specific asset details"""

    call_put: NotRequired[CallPut]
    r"""Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price."""
    exercise_style: NotRequired[ExerciseStyle]
    r"""Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration)."""
    expiration_date: NotRequired[Nullable[AssetExpirationDateTypedDict]]
    r"""The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date."""
    option_root: NotRequired[Nullable[OptionRootTypedDict]]
    r"""The full option root information"""
    option_type: NotRequired[OptionType]
    r"""Type of deliverable asset the option is set to deliver upon expiry."""
    root_symbol: NotRequired[str]
    r"""The leading segment of the OSI, which is typically the original deliverable symbol of the option. There are frequent exceptions to this rule, such as when there are multiple deliverables or the deliverable goes through a corporate action."""
    series_date: NotRequired[Nullable[SeriesDateTypedDict]]
    r"""The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated."""
    settlement_method: NotRequired[SettlementMethod]
    r"""Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference)."""
    settlement_type: NotRequired[SettlementType]
    r"""Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions."""
    strike_price: NotRequired[Nullable[StrikePriceTypedDict]]
    r"""The price at which the option holder can buy or sell the deliverable asset(s)"""


class Option(BaseModel):
    r"""Option specific asset details"""

    call_put: Annotated[
        Optional[CallPut], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price."""

    exercise_style: Annotated[
        Optional[ExerciseStyle], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration)."""

    expiration_date: OptionalNullable[AssetExpirationDate] = UNSET
    r"""The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date."""

    option_root: OptionalNullable[OptionRoot] = UNSET
    r"""The full option root information"""

    option_type: Annotated[
        Optional[OptionType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Type of deliverable asset the option is set to deliver upon expiry."""

    root_symbol: Optional[str] = None
    r"""The leading segment of the OSI, which is typically the original deliverable symbol of the option. There are frequent exceptions to this rule, such as when there are multiple deliverables or the deliverable goes through a corporate action."""

    series_date: OptionalNullable[SeriesDate] = UNSET
    r"""The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated."""

    settlement_method: Annotated[
        Optional[SettlementMethod], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference)."""

    settlement_type: Annotated[
        Optional[SettlementType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions."""

    strike_price: OptionalNullable[StrikePrice] = UNSET
    r"""The price at which the option holder can buy or sell the deliverable asset(s)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "call_put",
            "exercise_style",
            "expiration_date",
            "option_root",
            "option_type",
            "root_symbol",
            "series_date",
            "settlement_method",
            "settlement_type",
            "strike_price",
        ]
        nullable_fields = [
            "expiration_date",
            "option_root",
            "series_date",
            "strike_price",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class AssetType1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type or category of the asset"""

    TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    OPTION = "OPTION"
    CURRENCY = "CURRENCY"
    DIGITAL = "DIGITAL"
    FDIC_SYNTHETIC = "FDIC_SYNTHETIC"
    FIXED_INCOME = "FIXED_INCOME"
    MUTUAL_FUND = "MUTUAL_FUND"
    INDEX = "INDEX"


class AssetTypedDict(TypedDict):
    r"""Asset is the Apex representation of a security"""

    asset_id: NotRequired[str]
    r"""Apex internal identifier assigned upon entry to every security."""
    currency: NotRequired[Nullable[CurrencyTypedDict]]
    r"""Currency specific asset details"""
    cusip: NotRequired[str]
    r"""Identifier assigned to a security by the CUSIP Service Bureau of Standard & Poor’s Corporation"""
    description: NotRequired[str]
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""
    equity: NotRequired[Nullable[EquityTypedDict]]
    r"""Equity specific asset details"""
    fixed_income: NotRequired[Nullable[FixedIncomeTypedDict]]
    r"""FixedIncome specific asset details"""
    index: NotRequired[Nullable[IndexTypedDict]]
    r"""Index specific asset details"""
    isin: NotRequired[str]
    r"""isin is the International Securities Identification Number"""
    issuing_region_code: NotRequired[str]
    r"""A string attribute denoting the country of issuance or where the asset is trading."""
    mutual_fund: NotRequired[Nullable[MutualFundTypedDict]]
    r"""MutualFund specific asset details"""
    name: NotRequired[str]
    r"""assets/{asset_id}"""
    option: NotRequired[Nullable[OptionTypedDict]]
    r"""Option specific asset details"""
    originating_region_code: NotRequired[str]
    r"""ISO code identifying the region in which the entity was incorporated"""
    symbol: NotRequired[str]
    r"""An arrangement of characters—usually letters and or numbers — usually representing securities on an exchange"""
    type: NotRequired[AssetType1]
    r"""The type or category of the asset"""
    usable: NotRequired[bool]
    r"""A usable asset is active in its respective market and can be traded and/or transferred"""


class Asset(BaseModel):
    r"""Asset is the Apex representation of a security"""

    asset_id: Optional[str] = None
    r"""Apex internal identifier assigned upon entry to every security."""

    currency: OptionalNullable[Currency] = UNSET
    r"""Currency specific asset details"""

    cusip: Optional[str] = None
    r"""Identifier assigned to a security by the CUSIP Service Bureau of Standard & Poor’s Corporation"""

    description: Optional[str] = None
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""

    equity: OptionalNullable[Equity] = UNSET
    r"""Equity specific asset details"""

    fixed_income: OptionalNullable[FixedIncome] = UNSET
    r"""FixedIncome specific asset details"""

    index: OptionalNullable[Index] = UNSET
    r"""Index specific asset details"""

    isin: Optional[str] = None
    r"""isin is the International Securities Identification Number"""

    issuing_region_code: Optional[str] = None
    r"""A string attribute denoting the country of issuance or where the asset is trading."""

    mutual_fund: OptionalNullable[MutualFund] = UNSET
    r"""MutualFund specific asset details"""

    name: Optional[str] = None
    r"""assets/{asset_id}"""

    option: OptionalNullable[Option] = UNSET
    r"""Option specific asset details"""

    originating_region_code: Optional[str] = None
    r"""ISO code identifying the region in which the entity was incorporated"""

    symbol: Optional[str] = None
    r"""An arrangement of characters—usually letters and or numbers — usually representing securities on an exchange"""

    type: Annotated[
        Optional[AssetType1], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The type or category of the asset"""

    usable: Optional[bool] = None
    r"""A usable asset is active in its respective market and can be traded and/or transferred"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "asset_id",
            "currency",
            "cusip",
            "description",
            "equity",
            "fixed_income",
            "index",
            "isin",
            "issuing_region_code",
            "mutual_fund",
            "name",
            "option",
            "originating_region_code",
            "symbol",
            "type",
            "usable",
        ]
        nullable_fields = [
            "currency",
            "equity",
            "fixed_income",
            "index",
            "mutual_fund",
            "option",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
