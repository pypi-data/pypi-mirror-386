"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .contributionconstraints_contributiontypeinfo import (
    ContributionConstraintsContributionTypeInfo,
    ContributionConstraintsContributionTypeInfoTypedDict,
)
from .distributionconstraints_distributiontypeinfo import (
    DistributionConstraintsDistributionTypeInfo,
    DistributionConstraintsDistributionTypeInfoTypedDict,
)
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CashJournalConstraintsContributionConstraintsTypedDict(TypedDict):
    r"""Contribution constraints for the destination account"""

    only_allow_current_year: NotRequired[bool]
    r"""Deprecated! This value is determined based on the current date relative to the tax deadline. It will be inaccurate in cases where the previous year contribution deadline is not the tax deadline (e.g. `RECHARACTERIZATION`). Please refer to the `valid_types.previous_year_deadline` field instead."""
    valid_types: NotRequired[List[ContributionConstraintsContributionTypeInfoTypedDict]]
    r"""Valid contribution types"""


class CashJournalConstraintsContributionConstraints(BaseModel):
    r"""Contribution constraints for the destination account"""

    only_allow_current_year: Annotated[
        Optional[bool],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""Deprecated! This value is determined based on the current date relative to the tax deadline. It will be inaccurate in cases where the previous year contribution deadline is not the tax deadline (e.g. `RECHARACTERIZATION`). Please refer to the `valid_types.previous_year_deadline` field instead."""

    valid_types: Optional[List[ContributionConstraintsContributionTypeInfo]] = None
    r"""Valid contribution types"""


class CashJournalConstraintsDistributionConstraintsTypedDict(TypedDict):
    r"""Distribution constraints for the source account"""

    full_distribution_allowed: NotRequired[bool]
    r"""Whether a full distribution withdrawal is allowed"""
    valid_types: NotRequired[List[DistributionConstraintsDistributionTypeInfoTypedDict]]
    r"""Valid distribution types"""


class CashJournalConstraintsDistributionConstraints(BaseModel):
    r"""Distribution constraints for the source account"""

    full_distribution_allowed: Optional[bool] = None
    r"""Whether a full distribution withdrawal is allowed"""

    valid_types: Optional[List[DistributionConstraintsDistributionTypeInfo]] = None
    r"""Valid distribution types"""


class CashJournalConstraintsTypedDict(TypedDict):
    r"""Retirement constraints for cash journal transfers"""

    contribution_constraints: NotRequired[
        Nullable[CashJournalConstraintsContributionConstraintsTypedDict]
    ]
    r"""Contribution constraints for the destination account"""
    distribution_constraints: NotRequired[
        Nullable[CashJournalConstraintsDistributionConstraintsTypedDict]
    ]
    r"""Distribution constraints for the source account"""


class CashJournalConstraints(BaseModel):
    r"""Retirement constraints for cash journal transfers"""

    contribution_constraints: OptionalNullable[
        CashJournalConstraintsContributionConstraints
    ] = UNSET
    r"""Contribution constraints for the destination account"""

    distribution_constraints: OptionalNullable[
        CashJournalConstraintsDistributionConstraints
    ] = UNSET
    r"""Distribution constraints for the source account"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["contribution_constraints", "distribution_constraints"]
        nullable_fields = ["contribution_constraints", "distribution_constraints"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
