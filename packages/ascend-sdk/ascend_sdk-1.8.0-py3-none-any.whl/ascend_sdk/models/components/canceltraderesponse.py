"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .bookingfee import BookingFee, BookingFeeTypedDict
from .bookinglot import BookingLot, BookingLotTypedDict
from .execution import Execution, ExecutionTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CancelTradeResponseAssetType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the asset being traded."""

    ASSET_TYPE_UNSPECIFIED = "ASSET_TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    FIXED_INCOME = "FIXED_INCOME"


class CancelTradeResponseBrokerCapacity(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Broker capacity for the trade."""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class CancelTradeResponseIdentifierType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Identifier type for the asset being traded."""

    IDENTIFIER_TYPE_UNSPECIFIED = "IDENTIFIER_TYPE_UNSPECIFIED"
    ASSET_ID = "ASSET_ID"
    SYMBOL = "SYMBOL"
    CUSIP = "CUSIP"
    ISIN = "ISIN"


class CancelTradeResponseLocalMarketTradeDateTypedDict(TypedDict):
    r"""Date field to support extended trading hours."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CancelTradeResponseLocalMarketTradeDate(BaseModel):
    r"""Date field to support extended trading hours."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CancelTradeResponseRouteType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Route type for the trade."""

    ROUTE_TYPE_UNSPECIFIED = "ROUTE_TYPE_UNSPECIFIED"
    DMA = "DMA"
    MNGD = "MNGD"
    QUIK = "QUIK"
    ALGO = "ALGO"
    AWAY = "AWAY"
    CORR = "CORR"
    BOATS = "BOATS"


class CancelTradeResponseSettlementDateTypedDict(TypedDict):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CancelTradeResponseSettlementDate(BaseModel):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CancelTradeResponseSide(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes if the trade is a SELL or a BUY."""

    SIDE_UNSPECIFIED = "SIDE_UNSPECIFIED"
    BUY = "BUY"
    SELL = "SELL"


class CancelTradeResponseSideModifier(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Side modifier for the trade."""

    SIDE_MODIFIER_UNSPECIFIED = "SIDE_MODIFIER_UNSPECIFIED"
    SHORT = "SHORT"
    SHORT_EXEMPT = "SHORT_EXEMPT"
    SHORT_COVER = "SHORT_COVER"
    OPEN = "OPEN"
    CLOSE = "CLOSE"


class CancelTradeResponseSpecialInstructions(str, Enum, metaclass=utils.OpenEnumMeta):
    SPECIAL_INSTRUCTIONS_UNSPECIFIED = "SPECIAL_INSTRUCTIONS_UNSPECIFIED"
    RULE_144 = "RULE_144"
    WITH_DIVIDEND = "WITH_DIVIDEND"
    WITH_RIGHTS = "WITH_RIGHTS"
    CLOSE_CONTRACT = "CLOSE_CONTRACT"
    COVER_SHORT = "COVER_SHORT"
    CROSS_TRADE = "CROSS_TRADE"
    OPEN_CONTRACT_COVERED = "OPEN_CONTRACT_COVERED"
    DISCRETION_EXERCISED = "DISCRETION_EXERCISED"
    DISCRETION_NOT_EXERCISED = "DISCRETION_NOT_EXERCISED"
    OPTION_ASSIGNMENT = "OPTION_ASSIGNMENT"
    EMPLOYEE_STOCK_OPTION = "EMPLOYEE_STOCK_OPTION"
    INVESTMENT_BANKING = "INVESTMENT_BANKING"
    BROKER_DEALER_ORDER = "BROKER_DEALER_ORDER"
    MAKE_MARKET_IN_SECURITY = "MAKE_MARKET_IN_SECURITY"
    MAKE_MARKET_SOLICITED = "MAKE_MARKET_SOLICITED"
    MAKE_MARKET_UNSOLICITED = "MAKE_MARKET_UNSOLICITED"
    CUSTOMER_DIRECTED = "CUSTOMER_DIRECTED"
    FULLY_REGISTERED = "FULLY_REGISTERED"
    OPEN_CONTRACT = "OPEN_CONTRACT"
    ODDLOT_DIFF_ON_REQUEST = "ODDLOT_DIFF_ON_REQUEST"
    PROSPECTUS_ENCLOSED = "PROSPECTUS_ENCLOSED"
    PROSPECTUS_SEPARATE_MAIL = "PROSPECTUS_SEPARATE_MAIL"
    SOLICITED = "SOLICITED"
    UNSOLICITED = "UNSOLICITED"
    X_DIVIDEND = "X_DIVIDEND"
    ACTING_AS_PRINCIPAL = "ACTING_AS_PRINCIPAL"
    AVERAGE_PRICE = "AVERAGE_PRICE"
    BROKER_LIQUIDATION = "BROKER_LIQUIDATION"
    COUPON_BOOKS = "COUPON_BOOKS"
    HAS_POSTAGE_FEE = "HAS_POSTAGE_FEE"
    INTERNET_ORDER = "INTERNET_ORDER"
    MARGIN_SELLOUT = "MARGIN_SELLOUT"
    MARKET_MAKERS_AS_PRINCIPAL = "MARKET_MAKERS_AS_PRINCIPAL"
    NEGATIVE_NET_PROCEED = "NEGATIVE_NET_PROCEED"
    PRE_FIG_INDICATOR = "PRE_FIG_INDICATOR"
    RISKLESS_PRINCIPAL_INSTRUCTION = "RISKLESS_PRINCIPAL_INSTRUCTION"
    SHORT_INSTRUCTION = "SHORT_INSTRUCTION"
    THIRD_MARKET = "THIRD_MARKET"
    SUPPRESS_MSRB_TRANSMISSION = "SUPPRESS_MSRB_TRANSMISSION"
    SUPPRESS_TRACE_REPORTING = "SUPPRESS_TRACE_REPORTING"
    SUPPRESS_EMAIL_NOTIFICATION = "SUPPRESS_EMAIL_NOTIFICATION"
    STOCK_REWARD = "STOCK_REWARD"
    SUPPRESS_REG_FEES = "SUPPRESS_REG_FEES"
    SUPPRESS_SEC_FEE = "SUPPRESS_SEC_FEE"
    SUPPRESS_TAF_FEE = "SUPPRESS_TAF_FEE"
    DIVIDEND_REINVESTMENT = "DIVIDEND_REINVESTMENT"


class CancelTradeResponseVenue(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Exchange venue"""

    EXCHANGE_VENUE_UNSPECIFIED = "EXCHANGE_VENUE_UNSPECIFIED"
    AMEX = "AMEX"
    ARCA = "ARCA"
    BATS = "BATS"
    BATS_BYX = "BATS_BYX"
    BOSTON = "BOSTON"
    BOX = "BOX"
    BZX = "BZX"
    C2 = "C2"
    CBOE = "CBOE"
    CHICAGO = "CHICAGO"
    CINCINNATI = "CINCINNATI"
    EDGA = "EDGA"
    EDGX = "EDGX"
    EXCLEARING = "EXCLEARING"
    IEX = "IEX"
    ISE = "ISE"
    ISE_GEMINI = "ISE_GEMINI"
    MIAX = "MIAX"
    NASDAQ = "NASDAQ"
    NASDAQ_OMX_BX = "NASDAQ_OMX_BX"
    NYSE = "NYSE"
    PHLX = "PHLX"
    OTC = "OTC"
    QSR = "QSR"


class CancelTradeResponseWhenIssued(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes that this trade was either when_issued or when_distributed."""

    WHEN_ISSUED_TYPE_UNSPECIFIED = "WHEN_ISSUED_TYPE_UNSPECIFIED"
    WHEN_ISSUED = "WHEN_ISSUED"
    WHEN_DISTRIBUTED = "WHEN_DISTRIBUTED"


class CancelTradeResponseTradeTypedDict(TypedDict):
    r"""The trade that was canceled."""

    account_id: NotRequired[str]
    r"""A globally unique identifier referencing a single account."""
    activity_id: NotRequired[str]
    r"""The current activity_id of this trade in the Ledger."""
    additional_instructions: NotRequired[str]
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""
    alternate_order_id: NotRequired[str]
    r"""Fractional support for market-makers' internal order ids."""
    asset_type: NotRequired[CancelTradeResponseAssetType]
    r"""Type of the asset being traded."""
    broker_capacity: NotRequired[CancelTradeResponseBrokerCapacity]
    r"""Broker capacity for the trade."""
    client_order_id: NotRequired[str]
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""
    executing_broker: NotRequired[str]
    r"""Executing broker of the trade."""
    executions: NotRequired[List[ExecutionTypedDict]]
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""
    fees: NotRequired[List[BookingFeeTypedDict]]
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""
    identifier: NotRequired[str]
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""
    identifier_type: NotRequired[CancelTradeResponseIdentifierType]
    r"""Identifier type for the asset being traded."""
    issuing_region_code: NotRequired[str]
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""
    local_market_trade_date: NotRequired[
        Nullable[CancelTradeResponseLocalMarketTradeDateTypedDict]
    ]
    r"""Date field to support extended trading hours."""
    lot_matching_instructions: NotRequired[List[BookingLotTypedDict]]
    r"""One or many lot matching instructions for the trade."""
    mic_code: NotRequired[str]
    r"""Market Identifier Code"""
    name: NotRequired[str]
    r"""The resource name of the trade."""
    open: NotRequired[bool]
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""
    order_id: NotRequired[str]
    r"""Street-level order id, unique by day per broker."""
    route_type: NotRequired[CancelTradeResponseRouteType]
    r"""Route type for the trade."""
    settlement_date: NotRequired[Nullable[CancelTradeResponseSettlementDateTypedDict]]
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""
    side: NotRequired[CancelTradeResponseSide]
    r"""Denotes if the trade is a SELL or a BUY."""
    side_modifier: NotRequired[CancelTradeResponseSideModifier]
    r"""Side modifier for the trade."""
    source_application: NotRequired[str]
    r"""The source of the submission."""
    special_instructions: NotRequired[List[CancelTradeResponseSpecialInstructions]]
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""
    trade_id: NotRequired[str]
    r"""A ULID to uniquely identify the trade globally."""
    venue: NotRequired[CancelTradeResponseVenue]
    r"""Exchange venue"""
    when_issued: NotRequired[CancelTradeResponseWhenIssued]
    r"""Denotes that this trade was either when_issued or when_distributed."""


class CancelTradeResponseTrade(BaseModel):
    r"""The trade that was canceled."""

    account_id: Optional[str] = None
    r"""A globally unique identifier referencing a single account."""

    activity_id: Optional[str] = None
    r"""The current activity_id of this trade in the Ledger."""

    additional_instructions: Optional[str] = None
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""

    alternate_order_id: Optional[str] = None
    r"""Fractional support for market-makers' internal order ids."""

    asset_type: Annotated[
        Optional[CancelTradeResponseAssetType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Type of the asset being traded."""

    broker_capacity: Annotated[
        Optional[CancelTradeResponseBrokerCapacity],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Broker capacity for the trade."""

    client_order_id: Optional[str] = None
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""

    executing_broker: Optional[str] = None
    r"""Executing broker of the trade."""

    executions: Optional[List[Execution]] = None
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""

    fees: Optional[List[BookingFee]] = None
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""

    identifier: Optional[str] = None
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""

    identifier_type: Annotated[
        Optional[CancelTradeResponseIdentifierType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Identifier type for the asset being traded."""

    issuing_region_code: Optional[str] = None
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""

    local_market_trade_date: OptionalNullable[
        CancelTradeResponseLocalMarketTradeDate
    ] = UNSET
    r"""Date field to support extended trading hours."""

    lot_matching_instructions: Optional[List[BookingLot]] = None
    r"""One or many lot matching instructions for the trade."""

    mic_code: Optional[str] = None
    r"""Market Identifier Code"""

    name: Optional[str] = None
    r"""The resource name of the trade."""

    open: Optional[bool] = None
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""

    order_id: Optional[str] = None
    r"""Street-level order id, unique by day per broker."""

    route_type: Annotated[
        Optional[CancelTradeResponseRouteType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Route type for the trade."""

    settlement_date: OptionalNullable[CancelTradeResponseSettlementDate] = UNSET
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    side: Annotated[
        Optional[CancelTradeResponseSide], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes if the trade is a SELL or a BUY."""

    side_modifier: Annotated[
        Optional[CancelTradeResponseSideModifier],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Side modifier for the trade."""

    source_application: Optional[str] = None
    r"""The source of the submission."""

    special_instructions: Optional[
        List[
            Annotated[
                CancelTradeResponseSpecialInstructions,
                PlainValidator(validate_open_enum(False)),
            ]
        ]
    ] = None
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""

    trade_id: Optional[str] = None
    r"""A ULID to uniquely identify the trade globally."""

    venue: Annotated[
        Optional[CancelTradeResponseVenue], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Exchange venue"""

    when_issued: Annotated[
        Optional[CancelTradeResponseWhenIssued],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Denotes that this trade was either when_issued or when_distributed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "account_id",
            "activity_id",
            "additional_instructions",
            "alternate_order_id",
            "asset_type",
            "broker_capacity",
            "client_order_id",
            "executing_broker",
            "executions",
            "fees",
            "identifier",
            "identifier_type",
            "issuing_region_code",
            "local_market_trade_date",
            "lot_matching_instructions",
            "mic_code",
            "name",
            "open",
            "order_id",
            "route_type",
            "settlement_date",
            "side",
            "side_modifier",
            "source_application",
            "special_instructions",
            "trade_id",
            "venue",
            "when_issued",
        ]
        nullable_fields = ["local_market_trade_date", "settlement_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CancelTradeResponseTypedDict(TypedDict):
    r"""A response for the cancel trade method."""

    trade: NotRequired[Nullable[CancelTradeResponseTradeTypedDict]]
    r"""The trade that was canceled."""


class CancelTradeResponse(BaseModel):
    r"""A response for the cancel trade method."""

    trade: OptionalNullable[CancelTradeResponseTrade] = UNSET
    r"""The trade that was canceled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["trade"]
        nullable_fields = ["trade"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
