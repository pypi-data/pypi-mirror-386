"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from ascend_sdk import utils
from ascend_sdk._hooks import HookContext
from ascend_sdk.models import components, errors, operations
from ascend_sdk.types import OptionalNullable, UNSET
from ascend_sdk.utils.unmarshal_json_response import unmarshal_json_response
from jsonpath import JSONPath
from typing import Any, Dict, List, Mapping, Optional, Union


class ScheduleTransfers(BaseSDK):
    def list_schedule_summaries(
        self,
        *,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.TransferScheduleSummariesListScheduleSummariesResponse]:
        r"""List Schedule Summaries

        Lists transfer schedule summaries that match the filter in the request

        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `account`  `mechanism`  `direction`  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.TransferScheduleSummariesListScheduleSummariesRequest(
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/schedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TransferScheduleSummaries_ListScheduleSummaries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.TransferScheduleSummariesListScheduleSummariesResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_schedule_summaries(
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.TransferScheduleSummariesListScheduleSummariesResponse(
                list_schedule_summaries_response=unmarshal_json_response(
                    Optional[components.ListScheduleSummariesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.TransferScheduleSummariesListScheduleSummariesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_schedule_summaries_async(
        self,
        *,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.TransferScheduleSummariesListScheduleSummariesResponse]:
        r"""List Schedule Summaries

        Lists transfer schedule summaries that match the filter in the request

        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `account`  `mechanism`  `direction`  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.TransferScheduleSummariesListScheduleSummariesRequest(
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/schedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TransferScheduleSummaries_ListScheduleSummaries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.TransferScheduleSummariesListScheduleSummariesResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_schedule_summaries(
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.TransferScheduleSummariesListScheduleSummariesResponse(
                list_schedule_summaries_response=unmarshal_json_response(
                    Optional[components.ListScheduleSummariesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.TransferScheduleSummariesListScheduleSummariesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def create_ach_deposit_schedule(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_create: Union[
            components.AchDepositScheduleCreate,
            components.AchDepositScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesCreateAchDepositScheduleResponse:
        r"""Create ACH Deposit Schedule

        Creates an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesCreateAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_create=utils.get_pydantic_model(
                ach_deposit_schedule_create, components.AchDepositScheduleCreate
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_deposit_schedule_create,
                False,
                False,
                "json",
                components.AchDepositScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_CreateAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesCreateAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesCreateAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_ach_deposit_schedule_async(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_create: Union[
            components.AchDepositScheduleCreate,
            components.AchDepositScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesCreateAchDepositScheduleResponse:
        r"""Create ACH Deposit Schedule

        Creates an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesCreateAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_create=utils.get_pydantic_model(
                ach_deposit_schedule_create, components.AchDepositScheduleCreate
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_deposit_schedule_create,
                False,
                False,
                "json",
                components.AchDepositScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_CreateAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesCreateAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesCreateAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def list_ach_deposit_schedules(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.AchDepositSchedulesListAchDepositSchedulesResponse]:
        r"""List ACH Deposit Schedules

        Return a list of ACH deposit schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesListAchDepositSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_ListAchDepositSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.AchDepositSchedulesListAchDepositSchedulesResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_ach_deposit_schedules(
                account_id=account_id,
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesListAchDepositSchedulesResponse(
                list_ach_deposit_schedules_response=unmarshal_json_response(
                    Optional[components.ListAchDepositSchedulesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesListAchDepositSchedulesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_ach_deposit_schedules_async(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.AchDepositSchedulesListAchDepositSchedulesResponse]:
        r"""List ACH Deposit Schedules

        Return a list of ACH deposit schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesListAchDepositSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_ListAchDepositSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.AchDepositSchedulesListAchDepositSchedulesResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_ach_deposit_schedules(
                account_id=account_id,
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesListAchDepositSchedulesResponse(
                list_ach_deposit_schedules_response=unmarshal_json_response(
                    Optional[components.ListAchDepositSchedulesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesListAchDepositSchedulesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def get_ach_deposit_schedule(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesGetAchDepositScheduleResponse:
        r"""Get ACH Deposit Schedule

        Gets an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesGetAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_GetAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesGetAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesGetAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_ach_deposit_schedule_async(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesGetAchDepositScheduleResponse:
        r"""Get ACH Deposit Schedule

        Gets an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesGetAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_GetAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesGetAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesGetAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def update_ach_deposit_schedule(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        ach_deposit_schedule_update: Union[
            components.AchDepositScheduleUpdate,
            components.AchDepositScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesUpdateAchDepositScheduleResponse:
        r"""Update ACH Deposit Schedules

        Updates the amount of an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param ach_deposit_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesUpdateAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
            update_mask=update_mask,
            ach_deposit_schedule_update=utils.get_pydantic_model(
                ach_deposit_schedule_update, components.AchDepositScheduleUpdate
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_deposit_schedule_update,
                False,
                False,
                "json",
                components.AchDepositScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_UpdateAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesUpdateAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesUpdateAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_ach_deposit_schedule_async(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        ach_deposit_schedule_update: Union[
            components.AchDepositScheduleUpdate,
            components.AchDepositScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesUpdateAchDepositScheduleResponse:
        r"""Update ACH Deposit Schedules

        Updates the amount of an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param ach_deposit_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesUpdateAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
            update_mask=update_mask,
            ach_deposit_schedule_update=utils.get_pydantic_model(
                ach_deposit_schedule_update, components.AchDepositScheduleUpdate
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_deposit_schedule_update,
                False,
                False,
                "json",
                components.AchDepositScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_UpdateAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesUpdateAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesUpdateAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def cancel_ach_deposit_schedule(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        cancel_ach_deposit_schedule_request_create: Union[
            components.CancelAchDepositScheduleRequestCreate,
            components.CancelAchDepositScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesCancelAchDepositScheduleResponse:
        r"""Cancel ACH Deposit Schedule

        Cancels an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param cancel_ach_deposit_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesCancelAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
            cancel_ach_deposit_schedule_request_create=utils.get_pydantic_model(
                cancel_ach_deposit_schedule_request_create,
                components.CancelAchDepositScheduleRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_ach_deposit_schedule_request_create,
                False,
                False,
                "json",
                components.CancelAchDepositScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_CancelAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesCancelAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesCancelAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def cancel_ach_deposit_schedule_async(
        self,
        *,
        account_id: str,
        ach_deposit_schedule_id: str,
        cancel_ach_deposit_schedule_request_create: Union[
            components.CancelAchDepositScheduleRequestCreate,
            components.CancelAchDepositScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchDepositSchedulesCancelAchDepositScheduleResponse:
        r"""Cancel ACH Deposit Schedule

        Cancels an ACH deposit transfer schedule

        :param account_id: The account id.
        :param ach_deposit_schedule_id: The achDepositSchedule id.
        :param cancel_ach_deposit_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchDepositSchedulesCancelAchDepositScheduleRequest(
            account_id=account_id,
            ach_deposit_schedule_id=ach_deposit_schedule_id,
            cancel_ach_deposit_schedule_request_create=utils.get_pydantic_model(
                cancel_ach_deposit_schedule_request_create,
                components.CancelAchDepositScheduleRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achDepositSchedules/{achDepositSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_ach_deposit_schedule_request_create,
                False,
                False,
                "json",
                components.CancelAchDepositScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchDepositSchedules_CancelAchDepositSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchDepositSchedulesCancelAchDepositScheduleResponse(
                ach_deposit_schedule=unmarshal_json_response(
                    Optional[components.AchDepositSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchDepositSchedulesCancelAchDepositScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def create_ach_withdrawal_schedule(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_create: Union[
            components.AchWithdrawalScheduleCreate,
            components.AchWithdrawalScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse:
        r"""Create ACH Withdrawal Schedule

        Creates an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_create=utils.get_pydantic_model(
                ach_withdrawal_schedule_create, components.AchWithdrawalScheduleCreate
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_withdrawal_schedule_create,
                False,
                False,
                "json",
                components.AchWithdrawalScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_CreateAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_ach_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_create: Union[
            components.AchWithdrawalScheduleCreate,
            components.AchWithdrawalScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse:
        r"""Create ACH Withdrawal Schedule

        Creates an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_create=utils.get_pydantic_model(
                ach_withdrawal_schedule_create, components.AchWithdrawalScheduleCreate
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_withdrawal_schedule_create,
                False,
                False,
                "json",
                components.AchWithdrawalScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_CreateAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesCreateAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def list_ach_withdrawal_schedules(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse]:
        r"""List ACH Withdrawal Schedules

        Return a list of ACH withdrawal schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_ListAchWithdrawalSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[
                operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse
            ]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_ach_withdrawal_schedules(
                account_id=account_id,
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse(
                list_ach_withdrawal_schedules_response=unmarshal_json_response(
                    Optional[components.ListAchWithdrawalSchedulesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_ach_withdrawal_schedules_async(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse]:
        r"""List ACH Withdrawal Schedules

        Return a list of ACH withdrawal schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_ListAchWithdrawalSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[
                operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse
            ]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_ach_withdrawal_schedules(
                account_id=account_id,
                filter_=filter_,
                page_size=page_size,
                page_token=next_cursor,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse(
                list_ach_withdrawal_schedules_response=unmarshal_json_response(
                    Optional[components.ListAchWithdrawalSchedulesResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesListAchWithdrawalSchedulesResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def get_ach_withdrawal_schedule(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse:
        r"""Get ACH Withdrawal Schedule

        Gets an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_GetAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_ach_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse:
        r"""Get ACH Withdrawal Schedule

        Gets an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_GetAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesGetAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def update_ach_withdrawal_schedule(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        ach_withdrawal_schedule_update: Union[
            components.AchWithdrawalScheduleUpdate,
            components.AchWithdrawalScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse:
        r"""Update ACH Withdrawal Schedule

        Updates the amount of an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param ach_withdrawal_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
            update_mask=update_mask,
            ach_withdrawal_schedule_update=utils.get_pydantic_model(
                ach_withdrawal_schedule_update, components.AchWithdrawalScheduleUpdate
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_withdrawal_schedule_update,
                False,
                False,
                "json",
                components.AchWithdrawalScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_UpdateAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_ach_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        ach_withdrawal_schedule_update: Union[
            components.AchWithdrawalScheduleUpdate,
            components.AchWithdrawalScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse:
        r"""Update ACH Withdrawal Schedule

        Updates the amount of an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param ach_withdrawal_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
            update_mask=update_mask,
            ach_withdrawal_schedule_update=utils.get_pydantic_model(
                ach_withdrawal_schedule_update, components.AchWithdrawalScheduleUpdate
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.ach_withdrawal_schedule_update,
                False,
                False,
                "json",
                components.AchWithdrawalScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_UpdateAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesUpdateAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def cancel_ach_withdrawal_schedule(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        cancel_ach_withdrawal_schedule_request_create: Union[
            components.CancelAchWithdrawalScheduleRequestCreate,
            components.CancelAchWithdrawalScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse:
        r"""Cancel ACH Withdrawal Schedule

        Cancels an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param cancel_ach_withdrawal_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
            cancel_ach_withdrawal_schedule_request_create=utils.get_pydantic_model(
                cancel_ach_withdrawal_schedule_request_create,
                components.CancelAchWithdrawalScheduleRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_ach_withdrawal_schedule_request_create,
                False,
                False,
                "json",
                components.CancelAchWithdrawalScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_CancelAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def cancel_ach_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        ach_withdrawal_schedule_id: str,
        cancel_ach_withdrawal_schedule_request_create: Union[
            components.CancelAchWithdrawalScheduleRequestCreate,
            components.CancelAchWithdrawalScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse:
        r"""Cancel ACH Withdrawal Schedule

        Cancels an ACH withdrawal transfer schedule

        :param account_id: The account id.
        :param ach_withdrawal_schedule_id: The achWithdrawalSchedule id.
        :param cancel_ach_withdrawal_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleRequest(
            account_id=account_id,
            ach_withdrawal_schedule_id=ach_withdrawal_schedule_id,
            cancel_ach_withdrawal_schedule_request_create=utils.get_pydantic_model(
                cancel_ach_withdrawal_schedule_request_create,
                components.CancelAchWithdrawalScheduleRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/achWithdrawalSchedules/{achWithdrawalSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_ach_withdrawal_schedule_request_create,
                False,
                False,
                "json",
                components.CancelAchWithdrawalScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AchWithdrawalSchedules_CancelAchWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse(
                ach_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.AchWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.AchWithdrawalSchedulesCancelAchWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def create_wire_withdrawal_schedule(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_create: Union[
            components.WireWithdrawalScheduleCreate,
            components.WireWithdrawalScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse:
        r"""Create Wire Withdrawal Schedule

        Creates a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_create=utils.get_pydantic_model(
                wire_withdrawal_schedule_create, components.WireWithdrawalScheduleCreate
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.wire_withdrawal_schedule_create,
                False,
                False,
                "json",
                components.WireWithdrawalScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_CreateWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_wire_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_create: Union[
            components.WireWithdrawalScheduleCreate,
            components.WireWithdrawalScheduleCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse:
        r"""Create Wire Withdrawal Schedule

        Creates a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_create=utils.get_pydantic_model(
                wire_withdrawal_schedule_create, components.WireWithdrawalScheduleCreate
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.wire_withdrawal_schedule_create,
                False,
                False,
                "json",
                components.WireWithdrawalScheduleCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_CreateWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "409"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCreateWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def list_wire_withdrawal_schedules(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse:
        r"""List Wire Withdrawal Schedules

        Return a list of Wire withdrawal schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_ListWireWithdrawalSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse(
                    list_wire_withdrawal_schedules_response=unmarshal_json_response(
                        Optional[components.ListWireWithdrawalSchedulesResponse],
                        http_res,
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_wire_withdrawal_schedules_async(
        self,
        *,
        account_id: str,
        filter_: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse:
        r"""List Wire Withdrawal Schedules

        Return a list of Wire withdrawal schedules for the specified account and filter params

        :param account_id: The account id.
        :param filter_: A CEL string to filter results; See the [CEL Search](https://developer.apexclearing.com/apex-fintech-solutions/docs/cel-search) page in Guides for more information; Filter options include:  `state`  `start_date`  `end_date`
        :param page_size: The maximum number of schedules to return. The service may return fewer than this value. If unspecified, at most 25 schedules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: The page token to request
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesRequest(
            account_id=account_id,
            filter_=filter_,
            page_size=page_size,
            page_token=page_token,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_ListWireWithdrawalSchedules",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse(
                    list_wire_withdrawal_schedules_response=unmarshal_json_response(
                        Optional[components.ListWireWithdrawalSchedulesResponse],
                        http_res,
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesListWireWithdrawalSchedulesResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def get_wire_withdrawal_schedule(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse:
        r"""Get Wire Withdrawal Schedule

        Gets a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_GetWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse(
                wire_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.WireWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_wire_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse:
        r"""Get Wire Withdrawal Schedule

        Gets a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_GetWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse(
                wire_withdrawal_schedule=unmarshal_json_response(
                    Optional[components.WireWithdrawalSchedule], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.WireWithdrawalSchedulesGetWireWithdrawalScheduleResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def update_wire_withdrawal_schedule(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        wire_withdrawal_schedule_update: Union[
            components.WireWithdrawalScheduleUpdate,
            components.WireWithdrawalScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse:
        r"""Update Wire Withdrawal Schedule

        Updates the amount of a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param wire_withdrawal_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
            update_mask=update_mask,
            wire_withdrawal_schedule_update=utils.get_pydantic_model(
                wire_withdrawal_schedule_update, components.WireWithdrawalScheduleUpdate
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.wire_withdrawal_schedule_update,
                False,
                False,
                "json",
                components.WireWithdrawalScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_UpdateWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_wire_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        wire_withdrawal_schedule_update: Union[
            components.WireWithdrawalScheduleUpdate,
            components.WireWithdrawalScheduleUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse:
        r"""Update Wire Withdrawal Schedule

        Updates the amount of a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param wire_withdrawal_schedule_update:
        :param update_mask: A field mask representing the update. Note: only the 'schedule_details.amount' field of a schedule is currently updatable
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
            update_mask=update_mask,
            wire_withdrawal_schedule_update=utils.get_pydantic_model(
                wire_withdrawal_schedule_update, components.WireWithdrawalScheduleUpdate
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.wire_withdrawal_schedule_update,
                False,
                False,
                "json",
                components.WireWithdrawalScheduleUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_UpdateWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesUpdateWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def cancel_wire_withdrawal_schedule(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        cancel_wire_withdrawal_schedule_request_create: Union[
            components.CancelWireWithdrawalScheduleRequestCreate,
            components.CancelWireWithdrawalScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse:
        r"""Cancel Wire Withdrawal Schedule

        Cancels a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param cancel_wire_withdrawal_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
            cancel_wire_withdrawal_schedule_request_create=utils.get_pydantic_model(
                cancel_wire_withdrawal_schedule_request_create,
                components.CancelWireWithdrawalScheduleRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_wire_withdrawal_schedule_request_create,
                False,
                False,
                "json",
                components.CancelWireWithdrawalScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_CancelWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def cancel_wire_withdrawal_schedule_async(
        self,
        *,
        account_id: str,
        wire_withdrawal_schedule_id: str,
        cancel_wire_withdrawal_schedule_request_create: Union[
            components.CancelWireWithdrawalScheduleRequestCreate,
            components.CancelWireWithdrawalScheduleRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse:
        r"""Cancel Wire Withdrawal Schedule

        Cancels a Wire withdrawal transfer schedule

        :param account_id: The account id.
        :param wire_withdrawal_schedule_id: The wireWithdrawalSchedule id.
        :param cancel_wire_withdrawal_schedule_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleRequest(
            account_id=account_id,
            wire_withdrawal_schedule_id=wire_withdrawal_schedule_id,
            cancel_wire_withdrawal_schedule_request_create=utils.get_pydantic_model(
                cancel_wire_withdrawal_schedule_request_create,
                components.CancelWireWithdrawalScheduleRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/wireWithdrawalSchedules/{wireWithdrawalSchedule_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_wire_withdrawal_schedule_request_create,
                False,
                False,
                "json",
                components.CancelWireWithdrawalScheduleRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="WireWithdrawalSchedules_CancelWireWithdrawalSchedule",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse(
                    wire_withdrawal_schedule=unmarshal_json_response(
                        Optional[components.WireWithdrawalSchedule], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return (
                operations.WireWithdrawalSchedulesCancelWireWithdrawalScheduleResponse(
                    status=unmarshal_json_response(
                        Optional[components.Status], http_res
                    ),
                    http_meta=components.HTTPMetadata(request=req, response=http_res),
                )
            )

        raise errors.SDKError("Unexpected response received", http_res)
