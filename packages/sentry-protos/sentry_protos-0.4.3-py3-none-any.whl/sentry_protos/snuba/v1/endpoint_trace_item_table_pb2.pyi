"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sentry_protos.snuba.v1.attribute_conditional_aggregation_pb2
import sentry_protos.snuba.v1.formula_pb2
import sentry_protos.snuba.v1.request_common_pb2
import sentry_protos.snuba.v1.trace_item_attribute_pb2
import sentry_protos.snuba.v1.trace_item_filter_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class TraceItemTableRequest(google.protobuf.message.Message):
    """This is a request to the TraceItemTable endpoint,
    it is used to query for TraceItems (ex. spans)
    it returns tabular data where each row is a TraceItem,
    and the columns are the attributes of the TraceItem
    it can also be used for aggregations
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class OrderBy(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COLUMN_FIELD_NUMBER: builtins.int
        DESCENDING_FIELD_NUMBER: builtins.int
        descending: builtins.bool
        @property
        def column(self) -> global___Column: ...
        def __init__(
            self,
            *,
            column: global___Column | None = ...,
            descending: builtins.bool = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["column", b"column"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["column", b"column", "descending", b"descending"]) -> None: ...

    META_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    GROUP_BY_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    VIRTUAL_COLUMN_CONTEXTS_FIELD_NUMBER: builtins.int
    AGGREGATION_FILTER_FIELD_NUMBER: builtins.int
    TRACE_FILTERS_FIELD_NUMBER: builtins.int
    limit: builtins.int
    @property
    def meta(self) -> sentry_protos.snuba.v1.request_common_pb2.RequestMeta: ...
    @property
    def columns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Column]:
        """the columns or aggregations you want to get"""

    @property
    def filter(self) -> sentry_protos.snuba.v1.trace_item_filter_pb2.TraceItemFilter:
        """filter out trace items you dont want"""

    @property
    def order_by(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TraceItemTableRequest.OrderBy]: ...
    @property
    def group_by(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeKey]: ...
    @property
    def page_token(self) -> sentry_protos.snuba.v1.request_common_pb2.PageToken:
        """optional, used for pagination, the next page token will be returned in the response"""

    @property
    def virtual_column_contexts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[sentry_protos.snuba.v1.trace_item_attribute_pb2.VirtualColumnContext]: ...
    @property
    def aggregation_filter(self) -> global___AggregationFilter:
        """optional, filter out results of aggregates, same as SQL HAVING"""

    @property
    def trace_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[sentry_protos.snuba.v1.request_common_pb2.TraceItemFilterWithType]:
        """A list of filters applied to each item type provided. These filters will be applied on a trace level to find traces
        that contain each of the provided items with matching conditions. The overall request will then only apply on those traces.
        If specified, the endpoint will only consider traces that match all the filters.
        ex: Find spans in traces containing a span with op = 'db' that also contain errors with message = 'timeout'
        """

    def __init__(
        self,
        *,
        meta: sentry_protos.snuba.v1.request_common_pb2.RequestMeta | None = ...,
        columns: collections.abc.Iterable[global___Column] | None = ...,
        filter: sentry_protos.snuba.v1.trace_item_filter_pb2.TraceItemFilter | None = ...,
        order_by: collections.abc.Iterable[global___TraceItemTableRequest.OrderBy] | None = ...,
        group_by: collections.abc.Iterable[sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeKey] | None = ...,
        limit: builtins.int = ...,
        page_token: sentry_protos.snuba.v1.request_common_pb2.PageToken | None = ...,
        virtual_column_contexts: collections.abc.Iterable[sentry_protos.snuba.v1.trace_item_attribute_pb2.VirtualColumnContext] | None = ...,
        aggregation_filter: global___AggregationFilter | None = ...,
        trace_filters: collections.abc.Iterable[sentry_protos.snuba.v1.request_common_pb2.TraceItemFilterWithType] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation_filter", b"aggregation_filter", "filter", b"filter", "meta", b"meta", "page_token", b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_filter", b"aggregation_filter", "columns", b"columns", "filter", b"filter", "group_by", b"group_by", "limit", b"limit", "meta", b"meta", "order_by", b"order_by", "page_token", b"page_token", "trace_filters", b"trace_filters", "virtual_column_contexts", b"virtual_column_contexts"]) -> None: ...

global___TraceItemTableRequest = TraceItemTableRequest

@typing.final
class AggregationAndFilter(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FILTERS_FIELD_NUMBER: builtins.int
    @property
    def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationFilter]: ...
    def __init__(
        self,
        *,
        filters: collections.abc.Iterable[global___AggregationFilter] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["filters", b"filters"]) -> None: ...

global___AggregationAndFilter = AggregationAndFilter

@typing.final
class AggregationOrFilter(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FILTERS_FIELD_NUMBER: builtins.int
    @property
    def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationFilter]: ...
    def __init__(
        self,
        *,
        filters: collections.abc.Iterable[global___AggregationFilter] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["filters", b"filters"]) -> None: ...

global___AggregationOrFilter = AggregationOrFilter

@typing.final
class AggregationComparisonFilter(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Op:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[AggregationComparisonFilter._Op.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OP_UNSPECIFIED: AggregationComparisonFilter._Op.ValueType  # 0
        OP_LESS_THAN: AggregationComparisonFilter._Op.ValueType  # 1
        OP_GREATER_THAN: AggregationComparisonFilter._Op.ValueType  # 2
        OP_LESS_THAN_OR_EQUALS: AggregationComparisonFilter._Op.ValueType  # 3
        OP_GREATER_THAN_OR_EQUALS: AggregationComparisonFilter._Op.ValueType  # 4
        OP_EQUALS: AggregationComparisonFilter._Op.ValueType  # 5
        OP_NOT_EQUALS: AggregationComparisonFilter._Op.ValueType  # 6

    class Op(_Op, metaclass=_OpEnumTypeWrapper): ...
    OP_UNSPECIFIED: AggregationComparisonFilter.Op.ValueType  # 0
    OP_LESS_THAN: AggregationComparisonFilter.Op.ValueType  # 1
    OP_GREATER_THAN: AggregationComparisonFilter.Op.ValueType  # 2
    OP_LESS_THAN_OR_EQUALS: AggregationComparisonFilter.Op.ValueType  # 3
    OP_GREATER_THAN_OR_EQUALS: AggregationComparisonFilter.Op.ValueType  # 4
    OP_EQUALS: AggregationComparisonFilter.Op.ValueType  # 5
    OP_NOT_EQUALS: AggregationComparisonFilter.Op.ValueType  # 6

    COLUMN_FIELD_NUMBER: builtins.int
    OP_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    AGGREGATION_FIELD_NUMBER: builtins.int
    CONDITIONAL_AGGREGATION_FIELD_NUMBER: builtins.int
    FORMULA_FIELD_NUMBER: builtins.int
    op: global___AggregationComparisonFilter.Op.ValueType
    val: builtins.float
    @property
    def column(self) -> global___Column:
        """deprecated as columns should always be aggregated in a post aggregation filter"""

    @property
    def value(self) -> sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeValue:
        """since only aggregated columns are supported, the value should be numeric"""

    @property
    def aggregation(self) -> sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeAggregation: ...
    @property
    def conditional_aggregation(self) -> sentry_protos.snuba.v1.attribute_conditional_aggregation_pb2.AttributeConditionalAggregation: ...
    @property
    def formula(self) -> global___Column.BinaryFormula: ...
    def __init__(
        self,
        *,
        column: global___Column | None = ...,
        op: global___AggregationComparisonFilter.Op.ValueType = ...,
        value: sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeValue | None = ...,
        val: builtins.float = ...,
        aggregation: sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeAggregation | None = ...,
        conditional_aggregation: sentry_protos.snuba.v1.attribute_conditional_aggregation_pb2.AttributeConditionalAggregation | None = ...,
        formula: global___Column.BinaryFormula | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation", b"aggregation", "column", b"column", "conditional_aggregation", b"conditional_aggregation", "formula", b"formula", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation", b"aggregation", "column", b"column", "conditional_aggregation", b"conditional_aggregation", "formula", b"formula", "op", b"op", "val", b"val", "value", b"value"]) -> None: ...

global___AggregationComparisonFilter = AggregationComparisonFilter

@typing.final
class AggregationFilter(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AND_FILTER_FIELD_NUMBER: builtins.int
    OR_FILTER_FIELD_NUMBER: builtins.int
    COMPARISON_FILTER_FIELD_NUMBER: builtins.int
    @property
    def and_filter(self) -> global___AggregationAndFilter: ...
    @property
    def or_filter(self) -> global___AggregationOrFilter: ...
    @property
    def comparison_filter(self) -> global___AggregationComparisonFilter: ...
    def __init__(
        self,
        *,
        and_filter: global___AggregationAndFilter | None = ...,
        or_filter: global___AggregationOrFilter | None = ...,
        comparison_filter: global___AggregationComparisonFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["and_filter", b"and_filter", "comparison_filter", b"comparison_filter", "or_filter", b"or_filter", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["and_filter", b"and_filter", "comparison_filter", b"comparison_filter", "or_filter", b"or_filter", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["and_filter", "or_filter", "comparison_filter"] | None: ...

global___AggregationFilter = AggregationFilter

@typing.final
class Column(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class BinaryFormula(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Op:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Column.BinaryFormula._Op.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            OP_UNSPECIFIED: Column.BinaryFormula._Op.ValueType  # 0
            OP_DIVIDE: Column.BinaryFormula._Op.ValueType  # 1
            OP_MULTIPLY: Column.BinaryFormula._Op.ValueType  # 2
            OP_ADD: Column.BinaryFormula._Op.ValueType  # 3
            OP_SUBTRACT: Column.BinaryFormula._Op.ValueType  # 4

        class Op(_Op, metaclass=_OpEnumTypeWrapper): ...
        OP_UNSPECIFIED: Column.BinaryFormula.Op.ValueType  # 0
        OP_DIVIDE: Column.BinaryFormula.Op.ValueType  # 1
        OP_MULTIPLY: Column.BinaryFormula.Op.ValueType  # 2
        OP_ADD: Column.BinaryFormula.Op.ValueType  # 3
        OP_SUBTRACT: Column.BinaryFormula.Op.ValueType  # 4

        OP_FIELD_NUMBER: builtins.int
        LEFT_FIELD_NUMBER: builtins.int
        RIGHT_FIELD_NUMBER: builtins.int
        DEFAULT_VALUE_DOUBLE_FIELD_NUMBER: builtins.int
        DEFAULT_VALUE_INT64_FIELD_NUMBER: builtins.int
        op: global___Column.BinaryFormula.Op.ValueType
        default_value_double: builtins.float
        default_value_int64: builtins.int
        @property
        def left(self) -> global___Column: ...
        @property
        def right(self) -> global___Column: ...
        def __init__(
            self,
            *,
            op: global___Column.BinaryFormula.Op.ValueType = ...,
            left: global___Column | None = ...,
            right: global___Column | None = ...,
            default_value_double: builtins.float = ...,
            default_value_int64: builtins.int = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["default_value", b"default_value", "default_value_double", b"default_value_double", "default_value_int64", b"default_value_int64", "left", b"left", "right", b"right"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "default_value_double", b"default_value_double", "default_value_int64", b"default_value_int64", "left", b"left", "op", b"op", "right", b"right"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["default_value", b"default_value"]) -> typing.Literal["default_value_double", "default_value_int64"] | None: ...

    KEY_FIELD_NUMBER: builtins.int
    AGGREGATION_FIELD_NUMBER: builtins.int
    CONDITIONAL_AGGREGATION_FIELD_NUMBER: builtins.int
    FORMULA_FIELD_NUMBER: builtins.int
    LITERAL_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    label: builtins.str
    @property
    def key(self) -> sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeKey: ...
    @property
    def aggregation(self) -> sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeAggregation: ...
    @property
    def conditional_aggregation(self) -> sentry_protos.snuba.v1.attribute_conditional_aggregation_pb2.AttributeConditionalAggregation: ...
    @property
    def formula(self) -> global___Column.BinaryFormula: ...
    @property
    def literal(self) -> sentry_protos.snuba.v1.formula_pb2.Literal: ...
    def __init__(
        self,
        *,
        key: sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeKey | None = ...,
        aggregation: sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeAggregation | None = ...,
        conditional_aggregation: sentry_protos.snuba.v1.attribute_conditional_aggregation_pb2.AttributeConditionalAggregation | None = ...,
        formula: global___Column.BinaryFormula | None = ...,
        literal: sentry_protos.snuba.v1.formula_pb2.Literal | None = ...,
        label: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation", b"aggregation", "column", b"column", "conditional_aggregation", b"conditional_aggregation", "formula", b"formula", "key", b"key", "literal", b"literal"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation", b"aggregation", "column", b"column", "conditional_aggregation", b"conditional_aggregation", "formula", b"formula", "key", b"key", "label", b"label", "literal", b"literal"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["column", b"column"]) -> typing.Literal["key", "aggregation", "conditional_aggregation", "formula", "literal"] | None: ...

global___Column = Column

@typing.final
class TraceItemColumnValues(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ATTRIBUTE_NAME_FIELD_NUMBER: builtins.int
    RESULTS_FIELD_NUMBER: builtins.int
    RELIABILITIES_FIELD_NUMBER: builtins.int
    attribute_name: builtins.str
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeValue]: ...
    @property
    def reliabilities(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[sentry_protos.snuba.v1.trace_item_attribute_pb2.Reliability.ValueType]:
        """reliability of the values based on confidence interval and sample size math"""

    def __init__(
        self,
        *,
        attribute_name: builtins.str = ...,
        results: collections.abc.Iterable[sentry_protos.snuba.v1.trace_item_attribute_pb2.AttributeValue] | None = ...,
        reliabilities: collections.abc.Iterable[sentry_protos.snuba.v1.trace_item_attribute_pb2.Reliability.ValueType] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["attribute_name", b"attribute_name", "reliabilities", b"reliabilities", "results", b"results"]) -> None: ...

global___TraceItemColumnValues = TraceItemColumnValues

@typing.final
class TraceItemTableResponse(google.protobuf.message.Message):
    """this is a response from the TraceItemTable endpoint
    it is the counterpart to TraceItemTableRequest
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COLUMN_VALUES_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def column_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TraceItemColumnValues]:
        """the rows"""

    @property
    def page_token(self) -> sentry_protos.snuba.v1.request_common_pb2.PageToken:
        """page token for the next page of results"""

    @property
    def meta(self) -> sentry_protos.snuba.v1.request_common_pb2.ResponseMeta: ...
    def __init__(
        self,
        *,
        column_values: collections.abc.Iterable[global___TraceItemColumnValues] | None = ...,
        page_token: sentry_protos.snuba.v1.request_common_pb2.PageToken | None = ...,
        meta: sentry_protos.snuba.v1.request_common_pb2.ResponseMeta | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["meta", b"meta", "page_token", b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["column_values", b"column_values", "meta", b"meta", "page_token", b"page_token"]) -> None: ...

global___TraceItemTableResponse = TraceItemTableResponse
