# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AzureMetricsIntegrationPrincipal',
    'AzureMetricsIntegrationScrapeConfig',
    'AzureMetricsIntegrationScrapeConfigResourceType',
    'ConsumptionBudgetAlertActionConfig',
    'ConsumptionBudgetPriority',
    'ConsumptionBudgetPriorityFilter',
    'ConsumptionBudgetPriorityFilterLogFilter',
    'ConsumptionBudgetThreshold',
    'ConsumptionBudgetThresholdInstantRate',
    'ConsumptionBudgetThresholdVolume',
    'ConsumptionConfigPartition',
    'ConsumptionConfigPartitionFilter',
    'ConsumptionConfigPartitionFilterCondition',
    'ConsumptionConfigPartitionFilterConditionLogFilter',
    'ConsumptionConfigPartitionPartition',
    'ConsumptionConfigPartitionPartitionFilter',
    'ConsumptionConfigPartitionPartitionFilterCondition',
    'ConsumptionConfigPartitionPartitionFilterConditionLogFilter',
    'ConsumptionConfigPartitionPartitionPartition',
    'ConsumptionConfigPartitionPartitionPartitionFilter',
    'ConsumptionConfigPartitionPartitionPartitionFilterCondition',
    'ConsumptionConfigPartitionPartitionPartitionFilterConditionLogFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionFilterConditionLogFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilter',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition',
    'ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter',
    'DatasetConfiguration',
    'DatasetConfigurationLogDataset',
    'DatasetConfigurationLogDatasetMatchCriteria',
    'DatasetConfigurationTraceDataset',
    'DatasetConfigurationTraceDatasetMatchCriteria',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpan',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanError',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanIsRootSpan',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanService',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanSpanCount',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanTag',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanTagNumericValue',
    'DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue',
    'DatasetConfigurationTraceDatasetMatchCriteriaTrace',
    'DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration',
    'DatasetConfigurationTraceDatasetMatchCriteriaTraceError',
    'DerivedLabelMetricLabel',
    'DerivedLabelMetricLabelConstructedLabel',
    'DerivedLabelMetricLabelConstructedLabelValueDefinition',
    'DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter',
    'DerivedLabelMetricLabelMappingLabel',
    'DerivedLabelMetricLabelMappingLabelNameMapping',
    'DerivedLabelMetricLabelMappingLabelNameMappingFilter',
    'DerivedLabelMetricLabelMappingLabelNameMappingValueMapping',
    'DerivedLabelMetricLabelMappingLabelValueMapping',
    'DerivedLabelSpanTag',
    'DerivedLabelSpanTagNameMapping',
    'DerivedMetricQuery',
    'DerivedMetricQueryQuery',
    'DerivedMetricQueryQueryVariable',
    'DerivedMetricQuerySelector',
    'DropRuleValueBasedDrop',
    'GcpMetricsIntegrationMetricGroup',
    'GcpMetricsIntegrationServiceAccount',
    'LogAllocationConfigDatasetAllocation',
    'LogAllocationConfigDatasetAllocationAllocation',
    'LogAllocationConfigDatasetAllocationPriorities',
    'LogAllocationConfigDatasetAllocationPrioritiesHighPriorityFilter',
    'LogAllocationConfigDatasetAllocationPrioritiesLowPriorityFilter',
    'LogAllocationConfigDefaultDataset',
    'LogAllocationConfigDefaultDatasetAllocation',
    'LogAllocationConfigDefaultDatasetPriorities',
    'LogAllocationConfigDefaultDatasetPrioritiesHighPriorityFilter',
    'LogAllocationConfigDefaultDatasetPrioritiesLowPriorityFilter',
    'LogControlConfigRule',
    'LogControlConfigRuleDropField',
    'LogControlConfigRuleDropFieldParentPath',
    'LogControlConfigRuleEmitMetrics',
    'LogControlConfigRuleEmitMetricsCounter',
    'LogControlConfigRuleEmitMetricsCounterValue',
    'LogControlConfigRuleEmitMetricsGauge',
    'LogControlConfigRuleEmitMetricsGaugeValue',
    'LogControlConfigRuleEmitMetricsHistogram',
    'LogControlConfigRuleEmitMetricsHistogramValue',
    'LogControlConfigRuleEmitMetricsLabel',
    'LogControlConfigRuleEmitMetricsLabelValue',
    'LogControlConfigRuleReplaceField',
    'LogControlConfigRuleReplaceFieldField',
    'LogControlConfigRuleReplaceFieldMappedValue',
    'LogControlConfigRuleReplaceFieldMappedValuePair',
    'LogControlConfigRuleReplaceFieldStaticValue',
    'LogControlConfigRuleSample',
    'LogIngestConfigFieldNormalization',
    'LogIngestConfigFieldNormalizationCustomFieldNormalization',
    'LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization',
    'LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalizationSource',
    'LogIngestConfigFieldNormalizationMessage',
    'LogIngestConfigFieldNormalizationMessageSource',
    'LogIngestConfigFieldNormalizationPrimaryKey',
    'LogIngestConfigFieldNormalizationPrimaryKeyNormalization',
    'LogIngestConfigFieldNormalizationPrimaryKeyNormalizationSource',
    'LogIngestConfigFieldNormalizationSeverity',
    'LogIngestConfigFieldNormalizationSeveritySource',
    'LogIngestConfigFieldNormalizationTimestamp',
    'LogIngestConfigFieldNormalizationTimestampSource',
    'LogIngestConfigFieldParser',
    'LogIngestConfigFieldParserDestination',
    'LogIngestConfigFieldParserParser',
    'LogIngestConfigFieldParserParserKeyValueParser',
    'LogIngestConfigFieldParserParserRegexParser',
    'LogIngestConfigFieldParserSource',
    'LogIngestConfigPlaintextParser',
    'LogIngestConfigPlaintextParserParser',
    'LogIngestConfigPlaintextParserParserKeyValueParser',
    'LogIngestConfigPlaintextParserParserRegexParser',
    'LogscaleActionEmailAction',
    'LogscaleActionHumioAction',
    'LogscaleActionOpsGenieAction',
    'LogscaleActionPagerDutyAction',
    'LogscaleActionSlackAction',
    'LogscaleActionSlackPostMessageAction',
    'LogscaleActionUploadFileAction',
    'LogscaleActionVictorOpsAction',
    'LogscaleActionWebhookAction',
    'MappingRuleStoragePolicy',
    'MonitorQuery',
    'MonitorSchedule',
    'MonitorScheduleRange',
    'MonitorSeriesConditions',
    'MonitorSeriesConditionsCondition',
    'MonitorSeriesConditionsOverride',
    'MonitorSeriesConditionsOverrideCondition',
    'MonitorSeriesConditionsOverrideLabelMatcher',
    'MonitorSignalGrouping',
    'NotificationPolicyOverride',
    'NotificationPolicyOverrideAlertLabelMatcher',
    'NotificationPolicyOverrideRoute',
    'NotificationPolicyOverrideRouteGroupBy',
    'NotificationPolicyRoute',
    'NotificationPolicyRouteGroupBy',
    'OpsgenieAlertNotifierResponder',
    'OtelMetricsIngestionResourceAttributes',
    'PagerdutyAlertNotifierImage',
    'PagerdutyAlertNotifierLink',
    'ResourcePoolsConfigDefaultPool',
    'ResourcePoolsConfigDefaultPoolAllocation',
    'ResourcePoolsConfigDefaultPoolAllocationFixedValue',
    'ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold',
    'ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities',
    'ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority',
    'ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority',
    'ResourcePoolsConfigDefaultPoolPriorities',
    'ResourcePoolsConfigDefaultPoolPriorityThreshold',
    'ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities',
    'ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority',
    'ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority',
    'ResourcePoolsConfigPool',
    'ResourcePoolsConfigPoolAllocation',
    'ResourcePoolsConfigPoolAllocationFixedValue',
    'ResourcePoolsConfigPoolAllocationPriorityThreshold',
    'ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities',
    'ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority',
    'ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority',
    'ResourcePoolsConfigPoolPriorities',
    'RollupRuleGraphiteLabelPolicy',
    'RollupRuleGraphiteLabelPolicyReplace',
    'RollupRuleStoragePolicies',
    'SLODefinition',
    'SLODefinitionBurnRateAlertingConfig',
    'SLODefinitionTimeWindow',
    'SLOSignalGrouping',
    'SLOSli',
    'SLOSliAdditionalPromqlFilter',
    'SLOSliCustomIndicator',
    'SLOSliCustomTimesliceIndicator',
    'SLOSliCustomTimesliceIndicatorCondition',
    'ServiceAccountRestriction',
    'SlackAlertNotifierAction',
    'SlackAlertNotifierField',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategy',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy',
    'TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy',
    'TraceMetricsRuleGroupBy',
    'TraceMetricsRuleGroupByKey',
    'TraceMetricsRuleTraceFilter',
    'TraceMetricsRuleTraceFilterSpan',
    'TraceMetricsRuleTraceFilterSpanDuration',
    'TraceMetricsRuleTraceFilterSpanError',
    'TraceMetricsRuleTraceFilterSpanIsRootSpan',
    'TraceMetricsRuleTraceFilterSpanOperation',
    'TraceMetricsRuleTraceFilterSpanParentOperation',
    'TraceMetricsRuleTraceFilterSpanParentService',
    'TraceMetricsRuleTraceFilterSpanService',
    'TraceMetricsRuleTraceFilterSpanSpanCount',
    'TraceMetricsRuleTraceFilterSpanTag',
    'TraceMetricsRuleTraceFilterSpanTagNumericValue',
    'TraceMetricsRuleTraceFilterSpanTagValue',
    'TraceMetricsRuleTraceFilterTrace',
    'TraceMetricsRuleTraceFilterTraceDuration',
    'TraceMetricsRuleTraceFilterTraceError',
    'TraceTailSamplingRulesDefaultSampleRate',
    'TraceTailSamplingRulesRule',
    'TraceTailSamplingRulesRuleFilter',
    'TraceTailSamplingRulesRuleFilterSpan',
    'TraceTailSamplingRulesRuleFilterSpanDuration',
    'TraceTailSamplingRulesRuleFilterSpanError',
    'TraceTailSamplingRulesRuleFilterSpanIsRootSpan',
    'TraceTailSamplingRulesRuleFilterSpanOperation',
    'TraceTailSamplingRulesRuleFilterSpanParentOperation',
    'TraceTailSamplingRulesRuleFilterSpanParentService',
    'TraceTailSamplingRulesRuleFilterSpanService',
    'TraceTailSamplingRulesRuleFilterSpanSpanCount',
    'TraceTailSamplingRulesRuleFilterSpanTag',
    'TraceTailSamplingRulesRuleFilterSpanTagNumericValue',
    'TraceTailSamplingRulesRuleFilterSpanTagValue',
    'TraceTailSamplingRulesRuleFilterTrace',
    'TraceTailSamplingRulesRuleFilterTraceDuration',
    'TraceTailSamplingRulesRuleFilterTraceError',
]

@pulumi.output_type
class AzureMetricsIntegrationPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsIntegrationPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsIntegrationPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsIntegrationPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AzureMetricsIntegrationScrapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypes":
            suggest = "resource_types"
        elif key == "subscriptionIds":
            suggest = "subscription_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsIntegrationScrapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsIntegrationScrapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsIntegrationScrapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence[str]] = None,
                 resource_types: Optional[Sequence['outputs.AzureMetricsIntegrationScrapeConfigResourceType']] = None,
                 subscription_ids: Optional[Sequence[str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if subscription_ids is not None:
            pulumi.set(__self__, "subscription_ids", subscription_ids)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence['outputs.AzureMetricsIntegrationScrapeConfigResourceType']]:
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter(name="subscriptionIds")
    def subscription_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subscription_ids")


@pulumi.output_type
class AzureMetricsIntegrationScrapeConfigResourceType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricNames":
            suggest = "metric_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsIntegrationScrapeConfigResourceType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsIntegrationScrapeConfigResourceType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsIntegrationScrapeConfigResourceType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_names: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "metric_names")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ConsumptionBudgetAlertActionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instantRateSustainSecs":
            suggest = "instant_rate_sustain_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionBudgetAlertActionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionBudgetAlertActionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionBudgetAlertActionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 instant_rate_sustain_secs: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if instant_rate_sustain_secs is not None:
            pulumi.set(__self__, "instant_rate_sustain_secs", instant_rate_sustain_secs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="instantRateSustainSecs")
    def instant_rate_sustain_secs(self) -> Optional[int]:
        return pulumi.get(self, "instant_rate_sustain_secs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class ConsumptionBudgetPriority(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionBudgetPriorityFilter']] = None,
                 priority: Optional[int] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionBudgetPriorityFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class ConsumptionBudgetPriorityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionBudgetPriorityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionBudgetPriorityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionBudgetPriorityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionBudgetPriorityFilterLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionBudgetPriorityFilterLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionBudgetPriorityFilterLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionBudgetThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instantRate":
            suggest = "instant_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionBudgetThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionBudgetThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionBudgetThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 instant_rate: Optional['outputs.ConsumptionBudgetThresholdInstantRate'] = None,
                 type: Optional[str] = None,
                 volume: Optional['outputs.ConsumptionBudgetThresholdVolume'] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if instant_rate is not None:
            pulumi.set(__self__, "instant_rate", instant_rate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="instantRate")
    def instant_rate(self) -> Optional['outputs.ConsumptionBudgetThresholdInstantRate']:
        return pulumi.get(self, "instant_rate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def volume(self) -> Optional['outputs.ConsumptionBudgetThresholdVolume']:
        return pulumi.get(self, "volume")


@pulumi.output_type
class ConsumptionBudgetThresholdInstantRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValuePerSec":
            suggest = "fixed_value_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionBudgetThresholdInstantRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionBudgetThresholdInstantRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionBudgetThresholdInstantRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value_per_sec: Optional[int] = None):
        if fixed_value_per_sec is not None:
            pulumi.set(__self__, "fixed_value_per_sec", fixed_value_per_sec)

    @property
    @pulumi.getter(name="fixedValuePerSec")
    def fixed_value_per_sec(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value_per_sec")


@pulumi.output_type
class ConsumptionBudgetThresholdVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionBudgetThresholdVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionBudgetThresholdVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionBudgetThresholdVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")


@pulumi.output_type
class ConsumptionConfigPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionFilter']] = None,
                 name: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartition']] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionConfigPartitionPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionFilter']] = None,
                 name: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartition']] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionFilter']] = None,
                 name: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartition']] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionPartitionPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionPartitionPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionPartitionPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilter']] = None,
                 name: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartition']] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilter']] = None,
                 name: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartition']] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartition(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilter']] = None,
                 name: Optional[str] = None,
                 slug: Optional[str] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> Optional[str]:
        return pulumi.get(self, "slug")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilter(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition']] = None,
                 operator: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "logFilter":
            suggest = "log_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: Optional[str] = None,
                 log_filter: Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter'] = None):
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if log_filter is not None:
            pulumi.set(__self__, "log_filter", log_filter)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="logFilter")
    def log_filter(self) -> Optional['outputs.ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter']:
        return pulumi.get(self, "log_filter")


@pulumi.output_type
class ConsumptionConfigPartitionPartitionPartitionPartitionPartitionPartitionFilterConditionLogFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DatasetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDataset":
            suggest = "log_dataset"
        elif key == "traceDataset":
            suggest = "trace_dataset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 log_dataset: Optional['outputs.DatasetConfigurationLogDataset'] = None,
                 trace_dataset: Optional['outputs.DatasetConfigurationTraceDataset'] = None):
        pulumi.set(__self__, "type", type)
        if log_dataset is not None:
            pulumi.set(__self__, "log_dataset", log_dataset)
        if trace_dataset is not None:
            pulumi.set(__self__, "trace_dataset", trace_dataset)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="logDataset")
    def log_dataset(self) -> Optional['outputs.DatasetConfigurationLogDataset']:
        return pulumi.get(self, "log_dataset")

    @property
    @pulumi.getter(name="traceDataset")
    def trace_dataset(self) -> Optional['outputs.DatasetConfigurationTraceDataset']:
        return pulumi.get(self, "trace_dataset")


@pulumi.output_type
class DatasetConfigurationLogDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriteria":
            suggest = "match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationLogDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationLogDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationLogDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_criteria: Optional['outputs.DatasetConfigurationLogDatasetMatchCriteria'] = None):
        if match_criteria is not None:
            pulumi.set(__self__, "match_criteria", match_criteria)

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> Optional['outputs.DatasetConfigurationLogDatasetMatchCriteria']:
        return pulumi.get(self, "match_criteria")


@pulumi.output_type
class DatasetConfigurationLogDatasetMatchCriteria(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DatasetConfigurationTraceDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriteria":
            suggest = "match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_criteria: 'outputs.DatasetConfigurationTraceDatasetMatchCriteria'):
        pulumi.set(__self__, "match_criteria", match_criteria)

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> 'outputs.DatasetConfigurationTraceDatasetMatchCriteria':
        return pulumi.get(self, "match_criteria")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteria(dict):
    def __init__(__self__, *,
                 spans: Optional[Sequence['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpan']] = None,
                 trace: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTrace'] = None):
        if spans is not None:
            pulumi.set(__self__, "spans", spans)
        if trace is not None:
            pulumi.set(__self__, "trace", trace)

    @property
    @pulumi.getter
    def spans(self) -> Optional[Sequence['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpan']]:
        return pulumi.get(self, "spans")

    @property
    @pulumi.getter
    def trace(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTrace']:
        return pulumi.get(self, "trace")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRootSpan":
            suggest = "is_root_span"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "parentOperation":
            suggest = "parent_operation"
        elif key == "parentService":
            suggest = "parent_service"
        elif key == "spanCount":
            suggest = "span_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration'] = None,
                 error: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanError'] = None,
                 is_root_span: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanIsRootSpan'] = None,
                 match_type: Optional[str] = None,
                 operation: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation'] = None,
                 parent_operation: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation'] = None,
                 parent_service: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService'] = None,
                 service: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanService'] = None,
                 span_count: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanSpanCount'] = None,
                 tags: Optional[Sequence['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTag']] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if is_root_span is not None:
            pulumi.set(__self__, "is_root_span", is_root_span)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if parent_operation is not None:
            pulumi.set(__self__, "parent_operation", parent_operation)
        if parent_service is not None:
            pulumi.set(__self__, "parent_service", parent_service)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if span_count is not None:
            pulumi.set(__self__, "span_count", span_count)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanError']:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="isRootSpan")
    def is_root_span(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanIsRootSpan']:
        return pulumi.get(self, "is_root_span")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def operation(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation']:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="parentOperation")
    def parent_operation(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation']:
        return pulumi.get(self, "parent_operation")

    @property
    @pulumi.getter(name="parentService")
    def parent_service(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService']:
        return pulumi.get(self, "parent_service")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanService']:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanCount")
    def span_count(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanSpanCount']:
        return pulumi.get(self, "span_count")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanIsRootSpan(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanParentOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanParentService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanSpanCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numericValue":
            suggest = "numeric_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 numeric_value: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTagNumericValue'] = None,
                 value: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue'] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if numeric_value is not None:
            pulumi.set(__self__, "numeric_value", numeric_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="numericValue")
    def numeric_value(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTagNumericValue']:
        return pulumi.get(self, "numeric_value")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanTagNumericValue(dict):
    def __init__(__self__, *,
                 comparison: str,
                 value: float):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaSpanTagValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaTrace(dict):
    def __init__(__self__, *,
                 duration: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration'] = None,
                 error: Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTraceError'] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.DatasetConfigurationTraceDatasetMatchCriteriaTraceError']:
        return pulumi.get(self, "error")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetConfigurationTraceDatasetMatchCriteriaTraceDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class DatasetConfigurationTraceDatasetMatchCriteriaTraceError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class DerivedLabelMetricLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "constructedLabel":
            suggest = "constructed_label"
        elif key == "mappingLabel":
            suggest = "mapping_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constructed_label: Optional['outputs.DerivedLabelMetricLabelConstructedLabel'] = None,
                 mapping_label: Optional['outputs.DerivedLabelMetricLabelMappingLabel'] = None):
        if constructed_label is not None:
            pulumi.set(__self__, "constructed_label", constructed_label)
        if mapping_label is not None:
            pulumi.set(__self__, "mapping_label", mapping_label)

    @property
    @pulumi.getter(name="constructedLabel")
    def constructed_label(self) -> Optional['outputs.DerivedLabelMetricLabelConstructedLabel']:
        return pulumi.get(self, "constructed_label")

    @property
    @pulumi.getter(name="mappingLabel")
    def mapping_label(self) -> Optional['outputs.DerivedLabelMetricLabelMappingLabel']:
        return pulumi.get(self, "mapping_label")


@pulumi.output_type
class DerivedLabelMetricLabelConstructedLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueDefinitions":
            suggest = "value_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelConstructedLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelConstructedLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelConstructedLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_definitions: Sequence['outputs.DerivedLabelMetricLabelConstructedLabelValueDefinition']):
        pulumi.set(__self__, "value_definitions", value_definitions)

    @property
    @pulumi.getter(name="valueDefinitions")
    def value_definitions(self) -> Sequence['outputs.DerivedLabelMetricLabelConstructedLabelValueDefinition']:
        return pulumi.get(self, "value_definitions")


@pulumi.output_type
class DerivedLabelMetricLabelConstructedLabelValueDefinition(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter'],
                 value: str):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueGlob":
            suggest = "value_glob"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelConstructedLabelValueDefinitionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value_glob: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_glob", value_glob)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueGlob")
    def value_glob(self) -> str:
        return pulumi.get(self, "value_glob")


@pulumi.output_type
class DerivedLabelMetricLabelMappingLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameMappings":
            suggest = "name_mappings"
        elif key == "valueMappings":
            suggest = "value_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelMappingLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelMappingLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelMappingLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_mappings: Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMapping']] = None,
                 value_mappings: Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelValueMapping']] = None):
        if name_mappings is not None:
            pulumi.set(__self__, "name_mappings", name_mappings)
        if value_mappings is not None:
            pulumi.set(__self__, "value_mappings", value_mappings)

    @property
    @pulumi.getter(name="nameMappings")
    def name_mappings(self) -> Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMapping']]:
        return pulumi.get(self, "name_mappings")

    @property
    @pulumi.getter(name="valueMappings")
    def value_mappings(self) -> Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelValueMapping']]:
        return pulumi.get(self, "value_mappings")


@pulumi.output_type
class DerivedLabelMetricLabelMappingLabelNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceLabel":
            suggest = "source_label"
        elif key == "valueMappings":
            suggest = "value_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelMappingLabelNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMappingFilter'],
                 source_label: str,
                 value_mappings: Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMappingValueMapping']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "source_label", source_label)
        if value_mappings is not None:
            pulumi.set(__self__, "value_mappings", value_mappings)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMappingFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="sourceLabel")
    def source_label(self) -> str:
        return pulumi.get(self, "source_label")

    @property
    @pulumi.getter(name="valueMappings")
    def value_mappings(self) -> Optional[Sequence['outputs.DerivedLabelMetricLabelMappingLabelNameMappingValueMapping']]:
        return pulumi.get(self, "value_mappings")


@pulumi.output_type
class DerivedLabelMetricLabelMappingLabelNameMappingFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueGlob":
            suggest = "value_glob"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelMappingLabelNameMappingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMappingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMappingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value_glob: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_glob", value_glob)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueGlob")
    def value_glob(self) -> str:
        return pulumi.get(self, "value_glob")


@pulumi.output_type
class DerivedLabelMetricLabelMappingLabelNameMappingValueMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceValueGlobs":
            suggest = "source_value_globs"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelMappingLabelNameMappingValueMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMappingValueMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelMappingLabelNameMappingValueMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_value_globs: Sequence[str],
                 target_value: str):
        pulumi.set(__self__, "source_value_globs", source_value_globs)
        pulumi.set(__self__, "target_value", target_value)

    @property
    @pulumi.getter(name="sourceValueGlobs")
    def source_value_globs(self) -> Sequence[str]:
        return pulumi.get(self, "source_value_globs")

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> str:
        return pulumi.get(self, "target_value")


@pulumi.output_type
class DerivedLabelMetricLabelMappingLabelValueMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceValueGlobs":
            suggest = "source_value_globs"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelMetricLabelMappingLabelValueMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelMetricLabelMappingLabelValueMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelMetricLabelMappingLabelValueMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_value_globs: Sequence[str],
                 target_value: str):
        pulumi.set(__self__, "source_value_globs", source_value_globs)
        pulumi.set(__self__, "target_value", target_value)

    @property
    @pulumi.getter(name="sourceValueGlobs")
    def source_value_globs(self) -> Sequence[str]:
        return pulumi.get(self, "source_value_globs")

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> str:
        return pulumi.get(self, "target_value")


@pulumi.output_type
class DerivedLabelSpanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameMappings":
            suggest = "name_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelSpanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelSpanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelSpanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_mappings: Optional[Sequence['outputs.DerivedLabelSpanTagNameMapping']] = None):
        if name_mappings is not None:
            pulumi.set(__self__, "name_mappings", name_mappings)

    @property
    @pulumi.getter(name="nameMappings")
    def name_mappings(self) -> Optional[Sequence['outputs.DerivedLabelSpanTagNameMapping']]:
        return pulumi.get(self, "name_mappings")


@pulumi.output_type
class DerivedLabelSpanTagNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceTag":
            suggest = "source_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedLabelSpanTagNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedLabelSpanTagNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedLabelSpanTagNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_tag: str):
        pulumi.set(__self__, "source_tag", source_tag)

    @property
    @pulumi.getter(name="sourceTag")
    def source_tag(self) -> str:
        return pulumi.get(self, "source_tag")


@pulumi.output_type
class DerivedMetricQuery(dict):
    def __init__(__self__, *,
                 query: 'outputs.DerivedMetricQueryQuery',
                 selector: Optional['outputs.DerivedMetricQuerySelector'] = None):
        pulumi.set(__self__, "query", query)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DerivedMetricQueryQuery':
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.DerivedMetricQuerySelector']:
        return pulumi.get(self, "selector")


@pulumi.output_type
class DerivedMetricQueryQuery(dict):
    def __init__(__self__, *,
                 expr: str,
                 variables: Optional[Sequence['outputs.DerivedMetricQueryQueryVariable']] = None):
        pulumi.set(__self__, "expr", expr)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def expr(self) -> str:
        return pulumi.get(self, "expr")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.DerivedMetricQueryQueryVariable']]:
        return pulumi.get(self, "variables")


@pulumi.output_type
class DerivedMetricQueryQueryVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSelector":
            suggest = "default_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DerivedMetricQueryQueryVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DerivedMetricQueryQueryVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DerivedMetricQueryQueryVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_selector: str,
                 name: str):
        pulumi.set(__self__, "default_selector", default_selector)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultSelector")
    def default_selector(self) -> str:
        return pulumi.get(self, "default_selector")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class DerivedMetricQuerySelector(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None):
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class DropRuleValueBasedDrop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetDropValue":
            suggest = "target_drop_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DropRuleValueBasedDrop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DropRuleValueBasedDrop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DropRuleValueBasedDrop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_drop_value: float):
        pulumi.set(__self__, "target_drop_value", target_drop_value)

    @property
    @pulumi.getter(name="targetDropValue")
    def target_drop_value(self) -> float:
        return pulumi.get(self, "target_drop_value")


@pulumi.output_type
class GcpMetricsIntegrationMetricGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsIntegrationMetricGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsIntegrationMetricGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsIntegrationMetricGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 prefixes: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "project_id", project_id)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")


@pulumi.output_type
class GcpMetricsIntegrationServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsIntegrationServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsIntegrationServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsIntegrationServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_email: str):
        pulumi.set(__self__, "client_email", client_email)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        return pulumi.get(self, "client_email")


@pulumi.output_type
class LogAllocationConfigDatasetAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAllocationConfigDatasetAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAllocationConfigDatasetAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAllocationConfigDatasetAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation: 'outputs.LogAllocationConfigDatasetAllocationAllocation',
                 dataset_id: str,
                 priorities: Optional['outputs.LogAllocationConfigDatasetAllocationPriorities'] = None):
        pulumi.set(__self__, "allocation", allocation)
        pulumi.set(__self__, "dataset_id", dataset_id)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)

    @property
    @pulumi.getter
    def allocation(self) -> 'outputs.LogAllocationConfigDatasetAllocationAllocation':
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter
    def priorities(self) -> Optional['outputs.LogAllocationConfigDatasetAllocationPriorities']:
        return pulumi.get(self, "priorities")


@pulumi.output_type
class LogAllocationConfigDatasetAllocationAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentOfLicense":
            suggest = "percent_of_license"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAllocationConfigDatasetAllocationAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAllocationConfigDatasetAllocationAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAllocationConfigDatasetAllocationAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percent_of_license: float):
        pulumi.set(__self__, "percent_of_license", percent_of_license)

    @property
    @pulumi.getter(name="percentOfLicense")
    def percent_of_license(self) -> float:
        return pulumi.get(self, "percent_of_license")


@pulumi.output_type
class LogAllocationConfigDatasetAllocationPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highPriorityFilters":
            suggest = "high_priority_filters"
        elif key == "lowPriorityFilters":
            suggest = "low_priority_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAllocationConfigDatasetAllocationPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAllocationConfigDatasetAllocationPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAllocationConfigDatasetAllocationPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_priority_filters: Optional[Sequence['outputs.LogAllocationConfigDatasetAllocationPrioritiesHighPriorityFilter']] = None,
                 low_priority_filters: Optional[Sequence['outputs.LogAllocationConfigDatasetAllocationPrioritiesLowPriorityFilter']] = None):
        if high_priority_filters is not None:
            pulumi.set(__self__, "high_priority_filters", high_priority_filters)
        if low_priority_filters is not None:
            pulumi.set(__self__, "low_priority_filters", low_priority_filters)

    @property
    @pulumi.getter(name="highPriorityFilters")
    def high_priority_filters(self) -> Optional[Sequence['outputs.LogAllocationConfigDatasetAllocationPrioritiesHighPriorityFilter']]:
        return pulumi.get(self, "high_priority_filters")

    @property
    @pulumi.getter(name="lowPriorityFilters")
    def low_priority_filters(self) -> Optional[Sequence['outputs.LogAllocationConfigDatasetAllocationPrioritiesLowPriorityFilter']]:
        return pulumi.get(self, "low_priority_filters")


@pulumi.output_type
class LogAllocationConfigDatasetAllocationPrioritiesHighPriorityFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class LogAllocationConfigDatasetAllocationPrioritiesLowPriorityFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class LogAllocationConfigDefaultDataset(dict):
    def __init__(__self__, *,
                 allocation: 'outputs.LogAllocationConfigDefaultDatasetAllocation',
                 priorities: Optional['outputs.LogAllocationConfigDefaultDatasetPriorities'] = None):
        pulumi.set(__self__, "allocation", allocation)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)

    @property
    @pulumi.getter
    def allocation(self) -> 'outputs.LogAllocationConfigDefaultDatasetAllocation':
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def priorities(self) -> Optional['outputs.LogAllocationConfigDefaultDatasetPriorities']:
        return pulumi.get(self, "priorities")


@pulumi.output_type
class LogAllocationConfigDefaultDatasetAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentOfLicense":
            suggest = "percent_of_license"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAllocationConfigDefaultDatasetAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAllocationConfigDefaultDatasetAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAllocationConfigDefaultDatasetAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percent_of_license: float):
        pulumi.set(__self__, "percent_of_license", percent_of_license)

    @property
    @pulumi.getter(name="percentOfLicense")
    def percent_of_license(self) -> float:
        return pulumi.get(self, "percent_of_license")


@pulumi.output_type
class LogAllocationConfigDefaultDatasetPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highPriorityFilters":
            suggest = "high_priority_filters"
        elif key == "lowPriorityFilters":
            suggest = "low_priority_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAllocationConfigDefaultDatasetPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAllocationConfigDefaultDatasetPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAllocationConfigDefaultDatasetPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_priority_filters: Optional[Sequence['outputs.LogAllocationConfigDefaultDatasetPrioritiesHighPriorityFilter']] = None,
                 low_priority_filters: Optional[Sequence['outputs.LogAllocationConfigDefaultDatasetPrioritiesLowPriorityFilter']] = None):
        if high_priority_filters is not None:
            pulumi.set(__self__, "high_priority_filters", high_priority_filters)
        if low_priority_filters is not None:
            pulumi.set(__self__, "low_priority_filters", low_priority_filters)

    @property
    @pulumi.getter(name="highPriorityFilters")
    def high_priority_filters(self) -> Optional[Sequence['outputs.LogAllocationConfigDefaultDatasetPrioritiesHighPriorityFilter']]:
        return pulumi.get(self, "high_priority_filters")

    @property
    @pulumi.getter(name="lowPriorityFilters")
    def low_priority_filters(self) -> Optional[Sequence['outputs.LogAllocationConfigDefaultDatasetPrioritiesLowPriorityFilter']]:
        return pulumi.get(self, "low_priority_filters")


@pulumi.output_type
class LogAllocationConfigDefaultDatasetPrioritiesHighPriorityFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class LogAllocationConfigDefaultDatasetPrioritiesLowPriorityFilter(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class LogControlConfigRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropField":
            suggest = "drop_field"
        elif key == "emitMetrics":
            suggest = "emit_metrics"
        elif key == "replaceField":
            suggest = "replace_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drop_field: Optional['outputs.LogControlConfigRuleDropField'] = None,
                 emit_metrics: Optional['outputs.LogControlConfigRuleEmitMetrics'] = None,
                 filter: Optional[str] = None,
                 mode: Optional[str] = None,
                 name: Optional[str] = None,
                 replace_field: Optional['outputs.LogControlConfigRuleReplaceField'] = None,
                 sample: Optional['outputs.LogControlConfigRuleSample'] = None,
                 type: Optional[str] = None):
        if drop_field is not None:
            pulumi.set(__self__, "drop_field", drop_field)
        if emit_metrics is not None:
            pulumi.set(__self__, "emit_metrics", emit_metrics)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replace_field is not None:
            pulumi.set(__self__, "replace_field", replace_field)
        if sample is not None:
            pulumi.set(__self__, "sample", sample)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dropField")
    def drop_field(self) -> Optional['outputs.LogControlConfigRuleDropField']:
        return pulumi.get(self, "drop_field")

    @property
    @pulumi.getter(name="emitMetrics")
    def emit_metrics(self) -> Optional['outputs.LogControlConfigRuleEmitMetrics']:
        return pulumi.get(self, "emit_metrics")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replaceField")
    def replace_field(self) -> Optional['outputs.LogControlConfigRuleReplaceField']:
        return pulumi.get(self, "replace_field")

    @property
    @pulumi.getter
    def sample(self) -> Optional['outputs.LogControlConfigRuleSample']:
        return pulumi.get(self, "sample")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class LogControlConfigRuleDropField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldRegex":
            suggest = "field_regex"
        elif key == "parentPath":
            suggest = "parent_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRuleDropField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRuleDropField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRuleDropField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_regex: Optional[str] = None,
                 parent_path: Optional['outputs.LogControlConfigRuleDropFieldParentPath'] = None):
        if field_regex is not None:
            pulumi.set(__self__, "field_regex", field_regex)
        if parent_path is not None:
            pulumi.set(__self__, "parent_path", parent_path)

    @property
    @pulumi.getter(name="fieldRegex")
    def field_regex(self) -> Optional[str]:
        return pulumi.get(self, "field_regex")

    @property
    @pulumi.getter(name="parentPath")
    def parent_path(self) -> Optional['outputs.LogControlConfigRuleDropFieldParentPath']:
        return pulumi.get(self, "parent_path")


@pulumi.output_type
class LogControlConfigRuleDropFieldParentPath(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleEmitMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropLog":
            suggest = "drop_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRuleEmitMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRuleEmitMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRuleEmitMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter: Optional['outputs.LogControlConfigRuleEmitMetricsCounter'] = None,
                 drop_log: Optional[bool] = None,
                 gauge: Optional['outputs.LogControlConfigRuleEmitMetricsGauge'] = None,
                 histogram: Optional['outputs.LogControlConfigRuleEmitMetricsHistogram'] = None,
                 labels: Optional[Sequence['outputs.LogControlConfigRuleEmitMetricsLabel']] = None,
                 mode: Optional[str] = None,
                 name: Optional[str] = None):
        if counter is not None:
            pulumi.set(__self__, "counter", counter)
        if drop_log is not None:
            pulumi.set(__self__, "drop_log", drop_log)
        if gauge is not None:
            pulumi.set(__self__, "gauge", gauge)
        if histogram is not None:
            pulumi.set(__self__, "histogram", histogram)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def counter(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsCounter']:
        return pulumi.get(self, "counter")

    @property
    @pulumi.getter(name="dropLog")
    def drop_log(self) -> Optional[bool]:
        return pulumi.get(self, "drop_log")

    @property
    @pulumi.getter
    def gauge(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsGauge']:
        return pulumi.get(self, "gauge")

    @property
    @pulumi.getter
    def histogram(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsHistogram']:
        return pulumi.get(self, "histogram")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.LogControlConfigRuleEmitMetricsLabel']]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsCounter(dict):
    def __init__(__self__, *,
                 value: Optional['outputs.LogControlConfigRuleEmitMetricsCounterValue'] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsCounterValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsCounterValue(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsGauge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRuleEmitMetricsGauge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRuleEmitMetricsGauge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRuleEmitMetricsGauge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[str] = None,
                 value: Optional['outputs.LogControlConfigRuleEmitMetricsGaugeValue'] = None):
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsGaugeValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsGaugeValue(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsHistogram(dict):
    def __init__(__self__, *,
                 value: Optional['outputs.LogControlConfigRuleEmitMetricsHistogramValue'] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsHistogramValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsHistogramValue(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional['outputs.LogControlConfigRuleEmitMetricsLabelValue'] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.LogControlConfigRuleEmitMetricsLabelValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleEmitMetricsLabelValue(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleReplaceField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappedValue":
            suggest = "mapped_value"
        elif key == "replaceAll":
            suggest = "replace_all"
        elif key == "replaceMode":
            suggest = "replace_mode"
        elif key == "replaceRegex":
            suggest = "replace_regex"
        elif key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRuleReplaceField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRuleReplaceField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRuleReplaceField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: Optional['outputs.LogControlConfigRuleReplaceFieldField'] = None,
                 mapped_value: Optional['outputs.LogControlConfigRuleReplaceFieldMappedValue'] = None,
                 replace_all: Optional[bool] = None,
                 replace_mode: Optional[str] = None,
                 replace_regex: Optional[str] = None,
                 static_value: Optional['outputs.LogControlConfigRuleReplaceFieldStaticValue'] = None):
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mapped_value is not None:
            pulumi.set(__self__, "mapped_value", mapped_value)
        if replace_all is not None:
            pulumi.set(__self__, "replace_all", replace_all)
        if replace_mode is not None:
            pulumi.set(__self__, "replace_mode", replace_mode)
        if replace_regex is not None:
            pulumi.set(__self__, "replace_regex", replace_regex)
        if static_value is not None:
            pulumi.set(__self__, "static_value", static_value)

    @property
    @pulumi.getter
    def field(self) -> Optional['outputs.LogControlConfigRuleReplaceFieldField']:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="mappedValue")
    def mapped_value(self) -> Optional['outputs.LogControlConfigRuleReplaceFieldMappedValue']:
        return pulumi.get(self, "mapped_value")

    @property
    @pulumi.getter(name="replaceAll")
    def replace_all(self) -> Optional[bool]:
        return pulumi.get(self, "replace_all")

    @property
    @pulumi.getter(name="replaceMode")
    def replace_mode(self) -> Optional[str]:
        return pulumi.get(self, "replace_mode")

    @property
    @pulumi.getter(name="replaceRegex")
    def replace_regex(self) -> Optional[str]:
        return pulumi.get(self, "replace_regex")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional['outputs.LogControlConfigRuleReplaceFieldStaticValue']:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class LogControlConfigRuleReplaceFieldField(dict):
    def __init__(__self__, *,
                 selector: Optional[str] = None):
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogControlConfigRuleReplaceFieldMappedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "useDefault":
            suggest = "use_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogControlConfigRuleReplaceFieldMappedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogControlConfigRuleReplaceFieldMappedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogControlConfigRuleReplaceFieldMappedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[str] = None,
                 pairs: Optional[Sequence['outputs.LogControlConfigRuleReplaceFieldMappedValuePair']] = None,
                 use_default: Optional[bool] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if pairs is not None:
            pulumi.set(__self__, "pairs", pairs)
        if use_default is not None:
            pulumi.set(__self__, "use_default", use_default)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def pairs(self) -> Optional[Sequence['outputs.LogControlConfigRuleReplaceFieldMappedValuePair']]:
        return pulumi.get(self, "pairs")

    @property
    @pulumi.getter(name="useDefault")
    def use_default(self) -> Optional[bool]:
        return pulumi.get(self, "use_default")


@pulumi.output_type
class LogControlConfigRuleReplaceFieldMappedValuePair(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleReplaceFieldStaticValue(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogControlConfigRuleSample(dict):
    def __init__(__self__, *,
                 rate: Optional[float] = None):
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @property
    @pulumi.getter
    def rate(self) -> Optional[float]:
        return pulumi.get(self, "rate")


@pulumi.output_type
class LogIngestConfigFieldNormalization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldNormalizations":
            suggest = "custom_field_normalizations"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldNormalization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldNormalization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldNormalization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_field_normalizations: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalization']] = None,
                 message: Optional['outputs.LogIngestConfigFieldNormalizationMessage'] = None,
                 primary_key: Optional['outputs.LogIngestConfigFieldNormalizationPrimaryKey'] = None,
                 severity: Optional['outputs.LogIngestConfigFieldNormalizationSeverity'] = None,
                 timestamp: Optional['outputs.LogIngestConfigFieldNormalizationTimestamp'] = None):
        if custom_field_normalizations is not None:
            pulumi.set(__self__, "custom_field_normalizations", custom_field_normalizations)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="customFieldNormalizations")
    def custom_field_normalizations(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalization']]:
        return pulumi.get(self, "custom_field_normalizations")

    @property
    @pulumi.getter
    def message(self) -> Optional['outputs.LogIngestConfigFieldNormalizationMessage']:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional['outputs.LogIngestConfigFieldNormalizationPrimaryKey']:
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def severity(self) -> Optional['outputs.LogIngestConfigFieldNormalizationSeverity']:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.LogIngestConfigFieldNormalizationTimestamp']:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class LogIngestConfigFieldNormalizationCustomFieldNormalization(dict):
    def __init__(__self__, *,
                 normalization: Optional['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization'] = None,
                 target: Optional[str] = None):
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def normalization(self) -> Optional['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization']:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "sanitizePatterns":
            suggest = "sanitize_patterns"
        elif key == "valueMap":
            suggest = "value_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[str] = None,
                 sanitize_patterns: Optional[Sequence[str]] = None,
                 sources: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalizationSource']] = None,
                 value_map: Optional[Mapping[str, str]] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if sanitize_patterns is not None:
            pulumi.set(__self__, "sanitize_patterns", sanitize_patterns)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if value_map is not None:
            pulumi.set(__self__, "value_map", value_map)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="sanitizePatterns")
    def sanitize_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sanitize_patterns")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalizationSource']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="valueMap")
    def value_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "value_map")


@pulumi.output_type
class LogIngestConfigFieldNormalizationCustomFieldNormalizationNormalizationSource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldNormalizationMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "sanitizePatterns":
            suggest = "sanitize_patterns"
        elif key == "valueMap":
            suggest = "value_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldNormalizationMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldNormalizationMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldNormalizationMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[str] = None,
                 sanitize_patterns: Optional[Sequence[str]] = None,
                 sources: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationMessageSource']] = None,
                 value_map: Optional[Mapping[str, str]] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if sanitize_patterns is not None:
            pulumi.set(__self__, "sanitize_patterns", sanitize_patterns)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if value_map is not None:
            pulumi.set(__self__, "value_map", value_map)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="sanitizePatterns")
    def sanitize_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sanitize_patterns")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationMessageSource']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="valueMap")
    def value_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "value_map")


@pulumi.output_type
class LogIngestConfigFieldNormalizationMessageSource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldNormalizationPrimaryKey(dict):
    def __init__(__self__, *,
                 normalization: Optional['outputs.LogIngestConfigFieldNormalizationPrimaryKeyNormalization'] = None,
                 target: Optional[str] = None):
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def normalization(self) -> Optional['outputs.LogIngestConfigFieldNormalizationPrimaryKeyNormalization']:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class LogIngestConfigFieldNormalizationPrimaryKeyNormalization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "sanitizePatterns":
            suggest = "sanitize_patterns"
        elif key == "valueMap":
            suggest = "value_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldNormalizationPrimaryKeyNormalization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldNormalizationPrimaryKeyNormalization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldNormalizationPrimaryKeyNormalization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[str] = None,
                 sanitize_patterns: Optional[Sequence[str]] = None,
                 sources: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationPrimaryKeyNormalizationSource']] = None,
                 value_map: Optional[Mapping[str, str]] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if sanitize_patterns is not None:
            pulumi.set(__self__, "sanitize_patterns", sanitize_patterns)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if value_map is not None:
            pulumi.set(__self__, "value_map", value_map)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="sanitizePatterns")
    def sanitize_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sanitize_patterns")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationPrimaryKeyNormalizationSource']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="valueMap")
    def value_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "value_map")


@pulumi.output_type
class LogIngestConfigFieldNormalizationPrimaryKeyNormalizationSource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldNormalizationSeverity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "sanitizePatterns":
            suggest = "sanitize_patterns"
        elif key == "valueMap":
            suggest = "value_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldNormalizationSeverity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldNormalizationSeverity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldNormalizationSeverity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[str] = None,
                 sanitize_patterns: Optional[Sequence[str]] = None,
                 sources: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationSeveritySource']] = None,
                 value_map: Optional[Mapping[str, str]] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if sanitize_patterns is not None:
            pulumi.set(__self__, "sanitize_patterns", sanitize_patterns)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if value_map is not None:
            pulumi.set(__self__, "value_map", value_map)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="sanitizePatterns")
    def sanitize_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sanitize_patterns")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationSeveritySource']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="valueMap")
    def value_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "value_map")


@pulumi.output_type
class LogIngestConfigFieldNormalizationSeveritySource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldNormalizationTimestamp(dict):
    def __init__(__self__, *,
                 sources: Optional[Sequence['outputs.LogIngestConfigFieldNormalizationTimestampSource']] = None):
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.LogIngestConfigFieldNormalizationTimestampSource']]:
        return pulumi.get(self, "sources")


@pulumi.output_type
class LogIngestConfigFieldNormalizationTimestampSource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldParser(dict):
    def __init__(__self__, *,
                 parser: 'outputs.LogIngestConfigFieldParserParser',
                 source: 'outputs.LogIngestConfigFieldParserSource',
                 destination: Optional['outputs.LogIngestConfigFieldParserDestination'] = None,
                 mode: Optional[str] = None):
        pulumi.set(__self__, "parser", parser)
        pulumi.set(__self__, "source", source)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.LogIngestConfigFieldParserParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.LogIngestConfigFieldParserSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.LogIngestConfigFieldParserDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class LogIngestConfigFieldParserDestination(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigFieldParserParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parserType":
            suggest = "parser_type"
        elif key == "keyValueParser":
            suggest = "key_value_parser"
        elif key == "regexParser":
            suggest = "regex_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldParserParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldParserParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldParserParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parser_type: str,
                 key_value_parser: Optional['outputs.LogIngestConfigFieldParserParserKeyValueParser'] = None,
                 regex_parser: Optional['outputs.LogIngestConfigFieldParserParserRegexParser'] = None):
        pulumi.set(__self__, "parser_type", parser_type)
        if key_value_parser is not None:
            pulumi.set(__self__, "key_value_parser", key_value_parser)
        if regex_parser is not None:
            pulumi.set(__self__, "regex_parser", regex_parser)

    @property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> str:
        return pulumi.get(self, "parser_type")

    @property
    @pulumi.getter(name="keyValueParser")
    def key_value_parser(self) -> Optional['outputs.LogIngestConfigFieldParserParserKeyValueParser']:
        return pulumi.get(self, "key_value_parser")

    @property
    @pulumi.getter(name="regexParser")
    def regex_parser(self) -> Optional['outputs.LogIngestConfigFieldParserParserRegexParser']:
        return pulumi.get(self, "regex_parser")


@pulumi.output_type
class LogIngestConfigFieldParserParserKeyValueParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pairSeparator":
            suggest = "pair_separator"
        elif key == "trimSet":
            suggest = "trim_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigFieldParserParserKeyValueParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigFieldParserParserKeyValueParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigFieldParserParserKeyValueParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: str,
                 pair_separator: str,
                 trim_set: Optional[str] = None):
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "pair_separator", pair_separator)
        if trim_set is not None:
            pulumi.set(__self__, "trim_set", trim_set)

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="pairSeparator")
    def pair_separator(self) -> str:
        return pulumi.get(self, "pair_separator")

    @property
    @pulumi.getter(name="trimSet")
    def trim_set(self) -> Optional[str]:
        return pulumi.get(self, "trim_set")


@pulumi.output_type
class LogIngestConfigFieldParserParserRegexParser(dict):
    def __init__(__self__, *,
                 regex: str):
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class LogIngestConfigFieldParserSource(dict):
    def __init__(__self__, *,
                 selector: str):
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class LogIngestConfigPlaintextParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepOriginal":
            suggest = "keep_original"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigPlaintextParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigPlaintextParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigPlaintextParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parser: 'outputs.LogIngestConfigPlaintextParserParser',
                 keep_original: Optional[bool] = None,
                 mode: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parser", parser)
        if keep_original is not None:
            pulumi.set(__self__, "keep_original", keep_original)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.LogIngestConfigPlaintextParserParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter(name="keepOriginal")
    def keep_original(self) -> Optional[bool]:
        return pulumi.get(self, "keep_original")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class LogIngestConfigPlaintextParserParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parserType":
            suggest = "parser_type"
        elif key == "keyValueParser":
            suggest = "key_value_parser"
        elif key == "regexParser":
            suggest = "regex_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigPlaintextParserParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigPlaintextParserParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigPlaintextParserParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parser_type: str,
                 key_value_parser: Optional['outputs.LogIngestConfigPlaintextParserParserKeyValueParser'] = None,
                 regex_parser: Optional['outputs.LogIngestConfigPlaintextParserParserRegexParser'] = None):
        pulumi.set(__self__, "parser_type", parser_type)
        if key_value_parser is not None:
            pulumi.set(__self__, "key_value_parser", key_value_parser)
        if regex_parser is not None:
            pulumi.set(__self__, "regex_parser", regex_parser)

    @property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> str:
        return pulumi.get(self, "parser_type")

    @property
    @pulumi.getter(name="keyValueParser")
    def key_value_parser(self) -> Optional['outputs.LogIngestConfigPlaintextParserParserKeyValueParser']:
        return pulumi.get(self, "key_value_parser")

    @property
    @pulumi.getter(name="regexParser")
    def regex_parser(self) -> Optional['outputs.LogIngestConfigPlaintextParserParserRegexParser']:
        return pulumi.get(self, "regex_parser")


@pulumi.output_type
class LogIngestConfigPlaintextParserParserKeyValueParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pairSeparator":
            suggest = "pair_separator"
        elif key == "trimSet":
            suggest = "trim_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogIngestConfigPlaintextParserParserKeyValueParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogIngestConfigPlaintextParserParserKeyValueParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogIngestConfigPlaintextParserParserKeyValueParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: str,
                 pair_separator: str,
                 trim_set: Optional[str] = None):
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "pair_separator", pair_separator)
        if trim_set is not None:
            pulumi.set(__self__, "trim_set", trim_set)

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="pairSeparator")
    def pair_separator(self) -> str:
        return pulumi.get(self, "pair_separator")

    @property
    @pulumi.getter(name="trimSet")
    def trim_set(self) -> Optional[str]:
        return pulumi.get(self, "trim_set")


@pulumi.output_type
class LogIngestConfigPlaintextParserParserRegexParser(dict):
    def __init__(__self__, *,
                 regex: str):
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class LogscaleActionEmailAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachCsv":
            suggest = "attach_csv"
        elif key == "bodyTemplate":
            suggest = "body_template"
        elif key == "subjectTemplate":
            suggest = "subject_template"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionEmailAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionEmailAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionEmailAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recipients: Sequence[str],
                 attach_csv: Optional[bool] = None,
                 body_template: Optional[str] = None,
                 subject_template: Optional[str] = None,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "recipients", recipients)
        if attach_csv is not None:
            pulumi.set(__self__, "attach_csv", attach_csv)
        if body_template is not None:
            pulumi.set(__self__, "body_template", body_template)
        if subject_template is not None:
            pulumi.set(__self__, "subject_template", subject_template)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter
    def recipients(self) -> Sequence[str]:
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter(name="attachCsv")
    def attach_csv(self) -> Optional[bool]:
        return pulumi.get(self, "attach_csv")

    @property
    @pulumi.getter(name="bodyTemplate")
    def body_template(self) -> Optional[str]:
        return pulumi.get(self, "body_template")

    @property
    @pulumi.getter(name="subjectTemplate")
    def subject_template(self) -> Optional[str]:
        return pulumi.get(self, "subject_template")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionHumioAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingestToken":
            suggest = "ingest_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionHumioAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionHumioAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionHumioAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingest_token: str):
        pulumi.set(__self__, "ingest_token", ingest_token)

    @property
    @pulumi.getter(name="ingestToken")
    def ingest_token(self) -> str:
        return pulumi.get(self, "ingest_token")


@pulumi.output_type
class LogscaleActionOpsGenieAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "opsGenieKey":
            suggest = "ops_genie_key"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionOpsGenieAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionOpsGenieAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionOpsGenieAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: str,
                 ops_genie_key: str,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "ops_genie_key", ops_genie_key)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="opsGenieKey")
    def ops_genie_key(self) -> str:
        return pulumi.get(self, "ops_genie_key")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionPagerDutyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingKey":
            suggest = "routing_key"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionPagerDutyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionPagerDutyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionPagerDutyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_key: str,
                 severity: str,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "severity", severity)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionSlackAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionSlackAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionSlackAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionSlackAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 fields: Optional[Mapping[str, str]] = None,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "url", url)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionSlackPostMessageAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionSlackPostMessageAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionSlackPostMessageAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionSlackPostMessageAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 channels: Sequence[str],
                 fields: Optional[Mapping[str, str]] = None,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channels", channels)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def channels(self) -> Sequence[str]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionUploadFileAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionUploadFileAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionUploadFileAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionUploadFileAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: str):
        pulumi.set(__self__, "file_name", file_name)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        return pulumi.get(self, "file_name")


@pulumi.output_type
class LogscaleActionVictorOpsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageType":
            suggest = "message_type"
        elif key == "notifyUrl":
            suggest = "notify_url"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionVictorOpsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionVictorOpsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionVictorOpsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_type: str,
                 notify_url: str,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "message_type", message_type)
        pulumi.set(__self__, "notify_url", notify_url)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter(name="messageType")
    def message_type(self) -> str:
        return pulumi.get(self, "message_type")

    @property
    @pulumi.getter(name="notifyUrl")
    def notify_url(self) -> str:
        return pulumi.get(self, "notify_url")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class LogscaleActionWebhookAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyTemplate":
            suggest = "body_template"
        elif key == "ignoreSsl":
            suggest = "ignore_ssl"
        elif key == "useProxy":
            suggest = "use_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogscaleActionWebhookAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogscaleActionWebhookAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogscaleActionWebhookAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 body_template: Optional[str] = None,
                 headers: Optional[Mapping[str, str]] = None,
                 ignore_ssl: Optional[bool] = None,
                 use_proxy: Optional[bool] = None):
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if body_template is not None:
            pulumi.set(__self__, "body_template", body_template)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignore_ssl is not None:
            pulumi.set(__self__, "ignore_ssl", ignore_ssl)
        if use_proxy is not None:
            pulumi.set(__self__, "use_proxy", use_proxy)

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="bodyTemplate")
    def body_template(self) -> Optional[str]:
        return pulumi.get(self, "body_template")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ignoreSsl")
    def ignore_ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_ssl")

    @property
    @pulumi.getter(name="useProxy")
    def use_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "use_proxy")


@pulumi.output_type
class MappingRuleStoragePolicy(dict):
    def __init__(__self__, *,
                 resolution: str,
                 retention: str):
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "retention", retention)

    @property
    @pulumi.getter
    def resolution(self) -> str:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def retention(self) -> str:
        return pulumi.get(self, "retention")


@pulumi.output_type
class MonitorQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphiteExpr":
            suggest = "graphite_expr"
        elif key == "loggingExpr":
            suggest = "logging_expr"
        elif key == "prometheusExpr":
            suggest = "prometheus_expr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 graphite_expr: Optional[str] = None,
                 logging_expr: Optional[str] = None,
                 prometheus_expr: Optional[str] = None):
        if graphite_expr is not None:
            pulumi.set(__self__, "graphite_expr", graphite_expr)
        if logging_expr is not None:
            pulumi.set(__self__, "logging_expr", logging_expr)
        if prometheus_expr is not None:
            pulumi.set(__self__, "prometheus_expr", prometheus_expr)

    @property
    @pulumi.getter(name="graphiteExpr")
    def graphite_expr(self) -> Optional[str]:
        return pulumi.get(self, "graphite_expr")

    @property
    @pulumi.getter(name="loggingExpr")
    def logging_expr(self) -> Optional[str]:
        return pulumi.get(self, "logging_expr")

    @property
    @pulumi.getter(name="prometheusExpr")
    def prometheus_expr(self) -> Optional[str]:
        return pulumi.get(self, "prometheus_expr")


@pulumi.output_type
class MonitorSchedule(dict):
    def __init__(__self__, *,
                 timezone: str,
                 ranges: Optional[Sequence['outputs.MonitorScheduleRange']] = None):
        pulumi.set(__self__, "timezone", timezone)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter
    def timezone(self) -> str:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def ranges(self) -> Optional[Sequence['outputs.MonitorScheduleRange']]:
        return pulumi.get(self, "ranges")


@pulumi.output_type
class MonitorScheduleRange(dict):
    def __init__(__self__, *,
                 day: str,
                 end: str,
                 start: str):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def day(self) -> str:
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class MonitorSeriesConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.MonitorSeriesConditionsCondition'],
                 overrides: Optional[Sequence['outputs.MonitorSeriesConditionsOverride']] = None):
        pulumi.set(__self__, "conditions", conditions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.MonitorSeriesConditionsCondition']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.MonitorSeriesConditionsOverride']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class MonitorSeriesConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolveSustain":
            suggest = "resolve_sustain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSeriesConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSeriesConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSeriesConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 op: str,
                 severity: str,
                 resolve_sustain: Optional[str] = None,
                 sustain: Optional[str] = None,
                 value: Optional[float] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "severity", severity)
        if resolve_sustain is not None:
            pulumi.set(__self__, "resolve_sustain", resolve_sustain)
        if sustain is not None:
            pulumi.set(__self__, "sustain", sustain)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="resolveSustain")
    def resolve_sustain(self) -> Optional[str]:
        return pulumi.get(self, "resolve_sustain")

    @property
    @pulumi.getter
    def sustain(self) -> Optional[str]:
        return pulumi.get(self, "sustain")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class MonitorSeriesConditionsOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelMatchers":
            suggest = "label_matchers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSeriesConditionsOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSeriesConditionsOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSeriesConditionsOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.MonitorSeriesConditionsOverrideCondition'],
                 label_matchers: Sequence['outputs.MonitorSeriesConditionsOverrideLabelMatcher']):
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "label_matchers", label_matchers)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.MonitorSeriesConditionsOverrideCondition']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="labelMatchers")
    def label_matchers(self) -> Sequence['outputs.MonitorSeriesConditionsOverrideLabelMatcher']:
        return pulumi.get(self, "label_matchers")


@pulumi.output_type
class MonitorSeriesConditionsOverrideCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolveSustain":
            suggest = "resolve_sustain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSeriesConditionsOverrideCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSeriesConditionsOverrideCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSeriesConditionsOverrideCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 op: str,
                 severity: str,
                 resolve_sustain: Optional[str] = None,
                 sustain: Optional[str] = None,
                 value: Optional[float] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "severity", severity)
        if resolve_sustain is not None:
            pulumi.set(__self__, "resolve_sustain", resolve_sustain)
        if sustain is not None:
            pulumi.set(__self__, "sustain", sustain)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="resolveSustain")
    def resolve_sustain(self) -> Optional[str]:
        return pulumi.get(self, "resolve_sustain")

    @property
    @pulumi.getter
    def sustain(self) -> Optional[str]:
        return pulumi.get(self, "sustain")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class MonitorSeriesConditionsOverrideLabelMatcher(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MonitorSignalGrouping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelNames":
            suggest = "label_names"
        elif key == "signalPerSeries":
            suggest = "signal_per_series"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSignalGrouping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSignalGrouping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSignalGrouping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_names: Optional[Sequence[str]] = None,
                 signal_per_series: Optional[bool] = None):
        if label_names is not None:
            pulumi.set(__self__, "label_names", label_names)
        if signal_per_series is not None:
            pulumi.set(__self__, "signal_per_series", signal_per_series)

    @property
    @pulumi.getter(name="labelNames")
    def label_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "label_names")

    @property
    @pulumi.getter(name="signalPerSeries")
    def signal_per_series(self) -> Optional[bool]:
        return pulumi.get(self, "signal_per_series")


@pulumi.output_type
class NotificationPolicyOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertLabelMatchers":
            suggest = "alert_label_matchers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_label_matchers: Sequence['outputs.NotificationPolicyOverrideAlertLabelMatcher'],
                 routes: Optional[Sequence['outputs.NotificationPolicyOverrideRoute']] = None):
        pulumi.set(__self__, "alert_label_matchers", alert_label_matchers)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="alertLabelMatchers")
    def alert_label_matchers(self) -> Sequence['outputs.NotificationPolicyOverrideAlertLabelMatcher']:
        return pulumi.get(self, "alert_label_matchers")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.NotificationPolicyOverrideRoute']]:
        return pulumi.get(self, "routes")


@pulumi.output_type
class NotificationPolicyOverrideAlertLabelMatcher(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationPolicyOverrideRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyOverrideRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyOverrideRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyOverrideRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 severity: str,
                 group_by: Optional['outputs.NotificationPolicyOverrideRouteGroupBy'] = None,
                 notifiers: Optional[Sequence[str]] = None,
                 repeat_interval: Optional[str] = None):
        pulumi.set(__self__, "severity", severity)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if notifiers is not None:
            pulumi.set(__self__, "notifiers", notifiers)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional['outputs.NotificationPolicyOverrideRouteGroupBy']:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def notifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notifiers")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyOverrideRouteGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelNames":
            suggest = "label_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyOverrideRouteGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyOverrideRouteGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyOverrideRouteGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_names: Optional[Sequence[str]] = None):
        if label_names is not None:
            pulumi.set(__self__, "label_names", label_names)

    @property
    @pulumi.getter(name="labelNames")
    def label_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "label_names")


@pulumi.output_type
class NotificationPolicyRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 severity: str,
                 group_by: Optional['outputs.NotificationPolicyRouteGroupBy'] = None,
                 notifiers: Optional[Sequence[str]] = None,
                 repeat_interval: Optional[str] = None):
        pulumi.set(__self__, "severity", severity)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if notifiers is not None:
            pulumi.set(__self__, "notifiers", notifiers)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional['outputs.NotificationPolicyRouteGroupBy']:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def notifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notifiers")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[str]:
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class NotificationPolicyRouteGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelNames":
            suggest = "label_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPolicyRouteGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPolicyRouteGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPolicyRouteGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_names: Optional[Sequence[str]] = None):
        if label_names is not None:
            pulumi.set(__self__, "label_names", label_names)

    @property
    @pulumi.getter(name="labelNames")
    def label_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "label_names")


@pulumi.output_type
class OpsgenieAlertNotifierResponder(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 username: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class OtelMetricsIngestionResourceAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeKeys":
            suggest = "exclude_keys"
        elif key == "filterMode":
            suggest = "filter_mode"
        elif key == "flattenMode":
            suggest = "flatten_mode"
        elif key == "generateTargetInfo":
            suggest = "generate_target_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OtelMetricsIngestionResourceAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OtelMetricsIngestionResourceAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OtelMetricsIngestionResourceAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_keys: Optional[Sequence[str]] = None,
                 filter_mode: Optional[str] = None,
                 flatten_mode: Optional[str] = None,
                 generate_target_info: Optional[bool] = None):
        if exclude_keys is not None:
            pulumi.set(__self__, "exclude_keys", exclude_keys)
        if filter_mode is not None:
            pulumi.set(__self__, "filter_mode", filter_mode)
        if flatten_mode is not None:
            pulumi.set(__self__, "flatten_mode", flatten_mode)
        if generate_target_info is not None:
            pulumi.set(__self__, "generate_target_info", generate_target_info)

    @property
    @pulumi.getter(name="excludeKeys")
    def exclude_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_keys")

    @property
    @pulumi.getter(name="filterMode")
    def filter_mode(self) -> Optional[str]:
        return pulumi.get(self, "filter_mode")

    @property
    @pulumi.getter(name="flattenMode")
    def flatten_mode(self) -> Optional[str]:
        return pulumi.get(self, "flatten_mode")

    @property
    @pulumi.getter(name="generateTargetInfo")
    def generate_target_info(self) -> Optional[bool]:
        return pulumi.get(self, "generate_target_info")


@pulumi.output_type
class PagerdutyAlertNotifierImage(dict):
    def __init__(__self__, *,
                 src: str,
                 alt: Optional[str] = None,
                 href: Optional[str] = None):
        pulumi.set(__self__, "src", src)
        if alt is not None:
            pulumi.set(__self__, "alt", alt)
        if href is not None:
            pulumi.set(__self__, "href", href)

    @property
    @pulumi.getter
    def src(self) -> str:
        return pulumi.get(self, "src")

    @property
    @pulumi.getter
    def alt(self) -> Optional[str]:
        return pulumi.get(self, "alt")

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")


@pulumi.output_type
class PagerdutyAlertNotifierLink(dict):
    def __init__(__self__, *,
                 href: str,
                 text: Optional[str] = None):
        pulumi.set(__self__, "href", href)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")


@pulumi.output_type
class ResourcePoolsConfigDefaultPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "priorityThresholds":
            suggest = "priority_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation: Optional['outputs.ResourcePoolsConfigDefaultPoolAllocation'] = None,
                 priorities: Optional['outputs.ResourcePoolsConfigDefaultPoolPriorities'] = None,
                 priority_thresholds: Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolPriorityThreshold']] = None):
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if priority_thresholds is not None:
            pulumi.set(__self__, "priority_thresholds", priority_thresholds)

    @property
    @pulumi.getter
    def allocation(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolAllocation']:
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def priorities(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolPriorities']:
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter(name="priorityThresholds")
    def priority_thresholds(self) -> Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolPriorityThreshold']]:
        return pulumi.get(self, "priority_thresholds")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValues":
            suggest = "fixed_values"
        elif key == "percentOfLicense":
            suggest = "percent_of_license"
        elif key == "priorityThresholds":
            suggest = "priority_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_values: Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolAllocationFixedValue']] = None,
                 percent_of_license: Optional[float] = None,
                 priority_thresholds: Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold']] = None):
        if fixed_values is not None:
            pulumi.set(__self__, "fixed_values", fixed_values)
        if percent_of_license is not None:
            pulumi.set(__self__, "percent_of_license", percent_of_license)
        if priority_thresholds is not None:
            pulumi.set(__self__, "priority_thresholds", priority_thresholds)

    @property
    @pulumi.getter(name="fixedValues")
    def fixed_values(self) -> Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolAllocationFixedValue']]:
        return pulumi.get(self, "fixed_values")

    @property
    @pulumi.getter(name="percentOfLicense")
    def percent_of_license(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_license")

    @property
    @pulumi.getter(name="priorityThresholds")
    def priority_thresholds(self) -> Optional[Sequence['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold']]:
        return pulumi.get(self, "priority_thresholds")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocationFixedValue(dict):
    def __init__(__self__, *,
                 license: str,
                 value: int):
        pulumi.set(__self__, "license", license)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def license(self) -> str:
        return pulumi.get(self, "license")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allPriorities":
            suggest = "all_priorities"
        elif key == "defaultAndLowPriority":
            suggest = "default_and_low_priority"
        elif key == "lowPriority":
            suggest = "low_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license: str,
                 all_priorities: Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities'] = None,
                 default_and_low_priority: Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority'] = None,
                 low_priority: Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority'] = None):
        pulumi.set(__self__, "license", license)
        if all_priorities is not None:
            pulumi.set(__self__, "all_priorities", all_priorities)
        if default_and_low_priority is not None:
            pulumi.set(__self__, "default_and_low_priority", default_and_low_priority)
        if low_priority is not None:
            pulumi.set(__self__, "low_priority", low_priority)

    @property
    @pulumi.getter
    def license(self) -> str:
        return pulumi.get(self, "license")

    @property
    @pulumi.getter(name="allPriorities")
    def all_priorities(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities']:
        return pulumi.get(self, "all_priorities")

    @property
    @pulumi.getter(name="defaultAndLowPriority")
    def default_and_low_priority(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority']:
        return pulumi.get(self, "default_and_low_priority")

    @property
    @pulumi.getter(name="lowPriority")
    def low_priority(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority']:
        return pulumi.get(self, "low_priority")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdAllPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolAllocationPriorityThresholdLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highPriorityMatchRules":
            suggest = "high_priority_match_rules"
        elif key == "lowPriorityMatchRules":
            suggest = "low_priority_match_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_priority_match_rules: Optional[Sequence[str]] = None,
                 low_priority_match_rules: Optional[Sequence[str]] = None):
        if high_priority_match_rules is not None:
            pulumi.set(__self__, "high_priority_match_rules", high_priority_match_rules)
        if low_priority_match_rules is not None:
            pulumi.set(__self__, "low_priority_match_rules", low_priority_match_rules)

    @property
    @pulumi.getter(name="highPriorityMatchRules")
    def high_priority_match_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "high_priority_match_rules")

    @property
    @pulumi.getter(name="lowPriorityMatchRules")
    def low_priority_match_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "low_priority_match_rules")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolPriorityThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allPriorities":
            suggest = "all_priorities"
        elif key == "defaultAndLowPriority":
            suggest = "default_and_low_priority"
        elif key == "lowPriority":
            suggest = "low_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolPriorityThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license: str,
                 all_priorities: Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities'] = None,
                 default_and_low_priority: Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority'] = None,
                 low_priority: Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority'] = None):
        pulumi.set(__self__, "license", license)
        if all_priorities is not None:
            pulumi.set(__self__, "all_priorities", all_priorities)
        if default_and_low_priority is not None:
            pulumi.set(__self__, "default_and_low_priority", default_and_low_priority)
        if low_priority is not None:
            pulumi.set(__self__, "low_priority", low_priority)

    @property
    @pulumi.getter
    def license(self) -> str:
        return pulumi.get(self, "license")

    @property
    @pulumi.getter(name="allPriorities")
    def all_priorities(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities']:
        return pulumi.get(self, "all_priorities")

    @property
    @pulumi.getter(name="defaultAndLowPriority")
    def default_and_low_priority(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority']:
        return pulumi.get(self, "default_and_low_priority")

    @property
    @pulumi.getter(name="lowPriority")
    def low_priority(self) -> Optional['outputs.ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority']:
        return pulumi.get(self, "low_priority")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdAllPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigDefaultPoolPriorityThresholdLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRule":
            suggest = "match_rule"
        elif key == "matchRules":
            suggest = "match_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 allocation: Optional['outputs.ResourcePoolsConfigPoolAllocation'] = None,
                 match_rule: Optional[str] = None,
                 match_rules: Optional[Sequence[str]] = None,
                 priorities: Optional['outputs.ResourcePoolsConfigPoolPriorities'] = None):
        pulumi.set(__self__, "name", name)
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if match_rule is not None:
            pulumi.set(__self__, "match_rule", match_rule)
        if match_rules is not None:
            pulumi.set(__self__, "match_rules", match_rules)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def allocation(self) -> Optional['outputs.ResourcePoolsConfigPoolAllocation']:
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter(name="matchRule")
    def match_rule(self) -> Optional[str]:
        warnings.warn("""use match_rules""", DeprecationWarning)
        pulumi.log.warn("""match_rule is deprecated: use match_rules""")

        return pulumi.get(self, "match_rule")

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter
    def priorities(self) -> Optional['outputs.ResourcePoolsConfigPoolPriorities']:
        return pulumi.get(self, "priorities")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValues":
            suggest = "fixed_values"
        elif key == "percentOfLicense":
            suggest = "percent_of_license"
        elif key == "priorityThresholds":
            suggest = "priority_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_values: Optional[Sequence['outputs.ResourcePoolsConfigPoolAllocationFixedValue']] = None,
                 percent_of_license: Optional[float] = None,
                 priority_thresholds: Optional[Sequence['outputs.ResourcePoolsConfigPoolAllocationPriorityThreshold']] = None):
        if fixed_values is not None:
            pulumi.set(__self__, "fixed_values", fixed_values)
        if percent_of_license is not None:
            pulumi.set(__self__, "percent_of_license", percent_of_license)
        if priority_thresholds is not None:
            pulumi.set(__self__, "priority_thresholds", priority_thresholds)

    @property
    @pulumi.getter(name="fixedValues")
    def fixed_values(self) -> Optional[Sequence['outputs.ResourcePoolsConfigPoolAllocationFixedValue']]:
        return pulumi.get(self, "fixed_values")

    @property
    @pulumi.getter(name="percentOfLicense")
    def percent_of_license(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_license")

    @property
    @pulumi.getter(name="priorityThresholds")
    def priority_thresholds(self) -> Optional[Sequence['outputs.ResourcePoolsConfigPoolAllocationPriorityThreshold']]:
        return pulumi.get(self, "priority_thresholds")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocationFixedValue(dict):
    def __init__(__self__, *,
                 license: str,
                 value: int):
        pulumi.set(__self__, "license", license)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def license(self) -> str:
        return pulumi.get(self, "license")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocationPriorityThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allPriorities":
            suggest = "all_priorities"
        elif key == "defaultAndLowPriority":
            suggest = "default_and_low_priority"
        elif key == "lowPriority":
            suggest = "low_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolAllocationPriorityThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license: str,
                 all_priorities: Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities'] = None,
                 default_and_low_priority: Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority'] = None,
                 low_priority: Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority'] = None):
        pulumi.set(__self__, "license", license)
        if all_priorities is not None:
            pulumi.set(__self__, "all_priorities", all_priorities)
        if default_and_low_priority is not None:
            pulumi.set(__self__, "default_and_low_priority", default_and_low_priority)
        if low_priority is not None:
            pulumi.set(__self__, "low_priority", low_priority)

    @property
    @pulumi.getter
    def license(self) -> str:
        return pulumi.get(self, "license")

    @property
    @pulumi.getter(name="allPriorities")
    def all_priorities(self) -> Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities']:
        return pulumi.get(self, "all_priorities")

    @property
    @pulumi.getter(name="defaultAndLowPriority")
    def default_and_low_priority(self) -> Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority']:
        return pulumi.get(self, "default_and_low_priority")

    @property
    @pulumi.getter(name="lowPriority")
    def low_priority(self) -> Optional['outputs.ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority']:
        return pulumi.get(self, "low_priority")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdAllPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdDefaultAndLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "percentOfPoolAllocation":
            suggest = "percent_of_pool_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolAllocationPriorityThresholdLowPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: Optional[int] = None,
                 percent_of_pool_allocation: Optional[float] = None):
        if fixed_value is not None:
            pulumi.set(__self__, "fixed_value", fixed_value)
        if percent_of_pool_allocation is not None:
            pulumi.set(__self__, "percent_of_pool_allocation", percent_of_pool_allocation)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> Optional[int]:
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="percentOfPoolAllocation")
    def percent_of_pool_allocation(self) -> Optional[float]:
        return pulumi.get(self, "percent_of_pool_allocation")


@pulumi.output_type
class ResourcePoolsConfigPoolPriorities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highPriorityMatchRules":
            suggest = "high_priority_match_rules"
        elif key == "lowPriorityMatchRules":
            suggest = "low_priority_match_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolsConfigPoolPriorities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolsConfigPoolPriorities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolsConfigPoolPriorities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_priority_match_rules: Optional[Sequence[str]] = None,
                 low_priority_match_rules: Optional[Sequence[str]] = None):
        if high_priority_match_rules is not None:
            pulumi.set(__self__, "high_priority_match_rules", high_priority_match_rules)
        if low_priority_match_rules is not None:
            pulumi.set(__self__, "low_priority_match_rules", low_priority_match_rules)

    @property
    @pulumi.getter(name="highPriorityMatchRules")
    def high_priority_match_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "high_priority_match_rules")

    @property
    @pulumi.getter(name="lowPriorityMatchRules")
    def low_priority_match_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "low_priority_match_rules")


@pulumi.output_type
class RollupRuleGraphiteLabelPolicy(dict):
    def __init__(__self__, *,
                 replaces: Optional[Sequence['outputs.RollupRuleGraphiteLabelPolicyReplace']] = None):
        if replaces is not None:
            pulumi.set(__self__, "replaces", replaces)

    @property
    @pulumi.getter
    def replaces(self) -> Optional[Sequence['outputs.RollupRuleGraphiteLabelPolicyReplace']]:
        return pulumi.get(self, "replaces")


@pulumi.output_type
class RollupRuleGraphiteLabelPolicyReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newValue":
            suggest = "new_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RollupRuleGraphiteLabelPolicyReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RollupRuleGraphiteLabelPolicyReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RollupRuleGraphiteLabelPolicyReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 new_value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "new_value", new_value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> str:
        return pulumi.get(self, "new_value")


@pulumi.output_type
class RollupRuleStoragePolicies(dict):
    def __init__(__self__, *,
                 resolution: str,
                 retention: str):
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "retention", retention)

    @property
    @pulumi.getter
    def resolution(self) -> str:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def retention(self) -> str:
        return pulumi.get(self, "retention")


@pulumi.output_type
class SLODefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateAlertingConfigs":
            suggest = "burn_rate_alerting_configs"
        elif key == "enableBurnRateAlerting":
            suggest = "enable_burn_rate_alerting"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLODefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLODefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLODefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 objective: float,
                 burn_rate_alerting_configs: Optional[Sequence['outputs.SLODefinitionBurnRateAlertingConfig']] = None,
                 enable_burn_rate_alerting: Optional[bool] = None,
                 time_window: Optional['outputs.SLODefinitionTimeWindow'] = None):
        pulumi.set(__self__, "objective", objective)
        if burn_rate_alerting_configs is not None:
            pulumi.set(__self__, "burn_rate_alerting_configs", burn_rate_alerting_configs)
        if enable_burn_rate_alerting is not None:
            pulumi.set(__self__, "enable_burn_rate_alerting", enable_burn_rate_alerting)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter
    def objective(self) -> float:
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter(name="burnRateAlertingConfigs")
    def burn_rate_alerting_configs(self) -> Optional[Sequence['outputs.SLODefinitionBurnRateAlertingConfig']]:
        return pulumi.get(self, "burn_rate_alerting_configs")

    @property
    @pulumi.getter(name="enableBurnRateAlerting")
    def enable_burn_rate_alerting(self) -> Optional[bool]:
        return pulumi.get(self, "enable_burn_rate_alerting")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional['outputs.SLODefinitionTimeWindow']:
        return pulumi.get(self, "time_window")


@pulumi.output_type
class SLODefinitionBurnRateAlertingConfig(dict):
    def __init__(__self__, *,
                 budget: float,
                 severity: str,
                 window: str,
                 labels: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "budget", budget)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "window", window)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def budget(self) -> float:
        return pulumi.get(self, "budget")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def window(self) -> str:
        return pulumi.get(self, "window")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class SLODefinitionTimeWindow(dict):
    def __init__(__self__, *,
                 duration: str):
        pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")


@pulumi.output_type
class SLOSignalGrouping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelNames":
            suggest = "label_names"
        elif key == "signalPerSeries":
            suggest = "signal_per_series"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOSignalGrouping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOSignalGrouping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOSignalGrouping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_names: Optional[Sequence[str]] = None,
                 signal_per_series: Optional[bool] = None):
        if label_names is not None:
            pulumi.set(__self__, "label_names", label_names)
        if signal_per_series is not None:
            pulumi.set(__self__, "signal_per_series", signal_per_series)

    @property
    @pulumi.getter(name="labelNames")
    def label_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "label_names")

    @property
    @pulumi.getter(name="signalPerSeries")
    def signal_per_series(self) -> Optional[bool]:
        return pulumi.get(self, "signal_per_series")


@pulumi.output_type
class SLOSli(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalPromqlFilters":
            suggest = "additional_promql_filters"
        elif key == "customDimensionLabels":
            suggest = "custom_dimension_labels"
        elif key == "customIndicator":
            suggest = "custom_indicator"
        elif key == "customTimesliceIndicator":
            suggest = "custom_timeslice_indicator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOSli. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOSli.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOSli.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_promql_filters: Optional[Sequence['outputs.SLOSliAdditionalPromqlFilter']] = None,
                 custom_dimension_labels: Optional[Sequence[str]] = None,
                 custom_indicator: Optional['outputs.SLOSliCustomIndicator'] = None,
                 custom_timeslice_indicator: Optional['outputs.SLOSliCustomTimesliceIndicator'] = None):
        if additional_promql_filters is not None:
            pulumi.set(__self__, "additional_promql_filters", additional_promql_filters)
        if custom_dimension_labels is not None:
            pulumi.set(__self__, "custom_dimension_labels", custom_dimension_labels)
        if custom_indicator is not None:
            pulumi.set(__self__, "custom_indicator", custom_indicator)
        if custom_timeslice_indicator is not None:
            pulumi.set(__self__, "custom_timeslice_indicator", custom_timeslice_indicator)

    @property
    @pulumi.getter(name="additionalPromqlFilters")
    def additional_promql_filters(self) -> Optional[Sequence['outputs.SLOSliAdditionalPromqlFilter']]:
        return pulumi.get(self, "additional_promql_filters")

    @property
    @pulumi.getter(name="customDimensionLabels")
    def custom_dimension_labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "custom_dimension_labels")

    @property
    @pulumi.getter(name="customIndicator")
    def custom_indicator(self) -> Optional['outputs.SLOSliCustomIndicator']:
        return pulumi.get(self, "custom_indicator")

    @property
    @pulumi.getter(name="customTimesliceIndicator")
    def custom_timeslice_indicator(self) -> Optional['outputs.SLOSliCustomTimesliceIndicator']:
        return pulumi.get(self, "custom_timeslice_indicator")


@pulumi.output_type
class SLOSliAdditionalPromqlFilter(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SLOSliCustomIndicator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalQueryTemplate":
            suggest = "total_query_template"
        elif key == "badQueryTemplate":
            suggest = "bad_query_template"
        elif key == "goodQueryTemplate":
            suggest = "good_query_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOSliCustomIndicator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOSliCustomIndicator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOSliCustomIndicator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_query_template: str,
                 bad_query_template: Optional[str] = None,
                 good_query_template: Optional[str] = None):
        pulumi.set(__self__, "total_query_template", total_query_template)
        if bad_query_template is not None:
            pulumi.set(__self__, "bad_query_template", bad_query_template)
        if good_query_template is not None:
            pulumi.set(__self__, "good_query_template", good_query_template)

    @property
    @pulumi.getter(name="totalQueryTemplate")
    def total_query_template(self) -> str:
        return pulumi.get(self, "total_query_template")

    @property
    @pulumi.getter(name="badQueryTemplate")
    def bad_query_template(self) -> Optional[str]:
        return pulumi.get(self, "bad_query_template")

    @property
    @pulumi.getter(name="goodQueryTemplate")
    def good_query_template(self) -> Optional[str]:
        return pulumi.get(self, "good_query_template")


@pulumi.output_type
class SLOSliCustomTimesliceIndicator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryTemplate":
            suggest = "query_template"
        elif key == "timesliceSize":
            suggest = "timeslice_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLOSliCustomTimesliceIndicator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLOSliCustomTimesliceIndicator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLOSliCustomTimesliceIndicator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.SLOSliCustomTimesliceIndicatorCondition',
                 query_template: str,
                 timeslice_size: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "query_template", query_template)
        pulumi.set(__self__, "timeslice_size", timeslice_size)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.SLOSliCustomTimesliceIndicatorCondition':
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="queryTemplate")
    def query_template(self) -> str:
        return pulumi.get(self, "query_template")

    @property
    @pulumi.getter(name="timesliceSize")
    def timeslice_size(self) -> str:
        return pulumi.get(self, "timeslice_size")


@pulumi.output_type
class SLOSliCustomTimesliceIndicatorCondition(dict):
    def __init__(__self__, *,
                 op: str,
                 value: float):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceAccountRestriction(dict):
    def __init__(__self__, *,
                 permission: str,
                 labels: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "permission", permission)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class SlackAlertNotifierAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionConfirmDismissText":
            suggest = "action_confirm_dismiss_text"
        elif key == "actionConfirmOkText":
            suggest = "action_confirm_ok_text"
        elif key == "actionConfirmText":
            suggest = "action_confirm_text"
        elif key == "actionConfirmTile":
            suggest = "action_confirm_tile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlackAlertNotifierAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlackAlertNotifierAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlackAlertNotifierAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_confirm_dismiss_text: Optional[str] = None,
                 action_confirm_ok_text: Optional[str] = None,
                 action_confirm_text: Optional[str] = None,
                 action_confirm_tile: Optional[str] = None,
                 name: Optional[str] = None,
                 style: Optional[str] = None,
                 text: Optional[str] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None,
                 value: Optional[str] = None):
        if action_confirm_dismiss_text is not None:
            pulumi.set(__self__, "action_confirm_dismiss_text", action_confirm_dismiss_text)
        if action_confirm_ok_text is not None:
            pulumi.set(__self__, "action_confirm_ok_text", action_confirm_ok_text)
        if action_confirm_text is not None:
            pulumi.set(__self__, "action_confirm_text", action_confirm_text)
        if action_confirm_tile is not None:
            pulumi.set(__self__, "action_confirm_tile", action_confirm_tile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="actionConfirmDismissText")
    def action_confirm_dismiss_text(self) -> Optional[str]:
        return pulumi.get(self, "action_confirm_dismiss_text")

    @property
    @pulumi.getter(name="actionConfirmOkText")
    def action_confirm_ok_text(self) -> Optional[str]:
        return pulumi.get(self, "action_confirm_ok_text")

    @property
    @pulumi.getter(name="actionConfirmText")
    def action_confirm_text(self) -> Optional[str]:
        return pulumi.get(self, "action_confirm_text")

    @property
    @pulumi.getter(name="actionConfirmTile")
    def action_confirm_tile(self) -> Optional[str]:
        return pulumi.get(self, "action_confirm_tile")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def style(self) -> Optional[str]:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SlackAlertNotifierField(dict):
    def __init__(__self__, *,
                 short: Optional[bool] = None,
                 title: Optional[str] = None,
                 value: Optional[str] = None):
        if short is not None:
            pulumi.set(__self__, "short", short)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def short(self) -> Optional[bool]:
        return pulumi.get(self, "short")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perOperationStrategies":
            suggest = "per_operation_strategies"
        elif key == "probabilisticStrategy":
            suggest = "probabilistic_strategy"
        elif key == "rateLimitingStrategy":
            suggest = "rate_limiting_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_operation_strategies: Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies'] = None,
                 probabilistic_strategy: Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy'] = None,
                 rate_limiting_strategy: Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy'] = None):
        if per_operation_strategies is not None:
            pulumi.set(__self__, "per_operation_strategies", per_operation_strategies)
        if probabilistic_strategy is not None:
            pulumi.set(__self__, "probabilistic_strategy", probabilistic_strategy)
        if rate_limiting_strategy is not None:
            pulumi.set(__self__, "rate_limiting_strategy", rate_limiting_strategy)

    @property
    @pulumi.getter(name="perOperationStrategies")
    def per_operation_strategies(self) -> Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies']:
        return pulumi.get(self, "per_operation_strategies")

    @property
    @pulumi.getter(name="probabilisticStrategy")
    def probabilistic_strategy(self) -> Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy']:
        return pulumi.get(self, "probabilistic_strategy")

    @property
    @pulumi.getter(name="rateLimitingStrategy")
    def rate_limiting_strategy(self) -> Optional['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy']:
        return pulumi.get(self, "rate_limiting_strategy")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSamplingRate":
            suggest = "default_sampling_rate"
        elif key == "defaultLowerBoundTracesPerSecond":
            suggest = "default_lower_bound_traces_per_second"
        elif key == "defaultUpperBoundTracesPerSecond":
            suggest = "default_upper_bound_traces_per_second"
        elif key == "perOperationStrategies":
            suggest = "per_operation_strategies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_sampling_rate: float,
                 default_lower_bound_traces_per_second: Optional[float] = None,
                 default_upper_bound_traces_per_second: Optional[float] = None,
                 per_operation_strategies: Optional[Sequence['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy']] = None):
        pulumi.set(__self__, "default_sampling_rate", default_sampling_rate)
        if default_lower_bound_traces_per_second is not None:
            pulumi.set(__self__, "default_lower_bound_traces_per_second", default_lower_bound_traces_per_second)
        if default_upper_bound_traces_per_second is not None:
            pulumi.set(__self__, "default_upper_bound_traces_per_second", default_upper_bound_traces_per_second)
        if per_operation_strategies is not None:
            pulumi.set(__self__, "per_operation_strategies", per_operation_strategies)

    @property
    @pulumi.getter(name="defaultSamplingRate")
    def default_sampling_rate(self) -> float:
        return pulumi.get(self, "default_sampling_rate")

    @property
    @pulumi.getter(name="defaultLowerBoundTracesPerSecond")
    def default_lower_bound_traces_per_second(self) -> Optional[float]:
        return pulumi.get(self, "default_lower_bound_traces_per_second")

    @property
    @pulumi.getter(name="defaultUpperBoundTracesPerSecond")
    def default_upper_bound_traces_per_second(self) -> Optional[float]:
        return pulumi.get(self, "default_upper_bound_traces_per_second")

    @property
    @pulumi.getter(name="perOperationStrategies")
    def per_operation_strategies(self) -> Optional[Sequence['outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy']]:
        return pulumi.get(self, "per_operation_strategies")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probabilisticStrategy":
            suggest = "probabilistic_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operation: str,
                 probabilistic_strategy: 'outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy'):
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "probabilistic_strategy", probabilistic_strategy)

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="probabilisticStrategy")
    def probabilistic_strategy(self) -> 'outputs.TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy':
        return pulumi.get(self, "probabilistic_strategy")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingRate":
            suggest = "sampling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyPerOperationStrategiesPerOperationStrategyProbabilisticStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_rate: float):
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> float:
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingRate":
            suggest = "sampling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyProbabilisticStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_rate: float):
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> float:
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTracesPerSecond":
            suggest = "max_traces_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceJaegerRemoteSamplingStrategyAppliedStrategyRateLimitingStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_traces_per_second: int):
        pulumi.set(__self__, "max_traces_per_second", max_traces_per_second)

    @property
    @pulumi.getter(name="maxTracesPerSecond")
    def max_traces_per_second(self) -> int:
        return pulumi.get(self, "max_traces_per_second")


@pulumi.output_type
class TraceMetricsRuleGroupBy(dict):
    def __init__(__self__, *,
                 key: 'outputs.TraceMetricsRuleGroupByKey',
                 label: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> 'outputs.TraceMetricsRuleGroupByKey':
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class TraceMetricsRuleGroupByKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namedKey":
            suggest = "named_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleGroupByKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleGroupByKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleGroupByKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 named_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if named_key is not None:
            pulumi.set(__self__, "named_key", named_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="namedKey")
    def named_key(self) -> Optional[str]:
        return pulumi.get(self, "named_key")


@pulumi.output_type
class TraceMetricsRuleTraceFilter(dict):
    def __init__(__self__, *,
                 spans: Optional[Sequence['outputs.TraceMetricsRuleTraceFilterSpan']] = None,
                 trace: Optional['outputs.TraceMetricsRuleTraceFilterTrace'] = None):
        if spans is not None:
            pulumi.set(__self__, "spans", spans)
        if trace is not None:
            pulumi.set(__self__, "trace", trace)

    @property
    @pulumi.getter
    def spans(self) -> Optional[Sequence['outputs.TraceMetricsRuleTraceFilterSpan']]:
        return pulumi.get(self, "spans")

    @property
    @pulumi.getter
    def trace(self) -> Optional['outputs.TraceMetricsRuleTraceFilterTrace']:
        return pulumi.get(self, "trace")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRootSpan":
            suggest = "is_root_span"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "parentOperation":
            suggest = "parent_operation"
        elif key == "parentService":
            suggest = "parent_service"
        elif key == "spanCount":
            suggest = "span_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional['outputs.TraceMetricsRuleTraceFilterSpanDuration'] = None,
                 error: Optional['outputs.TraceMetricsRuleTraceFilterSpanError'] = None,
                 is_root_span: Optional['outputs.TraceMetricsRuleTraceFilterSpanIsRootSpan'] = None,
                 match_type: Optional[str] = None,
                 operation: Optional['outputs.TraceMetricsRuleTraceFilterSpanOperation'] = None,
                 parent_operation: Optional['outputs.TraceMetricsRuleTraceFilterSpanParentOperation'] = None,
                 parent_service: Optional['outputs.TraceMetricsRuleTraceFilterSpanParentService'] = None,
                 service: Optional['outputs.TraceMetricsRuleTraceFilterSpanService'] = None,
                 span_count: Optional['outputs.TraceMetricsRuleTraceFilterSpanSpanCount'] = None,
                 tags: Optional[Sequence['outputs.TraceMetricsRuleTraceFilterSpanTag']] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if is_root_span is not None:
            pulumi.set(__self__, "is_root_span", is_root_span)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if parent_operation is not None:
            pulumi.set(__self__, "parent_operation", parent_operation)
        if parent_service is not None:
            pulumi.set(__self__, "parent_service", parent_service)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if span_count is not None:
            pulumi.set(__self__, "span_count", span_count)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanError']:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="isRootSpan")
    def is_root_span(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanIsRootSpan']:
        return pulumi.get(self, "is_root_span")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def operation(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanOperation']:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="parentOperation")
    def parent_operation(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanParentOperation']:
        return pulumi.get(self, "parent_operation")

    @property
    @pulumi.getter(name="parentService")
    def parent_service(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanParentService']:
        return pulumi.get(self, "parent_service")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanService']:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanCount")
    def span_count(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanSpanCount']:
        return pulumi.get(self, "span_count")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TraceMetricsRuleTraceFilterSpanTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanIsRootSpan(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanParentOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanParentOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanParentOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanParentOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanParentService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanParentService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanParentService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanParentService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanSpanCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numericValue":
            suggest = "numeric_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 numeric_value: Optional['outputs.TraceMetricsRuleTraceFilterSpanTagNumericValue'] = None,
                 value: Optional['outputs.TraceMetricsRuleTraceFilterSpanTagValue'] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if numeric_value is not None:
            pulumi.set(__self__, "numeric_value", numeric_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="numericValue")
    def numeric_value(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanTagNumericValue']:
        return pulumi.get(self, "numeric_value")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TraceMetricsRuleTraceFilterSpanTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanTagNumericValue(dict):
    def __init__(__self__, *,
                 comparison: str,
                 value: float):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterSpanTagValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterSpanTagValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterSpanTagValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterSpanTagValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceMetricsRuleTraceFilterTrace(dict):
    def __init__(__self__, *,
                 duration: Optional['outputs.TraceMetricsRuleTraceFilterTraceDuration'] = None,
                 error: Optional['outputs.TraceMetricsRuleTraceFilterTraceError'] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.TraceMetricsRuleTraceFilterTraceDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.TraceMetricsRuleTraceFilterTraceError']:
        return pulumi.get(self, "error")


@pulumi.output_type
class TraceMetricsRuleTraceFilterTraceDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceMetricsRuleTraceFilterTraceDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceMetricsRuleTraceFilterTraceDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceMetricsRuleTraceFilterTraceDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class TraceMetricsRuleTraceFilterTraceError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesDefaultSampleRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesDefaultSampleRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesDefaultSampleRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesDefaultSampleRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sample_rate: float,
                 enabled: Optional[bool] = None):
        pulumi.set(__self__, "sample_rate", sample_rate)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TraceTailSamplingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "systemName":
            suggest = "system_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: 'outputs.TraceTailSamplingRulesRuleFilter',
                 sample_rate: float,
                 name: Optional[str] = None,
                 system_name: Optional[str] = None):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if system_name is not None:
            pulumi.set(__self__, "system_name", system_name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.TraceTailSamplingRulesRuleFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> Optional[str]:
        return pulumi.get(self, "system_name")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilter(dict):
    def __init__(__self__, *,
                 spans: Optional[Sequence['outputs.TraceTailSamplingRulesRuleFilterSpan']] = None,
                 trace: Optional['outputs.TraceTailSamplingRulesRuleFilterTrace'] = None):
        if spans is not None:
            pulumi.set(__self__, "spans", spans)
        if trace is not None:
            pulumi.set(__self__, "trace", trace)

    @property
    @pulumi.getter
    def spans(self) -> Optional[Sequence['outputs.TraceTailSamplingRulesRuleFilterSpan']]:
        return pulumi.get(self, "spans")

    @property
    @pulumi.getter
    def trace(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterTrace']:
        return pulumi.get(self, "trace")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRootSpan":
            suggest = "is_root_span"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "parentOperation":
            suggest = "parent_operation"
        elif key == "parentService":
            suggest = "parent_service"
        elif key == "spanCount":
            suggest = "span_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanDuration'] = None,
                 error: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanError'] = None,
                 is_root_span: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanIsRootSpan'] = None,
                 match_type: Optional[str] = None,
                 operation: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanOperation'] = None,
                 parent_operation: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanParentOperation'] = None,
                 parent_service: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanParentService'] = None,
                 service: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanService'] = None,
                 span_count: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanSpanCount'] = None,
                 tags: Optional[Sequence['outputs.TraceTailSamplingRulesRuleFilterSpanTag']] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if is_root_span is not None:
            pulumi.set(__self__, "is_root_span", is_root_span)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if parent_operation is not None:
            pulumi.set(__self__, "parent_operation", parent_operation)
        if parent_service is not None:
            pulumi.set(__self__, "parent_service", parent_service)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if span_count is not None:
            pulumi.set(__self__, "span_count", span_count)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanError']:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="isRootSpan")
    def is_root_span(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanIsRootSpan']:
        return pulumi.get(self, "is_root_span")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def operation(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanOperation']:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter(name="parentOperation")
    def parent_operation(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanParentOperation']:
        return pulumi.get(self, "parent_operation")

    @property
    @pulumi.getter(name="parentService")
    def parent_service(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanParentService']:
        return pulumi.get(self, "parent_service")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanService']:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanCount")
    def span_count(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanSpanCount']:
        return pulumi.get(self, "span_count")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TraceTailSamplingRulesRuleFilterSpanTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanIsRootSpan(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanParentOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanParentOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanParentOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanParentOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanParentService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanParentService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanParentService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanParentService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanSpanCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numericValue":
            suggest = "numeric_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 numeric_value: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanTagNumericValue'] = None,
                 value: Optional['outputs.TraceTailSamplingRulesRuleFilterSpanTagValue'] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if numeric_value is not None:
            pulumi.set(__self__, "numeric_value", numeric_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="numericValue")
    def numeric_value(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanTagNumericValue']:
        return pulumi.get(self, "numeric_value")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterSpanTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanTagNumericValue(dict):
    def __init__(__self__, *,
                 comparison: str,
                 value: float):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterSpanTagValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inValues":
            suggest = "in_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterSpanTagValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterSpanTagValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterSpanTagValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_values: Optional[Sequence[str]] = None,
                 match: Optional[str] = None,
                 value: Optional[str] = None):
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "in_values")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterTrace(dict):
    def __init__(__self__, *,
                 duration: Optional['outputs.TraceTailSamplingRulesRuleFilterTraceDuration'] = None,
                 error: Optional['outputs.TraceTailSamplingRulesRuleFilterTraceError'] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def duration(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterTraceDuration']:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.TraceTailSamplingRulesRuleFilterTraceError']:
        return pulumi.get(self, "error")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterTraceDuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSecs":
            suggest = "max_secs"
        elif key == "minSecs":
            suggest = "min_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TraceTailSamplingRulesRuleFilterTraceDuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TraceTailSamplingRulesRuleFilterTraceDuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TraceTailSamplingRulesRuleFilterTraceDuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_secs: Optional[float] = None,
                 min_secs: Optional[float] = None):
        if max_secs is not None:
            pulumi.set(__self__, "max_secs", max_secs)
        if min_secs is not None:
            pulumi.set(__self__, "min_secs", min_secs)

    @property
    @pulumi.getter(name="maxSecs")
    def max_secs(self) -> Optional[float]:
        return pulumi.get(self, "max_secs")

    @property
    @pulumi.getter(name="minSecs")
    def min_secs(self) -> Optional[float]:
        return pulumi.get(self, "min_secs")


@pulumi.output_type
class TraceTailSamplingRulesRuleFilterTraceError(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


